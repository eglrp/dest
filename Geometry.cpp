#include "Geometry.h"
#include "Ultility.h"
#include "Visualization.h"


using ceres::AutoDiffCostFunction;
using ceres::CostFunction;
using ceres::CauchyLoss;
using ceres::SoftLOneLoss;
using ceres::HuberLoss;
using ceres::Problem;
using ceres::Solver;

using namespace std;
using namespace cv;
using namespace Eigen;



class CvEMEstimator : public CvModelEstimator2
{
public:
	CvEMEstimator();
	virtual int runKernel(const CvMat* m1, const CvMat* m2, CvMat* model);
	virtual int run5Point(const CvMat* _q1, const CvMat* _q2, CvMat* _ematrix);
	//protected: 
	bool reliable(const CvMat* m1, const CvMat* m2, const CvMat* model);
	virtual void getCoeffMat(double *eet, double* a);
	virtual void computeReprojError(const CvMat* m1, const CvMat* m2,
		const CvMat* model, CvMat* error);
};

CvEMEstimator::CvEMEstimator()
	: CvModelEstimator2(5, cvSize(3, 3), 10)
{
}
int CvEMEstimator::runKernel(const CvMat* m1, const CvMat* m2, CvMat* model)
{
	return run5Point(m1, m2, model);
}
// Notice to keep compatibility with opencv ransac, q1 and q2 have to be of 1 row x n col x 2 channel. 
int CvEMEstimator::run5Point(const CvMat* q1, const CvMat* q2, CvMat* ematrix)
{
	Mat Q1 = Mat(q1).reshape(1, q1->cols);
	Mat Q2 = Mat(q2).reshape(1, q2->cols);

	int n = Q1.rows;
	Mat Q(n, 9, CV_64F);
	Q.col(0) = Q1.col(0).mul(Q2.col(0));
	Q.col(1) = Q1.col(1).mul(Q2.col(0));
	Q.col(2) = Q2.col(0) * 1.0;
	Q.col(3) = Q1.col(0).mul(Q2.col(1));
	Q.col(4) = Q1.col(1).mul(Q2.col(1));
	Q.col(5) = Q2.col(1) * 1.0;
	Q.col(6) = Q1.col(0) * 1.0;
	Q.col(7) = Q1.col(1) * 1.0;
	Q.col(8) = 1.0;

	Mat U, W, Vt;
	SVD::compute(Q, W, U, Vt, SVD::MODIFY_A | SVD::FULL_UV);

	Mat EE = Mat(Vt.t()).colRange(5, 9) * 1.0;
	Mat A(10, 20, CV_64F);
	EE = EE.t();
	getCoeffMat((double*)EE.data, (double*)A.data);
	EE = EE.t();

	A = A.colRange(0, 10).inv() * A.colRange(10, 20);

	double b[3 * 13];
	Mat B(3, 13, CV_64F, b);
	for (int i = 0; i < 3; i++)
	{
		Mat arow1 = A.row(i * 2 + 4) * 1.0;
		Mat arow2 = A.row(i * 2 + 5) * 1.0;
		Mat row1(1, 13, CV_64F, Scalar(0.0));
		Mat row2(1, 13, CV_64F, Scalar(0.0));

		row1.colRange(1, 4) = arow1.colRange(0, 3) * 1.0;
		row1.colRange(5, 8) = arow1.colRange(3, 6) * 1.0;
		row1.colRange(9, 13) = arow1.colRange(6, 10) * 1.0;

		row2.colRange(0, 3) = arow2.colRange(0, 3) * 1.0;
		row2.colRange(4, 7) = arow2.colRange(3, 6) * 1.0;
		row2.colRange(8, 12) = arow2.colRange(6, 10) * 1.0;

		B.row(i) = row1 - row2;
	}

	double c[11];
	Mat coeffs(1, 11, CV_64F, c);
	c[10] = (b[0] * b[17] * b[34] + b[26] * b[4] * b[21] - b[26] * b[17] * b[8] - b[13] * b[4] * b[34] - b[0] * b[21] * b[30] + b[13] * b[30] * b[8]);
	c[9] = (b[26] * b[4] * b[22] + b[14] * b[30] * b[8] + b[13] * b[31] * b[8] + b[1] * b[17] * b[34] - b[13] * b[5] * b[34] + b[26] * b[5] * b[21] - b[0] * b[21] * b[31] - b[26] * b[17] * b[9] - b[1] * b[21] * b[30] + b[27] * b[4] * b[21] + b[0] * b[17] * b[35] - b[0] * b[22] * b[30] + b[13] * b[30] * b[9] + b[0] * b[18] * b[34] - b[27] * b[17] * b[8] - b[14] * b[4] * b[34] - b[13] * b[4] * b[35] - b[26] * b[18] * b[8]);
	c[8] = (b[14] * b[30] * b[9] + b[14] * b[31] * b[8] + b[13] * b[31] * b[9] - b[13] * b[4] * b[36] - b[13] * b[5] * b[35] + b[15] * b[30] * b[8] - b[13] * b[6] * b[34] + b[13] * b[30] * b[10] + b[13] * b[32] * b[8] - b[14] * b[4] * b[35] - b[14] * b[5] * b[34] + b[26] * b[4] * b[23] + b[26] * b[5] * b[22] + b[26] * b[6] * b[21] - b[26] * b[17] * b[10] - b[15] * b[4] * b[34] - b[26] * b[18] * b[9] - b[26] * b[19] * b[8] + b[27] * b[4] * b[22] + b[27] * b[5] * b[21] - b[27] * b[17] * b[9] - b[27] * b[18] * b[8] - b[1] * b[21] * b[31] - b[0] * b[23] * b[30] - b[0] * b[21] * b[32] + b[28] * b[4] * b[21] - b[28] * b[17] * b[8] + b[2] * b[17] * b[34] + b[0] * b[18] * b[35] - b[0] * b[22] * b[31] + b[0] * b[17] * b[36] + b[0] * b[19] * b[34] - b[1] * b[22] * b[30] + b[1] * b[18] * b[34] + b[1] * b[17] * b[35] - b[2] * b[21] * b[30]);
	c[7] = (b[14] * b[30] * b[10] + b[14] * b[32] * b[8] - b[3] * b[21] * b[30] + b[3] * b[17] * b[34] + b[13] * b[32] * b[9] + b[13] * b[33] * b[8] - b[13] * b[4] * b[37] - b[13] * b[5] * b[36] + b[15] * b[30] * b[9] + b[15] * b[31] * b[8] - b[16] * b[4] * b[34] - b[13] * b[6] * b[35] - b[13] * b[7] * b[34] + b[13] * b[30] * b[11] + b[13] * b[31] * b[10] + b[14] * b[31] * b[9] - b[14] * b[4] * b[36] - b[14] * b[5] * b[35] - b[14] * b[6] * b[34] + b[16] * b[30] * b[8] - b[26] * b[20] * b[8] + b[26] * b[4] * b[24] + b[26] * b[5] * b[23] + b[26] * b[6] * b[22] + b[26] * b[7] * b[21] - b[26] * b[17] * b[11] - b[15] * b[4] * b[35] - b[15] * b[5] * b[34] - b[26] * b[18] * b[10] - b[26] * b[19] * b[9] + b[27] * b[4] * b[23] + b[27] * b[5] * b[22] + b[27] * b[6] * b[21] - b[27] * b[17] * b[10] - b[27] * b[18] * b[9] - b[27] * b[19] * b[8] + b[0] * b[17] * b[37] - b[0] * b[23] * b[31] - b[0] * b[24] * b[30] - b[0] * b[21] * b[33] - b[29] * b[17] * b[8] + b[28] * b[4] * b[22] + b[28] * b[5] * b[21] - b[28] * b[17] * b[9] - b[28] * b[18] * b[8] + b[29] * b[4] * b[21] + b[1] * b[19] * b[34] - b[2] * b[21] * b[31] + b[0] * b[20] * b[34] + b[0] * b[19] * b[35] + b[0] * b[18] * b[36] - b[0] * b[22] * b[32] - b[1] * b[23] * b[30] - b[1] * b[21] * b[32] + b[1] * b[18] * b[35] - b[1] * b[22] * b[31] - b[2] * b[22] * b[30] + b[2] * b[17] * b[35] + b[1] * b[17] * b[36] + b[2] * b[18] * b[34]);
	c[6] = (-b[14] * b[6] * b[35] - b[14] * b[7] * b[34] - b[3] * b[22] * b[30] - b[3] * b[21] * b[31] + b[3] * b[17] * b[35] + b[3] * b[18] * b[34] + b[13] * b[32] * b[10] + b[13] * b[33] * b[9] - b[13] * b[4] * b[38] - b[13] * b[5] * b[37] - b[15] * b[6] * b[34] + b[15] * b[30] * b[10] + b[15] * b[32] * b[8] - b[16] * b[4] * b[35] - b[13] * b[6] * b[36] - b[13] * b[7] * b[35] + b[13] * b[31] * b[11] + b[13] * b[30] * b[12] + b[14] * b[32] * b[9] + b[14] * b[33] * b[8] - b[14] * b[4] * b[37] - b[14] * b[5] * b[36] + b[16] * b[30] * b[9] + b[16] * b[31] * b[8] - b[26] * b[20] * b[9] + b[26] * b[4] * b[25] + b[26] * b[5] * b[24] + b[26] * b[6] * b[23] + b[26] * b[7] * b[22] - b[26] * b[17] * b[12] + b[14] * b[30] * b[11] + b[14] * b[31] * b[10] + b[15] * b[31] * b[9] - b[15] * b[4] * b[36] - b[15] * b[5] * b[35] - b[26] * b[18] * b[11] - b[26] * b[19] * b[10] - b[27] * b[20] * b[8] + b[27] * b[4] * b[24] + b[27] * b[5] * b[23] + b[27] * b[6] * b[22] + b[27] * b[7] * b[21] - b[27] * b[17] * b[11] - b[27] * b[18] * b[10] - b[27] * b[19] * b[9] - b[16] * b[5] * b[34] - b[29] * b[17] * b[9] - b[29] * b[18] * b[8] + b[28] * b[4] * b[23] + b[28] * b[5] * b[22] + b[28] * b[6] * b[21] - b[28] * b[17] * b[10] - b[28] * b[18] * b[9] - b[28] * b[19] * b[8] + b[29] * b[4] * b[22] + b[29] * b[5] * b[21] - b[2] * b[23] * b[30] + b[2] * b[18] * b[35] - b[1] * b[22] * b[32] - b[2] * b[21] * b[32] + b[2] * b[19] * b[34] + b[0] * b[19] * b[36] - b[0] * b[22] * b[33] + b[0] * b[20] * b[35] - b[0] * b[23] * b[32] - b[0] * b[25] * b[30] + b[0] * b[17] * b[38] + b[0] * b[18] * b[37] - b[0] * b[24] * b[31] + b[1] * b[17] * b[37] - b[1] * b[23] * b[31] - b[1] * b[24] * b[30] - b[1] * b[21] * b[33] + b[1] * b[20] * b[34] + b[1] * b[19] * b[35] + b[1] * b[18] * b[36] + b[2] * b[17] * b[36] - b[2] * b[22] * b[31]);
	c[5] = (-b[14] * b[6] * b[36] - b[14] * b[7] * b[35] + b[14] * b[31] * b[11] - b[3] * b[23] * b[30] - b[3] * b[21] * b[32] + b[3] * b[18] * b[35] - b[3] * b[22] * b[31] + b[3] * b[17] * b[36] + b[3] * b[19] * b[34] + b[13] * b[32] * b[11] + b[13] * b[33] * b[10] - b[13] * b[5] * b[38] - b[15] * b[6] * b[35] - b[15] * b[7] * b[34] + b[15] * b[30] * b[11] + b[15] * b[31] * b[10] + b[16] * b[31] * b[9] - b[13] * b[6] * b[37] - b[13] * b[7] * b[36] + b[13] * b[31] * b[12] + b[14] * b[32] * b[10] + b[14] * b[33] * b[9] - b[14] * b[4] * b[38] - b[14] * b[5] * b[37] - b[16] * b[6] * b[34] + b[16] * b[30] * b[10] + b[16] * b[32] * b[8] - b[26] * b[20] * b[10] + b[26] * b[5] * b[25] + b[26] * b[6] * b[24] + b[26] * b[7] * b[23] + b[14] * b[30] * b[12] + b[15] * b[32] * b[9] + b[15] * b[33] * b[8] - b[15] * b[4] * b[37] - b[15] * b[5] * b[36] + b[29] * b[5] * b[22] + b[29] * b[6] * b[21] - b[26] * b[18] * b[12] - b[26] * b[19] * b[11] - b[27] * b[20] * b[9] + b[27] * b[4] * b[25] + b[27] * b[5] * b[24] + b[27] * b[6] * b[23] + b[27] * b[7] * b[22] - b[27] * b[17] * b[12] - b[27] * b[18] * b[11] - b[27] * b[19] * b[10] - b[28] * b[20] * b[8] - b[16] * b[4] * b[36] - b[16] * b[5] * b[35] - b[29] * b[17] * b[10] - b[29] * b[18] * b[9] - b[29] * b[19] * b[8] + b[28] * b[4] * b[24] + b[28] * b[5] * b[23] + b[28] * b[6] * b[22] + b[28] * b[7] * b[21] - b[28] * b[17] * b[11] - b[28] * b[18] * b[10] - b[28] * b[19] * b[9] + b[29] * b[4] * b[23] - b[2] * b[22] * b[32] - b[2] * b[21] * b[33] - b[1] * b[24] * b[31] + b[0] * b[18] * b[38] - b[0] * b[24] * b[32] + b[0] * b[19] * b[37] + b[0] * b[20] * b[36] - b[0] * b[25] * b[31] - b[0] * b[23] * b[33] + b[1] * b[19] * b[36] - b[1] * b[22] * b[33] + b[1] * b[20] * b[35] + b[2] * b[19] * b[35] - b[2] * b[24] * b[30] - b[2] * b[23] * b[31] + b[2] * b[20] * b[34] + b[2] * b[17] * b[37] - b[1] * b[25] * b[30] + b[1] * b[18] * b[37] + b[1] * b[17] * b[38] - b[1] * b[23] * b[32] + b[2] * b[18] * b[36]);
	c[4] = (-b[14] * b[6] * b[37] - b[14] * b[7] * b[36] + b[14] * b[31] * b[12] + b[3] * b[17] * b[37] - b[3] * b[23] * b[31] - b[3] * b[24] * b[30] - b[3] * b[21] * b[33] + b[3] * b[20] * b[34] + b[3] * b[19] * b[35] + b[3] * b[18] * b[36] - b[3] * b[22] * b[32] + b[13] * b[32] * b[12] + b[13] * b[33] * b[11] - b[15] * b[6] * b[36] - b[15] * b[7] * b[35] + b[15] * b[31] * b[11] + b[15] * b[30] * b[12] + b[16] * b[32] * b[9] + b[16] * b[33] * b[8] - b[13] * b[6] * b[38] - b[13] * b[7] * b[37] + b[14] * b[32] * b[11] + b[14] * b[33] * b[10] - b[14] * b[5] * b[38] - b[16] * b[6] * b[35] - b[16] * b[7] * b[34] + b[16] * b[30] * b[11] + b[16] * b[31] * b[10] - b[26] * b[19] * b[12] - b[26] * b[20] * b[11] + b[26] * b[6] * b[25] + b[26] * b[7] * b[24] + b[15] * b[32] * b[10] + b[15] * b[33] * b[9] - b[15] * b[4] * b[38] - b[15] * b[5] * b[37] + b[29] * b[5] * b[23] + b[29] * b[6] * b[22] + b[29] * b[7] * b[21] - b[27] * b[20] * b[10] + b[27] * b[5] * b[25] + b[27] * b[6] * b[24] + b[27] * b[7] * b[23] - b[27] * b[18] * b[12] - b[27] * b[19] * b[11] - b[28] * b[20] * b[9] - b[16] * b[4] * b[37] - b[16] * b[5] * b[36] + b[0] * b[19] * b[38] - b[0] * b[24] * b[33] + b[0] * b[20] * b[37] - b[29] * b[17] * b[11] - b[29] * b[18] * b[10] - b[29] * b[19] * b[9] + b[28] * b[4] * b[25] + b[28] * b[5] * b[24] + b[28] * b[6] * b[23] + b[28] * b[7] * b[22] - b[28] * b[17] * b[12] - b[28] * b[18] * b[11] - b[28] * b[19] * b[10] - b[29] * b[20] * b[8] + b[29] * b[4] * b[24] + b[2] * b[18] * b[37] - b[0] * b[25] * b[32] + b[1] * b[18] * b[38] - b[1] * b[24] * b[32] + b[1] * b[19] * b[37] + b[1] * b[20] * b[36] - b[1] * b[25] * b[31] + b[2] * b[17] * b[38] + b[2] * b[19] * b[36] - b[2] * b[24] * b[31] - b[2] * b[22] * b[33] - b[2] * b[23] * b[32] + b[2] * b[20] * b[35] - b[1] * b[23] * b[33] - b[2] * b[25] * b[30]);
	c[3] = (-b[14] * b[6] * b[38] - b[14] * b[7] * b[37] + b[3] * b[19] * b[36] - b[3] * b[22] * b[33] + b[3] * b[20] * b[35] - b[3] * b[23] * b[32] - b[3] * b[25] * b[30] + b[3] * b[17] * b[38] + b[3] * b[18] * b[37] - b[3] * b[24] * b[31] - b[15] * b[6] * b[37] - b[15] * b[7] * b[36] + b[15] * b[31] * b[12] + b[16] * b[32] * b[10] + b[16] * b[33] * b[9] + b[13] * b[33] * b[12] - b[13] * b[7] * b[38] + b[14] * b[32] * b[12] + b[14] * b[33] * b[11] - b[16] * b[6] * b[36] - b[16] * b[7] * b[35] + b[16] * b[31] * b[11] + b[16] * b[30] * b[12] + b[15] * b[32] * b[11] + b[15] * b[33] * b[10] - b[15] * b[5] * b[38] + b[29] * b[5] * b[24] + b[29] * b[6] * b[23] - b[26] * b[20] * b[12] + b[26] * b[7] * b[25] - b[27] * b[19] * b[12] - b[27] * b[20] * b[11] + b[27] * b[6] * b[25] + b[27] * b[7] * b[24] - b[28] * b[20] * b[10] - b[16] * b[4] * b[38] - b[16] * b[5] * b[37] + b[29] * b[7] * b[22] - b[29] * b[17] * b[12] - b[29] * b[18] * b[11] - b[29] * b[19] * b[10] + b[28] * b[5] * b[25] + b[28] * b[6] * b[24] + b[28] * b[7] * b[23] - b[28] * b[18] * b[12] - b[28] * b[19] * b[11] - b[29] * b[20] * b[9] + b[29] * b[4] * b[25] - b[2] * b[24] * b[32] + b[0] * b[20] * b[38] - b[0] * b[25] * b[33] + b[1] * b[19] * b[38] - b[1] * b[24] * b[33] + b[1] * b[20] * b[37] - b[2] * b[25] * b[31] + b[2] * b[20] * b[36] - b[1] * b[25] * b[32] + b[2] * b[19] * b[37] + b[2] * b[18] * b[38] - b[2] * b[23] * b[33]);
	c[2] = (b[3] * b[18] * b[38] - b[3] * b[24] * b[32] + b[3] * b[19] * b[37] + b[3] * b[20] * b[36] - b[3] * b[25] * b[31] - b[3] * b[23] * b[33] - b[15] * b[6] * b[38] - b[15] * b[7] * b[37] + b[16] * b[32] * b[11] + b[16] * b[33] * b[10] - b[16] * b[5] * b[38] - b[16] * b[6] * b[37] - b[16] * b[7] * b[36] + b[16] * b[31] * b[12] + b[14] * b[33] * b[12] - b[14] * b[7] * b[38] + b[15] * b[32] * b[12] + b[15] * b[33] * b[11] + b[29] * b[5] * b[25] + b[29] * b[6] * b[24] - b[27] * b[20] * b[12] + b[27] * b[7] * b[25] - b[28] * b[19] * b[12] - b[28] * b[20] * b[11] + b[29] * b[7] * b[23] - b[29] * b[18] * b[12] - b[29] * b[19] * b[11] + b[28] * b[6] * b[25] + b[28] * b[7] * b[24] - b[29] * b[20] * b[10] + b[2] * b[19] * b[38] - b[1] * b[25] * b[33] + b[2] * b[20] * b[37] - b[2] * b[24] * b[33] - b[2] * b[25] * b[32] + b[1] * b[20] * b[38]);
	c[1] = (b[29] * b[7] * b[24] - b[29] * b[20] * b[11] + b[2] * b[20] * b[38] - b[2] * b[25] * b[33] - b[28] * b[20] * b[12] + b[28] * b[7] * b[25] - b[29] * b[19] * b[12] - b[3] * b[24] * b[33] + b[15] * b[33] * b[12] + b[3] * b[19] * b[38] - b[16] * b[6] * b[38] + b[3] * b[20] * b[37] + b[16] * b[32] * b[12] + b[29] * b[6] * b[25] - b[16] * b[7] * b[37] - b[3] * b[25] * b[32] - b[15] * b[7] * b[38] + b[16] * b[33] * b[11]);
	c[0] = -b[29] * b[20] * b[12] + b[29] * b[7] * b[25] + b[16] * b[33] * b[12] - b[16] * b[7] * b[38] + b[3] * b[20] * b[38] - b[3] * b[25] * b[33];

	std::vector<std::complex<double> > roots;
	solvePoly(coeffs, roots);

	std::vector<double> xs, ys, zs;
	int count = 0;
	double * e = ematrix->data.db;
	for (int i = 0; i < roots.size(); i++)
	{
		if (fabs(roots[i].imag()) > 1e-10) continue;
		double z1 = roots[i].real();
		double z2 = z1 * z1;
		double z3 = z2 * z1;
		double z4 = z3 * z1;

		double bz[3][3];
		for (int j = 0; j < 3; j++)
		{
			const double * br = b + j * 13;
			bz[j][0] = br[0] * z3 + br[1] * z2 + br[2] * z1 + br[3];
			bz[j][1] = br[4] * z3 + br[5] * z2 + br[6] * z1 + br[7];
			bz[j][2] = br[8] * z4 + br[9] * z3 + br[10] * z2 + br[11] * z1 + br[12];
		}

		Mat Bz(3, 3, CV_64F, bz);
		cv::Mat xy1;
		SVD::solveZ(Bz, xy1);

		if (fabs(xy1.at<double>(2)) < 1e-10) continue;
		xs.push_back(xy1.at<double>(0) / xy1.at<double>(2));
		ys.push_back(xy1.at<double>(1) / xy1.at<double>(2));
		zs.push_back(z1);

		cv::Mat Evec = EE.col(0) * xs.back() + EE.col(1) * ys.back() + EE.col(2) * zs.back() + EE.col(3);
		Evec /= norm(Evec);

		memcpy(e + count * 9, Evec.data, 9 * sizeof(double));
		count++;
	}

	return count;

}
// Same as the runKernel (run5Point), m1 and m2 should be 1 row x n col x 2 channels. And also, error has to be of CV_32FC1. 
void CvEMEstimator::computeReprojError(const CvMat* m1, const CvMat* m2, const CvMat* model, CvMat* error)
{
	Mat X1(m1), X2(m2);
	int n = X1.cols;
	X1 = X1.reshape(1, n);
	X2 = X2.reshape(1, n);

	X1.convertTo(X1, CV_64F);
	X2.convertTo(X2, CV_64F);

	Mat E(model);
	for (int i = 0; i < n; i++)
	{
		Mat x1 = (Mat_<double>(3, 1) << X1.at<double>(i, 0), X1.at<double>(i, 1), 1.0);
		Mat x2 = (Mat_<double>(3, 1) << X2.at<double>(i, 0), X2.at<double>(i, 1), 1.0);
		double x2tEx1 = x2.dot(E * x1);
		Mat Ex1 = E * x1;
		Mat Etx2 = E * x2;
		double a = Ex1.at<double>(0) * Ex1.at<double>(0);
		double b = Ex1.at<double>(1) * Ex1.at<double>(1);
		double c = Etx2.at<double>(0) * Etx2.at<double>(0);
		double d = Etx2.at<double>(0) * Etx2.at<double>(0);

		error->data.fl[i] = x2tEx1 * x2tEx1 / (a + b + c + d);
	}

	/*	Eigen::MatrixXd X1t, X2t;
	cv2eigen(Mat(m1).reshape(1, m1->cols), X1t);
	cv2eigen(Mat(m2).reshape(1, m2->cols), X2t);
	Eigen::MatrixXd X1(3, X1t.rows());
	Eigen::MatrixXd X2(3, X2t.rows());
	X1.topRows(2) = X1t.transpose();
	X2.topRows(2) = X2t.transpose();
	X1.row(2).setOnes();
	X2.row(2).setOnes();

	Eigen::MatrixXd E;
	cv2eigen(Mat(model), E);

	// Compute Simpson's error
	Eigen::MatrixXd Ex1, x2tEx1, Etx2, SimpsonError;
	Ex1 = E * X1;
	x2tEx1 = (X2.array() * Ex1.array()).matrix().colwise().sum();
	Etx2 = E.transpose() * X2;
	SimpsonError = x2tEx1.array().square() / (Ex1.row(0).array().square() + Ex1.row(1).array().square() + Etx2.row(0).array().square() + Etx2.row(1).array().square());

	assert( CV_IS_MAT_CONT(error->type) );
	Mat isInliers, R, t;
	for (int i = 0; i < SimpsonError.cols(); i++)
	{
	error->data.fl[i] = SimpsonError(0, i);
	}
	*/
}
void CvEMEstimator::getCoeffMat(double *e, double *A)
{
	double ep2[36], ep3[36];
	for (int i = 0; i < 36; i++)
	{
		ep2[i] = e[i] * e[i];
		ep3[i] = ep2[i] * e[i];
	}

	A[0] = e[33] * e[28] * e[32] - e[33] * e[31] * e[29] + e[30] * e[34] * e[29] - e[30] * e[28] * e[35] - e[27] * e[32] * e[34] + e[27] * e[31] * e[35];
	A[146] = .5000000000*e[6] * ep2[8] - .5000000000*e[6] * ep2[5] + .5000000000*ep3[6] + .5000000000*e[6] * ep2[7] - .5000000000*e[6] * ep2[4] + e[0] * e[2] * e[8] + e[3] * e[4] * e[7] + e[3] * e[5] * e[8] + e[0] * e[1] * e[7] - .5000000000*e[6] * ep2[1] - .5000000000*e[6] * ep2[2] + .5000000000*ep2[0] * e[6] + .5000000000*ep2[3] * e[6];
	A[1] = e[30] * e[34] * e[2] + e[33] * e[1] * e[32] - e[3] * e[28] * e[35] + e[0] * e[31] * e[35] + e[3] * e[34] * e[29] - e[30] * e[1] * e[35] + e[27] * e[31] * e[8] - e[27] * e[32] * e[7] - e[30] * e[28] * e[8] - e[33] * e[31] * e[2] - e[0] * e[32] * e[34] + e[6] * e[28] * e[32] - e[33] * e[4] * e[29] + e[33] * e[28] * e[5] + e[30] * e[7] * e[29] + e[27] * e[4] * e[35] - e[27] * e[5] * e[34] - e[6] * e[31] * e[29];
	A[147] = e[9] * e[27] * e[15] + e[9] * e[29] * e[17] + e[9] * e[11] * e[35] + e[9] * e[28] * e[16] + e[9] * e[10] * e[34] + e[27] * e[11] * e[17] + e[27] * e[10] * e[16] + e[12] * e[30] * e[15] + e[12] * e[32] * e[17] + e[12] * e[14] * e[35] + e[12] * e[31] * e[16] + e[12] * e[13] * e[34] + e[30] * e[14] * e[17] + e[30] * e[13] * e[16] + e[15] * e[35] * e[17] + e[15] * e[34] * e[16] - 1.*e[15] * e[28] * e[10] - 1.*e[15] * e[31] * e[13] - 1.*e[15] * e[32] * e[14] - 1.*e[15] * e[29] * e[11] + .5000000000*ep2[9] * e[33] + .5000000000*e[33] * ep2[16] - .5000000000*e[33] * ep2[11] + .5000000000*e[33] * ep2[12] + 1.500000000*e[33] * ep2[15] + .5000000000*e[33] * ep2[17] - .5000000000*e[33] * ep2[10] - .5000000000*e[33] * ep2[14] - .5000000000*e[33] * ep2[13];
	A[2] = -e[33] * e[22] * e[29] - e[33] * e[31] * e[20] - e[27] * e[32] * e[25] + e[27] * e[22] * e[35] - e[27] * e[23] * e[34] + e[27] * e[31] * e[26] + e[33] * e[28] * e[23] - e[21] * e[28] * e[35] + e[30] * e[25] * e[29] + e[24] * e[28] * e[32] - e[24] * e[31] * e[29] + e[18] * e[31] * e[35] - e[30] * e[28] * e[26] - e[30] * e[19] * e[35] + e[21] * e[34] * e[29] + e[33] * e[19] * e[32] - e[18] * e[32] * e[34] + e[30] * e[34] * e[20];
	A[144] = e[18] * e[2] * e[17] + e[3] * e[21] * e[15] + e[3] * e[12] * e[24] + e[3] * e[23] * e[17] + e[3] * e[14] * e[26] + e[3] * e[22] * e[16] + e[3] * e[13] * e[25] + 3.*e[6] * e[24] * e[15] + e[6] * e[26] * e[17] + e[6] * e[25] * e[16] + e[0] * e[20] * e[17] + e[0] * e[11] * e[26] + e[0] * e[19] * e[16] + e[0] * e[10] * e[25] + e[15] * e[26] * e[8] - 1.*e[15] * e[20] * e[2] - 1.*e[15] * e[19] * e[1] - 1.*e[15] * e[22] * e[4] + e[15] * e[25] * e[7] - 1.*e[15] * e[23] * e[5] + e[12] * e[21] * e[6] + e[12] * e[22] * e[7] + e[12] * e[4] * e[25] + e[12] * e[23] * e[8] + e[12] * e[5] * e[26] - 1.*e[24] * e[11] * e[2] - 1.*e[24] * e[10] * e[1] - 1.*e[24] * e[13] * e[4] + e[24] * e[16] * e[7] - 1.*e[24] * e[14] * e[5] + e[24] * e[17] * e[8] + e[21] * e[13] * e[7] + e[21] * e[4] * e[16] + e[21] * e[14] * e[8] + e[21] * e[5] * e[17] - 1.*e[6] * e[23] * e[14] - 1.*e[6] * e[20] * e[11] - 1.*e[6] * e[19] * e[10] - 1.*e[6] * e[22] * e[13] + e[9] * e[18] * e[6] + e[9] * e[0] * e[24] + e[9] * e[19] * e[7] + e[9] * e[1] * e[25] + e[9] * e[20] * e[8] + e[9] * e[2] * e[26] + e[18] * e[0] * e[15] + e[18] * e[10] * e[7] + e[18] * e[1] * e[16] + e[18] * e[11] * e[8];
	A[3] = e[33] * e[10] * e[32] + e[33] * e[28] * e[14] - e[33] * e[13] * e[29] - e[33] * e[31] * e[11] + e[9] * e[31] * e[35] - e[9] * e[32] * e[34] + e[27] * e[13] * e[35] - e[27] * e[32] * e[16] + e[27] * e[31] * e[17] - e[27] * e[14] * e[34] + e[12] * e[34] * e[29] - e[12] * e[28] * e[35] + e[30] * e[34] * e[11] + e[30] * e[16] * e[29] - e[30] * e[10] * e[35] - e[30] * e[28] * e[17] + e[15] * e[28] * e[32] - e[15] * e[31] * e[29];
	A[145] = e[0] * e[27] * e[6] + e[0] * e[28] * e[7] + e[0] * e[1] * e[34] + e[0] * e[29] * e[8] + e[0] * e[2] * e[35] + e[6] * e[34] * e[7] - 1.*e[6] * e[32] * e[5] + e[6] * e[30] * e[3] + e[6] * e[35] * e[8] - 1.*e[6] * e[29] * e[2] - 1.*e[6] * e[28] * e[1] - 1.*e[6] * e[31] * e[4] + e[27] * e[1] * e[7] + e[27] * e[2] * e[8] + e[3] * e[31] * e[7] + e[3] * e[4] * e[34] + e[3] * e[32] * e[8] + e[3] * e[5] * e[35] + e[30] * e[4] * e[7] + e[30] * e[5] * e[8] + .5000000000*ep2[0] * e[33] + 1.500000000*e[33] * ep2[6] - .5000000000*e[33] * ep2[4] - .5000000000*e[33] * ep2[5] - .5000000000*e[33] * ep2[1] + .5000000000*e[33] * ep2[7] + .5000000000*e[33] * ep2[3] - .5000000000*e[33] * ep2[2] + .5000000000*e[33] * ep2[8];
	A[4] = -e[0] * e[23] * e[16] + e[9] * e[4] * e[26] + e[9] * e[22] * e[8] - e[9] * e[5] * e[25] - e[9] * e[23] * e[7] + e[18] * e[4] * e[17] + e[18] * e[13] * e[8] - e[18] * e[5] * e[16] - e[18] * e[14] * e[7] + e[3] * e[16] * e[20] + e[3] * e[25] * e[11] - e[3] * e[10] * e[26] - e[3] * e[19] * e[17] + e[12] * e[7] * e[20] + e[12] * e[25] * e[2] - e[12] * e[1] * e[26] - e[12] * e[19] * e[8] + e[21] * e[7] * e[11] + e[21] * e[16] * e[2] - e[21] * e[1] * e[17] - e[21] * e[10] * e[8] + e[6] * e[10] * e[23] + e[6] * e[19] * e[14] - e[6] * e[13] * e[20] - e[6] * e[22] * e[11] + e[15] * e[1] * e[23] + e[15] * e[19] * e[5] - e[15] * e[4] * e[20] - e[15] * e[22] * e[2] + e[24] * e[1] * e[14] + e[24] * e[10] * e[5] - e[24] * e[4] * e[11] - e[24] * e[13] * e[2] + e[0] * e[13] * e[26] + e[0] * e[22] * e[17] - e[0] * e[14] * e[25];
	A[150] = e[18] * e[19] * e[25] + .5000000000*ep3[24] - .5000000000*e[24] * ep2[23] + e[18] * e[20] * e[26] + e[21] * e[22] * e[25] + e[21] * e[23] * e[26] - .5000000000*e[24] * ep2[19] + .5000000000*ep2[21] * e[24] + .5000000000*e[24] * ep2[26] - .5000000000*e[24] * ep2[20] + .5000000000*ep2[18] * e[24] - .5000000000*e[24] * ep2[22] + .5000000000*e[24] * ep2[25];
	A[5] = -e[3] * e[1] * e[35] - e[0] * e[32] * e[7] + e[27] * e[4] * e[8] + e[33] * e[1] * e[5] - e[33] * e[4] * e[2] + e[0] * e[4] * e[35] + e[3] * e[34] * e[2] - e[30] * e[1] * e[8] + e[30] * e[7] * e[2] - e[6] * e[4] * e[29] + e[3] * e[7] * e[29] + e[6] * e[1] * e[32] - e[0] * e[5] * e[34] - e[3] * e[28] * e[8] + e[0] * e[31] * e[8] + e[6] * e[28] * e[5] - e[6] * e[31] * e[2] - e[27] * e[5] * e[7];
	A[151] = e[33] * e[16] * e[7] - 1.*e[33] * e[14] * e[5] + e[33] * e[17] * e[8] + e[30] * e[13] * e[7] + e[30] * e[4] * e[16] + e[30] * e[14] * e[8] + e[30] * e[5] * e[17] + e[6] * e[27] * e[9] - 1.*e[6] * e[28] * e[10] - 1.*e[6] * e[31] * e[13] - 1.*e[6] * e[32] * e[14] - 1.*e[6] * e[29] * e[11] + e[9] * e[28] * e[7] + e[9] * e[1] * e[34] + e[9] * e[29] * e[8] + e[9] * e[2] * e[35] + e[27] * e[10] * e[7] + e[27] * e[1] * e[16] + e[27] * e[11] * e[8] + e[27] * e[2] * e[17] + e[3] * e[30] * e[15] + e[3] * e[12] * e[33] + e[3] * e[32] * e[17] + e[3] * e[14] * e[35] + e[3] * e[31] * e[16] + e[3] * e[13] * e[34] + 3.*e[6] * e[33] * e[15] + e[6] * e[35] * e[17] + e[6] * e[34] * e[16] + e[0] * e[27] * e[15] + e[0] * e[9] * e[33] + e[0] * e[29] * e[17] + e[0] * e[11] * e[35] + e[0] * e[28] * e[16] + e[0] * e[10] * e[34] + e[15] * e[34] * e[7] - 1.*e[15] * e[32] * e[5] + e[15] * e[35] * e[8] - 1.*e[15] * e[29] * e[2] - 1.*e[15] * e[28] * e[1] - 1.*e[15] * e[31] * e[4] + e[12] * e[30] * e[6] + e[12] * e[31] * e[7] + e[12] * e[4] * e[34] + e[12] * e[32] * e[8] + e[12] * e[5] * e[35] - 1.*e[33] * e[11] * e[2] - 1.*e[33] * e[10] * e[1] - 1.*e[33] * e[13] * e[4];
	A[6] = e[6] * e[1] * e[5] - e[6] * e[4] * e[2] + e[3] * e[7] * e[2] + e[0] * e[4] * e[8] - e[0] * e[5] * e[7] - e[3] * e[1] * e[8];
	A[148] = .5000000000*ep3[15] + e[9] * e[10] * e[16] - .5000000000*e[15] * ep2[11] + e[9] * e[11] * e[17] + .5000000000*ep2[12] * e[15] + .5000000000*e[15] * ep2[16] + .5000000000*e[15] * ep2[17] - .5000000000*e[15] * ep2[13] + .5000000000*ep2[9] * e[15] + e[12] * e[14] * e[17] - .5000000000*e[15] * ep2[10] - .5000000000*e[15] * ep2[14] + e[12] * e[13] * e[16];
	A[7] = e[15] * e[28] * e[14] - e[15] * e[13] * e[29] - e[15] * e[31] * e[11] + e[33] * e[10] * e[14] - e[33] * e[13] * e[11] + e[9] * e[13] * e[35] - e[9] * e[32] * e[16] + e[9] * e[31] * e[17] - e[9] * e[14] * e[34] + e[27] * e[13] * e[17] - e[27] * e[14] * e[16] + e[12] * e[34] * e[11] + e[12] * e[16] * e[29] - e[12] * e[10] * e[35] - e[12] * e[28] * e[17] + e[30] * e[16] * e[11] - e[30] * e[10] * e[17] + e[15] * e[10] * e[32];
	A[149] = e[18] * e[27] * e[24] + e[18] * e[28] * e[25] + e[18] * e[19] * e[34] + e[18] * e[29] * e[26] + e[18] * e[20] * e[35] + e[27] * e[19] * e[25] + e[27] * e[20] * e[26] + e[21] * e[30] * e[24] + e[21] * e[31] * e[25] + e[21] * e[22] * e[34] + e[21] * e[32] * e[26] + e[21] * e[23] * e[35] + e[30] * e[22] * e[25] + e[30] * e[23] * e[26] + e[24] * e[34] * e[25] + e[24] * e[35] * e[26] - 1.*e[24] * e[29] * e[20] - 1.*e[24] * e[31] * e[22] - 1.*e[24] * e[32] * e[23] - 1.*e[24] * e[28] * e[19] + 1.500000000*e[33] * ep2[24] + .5000000000*e[33] * ep2[25] + .5000000000*e[33] * ep2[26] - .5000000000*e[33] * ep2[23] - .5000000000*e[33] * ep2[19] - .5000000000*e[33] * ep2[20] - .5000000000*e[33] * ep2[22] + .5000000000*ep2[18] * e[33] + .5000000000*ep2[21] * e[33];
	A[9] = e[21] * e[25] * e[29] - e[27] * e[23] * e[25] + e[24] * e[19] * e[32] - e[21] * e[28] * e[26] - e[21] * e[19] * e[35] + e[18] * e[31] * e[26] - e[30] * e[19] * e[26] - e[24] * e[31] * e[20] + e[24] * e[28] * e[23] + e[27] * e[22] * e[26] + e[30] * e[25] * e[20] - e[33] * e[22] * e[20] + e[33] * e[19] * e[23] + e[21] * e[34] * e[20] - e[18] * e[23] * e[34] - e[24] * e[22] * e[29] - e[18] * e[32] * e[25] + e[18] * e[22] * e[35];
	A[155] = e[12] * e[14] * e[8] + e[12] * e[5] * e[17] + e[15] * e[16] * e[7] + e[15] * e[17] * e[8] + e[0] * e[11] * e[17] + e[0] * e[9] * e[15] + e[0] * e[10] * e[16] + e[3] * e[14] * e[17] + e[3] * e[13] * e[16] + e[9] * e[10] * e[7] + e[9] * e[1] * e[16] + e[9] * e[11] * e[8] + e[9] * e[2] * e[17] - 1.*e[15] * e[11] * e[2] - 1.*e[15] * e[10] * e[1] - 1.*e[15] * e[13] * e[4] - 1.*e[15] * e[14] * e[5] + e[12] * e[3] * e[15] + e[12] * e[13] * e[7] + e[12] * e[4] * e[16] + .5000000000*ep2[12] * e[6] + 1.500000000*ep2[15] * e[6] + .5000000000*e[6] * ep2[17] + .5000000000*e[6] * ep2[16] + .5000000000*e[6] * ep2[9] - .5000000000*e[6] * ep2[11] - .5000000000*e[6] * ep2[10] - .5000000000*e[6] * ep2[14] - .5000000000*e[6] * ep2[13];
	A[8] = -e[9] * e[14] * e[16] - e[12] * e[10] * e[17] + e[9] * e[13] * e[17] - e[15] * e[13] * e[11] + e[15] * e[10] * e[14] + e[12] * e[16] * e[11];
	A[154] = e[21] * e[14] * e[17] + e[21] * e[13] * e[16] + e[15] * e[26] * e[17] + e[15] * e[25] * e[16] - 1.*e[15] * e[23] * e[14] - 1.*e[15] * e[20] * e[11] - 1.*e[15] * e[19] * e[10] - 1.*e[15] * e[22] * e[13] + e[9] * e[20] * e[17] + e[9] * e[11] * e[26] + e[9] * e[19] * e[16] + e[9] * e[10] * e[25] + .5000000000*ep2[12] * e[24] + 1.500000000*e[24] * ep2[15] + .5000000000*e[24] * ep2[17] + .5000000000*e[24] * ep2[16] + .5000000000*ep2[9] * e[24] - .5000000000*e[24] * ep2[11] - .5000000000*e[24] * ep2[10] - .5000000000*e[24] * ep2[14] - .5000000000*e[24] * ep2[13] + e[18] * e[11] * e[17] + e[18] * e[9] * e[15] + e[18] * e[10] * e[16] + e[12] * e[21] * e[15] + e[12] * e[23] * e[17] + e[12] * e[14] * e[26] + e[12] * e[22] * e[16] + e[12] * e[13] * e[25];
	A[11] = -e[9] * e[5] * e[34] + e[9] * e[31] * e[8] - e[9] * e[32] * e[7] + e[27] * e[4] * e[17] + e[27] * e[13] * e[8] - e[27] * e[5] * e[16] - e[27] * e[14] * e[7] + e[0] * e[13] * e[35] - e[0] * e[32] * e[16] + e[0] * e[31] * e[17] - e[0] * e[14] * e[34] + e[9] * e[4] * e[35] + e[6] * e[10] * e[32] + e[6] * e[28] * e[14] - e[6] * e[13] * e[29] - e[6] * e[31] * e[11] + e[15] * e[1] * e[32] + e[3] * e[34] * e[11] + e[3] * e[16] * e[29] - e[3] * e[10] * e[35] - e[3] * e[28] * e[17] - e[12] * e[1] * e[35] + e[12] * e[7] * e[29] + e[12] * e[34] * e[2] - e[12] * e[28] * e[8] + e[15] * e[28] * e[5] - e[15] * e[4] * e[29] - e[15] * e[31] * e[2] + e[33] * e[1] * e[14] + e[33] * e[10] * e[5] - e[33] * e[4] * e[11] - e[33] * e[13] * e[2] + e[30] * e[7] * e[11] + e[30] * e[16] * e[2] - e[30] * e[1] * e[17] - e[30] * e[10] * e[8];
	A[153] = e[21] * e[31] * e[7] + e[21] * e[4] * e[34] + e[21] * e[32] * e[8] + e[21] * e[5] * e[35] + e[30] * e[22] * e[7] + e[30] * e[4] * e[25] + e[30] * e[23] * e[8] + e[30] * e[5] * e[26] + 3.*e[24] * e[33] * e[6] + e[24] * e[34] * e[7] + e[24] * e[35] * e[8] + e[33] * e[25] * e[7] + e[33] * e[26] * e[8] + e[0] * e[27] * e[24] + e[0] * e[18] * e[33] + e[0] * e[28] * e[25] + e[0] * e[19] * e[34] + e[0] * e[29] * e[26] + e[0] * e[20] * e[35] + e[18] * e[27] * e[6] + e[18] * e[28] * e[7] + e[18] * e[1] * e[34] + e[18] * e[29] * e[8] + e[18] * e[2] * e[35] + e[27] * e[19] * e[7] + e[27] * e[1] * e[25] + e[27] * e[20] * e[8] + e[27] * e[2] * e[26] + e[3] * e[30] * e[24] + e[3] * e[21] * e[33] + e[3] * e[31] * e[25] + e[3] * e[22] * e[34] + e[3] * e[32] * e[26] + e[3] * e[23] * e[35] + e[6] * e[30] * e[21] - 1.*e[6] * e[29] * e[20] + e[6] * e[35] * e[26] - 1.*e[6] * e[31] * e[22] - 1.*e[6] * e[32] * e[23] - 1.*e[6] * e[28] * e[19] + e[6] * e[34] * e[25] - 1.*e[24] * e[32] * e[5] - 1.*e[24] * e[29] * e[2] - 1.*e[24] * e[28] * e[1] - 1.*e[24] * e[31] * e[4] - 1.*e[33] * e[20] * e[2] - 1.*e[33] * e[19] * e[1] - 1.*e[33] * e[22] * e[4] - 1.*e[33] * e[23] * e[5];
	A[10] = e[21] * e[25] * e[20] - e[21] * e[19] * e[26] + e[18] * e[22] * e[26] - e[18] * e[23] * e[25] - e[24] * e[22] * e[20] + e[24] * e[19] * e[23];
	A[152] = e[3] * e[4] * e[25] + e[3] * e[23] * e[8] + e[3] * e[5] * e[26] + e[21] * e[4] * e[7] + e[21] * e[5] * e[8] + e[6] * e[25] * e[7] + e[6] * e[26] * e[8] + e[0] * e[19] * e[7] + e[0] * e[1] * e[25] + e[0] * e[20] * e[8] + e[0] * e[2] * e[26] - 1.*e[6] * e[20] * e[2] - 1.*e[6] * e[19] * e[1] - 1.*e[6] * e[22] * e[4] - 1.*e[6] * e[23] * e[5] + e[18] * e[1] * e[7] + e[18] * e[0] * e[6] + e[18] * e[2] * e[8] + e[3] * e[21] * e[6] + e[3] * e[22] * e[7] - .5000000000*e[24] * ep2[4] + .5000000000*e[24] * ep2[0] + 1.500000000*e[24] * ep2[6] - .5000000000*e[24] * ep2[5] - .5000000000*e[24] * ep2[1] + .5000000000*e[24] * ep2[7] + .5000000000*e[24] * ep2[3] - .5000000000*e[24] * ep2[2] + .5000000000*e[24] * ep2[8];
	A[13] = e[6] * e[28] * e[23] - e[6] * e[22] * e[29] - e[6] * e[31] * e[20] - e[3] * e[19] * e[35] + e[3] * e[34] * e[20] + e[3] * e[25] * e[29] - e[21] * e[1] * e[35] + e[21] * e[7] * e[29] + e[21] * e[34] * e[2] + e[24] * e[1] * e[32] + e[24] * e[28] * e[5] - e[24] * e[4] * e[29] - e[24] * e[31] * e[2] + e[33] * e[1] * e[23] + e[33] * e[19] * e[5] - e[33] * e[4] * e[20] - e[33] * e[22] * e[2] - e[21] * e[28] * e[8] + e[30] * e[7] * e[20] + e[30] * e[25] * e[2] - e[30] * e[1] * e[26] + e[18] * e[4] * e[35] - e[18] * e[5] * e[34] + e[18] * e[31] * e[8] - e[18] * e[32] * e[7] + e[27] * e[4] * e[26] + e[27] * e[22] * e[8] - e[27] * e[5] * e[25] - e[27] * e[23] * e[7] - e[3] * e[28] * e[26] - e[0] * e[32] * e[25] + e[0] * e[22] * e[35] - e[0] * e[23] * e[34] + e[0] * e[31] * e[26] - e[30] * e[19] * e[8] + e[6] * e[19] * e[32];
	A[159] = .5000000000*ep2[18] * e[6] + .5000000000*ep2[21] * e[6] + 1.500000000*ep2[24] * e[6] + .5000000000*e[6] * ep2[26] - .5000000000*e[6] * ep2[23] - .5000000000*e[6] * ep2[19] - .5000000000*e[6] * ep2[20] - .5000000000*e[6] * ep2[22] + .5000000000*e[6] * ep2[25] + e[21] * e[3] * e[24] + e[18] * e[20] * e[8] + e[21] * e[4] * e[25] + e[18] * e[19] * e[7] + e[18] * e[1] * e[25] + e[21] * e[22] * e[7] + e[21] * e[23] * e[8] + e[18] * e[0] * e[24] + e[18] * e[2] * e[26] + e[21] * e[5] * e[26] + e[24] * e[26] * e[8] - 1.*e[24] * e[20] * e[2] - 1.*e[24] * e[19] * e[1] - 1.*e[24] * e[22] * e[4] + e[24] * e[25] * e[7] - 1.*e[24] * e[23] * e[5] + e[0] * e[19] * e[25] + e[0] * e[20] * e[26] + e[3] * e[22] * e[25] + e[3] * e[23] * e[26];
	A[12] = e[18] * e[4] * e[8] + e[3] * e[7] * e[20] + e[3] * e[25] * e[2] - e[3] * e[1] * e[26] - e[18] * e[5] * e[7] + e[6] * e[1] * e[23] + e[6] * e[19] * e[5] - e[6] * e[4] * e[20] - e[6] * e[22] * e[2] + e[21] * e[7] * e[2] - e[21] * e[1] * e[8] + e[24] * e[1] * e[5] - e[24] * e[4] * e[2] - e[3] * e[19] * e[8] + e[0] * e[4] * e[26] + e[0] * e[22] * e[8] - e[0] * e[5] * e[25] - e[0] * e[23] * e[7];
	A[158] = e[9] * e[1] * e[7] + e[9] * e[0] * e[6] + e[9] * e[2] * e[8] + e[3] * e[12] * e[6] + e[3] * e[13] * e[7] + e[3] * e[4] * e[16] + e[3] * e[14] * e[8] + e[3] * e[5] * e[17] + e[12] * e[4] * e[7] + e[12] * e[5] * e[8] + e[6] * e[16] * e[7] + e[6] * e[17] * e[8] - 1.*e[6] * e[11] * e[2] - 1.*e[6] * e[10] * e[1] - 1.*e[6] * e[13] * e[4] - 1.*e[6] * e[14] * e[5] + e[0] * e[10] * e[7] + e[0] * e[1] * e[16] + e[0] * e[11] * e[8] + e[0] * e[2] * e[17] + .5000000000*ep2[3] * e[15] + 1.500000000*e[15] * ep2[6] + .5000000000*e[15] * ep2[7] + .5000000000*e[15] * ep2[8] + .5000000000*ep2[0] * e[15] - .5000000000*e[15] * ep2[4] - .5000000000*e[15] * ep2[5] - .5000000000*e[15] * ep2[1] - .5000000000*e[15] * ep2[2];
	A[15] = -e[15] * e[13] * e[2] - e[6] * e[13] * e[11] - e[15] * e[4] * e[11] + e[12] * e[16] * e[2] - e[3] * e[10] * e[17] + e[3] * e[16] * e[11] + e[0] * e[13] * e[17] - e[0] * e[14] * e[16] + e[15] * e[1] * e[14] - e[12] * e[10] * e[8] + e[9] * e[4] * e[17] + e[9] * e[13] * e[8] - e[9] * e[5] * e[16] - e[9] * e[14] * e[7] + e[15] * e[10] * e[5] + e[12] * e[7] * e[11] + e[6] * e[10] * e[14] - e[12] * e[1] * e[17];
	A[157] = e[12] * e[30] * e[24] + e[12] * e[21] * e[33] + e[12] * e[31] * e[25] + e[12] * e[22] * e[34] + e[12] * e[32] * e[26] + e[12] * e[23] * e[35] + e[9] * e[27] * e[24] + e[9] * e[18] * e[33] + e[9] * e[28] * e[25] + e[9] * e[19] * e[34] + e[9] * e[29] * e[26] + e[9] * e[20] * e[35] + e[21] * e[30] * e[15] + e[21] * e[32] * e[17] + e[21] * e[14] * e[35] + e[21] * e[31] * e[16] + e[21] * e[13] * e[34] + e[30] * e[23] * e[17] + e[30] * e[14] * e[26] + e[30] * e[22] * e[16] + e[30] * e[13] * e[25] + e[15] * e[27] * e[18] + 3.*e[15] * e[33] * e[24] - 1.*e[15] * e[29] * e[20] + e[15] * e[35] * e[26] - 1.*e[15] * e[31] * e[22] - 1.*e[15] * e[32] * e[23] - 1.*e[15] * e[28] * e[19] + e[15] * e[34] * e[25] + e[18] * e[29] * e[17] + e[18] * e[11] * e[35] + e[18] * e[28] * e[16] + e[18] * e[10] * e[34] + e[27] * e[20] * e[17] + e[27] * e[11] * e[26] + e[27] * e[19] * e[16] + e[27] * e[10] * e[25] - 1.*e[24] * e[28] * e[10] - 1.*e[24] * e[31] * e[13] - 1.*e[24] * e[32] * e[14] + e[24] * e[34] * e[16] + e[24] * e[35] * e[17] - 1.*e[24] * e[29] * e[11] - 1.*e[33] * e[23] * e[14] + e[33] * e[25] * e[16] + e[33] * e[26] * e[17] - 1.*e[33] * e[20] * e[11] - 1.*e[33] * e[19] * e[10] - 1.*e[33] * e[22] * e[13];
	A[14] = e[18] * e[13] * e[17] + e[9] * e[13] * e[26] + e[9] * e[22] * e[17] - e[9] * e[14] * e[25] - e[18] * e[14] * e[16] - e[15] * e[13] * e[20] - e[15] * e[22] * e[11] + e[12] * e[16] * e[20] + e[12] * e[25] * e[11] - e[12] * e[10] * e[26] - e[12] * e[19] * e[17] + e[21] * e[16] * e[11] - e[21] * e[10] * e[17] - e[9] * e[23] * e[16] + e[24] * e[10] * e[14] - e[24] * e[13] * e[11] + e[15] * e[10] * e[23] + e[15] * e[19] * e[14];
	A[156] = e[21] * e[12] * e[24] + e[21] * e[23] * e[17] + e[21] * e[14] * e[26] + e[21] * e[22] * e[16] + e[21] * e[13] * e[25] + e[24] * e[26] * e[17] + e[24] * e[25] * e[16] + e[9] * e[19] * e[25] + e[9] * e[18] * e[24] + e[9] * e[20] * e[26] + e[12] * e[22] * e[25] + e[12] * e[23] * e[26] + e[18] * e[20] * e[17] + e[18] * e[11] * e[26] + e[18] * e[19] * e[16] + e[18] * e[10] * e[25] - 1.*e[24] * e[23] * e[14] - 1.*e[24] * e[20] * e[11] - 1.*e[24] * e[19] * e[10] - 1.*e[24] * e[22] * e[13] + .5000000000*ep2[21] * e[15] + 1.500000000*ep2[24] * e[15] + .5000000000*e[15] * ep2[25] + .5000000000*e[15] * ep2[26] + .5000000000*e[15] * ep2[18] - .5000000000*e[15] * ep2[23] - .5000000000*e[15] * ep2[19] - .5000000000*e[15] * ep2[20] - .5000000000*e[15] * ep2[22];
	A[18] = e[6] * e[1] * e[14] + e[15] * e[1] * e[5] - e[0] * e[5] * e[16] - e[0] * e[14] * e[7] + e[0] * e[13] * e[8] - e[15] * e[4] * e[2] + e[12] * e[7] * e[2] + e[6] * e[10] * e[5] + e[3] * e[7] * e[11] - e[6] * e[4] * e[11] + e[3] * e[16] * e[2] - e[6] * e[13] * e[2] - e[3] * e[1] * e[17] - e[9] * e[5] * e[7] - e[3] * e[10] * e[8] - e[12] * e[1] * e[8] + e[0] * e[4] * e[17] + e[9] * e[4] * e[8];
	A[128] = -.5000000000*e[14] * ep2[16] - .5000000000*e[14] * ep2[10] - .5000000000*e[14] * ep2[9] + e[11] * e[9] * e[12] + .5000000000*ep3[14] + e[17] * e[13] * e[16] + .5000000000*e[14] * ep2[12] + e[11] * e[10] * e[13] - .5000000000*e[14] * ep2[15] + .5000000000*e[14] * ep2[17] + e[17] * e[12] * e[15] + .5000000000*ep2[11] * e[14] + .5000000000*e[14] * ep2[13];
	A[19] = -e[21] * e[19] * e[8] + e[18] * e[4] * e[26] - e[18] * e[5] * e[25] - e[18] * e[23] * e[7] + e[21] * e[25] * e[2] - e[21] * e[1] * e[26] + e[6] * e[19] * e[23] + e[18] * e[22] * e[8] - e[0] * e[23] * e[25] - e[6] * e[22] * e[20] + e[24] * e[1] * e[23] + e[24] * e[19] * e[5] - e[24] * e[4] * e[20] - e[24] * e[22] * e[2] + e[3] * e[25] * e[20] - e[3] * e[19] * e[26] + e[0] * e[22] * e[26] + e[21] * e[7] * e[20];
	A[129] = .5000000000*ep2[20] * e[32] + 1.500000000*e[32] * ep2[23] + .5000000000*e[32] * ep2[22] + .5000000000*e[32] * ep2[21] + .5000000000*e[32] * ep2[26] - .5000000000*e[32] * ep2[18] - .5000000000*e[32] * ep2[19] - .5000000000*e[32] * ep2[24] - .5000000000*e[32] * ep2[25] + e[20] * e[27] * e[21] + e[20] * e[18] * e[30] + e[20] * e[28] * e[22] + e[20] * e[19] * e[31] + e[20] * e[29] * e[23] + e[29] * e[19] * e[22] + e[29] * e[18] * e[21] + e[23] * e[30] * e[21] + e[23] * e[31] * e[22] + e[26] * e[30] * e[24] + e[26] * e[21] * e[33] + e[26] * e[31] * e[25] + e[26] * e[22] * e[34] + e[26] * e[23] * e[35] + e[35] * e[22] * e[25] + e[35] * e[21] * e[24] - 1.*e[23] * e[27] * e[18] - 1.*e[23] * e[33] * e[24] - 1.*e[23] * e[28] * e[19] - 1.*e[23] * e[34] * e[25];
	A[16] = -e[9] * e[23] * e[25] - e[21] * e[10] * e[26] - e[21] * e[19] * e[17] - e[18] * e[23] * e[16] + e[18] * e[13] * e[26] + e[12] * e[25] * e[20] - e[12] * e[19] * e[26] - e[15] * e[22] * e[20] + e[21] * e[16] * e[20] + e[21] * e[25] * e[11] + e[24] * e[10] * e[23] + e[24] * e[19] * e[14] - e[24] * e[13] * e[20] - e[24] * e[22] * e[11] + e[18] * e[22] * e[17] - e[18] * e[14] * e[25] + e[9] * e[22] * e[26] + e[15] * e[19] * e[23];
	A[130] = .5000000000*e[23] * ep2[21] + e[20] * e[19] * e[22] + e[20] * e[18] * e[21] + .5000000000*ep3[23] + e[26] * e[22] * e[25] + .5000000000*e[23] * ep2[26] - .5000000000*e[23] * ep2[18] + .5000000000*e[23] * ep2[22] - .5000000000*e[23] * ep2[19] + e[26] * e[21] * e[24] + .5000000000*ep2[20] * e[23] - .5000000000*e[23] * ep2[24] - .5000000000*e[23] * ep2[25];
	A[17] = e[18] * e[13] * e[35] - e[18] * e[32] * e[16] + e[18] * e[31] * e[17] - e[18] * e[14] * e[34] + e[27] * e[13] * e[26] + e[27] * e[22] * e[17] - e[27] * e[14] * e[25] - e[27] * e[23] * e[16] - e[9] * e[32] * e[25] + e[9] * e[22] * e[35] - e[9] * e[23] * e[34] + e[9] * e[31] * e[26] + e[15] * e[19] * e[32] + e[15] * e[28] * e[23] - e[15] * e[22] * e[29] - e[15] * e[31] * e[20] + e[24] * e[10] * e[32] + e[24] * e[28] * e[14] - e[24] * e[13] * e[29] - e[24] * e[31] * e[11] + e[33] * e[10] * e[23] + e[33] * e[19] * e[14] - e[33] * e[13] * e[20] - e[33] * e[22] * e[11] + e[21] * e[16] * e[29] - e[21] * e[10] * e[35] - e[21] * e[28] * e[17] + e[30] * e[16] * e[20] + e[30] * e[25] * e[11] - e[30] * e[10] * e[26] - e[30] * e[19] * e[17] - e[12] * e[28] * e[26] - e[12] * e[19] * e[35] + e[12] * e[34] * e[20] + e[12] * e[25] * e[29] + e[21] * e[34] * e[11];
	A[131] = -1.*e[32] * e[10] * e[1] + e[32] * e[13] * e[4] - 1.*e[32] * e[16] * e[7] - 1.*e[32] * e[15] * e[6] - 1.*e[32] * e[9] * e[0] + e[32] * e[12] * e[3] + e[17] * e[30] * e[6] + e[17] * e[3] * e[33] + e[17] * e[31] * e[7] + e[17] * e[4] * e[34] + e[17] * e[5] * e[35] - 1.*e[5] * e[27] * e[9] - 1.*e[5] * e[28] * e[10] - 1.*e[5] * e[33] * e[15] - 1.*e[5] * e[34] * e[16] + e[5] * e[29] * e[11] + e[35] * e[12] * e[6] + e[35] * e[3] * e[15] + e[35] * e[13] * e[7] + e[35] * e[4] * e[16] + e[11] * e[27] * e[3] + e[11] * e[0] * e[30] + e[11] * e[28] * e[4] + e[11] * e[1] * e[31] + e[29] * e[9] * e[3] + e[29] * e[0] * e[12] + e[29] * e[10] * e[4] + e[29] * e[1] * e[13] + e[5] * e[30] * e[12] + 3.*e[5] * e[32] * e[14] + e[5] * e[31] * e[13] + e[8] * e[30] * e[15] + e[8] * e[12] * e[33] + e[8] * e[32] * e[17] + e[8] * e[14] * e[35] + e[8] * e[31] * e[16] + e[8] * e[13] * e[34] + e[2] * e[27] * e[12] + e[2] * e[9] * e[30] + e[2] * e[29] * e[14] + e[2] * e[11] * e[32] + e[2] * e[28] * e[13] + e[2] * e[10] * e[31] - 1.*e[14] * e[27] * e[0] - 1.*e[14] * e[34] * e[7] - 1.*e[14] * e[33] * e[6] + e[14] * e[30] * e[3] - 1.*e[14] * e[28] * e[1] + e[14] * e[31] * e[4];
	A[22] = .5000000000*e[18] * ep2[29] + .5000000000*e[18] * ep2[28] + .5000000000*e[18] * ep2[30] + .5000000000*e[18] * ep2[33] - .5000000000*e[18] * ep2[32] - .5000000000*e[18] * ep2[31] - .5000000000*e[18] * ep2[34] - .5000000000*e[18] * ep2[35] + 1.500000000*e[18] * ep2[27] + e[27] * e[28] * e[19] + e[27] * e[29] * e[20] + e[21] * e[27] * e[30] + e[21] * e[29] * e[32] + e[21] * e[28] * e[31] + e[30] * e[28] * e[22] + e[30] * e[19] * e[31] + e[30] * e[29] * e[23] + e[30] * e[20] * e[32] + e[24] * e[27] * e[33] + e[24] * e[29] * e[35] + e[24] * e[28] * e[34] + e[33] * e[28] * e[25] + e[33] * e[19] * e[34] + e[33] * e[29] * e[26] + e[33] * e[20] * e[35] - 1.*e[27] * e[35] * e[26] - 1.*e[27] * e[31] * e[22] - 1.*e[27] * e[32] * e[23] - 1.*e[27] * e[34] * e[25];
	A[132] = e[20] * e[1] * e[4] + e[20] * e[0] * e[3] + e[20] * e[2] * e[5] + e[5] * e[21] * e[3] + e[5] * e[22] * e[4] + e[8] * e[21] * e[6] + e[8] * e[3] * e[24] + e[8] * e[22] * e[7] + e[8] * e[4] * e[25] + e[8] * e[5] * e[26] + e[26] * e[4] * e[7] + e[26] * e[3] * e[6] + e[2] * e[18] * e[3] + e[2] * e[0] * e[21] + e[2] * e[19] * e[4] + e[2] * e[1] * e[22] - 1.*e[5] * e[19] * e[1] - 1.*e[5] * e[18] * e[0] - 1.*e[5] * e[25] * e[7] - 1.*e[5] * e[24] * e[6] + .5000000000*e[23] * ep2[4] - .5000000000*e[23] * ep2[0] - .5000000000*e[23] * ep2[6] + 1.500000000*e[23] * ep2[5] - .5000000000*e[23] * ep2[1] - .5000000000*e[23] * ep2[7] + .5000000000*e[23] * ep2[3] + .5000000000*e[23] * ep2[2] + .5000000000*e[23] * ep2[8];
	A[23] = 1.500000000*e[9] * ep2[27] + .5000000000*e[9] * ep2[29] + .5000000000*e[9] * ep2[28] - .5000000000*e[9] * ep2[32] - .5000000000*e[9] * ep2[31] + .5000000000*e[9] * ep2[33] + .5000000000*e[9] * ep2[30] - .5000000000*e[9] * ep2[34] - .5000000000*e[9] * ep2[35] + e[33] * e[27] * e[15] + e[33] * e[29] * e[17] + e[33] * e[11] * e[35] + e[33] * e[28] * e[16] + e[33] * e[10] * e[34] + e[27] * e[29] * e[11] + e[27] * e[28] * e[10] + e[27] * e[30] * e[12] - 1.*e[27] * e[31] * e[13] - 1.*e[27] * e[32] * e[14] - 1.*e[27] * e[34] * e[16] - 1.*e[27] * e[35] * e[17] + e[30] * e[29] * e[14] + e[30] * e[11] * e[32] + e[30] * e[28] * e[13] + e[30] * e[10] * e[31] + e[12] * e[29] * e[32] + e[12] * e[28] * e[31] + e[15] * e[29] * e[35] + e[15] * e[28] * e[34];
	A[133] = -1.*e[32] * e[24] * e[6] + e[8] * e[30] * e[24] + e[8] * e[21] * e[33] + e[8] * e[31] * e[25] + e[8] * e[22] * e[34] + e[26] * e[30] * e[6] + e[26] * e[3] * e[33] + e[26] * e[31] * e[7] + e[26] * e[4] * e[34] + e[26] * e[32] * e[8] + e[26] * e[5] * e[35] + e[35] * e[21] * e[6] + e[35] * e[3] * e[24] + e[35] * e[22] * e[7] + e[35] * e[4] * e[25] + e[35] * e[23] * e[8] + e[2] * e[27] * e[21] + e[2] * e[18] * e[30] + e[2] * e[28] * e[22] + e[2] * e[19] * e[31] + e[2] * e[29] * e[23] + e[2] * e[20] * e[32] + e[20] * e[27] * e[3] + e[20] * e[0] * e[30] + e[20] * e[28] * e[4] + e[20] * e[1] * e[31] + e[20] * e[29] * e[5] + e[29] * e[18] * e[3] + e[29] * e[0] * e[21] + e[29] * e[19] * e[4] + e[29] * e[1] * e[22] + e[5] * e[30] * e[21] + e[5] * e[31] * e[22] + 3.*e[5] * e[32] * e[23] - 1.*e[5] * e[27] * e[18] - 1.*e[5] * e[33] * e[24] - 1.*e[5] * e[28] * e[19] - 1.*e[5] * e[34] * e[25] - 1.*e[23] * e[27] * e[0] - 1.*e[23] * e[34] * e[7] - 1.*e[23] * e[33] * e[6] + e[23] * e[30] * e[3] - 1.*e[23] * e[28] * e[1] + e[23] * e[31] * e[4] + e[32] * e[21] * e[3] - 1.*e[32] * e[19] * e[1] + e[32] * e[22] * e[4] - 1.*e[32] * e[18] * e[0] - 1.*e[32] * e[25] * e[7];
	A[20] = .5000000000*e[27] * ep2[33] - .5000000000*e[27] * ep2[32] - .5000000000*e[27] * ep2[31] - .5000000000*e[27] * ep2[34] - .5000000000*e[27] * ep2[35] + e[33] * e[29] * e[35] + .5000000000*e[27] * ep2[29] + e[30] * e[29] * e[32] + e[30] * e[28] * e[31] + e[33] * e[28] * e[34] + .5000000000*e[27] * ep2[28] + .5000000000*e[27] * ep2[30] + .5000000000*ep3[27];
	A[134] = e[14] * e[21] * e[12] + e[14] * e[22] * e[13] + e[17] * e[21] * e[15] + e[17] * e[12] * e[24] + e[17] * e[14] * e[26] + e[17] * e[22] * e[16] + e[17] * e[13] * e[25] + e[26] * e[12] * e[15] + e[26] * e[13] * e[16] - 1.*e[14] * e[24] * e[15] - 1.*e[14] * e[25] * e[16] - 1.*e[14] * e[18] * e[9] - 1.*e[14] * e[19] * e[10] + e[11] * e[18] * e[12] + e[11] * e[9] * e[21] + e[11] * e[19] * e[13] + e[11] * e[10] * e[22] + e[20] * e[11] * e[14] + e[20] * e[9] * e[12] + e[20] * e[10] * e[13] + 1.500000000*e[23] * ep2[14] + .5000000000*e[23] * ep2[12] + .5000000000*e[23] * ep2[13] + .5000000000*e[23] * ep2[17] + .5000000000*ep2[11] * e[23] - .5000000000*e[23] * ep2[16] - .5000000000*e[23] * ep2[9] - .5000000000*e[23] * ep2[15] - .5000000000*e[23] * ep2[10];
	A[21] = 1.500000000*e[0] * ep2[27] + .5000000000*e[0] * ep2[29] + .5000000000*e[0] * ep2[28] + .5000000000*e[0] * ep2[30] - .5000000000*e[0] * ep2[32] - .5000000000*e[0] * ep2[31] + .5000000000*e[0] * ep2[33] - .5000000000*e[0] * ep2[34] - .5000000000*e[0] * ep2[35] - 1.*e[27] * e[31] * e[4] + e[3] * e[27] * e[30] + e[3] * e[29] * e[32] + e[3] * e[28] * e[31] + e[30] * e[28] * e[4] + e[30] * e[1] * e[31] + e[30] * e[29] * e[5] + e[30] * e[2] * e[32] + e[6] * e[27] * e[33] + e[6] * e[29] * e[35] + e[6] * e[28] * e[34] + e[27] * e[28] * e[1] + e[27] * e[29] * e[2] + e[33] * e[28] * e[7] + e[33] * e[1] * e[34] + e[33] * e[29] * e[8] + e[33] * e[2] * e[35] - 1.*e[27] * e[34] * e[7] - 1.*e[27] * e[32] * e[5] - 1.*e[27] * e[35] * e[8];
	A[135] = e[14] * e[12] * e[3] + e[14] * e[13] * e[4] + e[17] * e[12] * e[6] + e[17] * e[3] * e[15] + e[17] * e[13] * e[7] + e[17] * e[4] * e[16] + e[17] * e[14] * e[8] + e[8] * e[12] * e[15] + e[8] * e[13] * e[16] + e[2] * e[11] * e[14] + e[2] * e[9] * e[12] + e[2] * e[10] * e[13] + e[11] * e[9] * e[3] + e[11] * e[0] * e[12] + e[11] * e[10] * e[4] + e[11] * e[1] * e[13] - 1.*e[14] * e[10] * e[1] - 1.*e[14] * e[16] * e[7] - 1.*e[14] * e[15] * e[6] - 1.*e[14] * e[9] * e[0] - .5000000000*e[5] * ep2[16] - .5000000000*e[5] * ep2[9] + .5000000000*e[5] * ep2[11] + .5000000000*e[5] * ep2[12] - .5000000000*e[5] * ep2[15] - .5000000000*e[5] * ep2[10] + .5000000000*e[5] * ep2[13] + 1.500000000*ep2[14] * e[5] + .5000000000*e[5] * ep2[17];
	A[27] = 1.500000000*e[27] * ep2[9] - .5000000000*e[27] * ep2[16] + .5000000000*e[27] * ep2[11] + .5000000000*e[27] * ep2[12] + .5000000000*e[27] * ep2[15] - .5000000000*e[27] * ep2[17] + .5000000000*e[27] * ep2[10] - .5000000000*e[27] * ep2[14] - .5000000000*e[27] * ep2[13] + e[12] * e[10] * e[31] + e[30] * e[11] * e[14] + e[30] * e[10] * e[13] + e[15] * e[9] * e[33] + e[15] * e[29] * e[17] + e[15] * e[11] * e[35] + e[15] * e[28] * e[16] + e[15] * e[10] * e[34] + e[33] * e[11] * e[17] + e[33] * e[10] * e[16] - 1.*e[9] * e[31] * e[13] - 1.*e[9] * e[32] * e[14] - 1.*e[9] * e[34] * e[16] - 1.*e[9] * e[35] * e[17] + e[9] * e[29] * e[11] + e[9] * e[28] * e[10] + e[12] * e[9] * e[30] + e[12] * e[29] * e[14] + e[12] * e[11] * e[32] + e[12] * e[28] * e[13];
	A[137] = e[29] * e[18] * e[12] + e[29] * e[9] * e[21] + e[29] * e[19] * e[13] + e[29] * e[10] * e[22] + e[17] * e[30] * e[24] + e[17] * e[21] * e[33] + e[17] * e[31] * e[25] + e[17] * e[22] * e[34] + e[17] * e[32] * e[26] + e[17] * e[23] * e[35] - 1.*e[23] * e[27] * e[9] - 1.*e[23] * e[28] * e[10] - 1.*e[23] * e[33] * e[15] - 1.*e[23] * e[34] * e[16] - 1.*e[32] * e[24] * e[15] - 1.*e[32] * e[25] * e[16] - 1.*e[32] * e[18] * e[9] - 1.*e[32] * e[19] * e[10] + e[26] * e[30] * e[15] + e[26] * e[12] * e[33] + e[26] * e[31] * e[16] + e[26] * e[13] * e[34] + e[35] * e[21] * e[15] + e[35] * e[12] * e[24] + e[35] * e[22] * e[16] + e[35] * e[13] * e[25] + e[14] * e[30] * e[21] + e[14] * e[31] * e[22] + 3.*e[14] * e[32] * e[23] + e[11] * e[27] * e[21] + e[11] * e[18] * e[30] + e[11] * e[28] * e[22] + e[11] * e[19] * e[31] + e[11] * e[29] * e[23] + e[11] * e[20] * e[32] + e[23] * e[30] * e[12] + e[23] * e[31] * e[13] + e[32] * e[21] * e[12] + e[32] * e[22] * e[13] - 1.*e[14] * e[27] * e[18] - 1.*e[14] * e[33] * e[24] + e[14] * e[29] * e[20] + e[14] * e[35] * e[26] - 1.*e[14] * e[28] * e[19] - 1.*e[14] * e[34] * e[25] + e[20] * e[27] * e[12] + e[20] * e[9] * e[30] + e[20] * e[28] * e[13] + e[20] * e[10] * e[31];
	A[26] = .5000000000*e[0] * ep2[1] + .5000000000*e[0] * ep2[2] + e[6] * e[2] * e[8] + e[6] * e[1] * e[7] + .5000000000*e[0] * ep2[3] + e[3] * e[1] * e[4] + .5000000000*e[0] * ep2[6] + e[3] * e[2] * e[5] - .5000000000*e[0] * ep2[5] - .5000000000*e[0] * ep2[8] + .5000000000*ep3[0] - .5000000000*e[0] * ep2[7] - .5000000000*e[0] * ep2[4];
	A[136] = 1.500000000*ep2[23] * e[14] + .5000000000*e[14] * ep2[26] - .5000000000*e[14] * ep2[18] - .5000000000*e[14] * ep2[19] + .5000000000*e[14] * ep2[20] + .5000000000*e[14] * ep2[22] - .5000000000*e[14] * ep2[24] + .5000000000*e[14] * ep2[21] - .5000000000*e[14] * ep2[25] + e[23] * e[21] * e[12] + e[23] * e[22] * e[13] + e[26] * e[21] * e[15] + e[26] * e[12] * e[24] + e[26] * e[23] * e[17] + e[26] * e[22] * e[16] + e[26] * e[13] * e[25] + e[17] * e[22] * e[25] + e[17] * e[21] * e[24] + e[11] * e[19] * e[22] + e[11] * e[18] * e[21] + e[11] * e[20] * e[23] + e[20] * e[18] * e[12] + e[20] * e[9] * e[21] + e[20] * e[19] * e[13] + e[20] * e[10] * e[22] - 1.*e[23] * e[24] * e[15] - 1.*e[23] * e[25] * e[16] - 1.*e[23] * e[18] * e[9] - 1.*e[23] * e[19] * e[10];
	A[25] = 1.500000000*e[27] * ep2[0] - .5000000000*e[27] * ep2[4] + .5000000000*e[27] * ep2[6] - .5000000000*e[27] * ep2[5] + .5000000000*e[27] * ep2[1] - .5000000000*e[27] * ep2[7] + .5000000000*e[27] * ep2[3] + .5000000000*e[27] * ep2[2] - .5000000000*e[27] * ep2[8] + e[0] * e[33] * e[6] + e[0] * e[30] * e[3] - 1.*e[0] * e[35] * e[8] - 1.*e[0] * e[31] * e[4] + e[3] * e[28] * e[4] + e[3] * e[1] * e[31] + e[3] * e[29] * e[5] + e[3] * e[2] * e[32] + e[30] * e[1] * e[4] + e[30] * e[2] * e[5] + e[6] * e[28] * e[7] + e[6] * e[1] * e[34] + e[6] * e[29] * e[8] + e[6] * e[2] * e[35] + e[33] * e[1] * e[7] + e[33] * e[2] * e[8] + e[0] * e[28] * e[1] + e[0] * e[29] * e[2] - 1.*e[0] * e[34] * e[7] - 1.*e[0] * e[32] * e[5];
	A[139] = e[8] * e[22] * e[25] + e[8] * e[21] * e[24] + e[20] * e[18] * e[3] + e[20] * e[0] * e[21] + e[20] * e[19] * e[4] + e[20] * e[1] * e[22] + e[20] * e[2] * e[23] + e[23] * e[21] * e[3] + e[23] * e[22] * e[4] + e[23] * e[26] * e[8] - 1.*e[23] * e[19] * e[1] - 1.*e[23] * e[18] * e[0] - 1.*e[23] * e[25] * e[7] - 1.*e[23] * e[24] * e[6] + e[2] * e[19] * e[22] + e[2] * e[18] * e[21] + e[26] * e[21] * e[6] + e[26] * e[3] * e[24] + e[26] * e[22] * e[7] + e[26] * e[4] * e[25] + .5000000000*ep2[20] * e[5] + 1.500000000*ep2[23] * e[5] + .5000000000*e[5] * ep2[22] + .5000000000*e[5] * ep2[21] + .5000000000*e[5] * ep2[26] - .5000000000*e[5] * ep2[18] - .5000000000*e[5] * ep2[19] - .5000000000*e[5] * ep2[24] - .5000000000*e[5] * ep2[25];
	A[24] = e[24] * e[11] * e[8] + e[24] * e[2] * e[17] + 3.*e[9] * e[18] * e[0] + e[9] * e[19] * e[1] + e[9] * e[20] * e[2] + e[18] * e[10] * e[1] + e[18] * e[11] * e[2] + e[3] * e[18] * e[12] + e[3] * e[9] * e[21] + e[3] * e[20] * e[14] + e[3] * e[11] * e[23] + e[3] * e[19] * e[13] + e[3] * e[10] * e[22] + e[6] * e[18] * e[15] + e[6] * e[9] * e[24] + e[6] * e[20] * e[17] + e[6] * e[11] * e[26] + e[6] * e[19] * e[16] + e[6] * e[10] * e[25] + e[0] * e[20] * e[11] + e[0] * e[19] * e[10] - 1.*e[9] * e[26] * e[8] - 1.*e[9] * e[22] * e[4] - 1.*e[9] * e[25] * e[7] - 1.*e[9] * e[23] * e[5] + e[12] * e[0] * e[21] + e[12] * e[19] * e[4] + e[12] * e[1] * e[22] + e[12] * e[20] * e[5] + e[12] * e[2] * e[23] - 1.*e[18] * e[13] * e[4] - 1.*e[18] * e[16] * e[7] - 1.*e[18] * e[14] * e[5] - 1.*e[18] * e[17] * e[8] + e[21] * e[10] * e[4] + e[21] * e[1] * e[13] + e[21] * e[11] * e[5] + e[21] * e[2] * e[14] + e[15] * e[0] * e[24] + e[15] * e[19] * e[7] + e[15] * e[1] * e[25] + e[15] * e[20] * e[8] + e[15] * e[2] * e[26] - 1.*e[0] * e[23] * e[14] - 1.*e[0] * e[25] * e[16] - 1.*e[0] * e[26] * e[17] - 1.*e[0] * e[22] * e[13] + e[24] * e[10] * e[7] + e[24] * e[1] * e[16];
	A[138] = e[11] * e[1] * e[4] + e[11] * e[0] * e[3] + e[11] * e[2] * e[5] + e[5] * e[12] * e[3] + e[5] * e[13] * e[4] + e[8] * e[12] * e[6] + e[8] * e[3] * e[15] + e[8] * e[13] * e[7] + e[8] * e[4] * e[16] + e[8] * e[5] * e[17] + e[17] * e[4] * e[7] + e[17] * e[3] * e[6] - 1.*e[5] * e[10] * e[1] - 1.*e[5] * e[16] * e[7] - 1.*e[5] * e[15] * e[6] - 1.*e[5] * e[9] * e[0] + e[2] * e[9] * e[3] + e[2] * e[0] * e[12] + e[2] * e[10] * e[4] + e[2] * e[1] * e[13] + .5000000000*ep2[2] * e[14] - .5000000000*e[14] * ep2[0] - .5000000000*e[14] * ep2[6] - .5000000000*e[14] * ep2[1] - .5000000000*e[14] * ep2[7] + 1.500000000*e[14] * ep2[5] + .5000000000*e[14] * ep2[4] + .5000000000*e[14] * ep2[3] + .5000000000*e[14] * ep2[8];
	A[31] = e[3] * e[27] * e[12] + e[3] * e[9] * e[30] + e[3] * e[29] * e[14] + e[3] * e[11] * e[32] + e[3] * e[28] * e[13] + e[3] * e[10] * e[31] + e[6] * e[27] * e[15] + e[6] * e[9] * e[33] + e[6] * e[29] * e[17] + e[6] * e[11] * e[35] + e[6] * e[28] * e[16] + e[6] * e[10] * e[34] + 3.*e[0] * e[27] * e[9] + e[0] * e[29] * e[11] + e[0] * e[28] * e[10] - 1.*e[9] * e[34] * e[7] - 1.*e[9] * e[32] * e[5] - 1.*e[9] * e[35] * e[8] + e[9] * e[29] * e[2] + e[9] * e[28] * e[1] - 1.*e[9] * e[31] * e[4] + e[12] * e[0] * e[30] + e[12] * e[28] * e[4] + e[12] * e[1] * e[31] + e[12] * e[29] * e[5] + e[12] * e[2] * e[32] + e[27] * e[11] * e[2] + e[27] * e[10] * e[1] - 1.*e[27] * e[13] * e[4] - 1.*e[27] * e[16] * e[7] - 1.*e[27] * e[14] * e[5] - 1.*e[27] * e[17] * e[8] + e[30] * e[10] * e[4] + e[30] * e[1] * e[13] + e[30] * e[11] * e[5] + e[30] * e[2] * e[14] + e[15] * e[0] * e[33] + e[15] * e[28] * e[7] + e[15] * e[1] * e[34] + e[15] * e[29] * e[8] + e[15] * e[2] * e[35] - 1.*e[0] * e[31] * e[13] - 1.*e[0] * e[32] * e[14] - 1.*e[0] * e[34] * e[16] - 1.*e[0] * e[35] * e[17] + e[33] * e[10] * e[7] + e[33] * e[1] * e[16] + e[33] * e[11] * e[8] + e[33] * e[2] * e[17];
	A[141] = .5000000000*ep2[30] * e[6] + .5000000000*e[6] * ep2[27] - .5000000000*e[6] * ep2[32] - .5000000000*e[6] * ep2[28] - .5000000000*e[6] * ep2[29] - .5000000000*e[6] * ep2[31] + 1.500000000*e[6] * ep2[33] + .5000000000*e[6] * ep2[34] + .5000000000*e[6] * ep2[35] + e[0] * e[27] * e[33] + e[0] * e[29] * e[35] + e[0] * e[28] * e[34] + e[3] * e[30] * e[33] + e[3] * e[32] * e[35] + e[3] * e[31] * e[34] + e[30] * e[31] * e[7] + e[30] * e[4] * e[34] + e[30] * e[32] * e[8] + e[30] * e[5] * e[35] + e[27] * e[28] * e[7] + e[27] * e[1] * e[34] + e[27] * e[29] * e[8] + e[27] * e[2] * e[35] + e[33] * e[34] * e[7] + e[33] * e[35] * e[8] - 1.*e[33] * e[32] * e[5] - 1.*e[33] * e[29] * e[2] - 1.*e[33] * e[28] * e[1] - 1.*e[33] * e[31] * e[4];
	A[30] = e[24] * e[20] * e[26] + e[21] * e[19] * e[22] - .5000000000*e[18] * ep2[22] - .5000000000*e[18] * ep2[25] + .5000000000*ep3[18] + .5000000000*e[18] * ep2[21] + e[21] * e[20] * e[23] + .5000000000*e[18] * ep2[20] + .5000000000*e[18] * ep2[19] + .5000000000*e[18] * ep2[24] + e[24] * e[19] * e[25] - .5000000000*e[18] * ep2[23] - .5000000000*e[18] * ep2[26];
	A[140] = .5000000000*e[33] * ep2[35] + .5000000000*ep3[33] + .5000000000*ep2[27] * e[33] + .5000000000*ep2[30] * e[33] - .5000000000*e[33] * ep2[29] + .5000000000*e[33] * ep2[34] - .5000000000*e[33] * ep2[32] - .5000000000*e[33] * ep2[28] + e[30] * e[32] * e[35] - .5000000000*e[33] * ep2[31] + e[27] * e[29] * e[35] + e[27] * e[28] * e[34] + e[30] * e[31] * e[34];
	A[29] = 1.500000000*e[27] * ep2[18] + .5000000000*e[27] * ep2[19] + .5000000000*e[27] * ep2[20] + .5000000000*e[27] * ep2[21] + .5000000000*e[27] * ep2[24] - .5000000000*e[27] * ep2[26] - .5000000000*e[27] * ep2[23] - .5000000000*e[27] * ep2[22] - .5000000000*e[27] * ep2[25] + e[33] * e[20] * e[26] - 1.*e[18] * e[35] * e[26] - 1.*e[18] * e[31] * e[22] - 1.*e[18] * e[32] * e[23] - 1.*e[18] * e[34] * e[25] + e[18] * e[28] * e[19] + e[18] * e[29] * e[20] + e[21] * e[18] * e[30] + e[21] * e[28] * e[22] + e[21] * e[19] * e[31] + e[21] * e[29] * e[23] + e[21] * e[20] * e[32] + e[30] * e[19] * e[22] + e[30] * e[20] * e[23] + e[24] * e[18] * e[33] + e[24] * e[28] * e[25] + e[24] * e[19] * e[34] + e[24] * e[29] * e[26] + e[24] * e[20] * e[35] + e[33] * e[19] * e[25];
	A[143] = e[9] * e[27] * e[33] + e[9] * e[29] * e[35] + e[9] * e[28] * e[34] + e[33] * e[35] * e[17] + e[33] * e[34] * e[16] + e[27] * e[29] * e[17] + e[27] * e[11] * e[35] + e[27] * e[28] * e[16] + e[27] * e[10] * e[34] + e[33] * e[30] * e[12] - 1.*e[33] * e[28] * e[10] - 1.*e[33] * e[31] * e[13] - 1.*e[33] * e[32] * e[14] - 1.*e[33] * e[29] * e[11] + e[30] * e[32] * e[17] + e[30] * e[14] * e[35] + e[30] * e[31] * e[16] + e[30] * e[13] * e[34] + e[12] * e[32] * e[35] + e[12] * e[31] * e[34] + .5000000000*e[15] * ep2[27] - .5000000000*e[15] * ep2[32] - .5000000000*e[15] * ep2[28] - .5000000000*e[15] * ep2[29] - .5000000000*e[15] * ep2[31] + 1.500000000*e[15] * ep2[33] + .5000000000*e[15] * ep2[30] + .5000000000*e[15] * ep2[34] + .5000000000*e[15] * ep2[35];
	A[28] = .5000000000*e[9] * ep2[12] - .5000000000*e[9] * ep2[16] + .5000000000*e[9] * ep2[10] - .5000000000*e[9] * ep2[17] - .5000000000*e[9] * ep2[13] + e[15] * e[10] * e[16] + e[12] * e[11] * e[14] + .5000000000*e[9] * ep2[11] + .5000000000*e[9] * ep2[15] - .5000000000*e[9] * ep2[14] + e[15] * e[11] * e[17] + .5000000000*ep3[9] + e[12] * e[10] * e[13];
	A[142] = e[18] * e[27] * e[33] + e[18] * e[29] * e[35] + e[18] * e[28] * e[34] + e[27] * e[28] * e[25] + e[27] * e[19] * e[34] + e[27] * e[29] * e[26] + e[27] * e[20] * e[35] + e[21] * e[30] * e[33] + e[21] * e[32] * e[35] + e[21] * e[31] * e[34] + e[30] * e[31] * e[25] + e[30] * e[22] * e[34] + e[30] * e[32] * e[26] + e[30] * e[23] * e[35] + e[33] * e[34] * e[25] + e[33] * e[35] * e[26] - 1.*e[33] * e[29] * e[20] - 1.*e[33] * e[31] * e[22] - 1.*e[33] * e[32] * e[23] - 1.*e[33] * e[28] * e[19] + .5000000000*ep2[27] * e[24] + .5000000000*ep2[30] * e[24] + 1.500000000*e[24] * ep2[33] + .5000000000*e[24] * ep2[35] + .5000000000*e[24] * ep2[34] - .5000000000*e[24] * ep2[32] - .5000000000*e[24] * ep2[28] - .5000000000*e[24] * ep2[29] - .5000000000*e[24] * ep2[31];
	A[36] = .5000000000*e[9] * ep2[21] + .5000000000*e[9] * ep2[24] + .5000000000*e[9] * ep2[19] + 1.500000000*e[9] * ep2[18] + .5000000000*e[9] * ep2[20] - .5000000000*e[9] * ep2[26] - .5000000000*e[9] * ep2[23] - .5000000000*e[9] * ep2[22] - .5000000000*e[9] * ep2[25] + e[21] * e[18] * e[12] + e[21] * e[20] * e[14] + e[21] * e[11] * e[23] + e[21] * e[19] * e[13] + e[21] * e[10] * e[22] + e[24] * e[18] * e[15] + e[24] * e[20] * e[17] + e[24] * e[11] * e[26] + e[24] * e[19] * e[16] + e[24] * e[10] * e[25] + e[15] * e[19] * e[25] + e[15] * e[20] * e[26] + e[12] * e[19] * e[22] + e[12] * e[20] * e[23] + e[18] * e[20] * e[11] + e[18] * e[19] * e[10] - 1.*e[18] * e[23] * e[14] - 1.*e[18] * e[25] * e[16] - 1.*e[18] * e[26] * e[17] - 1.*e[18] * e[22] * e[13];
	A[182] = .5000000000*ep2[29] * e[26] + .5000000000*ep2[32] * e[26] + .5000000000*e[26] * ep2[33] + 1.500000000*e[26] * ep2[35] + .5000000000*e[26] * ep2[34] - .5000000000*e[26] * ep2[27] - .5000000000*e[26] * ep2[28] - .5000000000*e[26] * ep2[31] - .5000000000*e[26] * ep2[30] + e[20] * e[27] * e[33] + e[20] * e[29] * e[35] + e[20] * e[28] * e[34] + e[29] * e[27] * e[24] + e[29] * e[18] * e[33] + e[29] * e[28] * e[25] + e[29] * e[19] * e[34] + e[23] * e[30] * e[33] + e[23] * e[32] * e[35] + e[23] * e[31] * e[34] + e[32] * e[30] * e[24] + e[32] * e[21] * e[33] + e[32] * e[31] * e[25] + e[32] * e[22] * e[34] + e[35] * e[33] * e[24] + e[35] * e[34] * e[25] - 1.*e[35] * e[27] * e[18] - 1.*e[35] * e[30] * e[21] - 1.*e[35] * e[31] * e[22] - 1.*e[35] * e[28] * e[19];
	A[37] = e[12] * e[19] * e[31] + e[12] * e[29] * e[23] + e[12] * e[20] * e[32] + 3.*e[9] * e[27] * e[18] + e[9] * e[28] * e[19] + e[9] * e[29] * e[20] + e[21] * e[9] * e[30] + e[21] * e[29] * e[14] + e[21] * e[11] * e[32] + e[21] * e[28] * e[13] + e[21] * e[10] * e[31] + e[30] * e[20] * e[14] + e[30] * e[11] * e[23] + e[30] * e[19] * e[13] + e[30] * e[10] * e[22] + e[9] * e[33] * e[24] - 1.*e[9] * e[35] * e[26] - 1.*e[9] * e[31] * e[22] - 1.*e[9] * e[32] * e[23] - 1.*e[9] * e[34] * e[25] + e[18] * e[29] * e[11] + e[18] * e[28] * e[10] + e[27] * e[20] * e[11] + e[27] * e[19] * e[10] + e[15] * e[27] * e[24] + e[15] * e[18] * e[33] + e[15] * e[28] * e[25] + e[15] * e[19] * e[34] + e[15] * e[29] * e[26] + e[15] * e[20] * e[35] - 1.*e[18] * e[31] * e[13] - 1.*e[18] * e[32] * e[14] - 1.*e[18] * e[34] * e[16] - 1.*e[18] * e[35] * e[17] - 1.*e[27] * e[23] * e[14] - 1.*e[27] * e[25] * e[16] - 1.*e[27] * e[26] * e[17] - 1.*e[27] * e[22] * e[13] + e[24] * e[29] * e[17] + e[24] * e[11] * e[35] + e[24] * e[28] * e[16] + e[24] * e[10] * e[34] + e[33] * e[20] * e[17] + e[33] * e[11] * e[26] + e[33] * e[19] * e[16] + e[33] * e[10] * e[25] + e[12] * e[27] * e[21] + e[12] * e[18] * e[30] + e[12] * e[28] * e[22];
	A[183] = -.5000000000*e[17] * ep2[27] + .5000000000*e[17] * ep2[32] - .5000000000*e[17] * ep2[28] + .5000000000*e[17] * ep2[29] - .5000000000*e[17] * ep2[31] + .5000000000*e[17] * ep2[33] - .5000000000*e[17] * ep2[30] + .5000000000*e[17] * ep2[34] + 1.500000000*e[17] * ep2[35] + e[32] * e[30] * e[15] + e[32] * e[12] * e[33] + e[32] * e[31] * e[16] + e[32] * e[13] * e[34] + e[14] * e[30] * e[33] + e[14] * e[31] * e[34] + e[11] * e[27] * e[33] + e[11] * e[29] * e[35] + e[11] * e[28] * e[34] + e[35] * e[33] * e[15] + e[35] * e[34] * e[16] + e[29] * e[27] * e[15] + e[29] * e[9] * e[33] + e[29] * e[28] * e[16] + e[29] * e[10] * e[34] - 1.*e[35] * e[27] * e[9] - 1.*e[35] * e[30] * e[12] - 1.*e[35] * e[28] * e[10] - 1.*e[35] * e[31] * e[13] + e[35] * e[32] * e[14];
	A[38] = .5000000000*e[9] * ep2[1] + 1.500000000*e[9] * ep2[0] + .5000000000*e[9] * ep2[2] + .5000000000*e[9] * ep2[3] + .5000000000*e[9] * ep2[6] - .5000000000*e[9] * ep2[4] - .5000000000*e[9] * ep2[5] - .5000000000*e[9] * ep2[7] - .5000000000*e[9] * ep2[8] + e[6] * e[0] * e[15] + e[6] * e[10] * e[7] + e[6] * e[1] * e[16] + e[6] * e[11] * e[8] + e[6] * e[2] * e[17] + e[15] * e[1] * e[7] + e[15] * e[2] * e[8] + e[0] * e[11] * e[2] + e[0] * e[10] * e[1] - 1.*e[0] * e[13] * e[4] - 1.*e[0] * e[16] * e[7] - 1.*e[0] * e[14] * e[5] - 1.*e[0] * e[17] * e[8] + e[3] * e[0] * e[12] + e[3] * e[10] * e[4] + e[3] * e[1] * e[13] + e[3] * e[11] * e[5] + e[3] * e[2] * e[14] + e[12] * e[1] * e[4] + e[12] * e[2] * e[5];
	A[180] = .5000000000*e[35] * ep2[33] + .5000000000*e[35] * ep2[34] - .5000000000*e[35] * ep2[27] - .5000000000*e[35] * ep2[28] - .5000000000*e[35] * ep2[31] - .5000000000*e[35] * ep2[30] + e[32] * e[31] * e[34] + .5000000000*ep2[29] * e[35] + .5000000000*ep2[32] * e[35] + e[29] * e[28] * e[34] + e[32] * e[30] * e[33] + .5000000000*ep3[35] + e[29] * e[27] * e[33];
	A[39] = .5000000000*e[0] * ep2[19] + .5000000000*e[0] * ep2[20] + .5000000000*e[0] * ep2[24] - .5000000000*e[0] * ep2[26] - .5000000000*e[0] * ep2[23] - .5000000000*e[0] * ep2[22] - .5000000000*e[0] * ep2[25] + 1.500000000*ep2[18] * e[0] + .5000000000*e[0] * ep2[21] + e[18] * e[19] * e[1] + e[18] * e[20] * e[2] + e[21] * e[18] * e[3] + e[21] * e[19] * e[4] + e[21] * e[1] * e[22] + e[21] * e[20] * e[5] + e[21] * e[2] * e[23] - 1.*e[18] * e[26] * e[8] - 1.*e[18] * e[22] * e[4] - 1.*e[18] * e[25] * e[7] - 1.*e[18] * e[23] * e[5] + e[18] * e[24] * e[6] + e[3] * e[19] * e[22] + e[3] * e[20] * e[23] + e[24] * e[19] * e[7] + e[24] * e[1] * e[25] + e[24] * e[20] * e[8] + e[24] * e[2] * e[26] + e[6] * e[19] * e[25] + e[6] * e[20] * e[26];
	A[181] = .5000000000*ep2[32] * e[8] - .5000000000*e[8] * ep2[27] - .5000000000*e[8] * ep2[28] + .5000000000*e[8] * ep2[29] - .5000000000*e[8] * ep2[31] + .5000000000*e[8] * ep2[33] - .5000000000*e[8] * ep2[30] + .5000000000*e[8] * ep2[34] + 1.500000000*e[8] * ep2[35] + e[2] * e[27] * e[33] + e[2] * e[29] * e[35] + e[2] * e[28] * e[34] + e[5] * e[30] * e[33] + e[5] * e[32] * e[35] + e[5] * e[31] * e[34] + e[32] * e[30] * e[6] + e[32] * e[3] * e[33] + e[32] * e[31] * e[7] + e[32] * e[4] * e[34] + e[29] * e[27] * e[6] + e[29] * e[0] * e[33] + e[29] * e[28] * e[7] + e[29] * e[1] * e[34] + e[35] * e[33] * e[6] + e[35] * e[34] * e[7] - 1.*e[35] * e[27] * e[0] - 1.*e[35] * e[30] * e[3] - 1.*e[35] * e[28] * e[1] - 1.*e[35] * e[31] * e[4];
	A[32] = -.5000000000*e[18] * ep2[4] + 1.500000000*e[18] * ep2[0] + .5000000000*e[18] * ep2[6] - .5000000000*e[18] * ep2[5] + .5000000000*e[18] * ep2[1] - .5000000000*e[18] * ep2[7] + .5000000000*e[18] * ep2[3] + .5000000000*e[18] * ep2[2] - .5000000000*e[18] * ep2[8] + e[3] * e[0] * e[21] + e[3] * e[19] * e[4] + e[3] * e[1] * e[22] + e[3] * e[20] * e[5] + e[3] * e[2] * e[23] + e[21] * e[1] * e[4] + e[21] * e[2] * e[5] + e[6] * e[0] * e[24] + e[6] * e[19] * e[7] + e[6] * e[1] * e[25] + e[6] * e[20] * e[8] + e[6] * e[2] * e[26] + e[24] * e[1] * e[7] + e[24] * e[2] * e[8] + e[0] * e[19] * e[1] + e[0] * e[20] * e[2] - 1.*e[0] * e[26] * e[8] - 1.*e[0] * e[22] * e[4] - 1.*e[0] * e[25] * e[7] - 1.*e[0] * e[23] * e[5];
	A[178] = e[10] * e[1] * e[7] + e[10] * e[0] * e[6] + e[10] * e[2] * e[8] + e[4] * e[12] * e[6] + e[4] * e[3] * e[15] + e[4] * e[13] * e[7] + e[4] * e[14] * e[8] + e[4] * e[5] * e[17] + e[13] * e[3] * e[6] + e[13] * e[5] * e[8] + e[7] * e[15] * e[6] + e[7] * e[17] * e[8] - 1.*e[7] * e[11] * e[2] - 1.*e[7] * e[9] * e[0] - 1.*e[7] * e[14] * e[5] - 1.*e[7] * e[12] * e[3] + e[1] * e[9] * e[6] + e[1] * e[0] * e[15] + e[1] * e[11] * e[8] + e[1] * e[2] * e[17] + 1.500000000*e[16] * ep2[7] + .5000000000*e[16] * ep2[6] + .5000000000*e[16] * ep2[8] + .5000000000*ep2[1] * e[16] - .5000000000*e[16] * ep2[0] - .5000000000*e[16] * ep2[5] - .5000000000*e[16] * ep2[3] - .5000000000*e[16] * ep2[2] + .5000000000*ep2[4] * e[16];
	A[33] = e[0] * e[30] * e[21] - 1.*e[0] * e[35] * e[26] - 1.*e[0] * e[31] * e[22] - 1.*e[0] * e[32] * e[23] - 1.*e[0] * e[34] * e[25] - 1.*e[18] * e[34] * e[7] - 1.*e[18] * e[32] * e[5] - 1.*e[18] * e[35] * e[8] - 1.*e[18] * e[31] * e[4] - 1.*e[27] * e[26] * e[8] - 1.*e[27] * e[22] * e[4] - 1.*e[27] * e[25] * e[7] - 1.*e[27] * e[23] * e[5] + e[6] * e[28] * e[25] + e[6] * e[19] * e[34] + e[6] * e[29] * e[26] + e[6] * e[20] * e[35] + e[21] * e[28] * e[4] + e[21] * e[1] * e[31] + e[21] * e[29] * e[5] + e[21] * e[2] * e[32] + e[30] * e[19] * e[4] + e[30] * e[1] * e[22] + e[30] * e[20] * e[5] + e[30] * e[2] * e[23] + e[24] * e[27] * e[6] + e[24] * e[0] * e[33] + e[24] * e[28] * e[7] + e[24] * e[1] * e[34] + e[24] * e[29] * e[8] + e[24] * e[2] * e[35] + e[33] * e[18] * e[6] + e[33] * e[19] * e[7] + e[33] * e[1] * e[25] + e[33] * e[20] * e[8] + e[33] * e[2] * e[26] + 3.*e[0] * e[27] * e[18] + e[0] * e[28] * e[19] + e[0] * e[29] * e[20] + e[18] * e[28] * e[1] + e[18] * e[29] * e[2] + e[27] * e[19] * e[1] + e[27] * e[20] * e[2] + e[3] * e[27] * e[21] + e[3] * e[18] * e[30] + e[3] * e[28] * e[22] + e[3] * e[19] * e[31] + e[3] * e[29] * e[23] + e[3] * e[20] * e[32];
	A[179] = e[19] * e[18] * e[6] + e[19] * e[0] * e[24] + e[19] * e[1] * e[25] + e[19] * e[20] * e[8] + e[19] * e[2] * e[26] + e[22] * e[21] * e[6] + e[22] * e[3] * e[24] + e[22] * e[4] * e[25] + e[22] * e[23] * e[8] + e[22] * e[5] * e[26] - 1.*e[25] * e[21] * e[3] + e[25] * e[26] * e[8] - 1.*e[25] * e[20] * e[2] - 1.*e[25] * e[18] * e[0] - 1.*e[25] * e[23] * e[5] + e[25] * e[24] * e[6] + e[1] * e[18] * e[24] + e[1] * e[20] * e[26] + e[4] * e[21] * e[24] + e[4] * e[23] * e[26] + .5000000000*ep2[19] * e[7] + .5000000000*ep2[22] * e[7] + 1.500000000*ep2[25] * e[7] + .5000000000*e[7] * ep2[26] - .5000000000*e[7] * ep2[18] - .5000000000*e[7] * ep2[23] - .5000000000*e[7] * ep2[20] + .5000000000*e[7] * ep2[24] - .5000000000*e[7] * ep2[21];
	A[34] = .5000000000*e[18] * ep2[11] + 1.500000000*e[18] * ep2[9] + .5000000000*e[18] * ep2[10] + .5000000000*e[18] * ep2[12] + .5000000000*e[18] * ep2[15] - .5000000000*e[18] * ep2[16] - .5000000000*e[18] * ep2[17] - .5000000000*e[18] * ep2[14] - .5000000000*e[18] * ep2[13] + e[12] * e[9] * e[21] + e[12] * e[20] * e[14] + e[12] * e[11] * e[23] + e[12] * e[19] * e[13] + e[12] * e[10] * e[22] + e[21] * e[11] * e[14] + e[21] * e[10] * e[13] + e[15] * e[9] * e[24] + e[15] * e[20] * e[17] + e[15] * e[11] * e[26] + e[15] * e[19] * e[16] + e[15] * e[10] * e[25] + e[24] * e[11] * e[17] + e[24] * e[10] * e[16] - 1.*e[9] * e[23] * e[14] - 1.*e[9] * e[25] * e[16] - 1.*e[9] * e[26] * e[17] + e[9] * e[20] * e[11] + e[9] * e[19] * e[10] - 1.*e[9] * e[22] * e[13];
	A[176] = e[13] * e[21] * e[24] + e[13] * e[23] * e[26] + e[19] * e[18] * e[15] + e[19] * e[9] * e[24] + e[19] * e[20] * e[17] + e[19] * e[11] * e[26] - 1.*e[25] * e[23] * e[14] - 1.*e[25] * e[20] * e[11] - 1.*e[25] * e[18] * e[9] - 1.*e[25] * e[21] * e[12] + e[22] * e[21] * e[15] + e[22] * e[12] * e[24] + e[22] * e[23] * e[17] + e[22] * e[14] * e[26] + e[22] * e[13] * e[25] + e[25] * e[24] * e[15] + e[25] * e[26] * e[17] + e[10] * e[19] * e[25] + e[10] * e[18] * e[24] + e[10] * e[20] * e[26] - .5000000000*e[16] * ep2[18] - .5000000000*e[16] * ep2[23] + .5000000000*e[16] * ep2[19] - .5000000000*e[16] * ep2[20] - .5000000000*e[16] * ep2[21] + .5000000000*ep2[22] * e[16] + 1.500000000*ep2[25] * e[16] + .5000000000*e[16] * ep2[24] + .5000000000*e[16] * ep2[26];
	A[35] = .5000000000*e[0] * ep2[12] + .5000000000*e[0] * ep2[15] + .5000000000*e[0] * ep2[11] + 1.500000000*e[0] * ep2[9] + .5000000000*e[0] * ep2[10] - .5000000000*e[0] * ep2[16] - .5000000000*e[0] * ep2[17] - .5000000000*e[0] * ep2[14] - .5000000000*e[0] * ep2[13] + e[12] * e[9] * e[3] + e[12] * e[10] * e[4] + e[12] * e[1] * e[13] + e[12] * e[11] * e[5] + e[12] * e[2] * e[14] + e[15] * e[9] * e[6] + e[15] * e[10] * e[7] + e[15] * e[1] * e[16] + e[15] * e[11] * e[8] + e[15] * e[2] * e[17] + e[6] * e[11] * e[17] + e[6] * e[10] * e[16] + e[3] * e[11] * e[14] + e[3] * e[10] * e[13] + e[9] * e[10] * e[1] + e[9] * e[11] * e[2] - 1.*e[9] * e[13] * e[4] - 1.*e[9] * e[16] * e[7] - 1.*e[9] * e[14] * e[5] - 1.*e[9] * e[17] * e[8];
	A[177] = e[19] * e[11] * e[35] + e[28] * e[18] * e[15] + e[28] * e[9] * e[24] + e[28] * e[20] * e[17] + e[28] * e[11] * e[26] - 1.*e[25] * e[27] * e[9] - 1.*e[25] * e[30] * e[12] - 1.*e[25] * e[32] * e[14] + e[25] * e[33] * e[15] + e[25] * e[35] * e[17] - 1.*e[25] * e[29] * e[11] - 1.*e[34] * e[23] * e[14] + e[34] * e[24] * e[15] + e[34] * e[26] * e[17] - 1.*e[34] * e[20] * e[11] - 1.*e[34] * e[18] * e[9] - 1.*e[34] * e[21] * e[12] + e[13] * e[30] * e[24] + e[13] * e[21] * e[33] + e[13] * e[31] * e[25] + e[13] * e[22] * e[34] + e[13] * e[32] * e[26] + e[13] * e[23] * e[35] + e[10] * e[27] * e[24] + e[10] * e[18] * e[33] + e[10] * e[28] * e[25] + e[10] * e[19] * e[34] + e[10] * e[29] * e[26] + e[10] * e[20] * e[35] + e[22] * e[30] * e[15] + e[22] * e[12] * e[33] + e[22] * e[32] * e[17] + e[22] * e[14] * e[35] + e[22] * e[31] * e[16] + e[31] * e[21] * e[15] + e[31] * e[12] * e[24] + e[31] * e[23] * e[17] + e[31] * e[14] * e[26] - 1.*e[16] * e[27] * e[18] + e[16] * e[33] * e[24] - 1.*e[16] * e[30] * e[21] - 1.*e[16] * e[29] * e[20] + e[16] * e[35] * e[26] - 1.*e[16] * e[32] * e[23] + e[16] * e[28] * e[19] + 3.*e[16] * e[34] * e[25] + e[19] * e[27] * e[15] + e[19] * e[9] * e[33] + e[19] * e[29] * e[17];
	A[45] = e[4] * e[27] * e[3] + e[4] * e[0] * e[30] + e[4] * e[29] * e[5] + e[4] * e[2] * e[32] + e[31] * e[0] * e[3] + e[31] * e[2] * e[5] + e[7] * e[27] * e[6] + e[7] * e[0] * e[33] + e[7] * e[29] * e[8] + e[7] * e[2] * e[35] + e[34] * e[0] * e[6] + e[34] * e[2] * e[8] + e[1] * e[27] * e[0] + e[1] * e[29] * e[2] + e[1] * e[34] * e[7] - 1.*e[1] * e[32] * e[5] - 1.*e[1] * e[33] * e[6] - 1.*e[1] * e[30] * e[3] - 1.*e[1] * e[35] * e[8] + e[1] * e[31] * e[4] + 1.500000000*e[28] * ep2[1] + .5000000000*e[28] * ep2[4] + .5000000000*e[28] * ep2[0] - .5000000000*e[28] * ep2[6] - .5000000000*e[28] * ep2[5] + .5000000000*e[28] * ep2[7] - .5000000000*e[28] * ep2[3] + .5000000000*e[28] * ep2[2] - .5000000000*e[28] * ep2[8];
	A[191] = -1.*e[35] * e[10] * e[1] - 1.*e[35] * e[13] * e[4] + e[35] * e[16] * e[7] + e[35] * e[15] * e[6] - 1.*e[35] * e[9] * e[0] - 1.*e[35] * e[12] * e[3] + e[32] * e[12] * e[6] + e[32] * e[3] * e[15] + e[32] * e[13] * e[7] + e[32] * e[4] * e[16] - 1.*e[8] * e[27] * e[9] - 1.*e[8] * e[30] * e[12] - 1.*e[8] * e[28] * e[10] - 1.*e[8] * e[31] * e[13] + e[8] * e[29] * e[11] + e[11] * e[27] * e[6] + e[11] * e[0] * e[33] + e[11] * e[28] * e[7] + e[11] * e[1] * e[34] + e[29] * e[9] * e[6] + e[29] * e[0] * e[15] + e[29] * e[10] * e[7] + e[29] * e[1] * e[16] + e[5] * e[30] * e[15] + e[5] * e[12] * e[33] + e[5] * e[32] * e[17] + e[5] * e[14] * e[35] + e[5] * e[31] * e[16] + e[5] * e[13] * e[34] + e[8] * e[33] * e[15] + 3.*e[8] * e[35] * e[17] + e[8] * e[34] * e[16] + e[2] * e[27] * e[15] + e[2] * e[9] * e[33] + e[2] * e[29] * e[17] + e[2] * e[11] * e[35] + e[2] * e[28] * e[16] + e[2] * e[10] * e[34] - 1.*e[17] * e[27] * e[0] + e[17] * e[34] * e[7] + e[17] * e[33] * e[6] - 1.*e[17] * e[30] * e[3] - 1.*e[17] * e[28] * e[1] - 1.*e[17] * e[31] * e[4] + e[14] * e[30] * e[6] + e[14] * e[3] * e[33] + e[14] * e[31] * e[7] + e[14] * e[4] * e[34] + e[14] * e[32] * e[8];
	A[44] = e[19] * e[11] * e[2] + e[4] * e[18] * e[12] + e[4] * e[9] * e[21] + e[4] * e[20] * e[14] + e[4] * e[11] * e[23] + e[4] * e[19] * e[13] + e[4] * e[10] * e[22] + e[7] * e[18] * e[15] + e[7] * e[9] * e[24] + e[7] * e[20] * e[17] + e[7] * e[11] * e[26] + e[7] * e[19] * e[16] + e[7] * e[10] * e[25] + e[1] * e[18] * e[9] + e[1] * e[20] * e[11] - 1.*e[10] * e[21] * e[3] - 1.*e[10] * e[26] * e[8] - 1.*e[10] * e[23] * e[5] - 1.*e[10] * e[24] * e[6] + e[13] * e[18] * e[3] + e[13] * e[0] * e[21] + e[13] * e[1] * e[22] + e[13] * e[20] * e[5] + e[13] * e[2] * e[23] - 1.*e[19] * e[15] * e[6] - 1.*e[19] * e[14] * e[5] - 1.*e[19] * e[12] * e[3] - 1.*e[19] * e[17] * e[8] + e[22] * e[9] * e[3] + e[22] * e[0] * e[12] + e[22] * e[11] * e[5] + e[22] * e[2] * e[14] + e[16] * e[18] * e[6] + e[16] * e[0] * e[24] + e[16] * e[1] * e[25] + e[16] * e[20] * e[8] + e[16] * e[2] * e[26] - 1.*e[1] * e[23] * e[14] - 1.*e[1] * e[24] * e[15] - 1.*e[1] * e[26] * e[17] - 1.*e[1] * e[21] * e[12] + e[25] * e[9] * e[6] + e[25] * e[0] * e[15] + e[25] * e[11] * e[8] + e[25] * e[2] * e[17] + e[10] * e[18] * e[0] + 3.*e[10] * e[19] * e[1] + e[10] * e[20] * e[2] + e[19] * e[9] * e[0];
	A[190] = .5000000000*ep2[23] * e[26] + .5000000000*e[26] * ep2[25] + .5000000000*ep2[20] * e[26] - .5000000000*e[26] * ep2[18] + .5000000000*ep3[26] + .5000000000*e[26] * ep2[24] + e[20] * e[19] * e[25] - .5000000000*e[26] * ep2[19] - .5000000000*e[26] * ep2[21] + e[20] * e[18] * e[24] - .5000000000*e[26] * ep2[22] + e[23] * e[21] * e[24] + e[23] * e[22] * e[25];
	A[47] = e[16] * e[9] * e[33] + e[16] * e[29] * e[17] + e[16] * e[11] * e[35] + e[16] * e[10] * e[34] + e[34] * e[11] * e[17] + e[34] * e[9] * e[15] - 1.*e[10] * e[30] * e[12] - 1.*e[10] * e[32] * e[14] - 1.*e[10] * e[33] * e[15] - 1.*e[10] * e[35] * e[17] + e[10] * e[27] * e[9] + e[10] * e[29] * e[11] + e[13] * e[27] * e[12] + e[13] * e[9] * e[30] + e[13] * e[29] * e[14] + e[13] * e[11] * e[32] + e[13] * e[10] * e[31] + e[31] * e[11] * e[14] + e[31] * e[9] * e[12] + e[16] * e[27] * e[15] + 1.500000000*e[28] * ep2[10] + .5000000000*e[28] * ep2[16] + .5000000000*e[28] * ep2[9] + .5000000000*e[28] * ep2[11] - .5000000000*e[28] * ep2[12] - .5000000000*e[28] * ep2[15] - .5000000000*e[28] * ep2[17] - .5000000000*e[28] * ep2[14] + .5000000000*e[28] * ep2[13];
	A[189] = .5000000000*ep2[20] * e[35] + .5000000000*ep2[23] * e[35] + 1.500000000*e[35] * ep2[26] + .5000000000*e[35] * ep2[25] + .5000000000*e[35] * ep2[24] - .5000000000*e[35] * ep2[18] - .5000000000*e[35] * ep2[19] - .5000000000*e[35] * ep2[22] - .5000000000*e[35] * ep2[21] + e[20] * e[27] * e[24] + e[20] * e[18] * e[33] + e[20] * e[28] * e[25] + e[20] * e[19] * e[34] + e[20] * e[29] * e[26] + e[29] * e[19] * e[25] + e[29] * e[18] * e[24] + e[23] * e[30] * e[24] + e[23] * e[21] * e[33] + e[23] * e[31] * e[25] + e[23] * e[22] * e[34] + e[23] * e[32] * e[26] + e[32] * e[22] * e[25] + e[32] * e[21] * e[24] + e[26] * e[33] * e[24] + e[26] * e[34] * e[25] - 1.*e[26] * e[27] * e[18] - 1.*e[26] * e[30] * e[21] - 1.*e[26] * e[31] * e[22] - 1.*e[26] * e[28] * e[19];
	A[46] = e[4] * e[2] * e[5] + .5000000000*e[1] * ep2[0] - .5000000000*e[1] * ep2[6] + e[7] * e[0] * e[6] + .5000000000*e[1] * ep2[7] + .5000000000*e[1] * ep2[4] - .5000000000*e[1] * ep2[8] + .5000000000*e[1] * ep2[2] - .5000000000*e[1] * ep2[3] + .5000000000*ep3[1] + e[7] * e[2] * e[8] - .5000000000*e[1] * ep2[5] + e[4] * e[0] * e[3];
	A[188] = -.5000000000*e[17] * ep2[13] - .5000000000*e[17] * ep2[9] + .5000000000*e[17] * ep2[16] + .5000000000*e[17] * ep2[15] + .5000000000*ep3[17] - .5000000000*e[17] * ep2[10] + e[14] * e[13] * e[16] + e[14] * e[12] * e[15] + .5000000000*ep2[14] * e[17] + e[11] * e[10] * e[16] - .5000000000*e[17] * ep2[12] + .5000000000*ep2[11] * e[17] + e[11] * e[9] * e[15];
	A[41] = e[4] * e[27] * e[30] + e[4] * e[29] * e[32] + e[4] * e[28] * e[31] + e[31] * e[27] * e[3] + e[31] * e[0] * e[30] + e[31] * e[29] * e[5] + e[31] * e[2] * e[32] + e[7] * e[27] * e[33] + e[7] * e[29] * e[35] + e[7] * e[28] * e[34] + e[28] * e[27] * e[0] + e[28] * e[29] * e[2] + e[34] * e[27] * e[6] + e[34] * e[0] * e[33] + e[34] * e[29] * e[8] + e[34] * e[2] * e[35] - 1.*e[28] * e[32] * e[5] - 1.*e[28] * e[33] * e[6] - 1.*e[28] * e[30] * e[3] - 1.*e[28] * e[35] * e[8] + .5000000000*e[1] * ep2[27] + .5000000000*e[1] * ep2[29] + 1.500000000*e[1] * ep2[28] + .5000000000*e[1] * ep2[31] - .5000000000*e[1] * ep2[32] - .5000000000*e[1] * ep2[33] - .5000000000*e[1] * ep2[30] + .5000000000*e[1] * ep2[34] - .5000000000*e[1] * ep2[35];
	A[187] = .5000000000*ep2[11] * e[35] + .5000000000*e[35] * ep2[16] - .5000000000*e[35] * ep2[9] - .5000000000*e[35] * ep2[12] + .5000000000*e[35] * ep2[15] + 1.500000000*e[35] * ep2[17] - .5000000000*e[35] * ep2[10] + .5000000000*e[35] * ep2[14] - .5000000000*e[35] * ep2[13] + e[11] * e[27] * e[15] + e[11] * e[9] * e[33] + e[11] * e[29] * e[17] + e[11] * e[28] * e[16] + e[11] * e[10] * e[34] + e[29] * e[9] * e[15] + e[29] * e[10] * e[16] + e[14] * e[30] * e[15] + e[14] * e[12] * e[33] + e[14] * e[32] * e[17] + e[14] * e[31] * e[16] + e[14] * e[13] * e[34] + e[32] * e[12] * e[15] + e[32] * e[13] * e[16] + e[17] * e[33] * e[15] + e[17] * e[34] * e[16] - 1.*e[17] * e[27] * e[9] - 1.*e[17] * e[30] * e[12] - 1.*e[17] * e[28] * e[10] - 1.*e[17] * e[31] * e[13];
	A[40] = e[34] * e[27] * e[33] + e[34] * e[29] * e[35] - .5000000000*e[28] * ep2[30] - .5000000000*e[28] * ep2[35] + .5000000000*ep3[28] + .5000000000*e[28] * ep2[27] + .5000000000*e[28] * ep2[29] + e[31] * e[27] * e[30] + e[31] * e[29] * e[32] - .5000000000*e[28] * ep2[32] - .5000000000*e[28] * ep2[33] + .5000000000*e[28] * ep2[31] + .5000000000*e[28] * ep2[34];
	A[186] = .5000000000*ep2[5] * e[8] + e[2] * e[0] * e[6] + .5000000000*ep2[2] * e[8] + .5000000000*ep3[8] - .5000000000*e[8] * ep2[0] + e[5] * e[4] * e[7] + e[5] * e[3] * e[6] + .5000000000*e[8] * ep2[7] + e[2] * e[1] * e[7] - .5000000000*e[8] * ep2[1] - .5000000000*e[8] * ep2[4] - .5000000000*e[8] * ep2[3] + .5000000000*e[8] * ep2[6];
	A[43] = e[28] * e[27] * e[9] + e[28] * e[29] * e[11] - 1.*e[28] * e[30] * e[12] + e[28] * e[31] * e[13] - 1.*e[28] * e[32] * e[14] - 1.*e[28] * e[33] * e[15] - 1.*e[28] * e[35] * e[17] + e[31] * e[27] * e[12] + e[31] * e[9] * e[30] + e[31] * e[29] * e[14] + e[31] * e[11] * e[32] + e[13] * e[27] * e[30] + e[13] * e[29] * e[32] + e[16] * e[27] * e[33] + e[16] * e[29] * e[35] + e[34] * e[27] * e[15] + e[34] * e[9] * e[33] + e[34] * e[29] * e[17] + e[34] * e[11] * e[35] + e[34] * e[28] * e[16] + .5000000000*e[10] * ep2[27] + .5000000000*e[10] * ep2[29] + 1.500000000*e[10] * ep2[28] - .5000000000*e[10] * ep2[32] + .5000000000*e[10] * ep2[31] - .5000000000*e[10] * ep2[33] - .5000000000*e[10] * ep2[30] + .5000000000*e[10] * ep2[34] - .5000000000*e[10] * ep2[35];
	A[185] = -.5000000000*e[35] * ep2[1] + .5000000000*e[35] * ep2[7] - .5000000000*e[35] * ep2[3] + .5000000000*ep2[2] * e[35] + 1.500000000*e[35] * ep2[8] - .5000000000*e[35] * ep2[4] - .5000000000*e[35] * ep2[0] + .5000000000*e[35] * ep2[6] + .5000000000*e[35] * ep2[5] + e[2] * e[27] * e[6] + e[2] * e[0] * e[33] + e[2] * e[28] * e[7] + e[2] * e[1] * e[34] + e[2] * e[29] * e[8] - 1.*e[8] * e[27] * e[0] + e[8] * e[34] * e[7] + e[8] * e[32] * e[5] + e[8] * e[33] * e[6] - 1.*e[8] * e[30] * e[3] - 1.*e[8] * e[28] * e[1] - 1.*e[8] * e[31] * e[4] + e[29] * e[1] * e[7] + e[29] * e[0] * e[6] + e[5] * e[30] * e[6] + e[5] * e[3] * e[33] + e[5] * e[31] * e[7] + e[5] * e[4] * e[34] + e[32] * e[4] * e[7] + e[32] * e[3] * e[6];
	A[42] = e[28] * e[27] * e[18] + e[28] * e[29] * e[20] + e[22] * e[27] * e[30] + e[22] * e[29] * e[32] + e[22] * e[28] * e[31] + e[31] * e[27] * e[21] + e[31] * e[18] * e[30] + e[31] * e[29] * e[23] + e[31] * e[20] * e[32] + e[25] * e[27] * e[33] + e[25] * e[29] * e[35] + e[25] * e[28] * e[34] + e[34] * e[27] * e[24] + e[34] * e[18] * e[33] + e[34] * e[29] * e[26] + e[34] * e[20] * e[35] - 1.*e[28] * e[33] * e[24] - 1.*e[28] * e[30] * e[21] - 1.*e[28] * e[35] * e[26] - 1.*e[28] * e[32] * e[23] - .5000000000*e[19] * ep2[33] - .5000000000*e[19] * ep2[30] - .5000000000*e[19] * ep2[35] + .5000000000*e[19] * ep2[27] + .5000000000*e[19] * ep2[29] + 1.500000000*e[19] * ep2[28] + .5000000000*e[19] * ep2[31] + .5000000000*e[19] * ep2[34] - .5000000000*e[19] * ep2[32];
	A[184] = e[23] * e[3] * e[15] - 1.*e[17] * e[19] * e[1] - 1.*e[17] * e[22] * e[4] - 1.*e[17] * e[18] * e[0] + e[17] * e[25] * e[7] + e[17] * e[24] * e[6] + e[14] * e[21] * e[6] + e[14] * e[3] * e[24] + e[14] * e[22] * e[7] + e[14] * e[4] * e[25] + e[14] * e[23] * e[8] - 1.*e[26] * e[10] * e[1] - 1.*e[26] * e[13] * e[4] + e[26] * e[16] * e[7] + e[26] * e[15] * e[6] - 1.*e[26] * e[9] * e[0] - 1.*e[26] * e[12] * e[3] + e[23] * e[12] * e[6] + e[11] * e[18] * e[6] + e[11] * e[0] * e[24] + e[11] * e[19] * e[7] + e[11] * e[1] * e[25] + e[11] * e[20] * e[8] + e[11] * e[2] * e[26] + e[20] * e[9] * e[6] + e[20] * e[0] * e[15] + e[20] * e[10] * e[7] + e[20] * e[1] * e[16] + e[20] * e[2] * e[17] + e[5] * e[21] * e[15] + e[5] * e[12] * e[24] + e[5] * e[23] * e[17] + e[5] * e[14] * e[26] + e[5] * e[22] * e[16] + e[5] * e[13] * e[25] + e[8] * e[24] * e[15] + 3.*e[8] * e[26] * e[17] + e[8] * e[25] * e[16] + e[2] * e[18] * e[15] + e[2] * e[9] * e[24] + e[2] * e[19] * e[16] + e[2] * e[10] * e[25] - 1.*e[17] * e[21] * e[3] + e[23] * e[4] * e[16] + e[23] * e[13] * e[7] - 1.*e[8] * e[18] * e[9] - 1.*e[8] * e[21] * e[12] - 1.*e[8] * e[19] * e[10] - 1.*e[8] * e[22] * e[13];
	A[54] = e[13] * e[18] * e[12] + e[13] * e[9] * e[21] + e[13] * e[20] * e[14] + e[13] * e[11] * e[23] + e[13] * e[10] * e[22] + e[22] * e[11] * e[14] + e[22] * e[9] * e[12] + e[16] * e[18] * e[15] + e[16] * e[9] * e[24] + e[16] * e[20] * e[17] + e[16] * e[11] * e[26] + e[16] * e[10] * e[25] + e[25] * e[11] * e[17] + e[25] * e[9] * e[15] - 1.*e[10] * e[23] * e[14] - 1.*e[10] * e[24] * e[15] - 1.*e[10] * e[26] * e[17] + e[10] * e[20] * e[11] + e[10] * e[18] * e[9] - 1.*e[10] * e[21] * e[12] + .5000000000*e[19] * ep2[11] + .5000000000*e[19] * ep2[9] + 1.500000000*e[19] * ep2[10] + .5000000000*e[19] * ep2[13] + .5000000000*e[19] * ep2[16] - .5000000000*e[19] * ep2[12] - .5000000000*e[19] * ep2[15] - .5000000000*e[19] * ep2[17] - .5000000000*e[19] * ep2[14];
	A[164] = e[10] * e[18] * e[6] + e[10] * e[0] * e[24] + e[10] * e[19] * e[7] + e[10] * e[1] * e[25] + e[10] * e[20] * e[8] + e[10] * e[2] * e[26] + e[19] * e[9] * e[6] + e[19] * e[0] * e[15] + e[19] * e[1] * e[16] + e[19] * e[11] * e[8] + e[19] * e[2] * e[17] + e[4] * e[21] * e[15] + e[4] * e[12] * e[24] + e[4] * e[23] * e[17] + e[4] * e[14] * e[26] + e[4] * e[22] * e[16] + e[4] * e[13] * e[25] + e[7] * e[24] * e[15] + e[7] * e[26] * e[17] + 3.*e[7] * e[25] * e[16] + e[1] * e[18] * e[15] + e[1] * e[9] * e[24] + e[1] * e[20] * e[17] + e[1] * e[11] * e[26] - 1.*e[16] * e[21] * e[3] + e[16] * e[26] * e[8] - 1.*e[16] * e[20] * e[2] - 1.*e[16] * e[18] * e[0] - 1.*e[16] * e[23] * e[5] + e[16] * e[24] * e[6] + e[13] * e[21] * e[6] + e[13] * e[3] * e[24] + e[13] * e[22] * e[7] + e[13] * e[23] * e[8] + e[13] * e[5] * e[26] - 1.*e[25] * e[11] * e[2] + e[25] * e[15] * e[6] - 1.*e[25] * e[9] * e[0] - 1.*e[25] * e[14] * e[5] - 1.*e[25] * e[12] * e[3] + e[25] * e[17] * e[8] + e[22] * e[12] * e[6] + e[22] * e[3] * e[15] + e[22] * e[14] * e[8] + e[22] * e[5] * e[17] - 1.*e[7] * e[23] * e[14] - 1.*e[7] * e[20] * e[11] - 1.*e[7] * e[18] * e[9] - 1.*e[7] * e[21] * e[12];
	A[55] = e[13] * e[9] * e[3] + e[13] * e[0] * e[12] + e[13] * e[10] * e[4] + e[13] * e[11] * e[5] + e[13] * e[2] * e[14] + e[16] * e[9] * e[6] + e[16] * e[0] * e[15] + e[16] * e[10] * e[7] + e[16] * e[11] * e[8] + e[16] * e[2] * e[17] + e[7] * e[11] * e[17] + e[7] * e[9] * e[15] + e[4] * e[11] * e[14] + e[4] * e[9] * e[12] + e[10] * e[9] * e[0] + e[10] * e[11] * e[2] - 1.*e[10] * e[15] * e[6] - 1.*e[10] * e[14] * e[5] - 1.*e[10] * e[12] * e[3] - 1.*e[10] * e[17] * e[8] + .5000000000*e[1] * ep2[11] + .5000000000*e[1] * ep2[9] + 1.500000000*e[1] * ep2[10] - .5000000000*e[1] * ep2[12] - .5000000000*e[1] * ep2[15] - .5000000000*e[1] * ep2[17] - .5000000000*e[1] * ep2[14] + .5000000000*e[1] * ep2[13] + .5000000000*e[1] * ep2[16];
	A[165] = e[1] * e[27] * e[6] + e[1] * e[0] * e[33] + e[1] * e[28] * e[7] + e[1] * e[29] * e[8] + e[1] * e[2] * e[35] - 1.*e[7] * e[27] * e[0] - 1.*e[7] * e[32] * e[5] + e[7] * e[33] * e[6] - 1.*e[7] * e[30] * e[3] + e[7] * e[35] * e[8] - 1.*e[7] * e[29] * e[2] + e[7] * e[31] * e[4] + e[28] * e[0] * e[6] + e[28] * e[2] * e[8] + e[4] * e[30] * e[6] + e[4] * e[3] * e[33] + e[4] * e[32] * e[8] + e[4] * e[5] * e[35] + e[31] * e[3] * e[6] + e[31] * e[5] * e[8] + .5000000000*ep2[1] * e[34] + 1.500000000*e[34] * ep2[7] + .5000000000*e[34] * ep2[4] - .5000000000*e[34] * ep2[0] + .5000000000*e[34] * ep2[6] - .5000000000*e[34] * ep2[5] - .5000000000*e[34] * ep2[3] - .5000000000*e[34] * ep2[2] + .5000000000*e[34] * ep2[8];
	A[52] = e[4] * e[18] * e[3] + e[4] * e[0] * e[21] + e[4] * e[1] * e[22] + e[4] * e[20] * e[5] + e[4] * e[2] * e[23] + e[22] * e[0] * e[3] + e[22] * e[2] * e[5] + e[7] * e[18] * e[6] + e[7] * e[0] * e[24] + e[7] * e[1] * e[25] + e[7] * e[20] * e[8] + e[7] * e[2] * e[26] + e[25] * e[0] * e[6] + e[25] * e[2] * e[8] + e[1] * e[18] * e[0] + e[1] * e[20] * e[2] - 1.*e[1] * e[21] * e[3] - 1.*e[1] * e[26] * e[8] - 1.*e[1] * e[23] * e[5] - 1.*e[1] * e[24] * e[6] + .5000000000*e[19] * ep2[4] + .5000000000*e[19] * ep2[0] - .5000000000*e[19] * ep2[6] - .5000000000*e[19] * ep2[5] + 1.500000000*e[19] * ep2[1] + .5000000000*e[19] * ep2[7] - .5000000000*e[19] * ep2[3] + .5000000000*e[19] * ep2[2] - .5000000000*e[19] * ep2[8];
	A[166] = -.5000000000*e[7] * ep2[0] + e[4] * e[5] * e[8] + .5000000000*ep2[4] * e[7] - .5000000000*e[7] * ep2[2] + .5000000000*e[7] * ep2[8] - .5000000000*e[7] * ep2[5] + .5000000000*e[7] * ep2[6] + e[1] * e[0] * e[6] + .5000000000*ep3[7] + e[4] * e[3] * e[6] + e[1] * e[2] * e[8] - .5000000000*e[7] * ep2[3] + .5000000000*ep2[1] * e[7];
	A[53] = -1.*e[1] * e[32] * e[23] - 1.*e[19] * e[32] * e[5] - 1.*e[19] * e[33] * e[6] - 1.*e[19] * e[30] * e[3] - 1.*e[19] * e[35] * e[8] - 1.*e[28] * e[21] * e[3] - 1.*e[28] * e[26] * e[8] - 1.*e[28] * e[23] * e[5] - 1.*e[28] * e[24] * e[6] + e[7] * e[27] * e[24] + e[7] * e[18] * e[33] + e[7] * e[29] * e[26] + e[7] * e[20] * e[35] + e[22] * e[27] * e[3] + e[22] * e[0] * e[30] + e[22] * e[29] * e[5] + e[22] * e[2] * e[32] + e[31] * e[18] * e[3] + e[31] * e[0] * e[21] + e[31] * e[20] * e[5] + e[31] * e[2] * e[23] + e[25] * e[27] * e[6] + e[25] * e[0] * e[33] + e[25] * e[28] * e[7] + e[25] * e[1] * e[34] + e[25] * e[29] * e[8] + e[25] * e[2] * e[35] + e[34] * e[18] * e[6] + e[34] * e[0] * e[24] + e[34] * e[19] * e[7] + e[34] * e[20] * e[8] + e[34] * e[2] * e[26] + e[1] * e[27] * e[18] + 3.*e[1] * e[28] * e[19] + e[1] * e[29] * e[20] + e[19] * e[27] * e[0] + e[19] * e[29] * e[2] + e[28] * e[18] * e[0] + e[28] * e[20] * e[2] + e[4] * e[27] * e[21] + e[4] * e[18] * e[30] + e[4] * e[28] * e[22] + e[4] * e[19] * e[31] + e[4] * e[29] * e[23] + e[4] * e[20] * e[32] - 1.*e[1] * e[33] * e[24] - 1.*e[1] * e[30] * e[21] - 1.*e[1] * e[35] * e[26] + e[1] * e[31] * e[22];
	A[167] = e[10] * e[27] * e[15] + e[10] * e[9] * e[33] + e[10] * e[29] * e[17] + e[10] * e[11] * e[35] + e[10] * e[28] * e[16] + e[28] * e[11] * e[17] + e[28] * e[9] * e[15] + e[13] * e[30] * e[15] + e[13] * e[12] * e[33] + e[13] * e[32] * e[17] + e[13] * e[14] * e[35] + e[13] * e[31] * e[16] + e[31] * e[14] * e[17] + e[31] * e[12] * e[15] + e[16] * e[33] * e[15] + e[16] * e[35] * e[17] - 1.*e[16] * e[27] * e[9] - 1.*e[16] * e[30] * e[12] - 1.*e[16] * e[32] * e[14] - 1.*e[16] * e[29] * e[11] + .5000000000*ep2[10] * e[34] + 1.500000000*e[34] * ep2[16] - .5000000000*e[34] * ep2[9] - .5000000000*e[34] * ep2[11] - .5000000000*e[34] * ep2[12] + .5000000000*e[34] * ep2[15] + .5000000000*e[34] * ep2[17] - .5000000000*e[34] * ep2[14] + .5000000000*e[34] * ep2[13];
	A[50] = .5000000000*e[19] * ep2[18] + .5000000000*e[19] * ep2[25] + .5000000000*e[19] * ep2[22] + e[25] * e[20] * e[26] - .5000000000*e[19] * ep2[21] + .5000000000*e[19] * ep2[20] - .5000000000*e[19] * ep2[26] - .5000000000*e[19] * ep2[23] - .5000000000*e[19] * ep2[24] + .5000000000*ep3[19] + e[22] * e[20] * e[23] + e[25] * e[18] * e[24] + e[22] * e[18] * e[21];
	A[160] = .5000000000*e[34] * ep2[33] + .5000000000*e[34] * ep2[35] - .5000000000*e[34] * ep2[27] - .5000000000*e[34] * ep2[32] - .5000000000*e[34] * ep2[29] - .5000000000*e[34] * ep2[30] + .5000000000*ep2[28] * e[34] + e[31] * e[30] * e[33] + e[31] * e[32] * e[35] + e[28] * e[27] * e[33] + .5000000000*ep3[34] + e[28] * e[29] * e[35] + .5000000000*ep2[31] * e[34];
	A[51] = e[4] * e[28] * e[13] + e[4] * e[10] * e[31] + e[7] * e[27] * e[15] + e[7] * e[9] * e[33] + e[7] * e[29] * e[17] + e[7] * e[11] * e[35] + e[7] * e[28] * e[16] + e[7] * e[10] * e[34] + e[1] * e[27] * e[9] + e[1] * e[29] * e[11] + 3.*e[1] * e[28] * e[10] + e[10] * e[27] * e[0] - 1.*e[10] * e[32] * e[5] - 1.*e[10] * e[33] * e[6] - 1.*e[10] * e[30] * e[3] - 1.*e[10] * e[35] * e[8] + e[10] * e[29] * e[2] + e[13] * e[27] * e[3] + e[13] * e[0] * e[30] + e[13] * e[1] * e[31] + e[13] * e[29] * e[5] + e[13] * e[2] * e[32] + e[28] * e[11] * e[2] - 1.*e[28] * e[15] * e[6] + e[28] * e[9] * e[0] - 1.*e[28] * e[14] * e[5] - 1.*e[28] * e[12] * e[3] - 1.*e[28] * e[17] * e[8] + e[31] * e[9] * e[3] + e[31] * e[0] * e[12] + e[31] * e[11] * e[5] + e[31] * e[2] * e[14] + e[16] * e[27] * e[6] + e[16] * e[0] * e[33] + e[16] * e[1] * e[34] + e[16] * e[29] * e[8] + e[16] * e[2] * e[35] - 1.*e[1] * e[30] * e[12] - 1.*e[1] * e[32] * e[14] - 1.*e[1] * e[33] * e[15] - 1.*e[1] * e[35] * e[17] + e[34] * e[9] * e[6] + e[34] * e[0] * e[15] + e[34] * e[11] * e[8] + e[34] * e[2] * e[17] + e[4] * e[27] * e[12] + e[4] * e[9] * e[30] + e[4] * e[29] * e[14] + e[4] * e[11] * e[32];
	A[161] = e[4] * e[30] * e[33] + e[4] * e[32] * e[35] + e[4] * e[31] * e[34] + e[31] * e[30] * e[6] + e[31] * e[3] * e[33] + e[31] * e[32] * e[8] + e[31] * e[5] * e[35] + e[28] * e[27] * e[6] + e[28] * e[0] * e[33] + e[28] * e[29] * e[8] + e[28] * e[2] * e[35] + e[34] * e[33] * e[6] + e[34] * e[35] * e[8] - 1.*e[34] * e[27] * e[0] - 1.*e[34] * e[32] * e[5] - 1.*e[34] * e[30] * e[3] - 1.*e[34] * e[29] * e[2] + e[1] * e[27] * e[33] + e[1] * e[29] * e[35] + e[1] * e[28] * e[34] + .5000000000*ep2[31] * e[7] - .5000000000*e[7] * ep2[27] - .5000000000*e[7] * ep2[32] + .5000000000*e[7] * ep2[28] - .5000000000*e[7] * ep2[29] + .5000000000*e[7] * ep2[33] - .5000000000*e[7] * ep2[30] + 1.500000000*e[7] * ep2[34] + .5000000000*e[7] * ep2[35];
	A[48] = -.5000000000*e[10] * ep2[14] - .5000000000*e[10] * ep2[17] - .5000000000*e[10] * ep2[15] + e[13] * e[11] * e[14] + e[16] * e[11] * e[17] + .5000000000*e[10] * ep2[13] + e[13] * e[9] * e[12] - .5000000000*e[10] * ep2[12] + .5000000000*ep3[10] + e[16] * e[9] * e[15] + .5000000000*e[10] * ep2[16] + .5000000000*e[10] * ep2[11] + .5000000000*e[10] * ep2[9];
	A[162] = e[22] * e[32] * e[35] + e[22] * e[31] * e[34] + e[31] * e[30] * e[24] + e[31] * e[21] * e[33] + e[31] * e[32] * e[26] + e[31] * e[23] * e[35] + e[34] * e[33] * e[24] + e[34] * e[35] * e[26] - 1.*e[34] * e[27] * e[18] - 1.*e[34] * e[30] * e[21] - 1.*e[34] * e[29] * e[20] - 1.*e[34] * e[32] * e[23] + e[19] * e[27] * e[33] + e[19] * e[29] * e[35] + e[19] * e[28] * e[34] + e[28] * e[27] * e[24] + e[28] * e[18] * e[33] + e[28] * e[29] * e[26] + e[28] * e[20] * e[35] + e[22] * e[30] * e[33] + .5000000000*ep2[28] * e[25] + .5000000000*ep2[31] * e[25] + .5000000000*e[25] * ep2[33] + .5000000000*e[25] * ep2[35] + 1.500000000*e[25] * ep2[34] - .5000000000*e[25] * ep2[27] - .5000000000*e[25] * ep2[32] - .5000000000*e[25] * ep2[29] - .5000000000*e[25] * ep2[30];
	A[49] = -1.*e[19] * e[35] * e[26] - 1.*e[19] * e[32] * e[23] + e[19] * e[27] * e[18] + e[19] * e[29] * e[20] + e[22] * e[27] * e[21] + e[22] * e[18] * e[30] + e[22] * e[19] * e[31] + e[22] * e[29] * e[23] + e[22] * e[20] * e[32] + e[31] * e[18] * e[21] + e[31] * e[20] * e[23] + e[25] * e[27] * e[24] + e[25] * e[18] * e[33] + e[25] * e[19] * e[34] + e[25] * e[29] * e[26] + e[25] * e[20] * e[35] + e[34] * e[18] * e[24] + e[34] * e[20] * e[26] - 1.*e[19] * e[33] * e[24] - 1.*e[19] * e[30] * e[21] + 1.500000000*e[28] * ep2[19] + .5000000000*e[28] * ep2[18] + .5000000000*e[28] * ep2[20] + .5000000000*e[28] * ep2[22] + .5000000000*e[28] * ep2[25] - .5000000000*e[28] * ep2[26] - .5000000000*e[28] * ep2[23] - .5000000000*e[28] * ep2[24] - .5000000000*e[28] * ep2[21];
	A[163] = e[10] * e[27] * e[33] + e[10] * e[29] * e[35] + e[10] * e[28] * e[34] + e[34] * e[33] * e[15] + e[34] * e[35] * e[17] + e[28] * e[27] * e[15] + e[28] * e[9] * e[33] + e[28] * e[29] * e[17] + e[28] * e[11] * e[35] - 1.*e[34] * e[27] * e[9] - 1.*e[34] * e[30] * e[12] + e[34] * e[31] * e[13] - 1.*e[34] * e[32] * e[14] - 1.*e[34] * e[29] * e[11] + e[31] * e[30] * e[15] + e[31] * e[12] * e[33] + e[31] * e[32] * e[17] + e[31] * e[14] * e[35] + e[13] * e[30] * e[33] + e[13] * e[32] * e[35] - .5000000000*e[16] * ep2[27] - .5000000000*e[16] * ep2[32] + .5000000000*e[16] * ep2[28] - .5000000000*e[16] * ep2[29] + .5000000000*e[16] * ep2[31] + .5000000000*e[16] * ep2[33] - .5000000000*e[16] * ep2[30] + 1.500000000*e[16] * ep2[34] + .5000000000*e[16] * ep2[35];
	A[63] = e[29] * e[32] * e[14] - 1.*e[29] * e[33] * e[15] - 1.*e[29] * e[34] * e[16] + e[32] * e[27] * e[12] + e[32] * e[9] * e[30] + e[32] * e[28] * e[13] + e[32] * e[10] * e[31] + e[14] * e[27] * e[30] + e[14] * e[28] * e[31] + e[17] * e[27] * e[33] + e[17] * e[28] * e[34] + e[35] * e[27] * e[15] + e[35] * e[9] * e[33] + e[35] * e[29] * e[17] + e[35] * e[28] * e[16] + e[35] * e[10] * e[34] + e[29] * e[27] * e[9] + e[29] * e[28] * e[10] - 1.*e[29] * e[30] * e[12] - 1.*e[29] * e[31] * e[13] + .5000000000*e[11] * ep2[27] + 1.500000000*e[11] * ep2[29] + .5000000000*e[11] * ep2[28] + .5000000000*e[11] * ep2[32] - .5000000000*e[11] * ep2[31] - .5000000000*e[11] * ep2[33] - .5000000000*e[11] * ep2[30] - .5000000000*e[11] * ep2[34] + .5000000000*e[11] * ep2[35];
	A[173] = e[1] * e[20] * e[35] + e[19] * e[27] * e[6] + e[19] * e[0] * e[33] + e[19] * e[28] * e[7] + e[19] * e[29] * e[8] + e[19] * e[2] * e[35] + e[28] * e[18] * e[6] + e[28] * e[0] * e[24] + e[28] * e[20] * e[8] + e[28] * e[2] * e[26] + e[4] * e[30] * e[24] + e[4] * e[21] * e[33] + e[4] * e[31] * e[25] + e[4] * e[22] * e[34] + e[4] * e[32] * e[26] + e[4] * e[23] * e[35] - 1.*e[7] * e[27] * e[18] + e[7] * e[33] * e[24] - 1.*e[7] * e[30] * e[21] - 1.*e[7] * e[29] * e[20] + e[7] * e[35] * e[26] + e[7] * e[31] * e[22] - 1.*e[7] * e[32] * e[23] - 1.*e[25] * e[27] * e[0] - 1.*e[25] * e[32] * e[5] - 1.*e[25] * e[30] * e[3] - 1.*e[25] * e[29] * e[2] - 1.*e[34] * e[21] * e[3] - 1.*e[34] * e[20] * e[2] - 1.*e[34] * e[18] * e[0] - 1.*e[34] * e[23] * e[5] + e[22] * e[30] * e[6] + e[22] * e[3] * e[33] + e[22] * e[32] * e[8] + e[22] * e[5] * e[35] + e[31] * e[21] * e[6] + e[31] * e[3] * e[24] + e[31] * e[23] * e[8] + e[31] * e[5] * e[26] + e[34] * e[26] * e[8] + e[1] * e[27] * e[24] + e[1] * e[18] * e[33] + e[1] * e[28] * e[25] + e[1] * e[19] * e[34] + e[1] * e[29] * e[26] + e[34] * e[24] * e[6] + e[25] * e[33] * e[6] + 3.*e[25] * e[34] * e[7] + e[25] * e[35] * e[8];
	A[62] = .5000000000*e[20] * ep2[27] + 1.500000000*e[20] * ep2[29] + .5000000000*e[20] * ep2[28] + .5000000000*e[20] * ep2[32] + .5000000000*e[20] * ep2[35] - .5000000000*e[20] * ep2[31] - .5000000000*e[20] * ep2[33] - .5000000000*e[20] * ep2[30] - .5000000000*e[20] * ep2[34] + e[29] * e[27] * e[18] + e[29] * e[28] * e[19] + e[23] * e[27] * e[30] + e[23] * e[29] * e[32] + e[23] * e[28] * e[31] + e[32] * e[27] * e[21] + e[32] * e[18] * e[30] + e[32] * e[28] * e[22] + e[32] * e[19] * e[31] + e[26] * e[27] * e[33] + e[26] * e[29] * e[35] + e[26] * e[28] * e[34] + e[35] * e[27] * e[24] + e[35] * e[18] * e[33] + e[35] * e[28] * e[25] + e[35] * e[19] * e[34] - 1.*e[29] * e[33] * e[24] - 1.*e[29] * e[30] * e[21] - 1.*e[29] * e[31] * e[22] - 1.*e[29] * e[34] * e[25];
	A[172] = e[19] * e[1] * e[7] + e[19] * e[0] * e[6] + e[19] * e[2] * e[8] + e[4] * e[21] * e[6] + e[4] * e[3] * e[24] + e[4] * e[22] * e[7] + e[4] * e[23] * e[8] + e[4] * e[5] * e[26] + e[22] * e[3] * e[6] + e[22] * e[5] * e[8] + e[7] * e[24] * e[6] + e[7] * e[26] * e[8] + e[1] * e[18] * e[6] + e[1] * e[0] * e[24] + e[1] * e[20] * e[8] + e[1] * e[2] * e[26] - 1.*e[7] * e[21] * e[3] - 1.*e[7] * e[20] * e[2] - 1.*e[7] * e[18] * e[0] - 1.*e[7] * e[23] * e[5] + .5000000000*e[25] * ep2[4] - .5000000000*e[25] * ep2[0] + .5000000000*e[25] * ep2[6] - .5000000000*e[25] * ep2[5] + .5000000000*e[25] * ep2[1] + 1.500000000*e[25] * ep2[7] - .5000000000*e[25] * ep2[3] - .5000000000*e[25] * ep2[2] + .5000000000*e[25] * ep2[8];
	A[61] = e[5] * e[27] * e[30] + e[5] * e[29] * e[32] + e[5] * e[28] * e[31] + e[32] * e[27] * e[3] + e[32] * e[0] * e[30] + e[32] * e[28] * e[4] + e[32] * e[1] * e[31] + e[8] * e[27] * e[33] + e[8] * e[29] * e[35] + e[8] * e[28] * e[34] + e[29] * e[27] * e[0] + e[29] * e[28] * e[1] + e[35] * e[27] * e[6] + e[35] * e[0] * e[33] + e[35] * e[28] * e[7] + e[35] * e[1] * e[34] - 1.*e[29] * e[34] * e[7] - 1.*e[29] * e[33] * e[6] - 1.*e[29] * e[30] * e[3] - 1.*e[29] * e[31] * e[4] + .5000000000*e[2] * ep2[27] + 1.500000000*e[2] * ep2[29] + .5000000000*e[2] * ep2[28] + .5000000000*e[2] * ep2[32] - .5000000000*e[2] * ep2[31] - .5000000000*e[2] * ep2[33] - .5000000000*e[2] * ep2[30] - .5000000000*e[2] * ep2[34] + .5000000000*e[2] * ep2[35];
	A[175] = e[13] * e[12] * e[6] + e[13] * e[3] * e[15] + e[13] * e[4] * e[16] + e[13] * e[14] * e[8] + e[13] * e[5] * e[17] + e[16] * e[15] * e[6] + e[16] * e[17] * e[8] + e[1] * e[11] * e[17] + e[1] * e[9] * e[15] + e[1] * e[10] * e[16] + e[4] * e[14] * e[17] + e[4] * e[12] * e[15] + e[10] * e[9] * e[6] + e[10] * e[0] * e[15] + e[10] * e[11] * e[8] + e[10] * e[2] * e[17] - 1.*e[16] * e[11] * e[2] - 1.*e[16] * e[9] * e[0] - 1.*e[16] * e[14] * e[5] - 1.*e[16] * e[12] * e[3] + .5000000000*ep2[13] * e[7] + 1.500000000*ep2[16] * e[7] + .5000000000*e[7] * ep2[17] + .5000000000*e[7] * ep2[15] - .5000000000*e[7] * ep2[9] - .5000000000*e[7] * ep2[11] - .5000000000*e[7] * ep2[12] + .5000000000*e[7] * ep2[10] - .5000000000*e[7] * ep2[14];
	A[60] = .5000000000*e[29] * ep2[32] + .5000000000*e[29] * ep2[35] - .5000000000*e[29] * ep2[31] - .5000000000*e[29] * ep2[33] - .5000000000*e[29] * ep2[30] - .5000000000*e[29] * ep2[34] + e[32] * e[27] * e[30] + .5000000000*ep3[29] + .5000000000*e[29] * ep2[28] + e[35] * e[28] * e[34] + .5000000000*e[29] * ep2[27] + e[35] * e[27] * e[33] + e[32] * e[28] * e[31];
	A[174] = -1.*e[16] * e[21] * e[12] + e[10] * e[18] * e[15] + e[10] * e[9] * e[24] + e[10] * e[20] * e[17] + e[10] * e[11] * e[26] + e[19] * e[11] * e[17] + e[19] * e[9] * e[15] + e[19] * e[10] * e[16] + e[13] * e[21] * e[15] + e[13] * e[12] * e[24] + e[13] * e[23] * e[17] + e[13] * e[14] * e[26] + e[13] * e[22] * e[16] + e[22] * e[14] * e[17] + e[22] * e[12] * e[15] + e[16] * e[24] * e[15] + e[16] * e[26] * e[17] - 1.*e[16] * e[23] * e[14] - 1.*e[16] * e[20] * e[11] - 1.*e[16] * e[18] * e[9] + .5000000000*ep2[13] * e[25] + 1.500000000*e[25] * ep2[16] + .5000000000*e[25] * ep2[17] + .5000000000*e[25] * ep2[15] + .5000000000*ep2[10] * e[25] - .5000000000*e[25] * ep2[9] - .5000000000*e[25] * ep2[11] - .5000000000*e[25] * ep2[12] - .5000000000*e[25] * ep2[14];
	A[59] = e[19] * e[20] * e[2] + e[22] * e[18] * e[3] + e[22] * e[0] * e[21] + e[22] * e[19] * e[4] + e[22] * e[20] * e[5] + e[22] * e[2] * e[23] - 1.*e[19] * e[21] * e[3] - 1.*e[19] * e[26] * e[8] + e[19] * e[25] * e[7] - 1.*e[19] * e[23] * e[5] - 1.*e[19] * e[24] * e[6] + e[4] * e[18] * e[21] + e[4] * e[20] * e[23] + e[25] * e[18] * e[6] + e[25] * e[0] * e[24] + e[25] * e[20] * e[8] + e[25] * e[2] * e[26] + e[7] * e[18] * e[24] + e[7] * e[20] * e[26] + e[19] * e[18] * e[0] + 1.500000000*ep2[19] * e[1] + .5000000000*e[1] * ep2[22] + .5000000000*e[1] * ep2[18] + .5000000000*e[1] * ep2[20] + .5000000000*e[1] * ep2[25] - .5000000000*e[1] * ep2[26] - .5000000000*e[1] * ep2[23] - .5000000000*e[1] * ep2[24] - .5000000000*e[1] * ep2[21];
	A[169] = e[19] * e[27] * e[24] + e[19] * e[18] * e[33] + e[19] * e[28] * e[25] + e[19] * e[29] * e[26] + e[19] * e[20] * e[35] + e[28] * e[18] * e[24] + e[28] * e[20] * e[26] + e[22] * e[30] * e[24] + e[22] * e[21] * e[33] + e[22] * e[31] * e[25] + e[22] * e[32] * e[26] + e[22] * e[23] * e[35] + e[31] * e[21] * e[24] + e[31] * e[23] * e[26] + e[25] * e[33] * e[24] + e[25] * e[35] * e[26] - 1.*e[25] * e[27] * e[18] - 1.*e[25] * e[30] * e[21] - 1.*e[25] * e[29] * e[20] - 1.*e[25] * e[32] * e[23] - .5000000000*e[34] * ep2[18] - .5000000000*e[34] * ep2[23] - .5000000000*e[34] * ep2[20] - .5000000000*e[34] * ep2[21] + .5000000000*ep2[19] * e[34] + .5000000000*ep2[22] * e[34] + 1.500000000*e[34] * ep2[25] + .5000000000*e[34] * ep2[24] + .5000000000*e[34] * ep2[26];
	A[58] = e[16] * e[0] * e[6] + e[16] * e[2] * e[8] + e[1] * e[11] * e[2] - 1.*e[1] * e[15] * e[6] + e[1] * e[9] * e[0] - 1.*e[1] * e[14] * e[5] - 1.*e[1] * e[12] * e[3] - 1.*e[1] * e[17] * e[8] + e[4] * e[9] * e[3] + e[4] * e[0] * e[12] + e[4] * e[1] * e[13] + e[4] * e[11] * e[5] + e[4] * e[2] * e[14] + e[13] * e[0] * e[3] + e[13] * e[2] * e[5] + e[7] * e[9] * e[6] + e[7] * e[0] * e[15] + e[7] * e[1] * e[16] + e[7] * e[11] * e[8] + e[7] * e[2] * e[17] - .5000000000*e[10] * ep2[6] - .5000000000*e[10] * ep2[5] - .5000000000*e[10] * ep2[3] - .5000000000*e[10] * ep2[8] + 1.500000000*e[10] * ep2[1] + .5000000000*e[10] * ep2[0] + .5000000000*e[10] * ep2[2] + .5000000000*e[10] * ep2[4] + .5000000000*e[10] * ep2[7];
	A[168] = e[13] * e[14] * e[17] + e[13] * e[12] * e[15] + e[10] * e[9] * e[15] + .5000000000*e[16] * ep2[15] - .5000000000*e[16] * ep2[11] - .5000000000*e[16] * ep2[12] - .5000000000*e[16] * ep2[14] + e[10] * e[11] * e[17] + .5000000000*ep2[10] * e[16] + .5000000000*ep3[16] - .5000000000*e[16] * ep2[9] + .5000000000*e[16] * ep2[17] + .5000000000*ep2[13] * e[16];
	A[57] = e[10] * e[29] * e[20] + e[22] * e[27] * e[12] + e[22] * e[9] * e[30] + e[22] * e[29] * e[14] + e[22] * e[11] * e[32] + e[22] * e[10] * e[31] + e[31] * e[18] * e[12] + e[31] * e[9] * e[21] + e[31] * e[20] * e[14] + e[31] * e[11] * e[23] - 1.*e[10] * e[33] * e[24] - 1.*e[10] * e[30] * e[21] - 1.*e[10] * e[35] * e[26] - 1.*e[10] * e[32] * e[23] + e[10] * e[34] * e[25] + e[19] * e[27] * e[9] + e[19] * e[29] * e[11] + e[28] * e[18] * e[9] + e[28] * e[20] * e[11] + e[16] * e[27] * e[24] + e[16] * e[18] * e[33] + e[16] * e[28] * e[25] + e[16] * e[19] * e[34] + e[16] * e[29] * e[26] + e[16] * e[20] * e[35] - 1.*e[19] * e[30] * e[12] - 1.*e[19] * e[32] * e[14] - 1.*e[19] * e[33] * e[15] - 1.*e[19] * e[35] * e[17] - 1.*e[28] * e[23] * e[14] - 1.*e[28] * e[24] * e[15] - 1.*e[28] * e[26] * e[17] - 1.*e[28] * e[21] * e[12] + e[25] * e[27] * e[15] + e[25] * e[9] * e[33] + e[25] * e[29] * e[17] + e[25] * e[11] * e[35] + e[34] * e[18] * e[15] + e[34] * e[9] * e[24] + e[34] * e[20] * e[17] + e[34] * e[11] * e[26] + e[13] * e[27] * e[21] + e[13] * e[18] * e[30] + e[13] * e[28] * e[22] + e[13] * e[19] * e[31] + e[13] * e[29] * e[23] + e[13] * e[20] * e[32] + e[10] * e[27] * e[18] + 3.*e[10] * e[28] * e[19];
	A[171] = e[4] * e[30] * e[15] + e[4] * e[12] * e[33] + e[4] * e[32] * e[17] + e[4] * e[14] * e[35] + e[4] * e[31] * e[16] + e[4] * e[13] * e[34] + e[7] * e[33] * e[15] + e[7] * e[35] * e[17] + 3.*e[7] * e[34] * e[16] + e[1] * e[27] * e[15] + e[1] * e[9] * e[33] + e[1] * e[29] * e[17] + e[1] * e[11] * e[35] + e[1] * e[28] * e[16] + e[1] * e[10] * e[34] - 1.*e[16] * e[27] * e[0] - 1.*e[16] * e[32] * e[5] + e[16] * e[33] * e[6] - 1.*e[16] * e[30] * e[3] + e[16] * e[35] * e[8] - 1.*e[16] * e[29] * e[2] + e[13] * e[30] * e[6] + e[13] * e[3] * e[33] + e[13] * e[31] * e[7] + e[13] * e[32] * e[8] + e[13] * e[5] * e[35] - 1.*e[34] * e[11] * e[2] + e[34] * e[15] * e[6] - 1.*e[34] * e[9] * e[0] - 1.*e[34] * e[14] * e[5] - 1.*e[34] * e[12] * e[3] + e[34] * e[17] * e[8] + e[31] * e[12] * e[6] + e[31] * e[3] * e[15] + e[31] * e[14] * e[8] + e[31] * e[5] * e[17] - 1.*e[7] * e[27] * e[9] - 1.*e[7] * e[30] * e[12] + e[7] * e[28] * e[10] - 1.*e[7] * e[32] * e[14] + e[10] * e[27] * e[6] + e[10] * e[0] * e[33] + e[10] * e[29] * e[8] + e[10] * e[2] * e[35] + e[28] * e[9] * e[6] + e[28] * e[0] * e[15] + e[28] * e[11] * e[8] + e[28] * e[2] * e[17] - 1.*e[7] * e[29] * e[11];
	A[56] = e[22] * e[18] * e[12] + e[22] * e[9] * e[21] + e[22] * e[20] * e[14] + e[22] * e[11] * e[23] + e[22] * e[19] * e[13] + e[25] * e[18] * e[15] + e[25] * e[9] * e[24] + e[25] * e[20] * e[17] + e[25] * e[11] * e[26] + e[25] * e[19] * e[16] + e[16] * e[18] * e[24] + e[16] * e[20] * e[26] + e[13] * e[18] * e[21] + e[13] * e[20] * e[23] + e[19] * e[18] * e[9] + e[19] * e[20] * e[11] - 1.*e[19] * e[23] * e[14] - 1.*e[19] * e[24] * e[15] - 1.*e[19] * e[26] * e[17] - 1.*e[19] * e[21] * e[12] + .5000000000*e[10] * ep2[22] + .5000000000*e[10] * ep2[25] + 1.500000000*e[10] * ep2[19] + .5000000000*e[10] * ep2[18] + .5000000000*e[10] * ep2[20] - .5000000000*e[10] * ep2[26] - .5000000000*e[10] * ep2[23] - .5000000000*e[10] * ep2[24] - .5000000000*e[10] * ep2[21];
	A[170] = e[19] * e[20] * e[26] - .5000000000*e[25] * ep2[20] + e[22] * e[21] * e[24] + e[19] * e[18] * e[24] + .5000000000*ep2[22] * e[25] - .5000000000*e[25] * ep2[21] - .5000000000*e[25] * ep2[23] + .5000000000*ep2[19] * e[25] - .5000000000*e[25] * ep2[18] + .5000000000*e[25] * ep2[24] + .5000000000*e[25] * ep2[26] + .5000000000*ep3[25] + e[22] * e[23] * e[26];
	A[73] = -1.*e[20] * e[33] * e[6] - 1.*e[20] * e[30] * e[3] - 1.*e[20] * e[31] * e[4] - 1.*e[29] * e[21] * e[3] - 1.*e[29] * e[22] * e[4] - 1.*e[29] * e[25] * e[7] - 1.*e[29] * e[24] * e[6] + e[8] * e[27] * e[24] + e[8] * e[18] * e[33] + e[8] * e[28] * e[25] + e[8] * e[19] * e[34] + e[23] * e[27] * e[3] + e[23] * e[0] * e[30] + e[23] * e[28] * e[4] + e[23] * e[1] * e[31] + e[32] * e[18] * e[3] + e[32] * e[0] * e[21] + e[32] * e[19] * e[4] + e[32] * e[1] * e[22] + e[26] * e[27] * e[6] + e[26] * e[0] * e[33] + e[26] * e[28] * e[7] + e[26] * e[1] * e[34] + e[26] * e[29] * e[8] + e[26] * e[2] * e[35] + e[35] * e[18] * e[6] + e[35] * e[0] * e[24] + e[35] * e[19] * e[7] + e[35] * e[1] * e[25] + e[35] * e[20] * e[8] + e[2] * e[27] * e[18] + e[2] * e[28] * e[19] + 3.*e[2] * e[29] * e[20] + e[20] * e[27] * e[0] + e[20] * e[28] * e[1] + e[29] * e[18] * e[0] + e[29] * e[19] * e[1] + e[5] * e[27] * e[21] + e[5] * e[18] * e[30] + e[5] * e[28] * e[22] + e[5] * e[19] * e[31] + e[5] * e[29] * e[23] + e[5] * e[20] * e[32] - 1.*e[2] * e[33] * e[24] - 1.*e[2] * e[30] * e[21] - 1.*e[2] * e[31] * e[22] + e[2] * e[32] * e[23] - 1.*e[2] * e[34] * e[25] - 1.*e[20] * e[34] * e[7];
	A[72] = e[5] * e[18] * e[3] + e[5] * e[0] * e[21] + e[5] * e[19] * e[4] + e[5] * e[1] * e[22] + e[5] * e[2] * e[23] + e[23] * e[1] * e[4] + e[23] * e[0] * e[3] + e[8] * e[18] * e[6] + e[8] * e[0] * e[24] + e[8] * e[19] * e[7] + e[8] * e[1] * e[25] + e[8] * e[2] * e[26] + e[26] * e[1] * e[7] + e[26] * e[0] * e[6] + e[2] * e[18] * e[0] + e[2] * e[19] * e[1] - 1.*e[2] * e[21] * e[3] - 1.*e[2] * e[22] * e[4] - 1.*e[2] * e[25] * e[7] - 1.*e[2] * e[24] * e[6] - .5000000000*e[20] * ep2[4] + .5000000000*e[20] * ep2[0] - .5000000000*e[20] * ep2[6] + .5000000000*e[20] * ep2[5] + .5000000000*e[20] * ep2[1] - .5000000000*e[20] * ep2[7] - .5000000000*e[20] * ep2[3] + 1.500000000*e[20] * ep2[2] + .5000000000*e[20] * ep2[8];
	A[75] = e[14] * e[9] * e[3] + e[14] * e[0] * e[12] + e[14] * e[10] * e[4] + e[14] * e[1] * e[13] + e[14] * e[11] * e[5] + e[17] * e[9] * e[6] + e[17] * e[0] * e[15] + e[17] * e[10] * e[7] + e[17] * e[1] * e[16] + e[17] * e[11] * e[8] + e[8] * e[9] * e[15] + e[8] * e[10] * e[16] + e[5] * e[9] * e[12] + e[5] * e[10] * e[13] + e[11] * e[9] * e[0] + e[11] * e[10] * e[1] - 1.*e[11] * e[13] * e[4] - 1.*e[11] * e[16] * e[7] - 1.*e[11] * e[15] * e[6] - 1.*e[11] * e[12] * e[3] + .5000000000*e[2] * ep2[14] + .5000000000*e[2] * ep2[17] + 1.500000000*e[2] * ep2[11] + .5000000000*e[2] * ep2[9] + .5000000000*e[2] * ep2[10] - .5000000000*e[2] * ep2[16] - .5000000000*e[2] * ep2[12] - .5000000000*e[2] * ep2[15] - .5000000000*e[2] * ep2[13];
	A[74] = e[14] * e[18] * e[12] + e[14] * e[9] * e[21] + e[14] * e[11] * e[23] + e[14] * e[19] * e[13] + e[14] * e[10] * e[22] + e[23] * e[9] * e[12] + e[23] * e[10] * e[13] + e[17] * e[18] * e[15] + e[17] * e[9] * e[24] + e[17] * e[11] * e[26] + e[17] * e[19] * e[16] + e[17] * e[10] * e[25] + e[26] * e[9] * e[15] + e[26] * e[10] * e[16] - 1.*e[11] * e[24] * e[15] - 1.*e[11] * e[25] * e[16] + e[11] * e[18] * e[9] - 1.*e[11] * e[21] * e[12] + e[11] * e[19] * e[10] - 1.*e[11] * e[22] * e[13] + 1.500000000*e[20] * ep2[11] + .5000000000*e[20] * ep2[9] + .5000000000*e[20] * ep2[10] + .5000000000*e[20] * ep2[14] + .5000000000*e[20] * ep2[17] - .5000000000*e[20] * ep2[16] - .5000000000*e[20] * ep2[12] - .5000000000*e[20] * ep2[15] - .5000000000*e[20] * ep2[13];
	A[77] = e[23] * e[10] * e[31] + e[32] * e[18] * e[12] + e[32] * e[9] * e[21] + e[32] * e[19] * e[13] + e[32] * e[10] * e[22] - 1.*e[11] * e[33] * e[24] - 1.*e[11] * e[30] * e[21] + e[11] * e[35] * e[26] - 1.*e[11] * e[31] * e[22] - 1.*e[11] * e[34] * e[25] + e[20] * e[27] * e[9] + e[20] * e[28] * e[10] + e[29] * e[18] * e[9] + e[29] * e[19] * e[10] + e[17] * e[27] * e[24] + e[17] * e[18] * e[33] + e[17] * e[28] * e[25] + e[17] * e[19] * e[34] + e[17] * e[29] * e[26] + e[17] * e[20] * e[35] - 1.*e[20] * e[30] * e[12] - 1.*e[20] * e[31] * e[13] - 1.*e[20] * e[33] * e[15] - 1.*e[20] * e[34] * e[16] - 1.*e[29] * e[24] * e[15] - 1.*e[29] * e[25] * e[16] - 1.*e[29] * e[21] * e[12] - 1.*e[29] * e[22] * e[13] + e[26] * e[27] * e[15] + e[26] * e[9] * e[33] + e[26] * e[28] * e[16] + e[26] * e[10] * e[34] + e[35] * e[18] * e[15] + e[35] * e[9] * e[24] + e[35] * e[19] * e[16] + e[35] * e[10] * e[25] + e[14] * e[27] * e[21] + e[14] * e[18] * e[30] + e[14] * e[28] * e[22] + e[14] * e[19] * e[31] + e[14] * e[29] * e[23] + e[14] * e[20] * e[32] + e[11] * e[27] * e[18] + e[11] * e[28] * e[19] + 3.*e[11] * e[29] * e[20] + e[23] * e[27] * e[12] + e[23] * e[9] * e[30] + e[23] * e[11] * e[32] + e[23] * e[28] * e[13];
	A[76] = e[23] * e[18] * e[12] + e[23] * e[9] * e[21] + e[23] * e[20] * e[14] + e[23] * e[19] * e[13] + e[23] * e[10] * e[22] + e[26] * e[18] * e[15] + e[26] * e[9] * e[24] + e[26] * e[20] * e[17] + e[26] * e[19] * e[16] + e[26] * e[10] * e[25] + e[17] * e[19] * e[25] + e[17] * e[18] * e[24] + e[14] * e[19] * e[22] + e[14] * e[18] * e[21] + e[20] * e[18] * e[9] + e[20] * e[19] * e[10] - 1.*e[20] * e[24] * e[15] - 1.*e[20] * e[25] * e[16] - 1.*e[20] * e[21] * e[12] - 1.*e[20] * e[22] * e[13] + .5000000000*e[11] * ep2[23] + .5000000000*e[11] * ep2[26] + .5000000000*e[11] * ep2[19] + .5000000000*e[11] * ep2[18] + 1.500000000*e[11] * ep2[20] - .5000000000*e[11] * ep2[22] - .5000000000*e[11] * ep2[24] - .5000000000*e[11] * ep2[21] - .5000000000*e[11] * ep2[25];
	A[79] = -1.*e[20] * e[21] * e[3] + e[20] * e[26] * e[8] - 1.*e[20] * e[22] * e[4] - 1.*e[20] * e[25] * e[7] - 1.*e[20] * e[24] * e[6] + e[5] * e[19] * e[22] + e[5] * e[18] * e[21] + e[26] * e[18] * e[6] + e[26] * e[0] * e[24] + e[26] * e[19] * e[7] + e[26] * e[1] * e[25] + e[8] * e[19] * e[25] + e[8] * e[18] * e[24] + e[20] * e[18] * e[0] + e[20] * e[19] * e[1] + e[23] * e[18] * e[3] + e[23] * e[0] * e[21] + e[23] * e[19] * e[4] + e[23] * e[1] * e[22] + e[23] * e[20] * e[5] + 1.500000000*ep2[20] * e[2] + .5000000000*e[2] * ep2[23] + .5000000000*e[2] * ep2[19] + .5000000000*e[2] * ep2[18] + .5000000000*e[2] * ep2[26] - .5000000000*e[2] * ep2[22] - .5000000000*e[2] * ep2[24] - .5000000000*e[2] * ep2[21] - .5000000000*e[2] * ep2[25];
	A[78] = -1.*e[2] * e[15] * e[6] + e[2] * e[9] * e[0] - 1.*e[2] * e[12] * e[3] + e[5] * e[9] * e[3] + e[5] * e[0] * e[12] + e[5] * e[10] * e[4] + e[5] * e[1] * e[13] + e[5] * e[2] * e[14] + e[14] * e[1] * e[4] + e[14] * e[0] * e[3] + e[8] * e[9] * e[6] + e[8] * e[0] * e[15] + e[8] * e[10] * e[7] + e[8] * e[1] * e[16] + e[8] * e[2] * e[17] + e[17] * e[1] * e[7] + e[17] * e[0] * e[6] + e[2] * e[10] * e[1] - 1.*e[2] * e[13] * e[4] - 1.*e[2] * e[16] * e[7] + .5000000000*e[11] * ep2[1] + .5000000000*e[11] * ep2[0] + 1.500000000*e[11] * ep2[2] + .5000000000*e[11] * ep2[5] + .5000000000*e[11] * ep2[8] - .5000000000*e[11] * ep2[4] - .5000000000*e[11] * ep2[6] - .5000000000*e[11] * ep2[7] - .5000000000*e[11] * ep2[3];
	A[64] = e[5] * e[19] * e[13] + e[5] * e[10] * e[22] + e[8] * e[18] * e[15] + e[8] * e[9] * e[24] + e[8] * e[20] * e[17] + e[8] * e[11] * e[26] + e[8] * e[19] * e[16] + e[8] * e[10] * e[25] + e[2] * e[18] * e[9] + e[2] * e[19] * e[10] - 1.*e[11] * e[21] * e[3] - 1.*e[11] * e[22] * e[4] - 1.*e[11] * e[25] * e[7] - 1.*e[11] * e[24] * e[6] + e[14] * e[18] * e[3] + e[14] * e[0] * e[21] + e[14] * e[19] * e[4] + e[14] * e[1] * e[22] + e[14] * e[2] * e[23] - 1.*e[20] * e[13] * e[4] - 1.*e[20] * e[16] * e[7] - 1.*e[20] * e[15] * e[6] - 1.*e[20] * e[12] * e[3] + e[23] * e[9] * e[3] + e[23] * e[0] * e[12] + e[23] * e[10] * e[4] + e[23] * e[1] * e[13] + e[17] * e[18] * e[6] + e[17] * e[0] * e[24] + e[17] * e[19] * e[7] + e[17] * e[1] * e[25] + e[17] * e[2] * e[26] - 1.*e[2] * e[24] * e[15] - 1.*e[2] * e[25] * e[16] - 1.*e[2] * e[21] * e[12] - 1.*e[2] * e[22] * e[13] + e[26] * e[9] * e[6] + e[26] * e[0] * e[15] + e[26] * e[10] * e[7] + e[26] * e[1] * e[16] + e[11] * e[18] * e[0] + e[11] * e[19] * e[1] + 3.*e[11] * e[20] * e[2] + e[20] * e[9] * e[0] + e[20] * e[10] * e[1] + e[5] * e[18] * e[12] + e[5] * e[9] * e[21] + e[5] * e[20] * e[14] + e[5] * e[11] * e[23];
	A[65] = e[32] * e[1] * e[4] + e[32] * e[0] * e[3] + e[8] * e[27] * e[6] + e[8] * e[0] * e[33] + e[8] * e[28] * e[7] + e[8] * e[1] * e[34] + e[35] * e[1] * e[7] + e[35] * e[0] * e[6] + e[2] * e[27] * e[0] + e[2] * e[28] * e[1] - 1.*e[2] * e[34] * e[7] + e[2] * e[32] * e[5] - 1.*e[2] * e[33] * e[6] - 1.*e[2] * e[30] * e[3] + e[2] * e[35] * e[8] - 1.*e[2] * e[31] * e[4] + e[5] * e[27] * e[3] + e[5] * e[0] * e[30] + e[5] * e[28] * e[4] + e[5] * e[1] * e[31] + 1.500000000*e[29] * ep2[2] - .5000000000*e[29] * ep2[4] + .5000000000*e[29] * ep2[0] - .5000000000*e[29] * ep2[6] + .5000000000*e[29] * ep2[5] + .5000000000*e[29] * ep2[1] - .5000000000*e[29] * ep2[7] - .5000000000*e[29] * ep2[3] + .5000000000*e[29] * ep2[8];
	A[66] = e[5] * e[0] * e[3] + e[8] * e[1] * e[7] + e[8] * e[0] * e[6] + e[5] * e[1] * e[4] - .5000000000*e[2] * ep2[4] + .5000000000*ep3[2] + .5000000000*e[2] * ep2[1] - .5000000000*e[2] * ep2[3] + .5000000000*e[2] * ep2[0] + .5000000000*e[2] * ep2[8] + .5000000000*e[2] * ep2[5] - .5000000000*e[2] * ep2[6] - .5000000000*e[2] * ep2[7];
	A[67] = e[35] * e[9] * e[15] + e[35] * e[10] * e[16] - 1.*e[11] * e[30] * e[12] - 1.*e[11] * e[31] * e[13] - 1.*e[11] * e[33] * e[15] - 1.*e[11] * e[34] * e[16] + e[11] * e[27] * e[9] + e[11] * e[28] * e[10] + e[14] * e[27] * e[12] + e[14] * e[9] * e[30] + e[14] * e[11] * e[32] + e[14] * e[28] * e[13] + e[14] * e[10] * e[31] + e[32] * e[9] * e[12] + e[32] * e[10] * e[13] + e[17] * e[27] * e[15] + e[17] * e[9] * e[33] + e[17] * e[11] * e[35] + e[17] * e[28] * e[16] + e[17] * e[10] * e[34] + 1.500000000*e[29] * ep2[11] - .5000000000*e[29] * ep2[16] + .5000000000*e[29] * ep2[9] - .5000000000*e[29] * ep2[12] - .5000000000*e[29] * ep2[15] + .5000000000*e[29] * ep2[17] + .5000000000*e[29] * ep2[10] + .5000000000*e[29] * ep2[14] - .5000000000*e[29] * ep2[13];
	A[68] = e[14] * e[9] * e[12] + e[17] * e[10] * e[16] + e[17] * e[9] * e[15] + .5000000000*ep3[11] + e[14] * e[10] * e[13] + .5000000000*e[11] * ep2[10] - .5000000000*e[11] * ep2[15] + .5000000000*e[11] * ep2[14] - .5000000000*e[11] * ep2[13] - .5000000000*e[11] * ep2[12] + .5000000000*e[11] * ep2[9] - .5000000000*e[11] * ep2[16] + .5000000000*e[11] * ep2[17];
	A[69] = e[20] * e[27] * e[18] + e[20] * e[28] * e[19] + e[23] * e[27] * e[21] + e[23] * e[18] * e[30] + e[23] * e[28] * e[22] + e[23] * e[19] * e[31] + e[23] * e[20] * e[32] + e[32] * e[19] * e[22] + e[32] * e[18] * e[21] + e[26] * e[27] * e[24] + e[26] * e[18] * e[33] + e[26] * e[28] * e[25] + e[26] * e[19] * e[34] + e[26] * e[20] * e[35] + e[35] * e[19] * e[25] + e[35] * e[18] * e[24] - 1.*e[20] * e[33] * e[24] - 1.*e[20] * e[30] * e[21] - 1.*e[20] * e[31] * e[22] - 1.*e[20] * e[34] * e[25] + .5000000000*e[29] * ep2[23] + .5000000000*e[29] * ep2[26] - .5000000000*e[29] * ep2[22] - .5000000000*e[29] * ep2[24] - .5000000000*e[29] * ep2[21] - .5000000000*e[29] * ep2[25] + 1.500000000*e[29] * ep2[20] + .5000000000*e[29] * ep2[19] + .5000000000*e[29] * ep2[18];
	A[70] = .5000000000*e[20] * ep2[26] + .5000000000*e[20] * ep2[18] + .5000000000*ep3[20] + .5000000000*e[20] * ep2[19] + e[26] * e[18] * e[24] + .5000000000*e[20] * ep2[23] - .5000000000*e[20] * ep2[25] + e[23] * e[19] * e[22] - .5000000000*e[20] * ep2[24] - .5000000000*e[20] * ep2[21] - .5000000000*e[20] * ep2[22] + e[23] * e[18] * e[21] + e[26] * e[19] * e[25];
	A[71] = e[8] * e[28] * e[16] + e[8] * e[10] * e[34] + e[2] * e[27] * e[9] + 3.*e[2] * e[29] * e[11] + e[2] * e[28] * e[10] + e[11] * e[27] * e[0] - 1.*e[11] * e[34] * e[7] - 1.*e[11] * e[33] * e[6] - 1.*e[11] * e[30] * e[3] + e[11] * e[28] * e[1] - 1.*e[11] * e[31] * e[4] + e[14] * e[27] * e[3] + e[14] * e[0] * e[30] + e[14] * e[28] * e[4] + e[14] * e[1] * e[31] + e[14] * e[2] * e[32] + e[29] * e[10] * e[1] - 1.*e[29] * e[13] * e[4] - 1.*e[29] * e[16] * e[7] - 1.*e[29] * e[15] * e[6] + e[29] * e[9] * e[0] - 1.*e[29] * e[12] * e[3] + e[32] * e[9] * e[3] + e[32] * e[0] * e[12] + e[32] * e[10] * e[4] + e[32] * e[1] * e[13] + e[17] * e[27] * e[6] + e[17] * e[0] * e[33] + e[17] * e[28] * e[7] + e[17] * e[1] * e[34] + e[17] * e[2] * e[35] - 1.*e[2] * e[30] * e[12] - 1.*e[2] * e[31] * e[13] - 1.*e[2] * e[33] * e[15] - 1.*e[2] * e[34] * e[16] + e[35] * e[9] * e[6] + e[35] * e[0] * e[15] + e[35] * e[10] * e[7] + e[35] * e[1] * e[16] + e[5] * e[27] * e[12] + e[5] * e[9] * e[30] + e[5] * e[29] * e[14] + e[5] * e[11] * e[32] + e[5] * e[28] * e[13] + e[5] * e[10] * e[31] + e[8] * e[27] * e[15] + e[8] * e[9] * e[33] + e[8] * e[29] * e[17] + e[8] * e[11] * e[35];
	A[91] = -1.*e[12] * e[34] * e[7] + e[12] * e[32] * e[5] - 1.*e[12] * e[35] * e[8] - 1.*e[12] * e[29] * e[2] - 1.*e[12] * e[28] * e[1] + e[12] * e[31] * e[4] - 1.*e[30] * e[11] * e[2] - 1.*e[30] * e[10] * e[1] + e[30] * e[13] * e[4] - 1.*e[30] * e[16] * e[7] + e[30] * e[14] * e[5] - 1.*e[30] * e[17] * e[8] + e[15] * e[3] * e[33] + e[15] * e[31] * e[7] + e[15] * e[4] * e[34] + e[15] * e[32] * e[8] + e[15] * e[5] * e[35] + e[3] * e[27] * e[9] - 1.*e[3] * e[28] * e[10] - 1.*e[3] * e[34] * e[16] - 1.*e[3] * e[35] * e[17] - 1.*e[3] * e[29] * e[11] + e[33] * e[13] * e[7] + e[33] * e[4] * e[16] + e[33] * e[14] * e[8] + e[33] * e[5] * e[17] + e[9] * e[28] * e[4] + e[9] * e[1] * e[31] + e[9] * e[29] * e[5] + e[9] * e[2] * e[32] + e[27] * e[10] * e[4] + e[27] * e[1] * e[13] + e[27] * e[11] * e[5] + e[27] * e[2] * e[14] + 3.*e[3] * e[30] * e[12] + e[3] * e[32] * e[14] + e[3] * e[31] * e[13] + e[6] * e[30] * e[15] + e[6] * e[12] * e[33] + e[6] * e[32] * e[17] + e[6] * e[14] * e[35] + e[6] * e[31] * e[16] + e[6] * e[13] * e[34] + e[0] * e[27] * e[12] + e[0] * e[9] * e[30] + e[0] * e[29] * e[14] + e[0] * e[11] * e[32] + e[0] * e[28] * e[13] + e[0] * e[10] * e[31];
	A[90] = .5000000000*e[21] * ep2[24] - .5000000000*e[21] * ep2[25] + .5000000000*e[21] * ep2[23] - .5000000000*e[21] * ep2[26] + .5000000000*ep2[18] * e[21] + .5000000000*e[21] * ep2[22] - .5000000000*e[21] * ep2[20] + e[24] * e[22] * e[25] + e[24] * e[23] * e[26] - .5000000000*e[21] * ep2[19] + e[18] * e[19] * e[22] + e[18] * e[20] * e[23] + .5000000000*ep3[21];
	A[89] = -.5000000000*e[30] * ep2[26] - .5000000000*e[30] * ep2[19] - .5000000000*e[30] * ep2[20] - .5000000000*e[30] * ep2[25] + .5000000000*ep2[18] * e[30] + 1.500000000*e[30] * ep2[21] + .5000000000*e[30] * ep2[22] + .5000000000*e[30] * ep2[23] + .5000000000*e[30] * ep2[24] + e[18] * e[27] * e[21] + e[18] * e[28] * e[22] + e[18] * e[19] * e[31] + e[18] * e[29] * e[23] + e[18] * e[20] * e[32] + e[27] * e[19] * e[22] + e[27] * e[20] * e[23] + e[21] * e[31] * e[22] + e[21] * e[32] * e[23] + e[24] * e[21] * e[33] + e[24] * e[31] * e[25] + e[24] * e[22] * e[34] + e[24] * e[32] * e[26] + e[24] * e[23] * e[35] + e[33] * e[22] * e[25] + e[33] * e[23] * e[26] - 1.*e[21] * e[29] * e[20] - 1.*e[21] * e[35] * e[26] - 1.*e[21] * e[28] * e[19] - 1.*e[21] * e[34] * e[25];
	A[88] = .5000000000*e[12] * ep2[15] - .5000000000*e[12] * ep2[17] + e[15] * e[13] * e[16] - .5000000000*e[12] * ep2[10] + e[15] * e[14] * e[17] - .5000000000*e[12] * ep2[16] - .5000000000*e[12] * ep2[11] + e[9] * e[10] * e[13] + .5000000000*e[12] * ep2[13] + .5000000000*ep2[9] * e[12] + .5000000000*ep3[12] + e[9] * e[11] * e[14] + .5000000000*e[12] * ep2[14];
	A[95] = e[12] * e[13] * e[4] + e[12] * e[14] * e[5] + e[15] * e[12] * e[6] + e[15] * e[13] * e[7] + e[15] * e[4] * e[16] + e[15] * e[14] * e[8] + e[15] * e[5] * e[17] + e[6] * e[14] * e[17] + e[6] * e[13] * e[16] + e[0] * e[11] * e[14] + e[0] * e[9] * e[12] + e[0] * e[10] * e[13] + e[9] * e[10] * e[4] + e[9] * e[1] * e[13] + e[9] * e[11] * e[5] + e[9] * e[2] * e[14] - 1.*e[12] * e[11] * e[2] - 1.*e[12] * e[10] * e[1] - 1.*e[12] * e[16] * e[7] - 1.*e[12] * e[17] * e[8] + 1.500000000*ep2[12] * e[3] + .5000000000*e[3] * ep2[15] - .5000000000*e[3] * ep2[16] + .5000000000*e[3] * ep2[9] - .5000000000*e[3] * ep2[11] - .5000000000*e[3] * ep2[17] - .5000000000*e[3] * ep2[10] + .5000000000*e[3] * ep2[14] + .5000000000*e[3] * ep2[13];
	A[94] = e[18] * e[11] * e[14] + e[18] * e[9] * e[12] + e[18] * e[10] * e[13] + e[12] * e[23] * e[14] + e[12] * e[22] * e[13] + e[15] * e[12] * e[24] + e[15] * e[23] * e[17] + e[15] * e[14] * e[26] + e[15] * e[22] * e[16] + e[15] * e[13] * e[25] + e[24] * e[14] * e[17] + e[24] * e[13] * e[16] - 1.*e[12] * e[25] * e[16] - 1.*e[12] * e[26] * e[17] - 1.*e[12] * e[20] * e[11] - 1.*e[12] * e[19] * e[10] + e[9] * e[20] * e[14] + e[9] * e[11] * e[23] + e[9] * e[19] * e[13] + e[9] * e[10] * e[22] + .5000000000*ep2[9] * e[21] - .5000000000*e[21] * ep2[16] - .5000000000*e[21] * ep2[11] - .5000000000*e[21] * ep2[17] - .5000000000*e[21] * ep2[10] + 1.500000000*e[21] * ep2[12] + .5000000000*e[21] * ep2[14] + .5000000000*e[21] * ep2[13] + .5000000000*e[21] * ep2[15];
	A[93] = -1.*e[21] * e[35] * e[8] - 1.*e[21] * e[29] * e[2] - 1.*e[21] * e[28] * e[1] + e[21] * e[31] * e[4] - 1.*e[30] * e[26] * e[8] - 1.*e[30] * e[20] * e[2] - 1.*e[30] * e[19] * e[1] + e[30] * e[22] * e[4] - 1.*e[30] * e[25] * e[7] + e[30] * e[23] * e[5] + e[6] * e[31] * e[25] + e[6] * e[22] * e[34] + e[6] * e[32] * e[26] + e[6] * e[23] * e[35] + e[24] * e[30] * e[6] + e[24] * e[3] * e[33] + e[24] * e[31] * e[7] + e[24] * e[4] * e[34] + e[24] * e[32] * e[8] + e[24] * e[5] * e[35] + e[33] * e[21] * e[6] + e[33] * e[22] * e[7] + e[33] * e[4] * e[25] + e[33] * e[23] * e[8] + e[33] * e[5] * e[26] + e[0] * e[27] * e[21] + e[0] * e[18] * e[30] + e[0] * e[28] * e[22] + e[0] * e[19] * e[31] + e[0] * e[29] * e[23] + e[0] * e[20] * e[32] + e[18] * e[27] * e[3] + e[18] * e[28] * e[4] + e[18] * e[1] * e[31] + e[18] * e[29] * e[5] + e[18] * e[2] * e[32] + e[27] * e[19] * e[4] + e[27] * e[1] * e[22] + e[27] * e[20] * e[5] + e[27] * e[2] * e[23] + 3.*e[3] * e[30] * e[21] + e[3] * e[31] * e[22] + e[3] * e[32] * e[23] - 1.*e[3] * e[29] * e[20] - 1.*e[3] * e[35] * e[26] - 1.*e[3] * e[28] * e[19] - 1.*e[3] * e[34] * e[25] - 1.*e[21] * e[34] * e[7] + e[21] * e[32] * e[5];
	A[92] = e[18] * e[1] * e[4] + e[18] * e[0] * e[3] + e[18] * e[2] * e[5] + e[3] * e[22] * e[4] + e[3] * e[23] * e[5] + e[6] * e[3] * e[24] + e[6] * e[22] * e[7] + e[6] * e[4] * e[25] + e[6] * e[23] * e[8] + e[6] * e[5] * e[26] + e[24] * e[4] * e[7] + e[24] * e[5] * e[8] + e[0] * e[19] * e[4] + e[0] * e[1] * e[22] + e[0] * e[20] * e[5] + e[0] * e[2] * e[23] - 1.*e[3] * e[26] * e[8] - 1.*e[3] * e[20] * e[2] - 1.*e[3] * e[19] * e[1] - 1.*e[3] * e[25] * e[7] + .5000000000*e[21] * ep2[4] + .5000000000*e[21] * ep2[0] + .5000000000*e[21] * ep2[6] + .5000000000*e[21] * ep2[5] - .5000000000*e[21] * ep2[1] - .5000000000*e[21] * ep2[7] + 1.500000000*e[21] * ep2[3] - .5000000000*e[21] * ep2[2] - .5000000000*e[21] * ep2[8];
	A[82] = .5000000000*ep2[27] * e[21] + 1.500000000*e[21] * ep2[30] + .5000000000*e[21] * ep2[32] + .5000000000*e[21] * ep2[31] + .5000000000*e[21] * ep2[33] - .5000000000*e[21] * ep2[28] - .5000000000*e[21] * ep2[29] - .5000000000*e[21] * ep2[34] - .5000000000*e[21] * ep2[35] + e[18] * e[27] * e[30] + e[18] * e[29] * e[32] + e[18] * e[28] * e[31] + e[27] * e[28] * e[22] + e[27] * e[19] * e[31] + e[27] * e[29] * e[23] + e[27] * e[20] * e[32] + e[30] * e[31] * e[22] + e[30] * e[32] * e[23] + e[24] * e[30] * e[33] + e[24] * e[32] * e[35] + e[24] * e[31] * e[34] + e[33] * e[31] * e[25] + e[33] * e[22] * e[34] + e[33] * e[32] * e[26] + e[33] * e[23] * e[35] - 1.*e[30] * e[29] * e[20] - 1.*e[30] * e[35] * e[26] - 1.*e[30] * e[28] * e[19] - 1.*e[30] * e[34] * e[25];
	A[192] = -.5000000000*e[26] * ep2[4] - .5000000000*e[26] * ep2[0] + .5000000000*e[26] * ep2[6] + .5000000000*e[26] * ep2[5] - .5000000000*e[26] * ep2[1] + .5000000000*e[26] * ep2[7] - .5000000000*e[26] * ep2[3] + .5000000000*e[26] * ep2[2] + 1.500000000*e[26] * ep2[8] + e[20] * e[0] * e[6] + e[20] * e[2] * e[8] + e[5] * e[21] * e[6] + e[5] * e[3] * e[24] + e[5] * e[22] * e[7] + e[5] * e[4] * e[25] + e[5] * e[23] * e[8] + e[23] * e[4] * e[7] + e[23] * e[3] * e[6] + e[8] * e[24] * e[6] + e[8] * e[25] * e[7] + e[2] * e[18] * e[6] + e[2] * e[0] * e[24] + e[2] * e[19] * e[7] + e[2] * e[1] * e[25] - 1.*e[8] * e[21] * e[3] - 1.*e[8] * e[19] * e[1] - 1.*e[8] * e[22] * e[4] - 1.*e[8] * e[18] * e[0] + e[20] * e[1] * e[7];
	A[83] = e[9] * e[27] * e[30] + e[9] * e[29] * e[32] + e[9] * e[28] * e[31] + e[33] * e[30] * e[15] + e[33] * e[32] * e[17] + e[33] * e[14] * e[35] + e[33] * e[31] * e[16] + e[33] * e[13] * e[34] + e[27] * e[29] * e[14] + e[27] * e[11] * e[32] + e[27] * e[28] * e[13] + e[27] * e[10] * e[31] - 1.*e[30] * e[28] * e[10] + e[30] * e[31] * e[13] + e[30] * e[32] * e[14] - 1.*e[30] * e[34] * e[16] - 1.*e[30] * e[35] * e[17] - 1.*e[30] * e[29] * e[11] + e[15] * e[32] * e[35] + e[15] * e[31] * e[34] - .5000000000*e[12] * ep2[34] - .5000000000*e[12] * ep2[35] + .5000000000*e[12] * ep2[27] + .5000000000*e[12] * ep2[32] - .5000000000*e[12] * ep2[28] - .5000000000*e[12] * ep2[29] + .5000000000*e[12] * ep2[31] + .5000000000*e[12] * ep2[33] + 1.500000000*e[12] * ep2[30];
	A[193] = e[23] * e[30] * e[6] + e[23] * e[3] * e[33] + e[23] * e[31] * e[7] + e[23] * e[4] * e[34] + e[32] * e[21] * e[6] + e[32] * e[3] * e[24] + e[32] * e[22] * e[7] + e[32] * e[4] * e[25] + e[26] * e[33] * e[6] + e[26] * e[34] * e[7] + 3.*e[26] * e[35] * e[8] + e[35] * e[24] * e[6] + e[35] * e[25] * e[7] + e[2] * e[27] * e[24] + e[2] * e[18] * e[33] + e[2] * e[28] * e[25] + e[2] * e[19] * e[34] + e[2] * e[29] * e[26] + e[2] * e[20] * e[35] + e[20] * e[27] * e[6] + e[20] * e[0] * e[33] + e[20] * e[28] * e[7] + e[20] * e[1] * e[34] + e[20] * e[29] * e[8] + e[29] * e[18] * e[6] + e[29] * e[0] * e[24] + e[29] * e[19] * e[7] + e[29] * e[1] * e[25] + e[5] * e[30] * e[24] + e[5] * e[21] * e[33] + e[5] * e[31] * e[25] + e[5] * e[22] * e[34] + e[5] * e[32] * e[26] + e[5] * e[23] * e[35] - 1.*e[8] * e[27] * e[18] + e[8] * e[33] * e[24] - 1.*e[8] * e[30] * e[21] - 1.*e[8] * e[31] * e[22] + e[8] * e[32] * e[23] - 1.*e[8] * e[28] * e[19] + e[8] * e[34] * e[25] - 1.*e[26] * e[27] * e[0] - 1.*e[26] * e[30] * e[3] - 1.*e[26] * e[28] * e[1] - 1.*e[26] * e[31] * e[4] - 1.*e[35] * e[21] * e[3] - 1.*e[35] * e[19] * e[1] - 1.*e[35] * e[22] * e[4] - 1.*e[35] * e[18] * e[0];
	A[80] = e[27] * e[29] * e[32] + e[27] * e[28] * e[31] + e[33] * e[32] * e[35] + e[33] * e[31] * e[34] + .5000000000*ep3[30] - .5000000000*e[30] * ep2[28] - .5000000000*e[30] * ep2[29] - .5000000000*e[30] * ep2[34] + .5000000000*e[30] * ep2[33] + .5000000000*ep2[27] * e[30] + .5000000000*e[30] * ep2[32] + .5000000000*e[30] * ep2[31] - .5000000000*e[30] * ep2[35];
	A[194] = .5000000000*ep2[14] * e[26] + 1.500000000*e[26] * ep2[17] + .5000000000*e[26] * ep2[15] + .5000000000*e[26] * ep2[16] + .5000000000*ep2[11] * e[26] - .5000000000*e[26] * ep2[9] - .5000000000*e[26] * ep2[12] - .5000000000*e[26] * ep2[10] - .5000000000*e[26] * ep2[13] + e[20] * e[11] * e[17] + e[20] * e[9] * e[15] + e[20] * e[10] * e[16] + e[14] * e[21] * e[15] + e[14] * e[12] * e[24] + e[14] * e[23] * e[17] + e[14] * e[22] * e[16] + e[14] * e[13] * e[25] + e[23] * e[12] * e[15] + e[23] * e[13] * e[16] + e[17] * e[24] * e[15] + e[17] * e[25] * e[16] - 1.*e[17] * e[18] * e[9] - 1.*e[17] * e[21] * e[12] - 1.*e[17] * e[19] * e[10] - 1.*e[17] * e[22] * e[13] + e[11] * e[18] * e[15] + e[11] * e[9] * e[24] + e[11] * e[19] * e[16] + e[11] * e[10] * e[25];
	A[81] = e[0] * e[27] * e[30] + e[0] * e[29] * e[32] + e[0] * e[28] * e[31] + e[30] * e[31] * e[4] + e[30] * e[32] * e[5] + e[6] * e[30] * e[33] + e[6] * e[32] * e[35] + e[6] * e[31] * e[34] + e[27] * e[28] * e[4] + e[27] * e[1] * e[31] + e[27] * e[29] * e[5] + e[27] * e[2] * e[32] + e[33] * e[31] * e[7] + e[33] * e[4] * e[34] + e[33] * e[32] * e[8] + e[33] * e[5] * e[35] - 1.*e[30] * e[34] * e[7] - 1.*e[30] * e[35] * e[8] - 1.*e[30] * e[29] * e[2] - 1.*e[30] * e[28] * e[1] + 1.500000000*e[3] * ep2[30] + .5000000000*e[3] * ep2[32] + .5000000000*e[3] * ep2[31] + .5000000000*e[3] * ep2[27] - .5000000000*e[3] * ep2[28] - .5000000000*e[3] * ep2[29] + .5000000000*e[3] * ep2[33] - .5000000000*e[3] * ep2[34] - .5000000000*e[3] * ep2[35];
	A[195] = .5000000000*ep2[14] * e[8] + 1.500000000*ep2[17] * e[8] + .5000000000*e[8] * ep2[15] + .5000000000*e[8] * ep2[16] - .5000000000*e[8] * ep2[9] + .5000000000*e[8] * ep2[11] - .5000000000*e[8] * ep2[12] - .5000000000*e[8] * ep2[10] - .5000000000*e[8] * ep2[13] + e[14] * e[12] * e[6] + e[14] * e[3] * e[15] + e[14] * e[13] * e[7] + e[14] * e[4] * e[16] + e[14] * e[5] * e[17] + e[17] * e[15] * e[6] + e[17] * e[16] * e[7] + e[2] * e[11] * e[17] + e[2] * e[9] * e[15] + e[2] * e[10] * e[16] + e[5] * e[12] * e[15] + e[5] * e[13] * e[16] + e[11] * e[9] * e[6] + e[11] * e[0] * e[15] + e[11] * e[10] * e[7] + e[11] * e[1] * e[16] - 1.*e[17] * e[10] * e[1] - 1.*e[17] * e[13] * e[4] - 1.*e[17] * e[9] * e[0] - 1.*e[17] * e[12] * e[3];
	A[86] = -.5000000000*e[3] * ep2[1] - .5000000000*e[3] * ep2[7] + .5000000000*ep3[3] - .5000000000*e[3] * ep2[8] + e[0] * e[2] * e[5] + .5000000000*e[3] * ep2[6] + .5000000000*e[3] * ep2[4] - .5000000000*e[3] * ep2[2] + e[0] * e[1] * e[4] + e[6] * e[4] * e[7] + .5000000000*ep2[0] * e[3] + .5000000000*e[3] * ep2[5] + e[6] * e[5] * e[8];
	A[196] = .5000000000*ep2[23] * e[17] + 1.500000000*ep2[26] * e[17] + .5000000000*e[17] * ep2[25] + .5000000000*e[17] * ep2[24] - .5000000000*e[17] * ep2[18] - .5000000000*e[17] * ep2[19] + .5000000000*e[17] * ep2[20] - .5000000000*e[17] * ep2[22] - .5000000000*e[17] * ep2[21] + e[23] * e[21] * e[15] + e[23] * e[12] * e[24] + e[23] * e[14] * e[26] + e[23] * e[22] * e[16] + e[23] * e[13] * e[25] + e[26] * e[24] * e[15] + e[26] * e[25] * e[16] + e[11] * e[19] * e[25] + e[11] * e[18] * e[24] + e[11] * e[20] * e[26] + e[14] * e[22] * e[25] + e[14] * e[21] * e[24] + e[20] * e[18] * e[15] + e[20] * e[9] * e[24] + e[20] * e[19] * e[16] + e[20] * e[10] * e[25] - 1.*e[26] * e[18] * e[9] - 1.*e[26] * e[21] * e[12] - 1.*e[26] * e[19] * e[10] - 1.*e[26] * e[22] * e[13];
	A[87] = -1.*e[12] * e[34] * e[16] - 1.*e[12] * e[35] * e[17] - 1.*e[12] * e[29] * e[11] + e[9] * e[27] * e[12] + e[9] * e[29] * e[14] + e[9] * e[11] * e[32] + e[9] * e[28] * e[13] + e[9] * e[10] * e[31] + e[27] * e[11] * e[14] + e[27] * e[10] * e[13] + e[12] * e[32] * e[14] + e[12] * e[31] * e[13] + e[15] * e[12] * e[33] + e[15] * e[32] * e[17] + e[15] * e[14] * e[35] + e[15] * e[31] * e[16] + e[15] * e[13] * e[34] + e[33] * e[14] * e[17] + e[33] * e[13] * e[16] - 1.*e[12] * e[28] * e[10] + .5000000000*ep2[9] * e[30] - .5000000000*e[30] * ep2[16] - .5000000000*e[30] * ep2[11] + 1.500000000*e[30] * ep2[12] + .5000000000*e[30] * ep2[15] - .5000000000*e[30] * ep2[17] - .5000000000*e[30] * ep2[10] + .5000000000*e[30] * ep2[14] + .5000000000*e[30] * ep2[13];
	A[197] = e[32] * e[22] * e[16] + e[32] * e[13] * e[25] - 1.*e[17] * e[27] * e[18] + e[17] * e[33] * e[24] - 1.*e[17] * e[30] * e[21] + e[17] * e[29] * e[20] + 3.*e[17] * e[35] * e[26] - 1.*e[17] * e[31] * e[22] - 1.*e[17] * e[28] * e[19] + e[17] * e[34] * e[25] + e[20] * e[27] * e[15] + e[20] * e[9] * e[33] + e[20] * e[28] * e[16] + e[20] * e[10] * e[34] + e[29] * e[18] * e[15] + e[29] * e[9] * e[24] + e[29] * e[19] * e[16] + e[29] * e[10] * e[25] - 1.*e[26] * e[27] * e[9] - 1.*e[26] * e[30] * e[12] - 1.*e[26] * e[28] * e[10] - 1.*e[26] * e[31] * e[13] + e[26] * e[33] * e[15] + e[26] * e[34] * e[16] + e[35] * e[24] * e[15] + e[35] * e[25] * e[16] - 1.*e[35] * e[18] * e[9] - 1.*e[35] * e[21] * e[12] - 1.*e[35] * e[19] * e[10] - 1.*e[35] * e[22] * e[13] + e[14] * e[30] * e[24] + e[14] * e[21] * e[33] + e[14] * e[31] * e[25] + e[14] * e[22] * e[34] + e[14] * e[32] * e[26] + e[14] * e[23] * e[35] + e[11] * e[27] * e[24] + e[11] * e[18] * e[33] + e[11] * e[28] * e[25] + e[11] * e[19] * e[34] + e[11] * e[29] * e[26] + e[11] * e[20] * e[35] + e[23] * e[30] * e[15] + e[23] * e[12] * e[33] + e[23] * e[32] * e[17] + e[23] * e[31] * e[16] + e[23] * e[13] * e[34] + e[32] * e[21] * e[15] + e[32] * e[12] * e[24];
	A[84] = e[6] * e[23] * e[17] + e[6] * e[14] * e[26] + e[6] * e[22] * e[16] + e[6] * e[13] * e[25] + e[0] * e[20] * e[14] + e[0] * e[11] * e[23] + e[0] * e[19] * e[13] + e[0] * e[10] * e[22] - 1.*e[12] * e[26] * e[8] - 1.*e[12] * e[20] * e[2] - 1.*e[12] * e[19] * e[1] + e[12] * e[22] * e[4] - 1.*e[12] * e[25] * e[7] + e[12] * e[23] * e[5] - 1.*e[21] * e[11] * e[2] - 1.*e[21] * e[10] * e[1] + e[21] * e[13] * e[4] - 1.*e[21] * e[16] * e[7] + e[21] * e[14] * e[5] - 1.*e[21] * e[17] * e[8] + e[15] * e[3] * e[24] + e[15] * e[22] * e[7] + e[15] * e[4] * e[25] + e[15] * e[23] * e[8] + e[15] * e[5] * e[26] - 1.*e[3] * e[25] * e[16] - 1.*e[3] * e[26] * e[17] - 1.*e[3] * e[20] * e[11] - 1.*e[3] * e[19] * e[10] + e[24] * e[13] * e[7] + e[24] * e[4] * e[16] + e[24] * e[14] * e[8] + e[24] * e[5] * e[17] + e[9] * e[18] * e[3] + e[9] * e[0] * e[21] + e[9] * e[19] * e[4] + e[9] * e[1] * e[22] + e[9] * e[20] * e[5] + e[9] * e[2] * e[23] + e[18] * e[0] * e[12] + e[18] * e[10] * e[4] + e[18] * e[1] * e[13] + e[18] * e[11] * e[5] + e[18] * e[2] * e[14] + 3.*e[3] * e[21] * e[12] + e[3] * e[23] * e[14] + e[3] * e[22] * e[13] + e[6] * e[21] * e[15] + e[6] * e[12] * e[24];
	A[198] = .5000000000*ep2[5] * e[17] + 1.500000000*e[17] * ep2[8] + .5000000000*e[17] * ep2[7] + .5000000000*e[17] * ep2[6] + .5000000000*ep2[2] * e[17] - .5000000000*e[17] * ep2[4] - .5000000000*e[17] * ep2[0] - .5000000000*e[17] * ep2[1] - .5000000000*e[17] * ep2[3] + e[11] * e[1] * e[7] + e[11] * e[0] * e[6] + e[11] * e[2] * e[8] + e[5] * e[12] * e[6] + e[5] * e[3] * e[15] + e[5] * e[13] * e[7] + e[5] * e[4] * e[16] + e[5] * e[14] * e[8] + e[14] * e[4] * e[7] + e[14] * e[3] * e[6] + e[8] * e[15] * e[6] + e[8] * e[16] * e[7] - 1.*e[8] * e[10] * e[1] - 1.*e[8] * e[13] * e[4] - 1.*e[8] * e[9] * e[0] - 1.*e[8] * e[12] * e[3] + e[2] * e[9] * e[6] + e[2] * e[0] * e[15] + e[2] * e[10] * e[7] + e[2] * e[1] * e[16];
	A[85] = e[6] * e[4] * e[34] + e[6] * e[32] * e[8] + e[6] * e[5] * e[35] + e[33] * e[4] * e[7] + e[33] * e[5] * e[8] + e[0] * e[27] * e[3] + e[0] * e[28] * e[4] + e[0] * e[1] * e[31] + e[0] * e[29] * e[5] + e[0] * e[2] * e[32] - 1.*e[3] * e[34] * e[7] + e[3] * e[32] * e[5] + e[3] * e[33] * e[6] - 1.*e[3] * e[35] * e[8] - 1.*e[3] * e[29] * e[2] - 1.*e[3] * e[28] * e[1] + e[3] * e[31] * e[4] + e[27] * e[1] * e[4] + e[27] * e[2] * e[5] + e[6] * e[31] * e[7] + .5000000000*e[30] * ep2[4] + .5000000000*e[30] * ep2[6] + .5000000000*e[30] * ep2[5] - .5000000000*e[30] * ep2[1] - .5000000000*e[30] * ep2[7] - .5000000000*e[30] * ep2[2] - .5000000000*e[30] * ep2[8] + .5000000000*ep2[0] * e[30] + 1.500000000*e[30] * ep2[3];
	A[199] = .5000000000*ep2[23] * e[8] + 1.500000000*ep2[26] * e[8] - .5000000000*e[8] * ep2[18] - .5000000000*e[8] * ep2[19] - .5000000000*e[8] * ep2[22] + .5000000000*e[8] * ep2[24] - .5000000000*e[8] * ep2[21] + .5000000000*e[8] * ep2[25] + .5000000000*ep2[20] * e[8] + e[20] * e[18] * e[6] + e[20] * e[0] * e[24] + e[20] * e[19] * e[7] + e[20] * e[1] * e[25] + e[20] * e[2] * e[26] + e[23] * e[21] * e[6] + e[23] * e[3] * e[24] + e[23] * e[22] * e[7] + e[23] * e[4] * e[25] + e[23] * e[5] * e[26] - 1.*e[26] * e[21] * e[3] - 1.*e[26] * e[19] * e[1] - 1.*e[26] * e[22] * e[4] - 1.*e[26] * e[18] * e[0] + e[26] * e[25] * e[7] + e[26] * e[24] * e[6] + e[2] * e[19] * e[25] + e[2] * e[18] * e[24] + e[5] * e[22] * e[25] + e[5] * e[21] * e[24];
	A[109] = e[19] * e[27] * e[21] + e[19] * e[18] * e[30] + e[19] * e[28] * e[22] + e[19] * e[29] * e[23] + e[19] * e[20] * e[32] + e[28] * e[18] * e[21] + e[28] * e[20] * e[23] + e[22] * e[30] * e[21] + e[22] * e[32] * e[23] + e[25] * e[30] * e[24] + e[25] * e[21] * e[33] + e[25] * e[22] * e[34] + e[25] * e[32] * e[26] + e[25] * e[23] * e[35] + e[34] * e[21] * e[24] + e[34] * e[23] * e[26] - 1.*e[22] * e[27] * e[18] - 1.*e[22] * e[33] * e[24] - 1.*e[22] * e[29] * e[20] - 1.*e[22] * e[35] * e[26] + .5000000000*ep2[19] * e[31] + 1.500000000*e[31] * ep2[22] + .5000000000*e[31] * ep2[21] + .5000000000*e[31] * ep2[23] + .5000000000*e[31] * ep2[25] - .5000000000*e[31] * ep2[26] - .5000000000*e[31] * ep2[18] - .5000000000*e[31] * ep2[20] - .5000000000*e[31] * ep2[24];
	A[108] = -.5000000000*e[13] * ep2[15] + .5000000000*e[13] * ep2[16] + .5000000000*e[13] * ep2[12] + e[16] * e[12] * e[15] + .5000000000*ep3[13] + e[10] * e[11] * e[14] + .5000000000*e[13] * ep2[14] - .5000000000*e[13] * ep2[17] - .5000000000*e[13] * ep2[11] - .5000000000*e[13] * ep2[9] + .5000000000*ep2[10] * e[13] + e[10] * e[9] * e[12] + e[16] * e[14] * e[17];
	A[111] = -1.*e[13] * e[29] * e[2] - 1.*e[31] * e[11] * e[2] - 1.*e[31] * e[15] * e[6] - 1.*e[31] * e[9] * e[0] + e[31] * e[14] * e[5] + e[31] * e[12] * e[3] - 1.*e[31] * e[17] * e[8] + e[16] * e[30] * e[6] + e[16] * e[3] * e[33] + e[16] * e[4] * e[34] + e[16] * e[32] * e[8] + e[16] * e[5] * e[35] - 1.*e[4] * e[27] * e[9] + e[4] * e[28] * e[10] - 1.*e[4] * e[33] * e[15] - 1.*e[4] * e[35] * e[17] - 1.*e[4] * e[29] * e[11] + e[34] * e[12] * e[6] + e[34] * e[3] * e[15] + e[34] * e[14] * e[8] + e[34] * e[5] * e[17] + e[10] * e[27] * e[3] + e[10] * e[0] * e[30] + e[10] * e[29] * e[5] + e[10] * e[2] * e[32] + e[28] * e[9] * e[3] + e[28] * e[0] * e[12] + e[28] * e[11] * e[5] + e[28] * e[2] * e[14] + e[4] * e[30] * e[12] + e[4] * e[32] * e[14] + 3.*e[4] * e[31] * e[13] + e[7] * e[30] * e[15] + e[7] * e[12] * e[33] + e[7] * e[32] * e[17] + e[7] * e[14] * e[35] + e[7] * e[31] * e[16] + e[7] * e[13] * e[34] + e[1] * e[27] * e[12] + e[1] * e[9] * e[30] + e[1] * e[29] * e[14] + e[1] * e[11] * e[32] + e[1] * e[28] * e[13] + e[1] * e[10] * e[31] - 1.*e[13] * e[27] * e[0] + e[13] * e[32] * e[5] - 1.*e[13] * e[33] * e[6] + e[13] * e[30] * e[3] - 1.*e[13] * e[35] * e[8];
	A[110] = e[25] * e[23] * e[26] + e[19] * e[20] * e[23] + e[19] * e[18] * e[21] + e[25] * e[21] * e[24] + .5000000000*ep3[22] + .5000000000*e[22] * ep2[23] + .5000000000*ep2[19] * e[22] - .5000000000*e[22] * ep2[18] - .5000000000*e[22] * ep2[24] + .5000000000*e[22] * ep2[21] + .5000000000*e[22] * ep2[25] - .5000000000*e[22] * ep2[20] - .5000000000*e[22] * ep2[26];
	A[105] = e[34] * e[5] * e[8] + e[1] * e[27] * e[3] + e[1] * e[0] * e[30] + e[1] * e[28] * e[4] + e[1] * e[29] * e[5] + e[1] * e[2] * e[32] - 1.*e[4] * e[27] * e[0] + e[4] * e[34] * e[7] + e[4] * e[32] * e[5] - 1.*e[4] * e[33] * e[6] + e[4] * e[30] * e[3] - 1.*e[4] * e[35] * e[8] - 1.*e[4] * e[29] * e[2] + e[28] * e[0] * e[3] + e[28] * e[2] * e[5] + e[7] * e[30] * e[6] + e[7] * e[3] * e[33] + e[7] * e[32] * e[8] + e[7] * e[5] * e[35] + e[34] * e[3] * e[6] + .5000000000*ep2[1] * e[31] + 1.500000000*e[31] * ep2[4] - .5000000000*e[31] * ep2[0] - .5000000000*e[31] * ep2[6] + .5000000000*e[31] * ep2[5] + .5000000000*e[31] * ep2[7] + .5000000000*e[31] * ep2[3] - .5000000000*e[31] * ep2[2] - .5000000000*e[31] * ep2[8];
	A[104] = e[1] * e[20] * e[14] + e[1] * e[11] * e[23] + e[13] * e[21] * e[3] - 1.*e[13] * e[26] * e[8] - 1.*e[13] * e[20] * e[2] - 1.*e[13] * e[18] * e[0] + e[13] * e[23] * e[5] - 1.*e[13] * e[24] * e[6] - 1.*e[22] * e[11] * e[2] - 1.*e[22] * e[15] * e[6] - 1.*e[22] * e[9] * e[0] + e[22] * e[14] * e[5] + e[22] * e[12] * e[3] - 1.*e[22] * e[17] * e[8] + e[16] * e[21] * e[6] + e[16] * e[3] * e[24] + e[16] * e[4] * e[25] + e[16] * e[23] * e[8] + e[16] * e[5] * e[26] - 1.*e[4] * e[24] * e[15] - 1.*e[4] * e[26] * e[17] - 1.*e[4] * e[20] * e[11] - 1.*e[4] * e[18] * e[9] + e[25] * e[12] * e[6] + e[25] * e[3] * e[15] + e[25] * e[14] * e[8] + e[25] * e[5] * e[17] + e[10] * e[18] * e[3] + e[10] * e[0] * e[21] + e[10] * e[19] * e[4] + e[10] * e[1] * e[22] + e[10] * e[20] * e[5] + e[10] * e[2] * e[23] + e[19] * e[9] * e[3] + e[19] * e[0] * e[12] + e[19] * e[1] * e[13] + e[19] * e[11] * e[5] + e[19] * e[2] * e[14] + e[4] * e[21] * e[12] + e[4] * e[23] * e[14] + 3.*e[4] * e[22] * e[13] + e[7] * e[21] * e[15] + e[7] * e[12] * e[24] + e[7] * e[23] * e[17] + e[7] * e[14] * e[26] + e[7] * e[22] * e[16] + e[7] * e[13] * e[25] + e[1] * e[18] * e[12] + e[1] * e[9] * e[21];
	A[107] = e[10] * e[27] * e[12] + e[10] * e[9] * e[30] + e[10] * e[29] * e[14] + e[10] * e[11] * e[32] + e[10] * e[28] * e[13] + e[28] * e[11] * e[14] + e[28] * e[9] * e[12] + e[13] * e[30] * e[12] + e[13] * e[32] * e[14] + e[16] * e[30] * e[15] + e[16] * e[12] * e[33] + e[16] * e[32] * e[17] + e[16] * e[14] * e[35] + e[16] * e[13] * e[34] + e[34] * e[14] * e[17] + e[34] * e[12] * e[15] - 1.*e[13] * e[27] * e[9] - 1.*e[13] * e[33] * e[15] - 1.*e[13] * e[35] * e[17] - 1.*e[13] * e[29] * e[11] + .5000000000*ep2[10] * e[31] + .5000000000*e[31] * ep2[16] - .5000000000*e[31] * ep2[9] - .5000000000*e[31] * ep2[11] + .5000000000*e[31] * ep2[12] - .5000000000*e[31] * ep2[15] - .5000000000*e[31] * ep2[17] + .5000000000*e[31] * ep2[14] + 1.500000000*e[31] * ep2[13];
	A[106] = -.5000000000*e[4] * ep2[6] - .5000000000*e[4] * ep2[0] + e[1] * e[2] * e[5] + .5000000000*e[4] * ep2[7] + e[1] * e[0] * e[3] + e[7] * e[5] * e[8] - .5000000000*e[4] * ep2[8] + .5000000000*e[4] * ep2[3] + .5000000000*e[4] * ep2[5] + e[7] * e[3] * e[6] - .5000000000*e[4] * ep2[2] + .5000000000*ep3[4] + .5000000000*ep2[1] * e[4];
	A[100] = e[34] * e[32] * e[35] - .5000000000*e[31] * ep2[35] + .5000000000*e[31] * ep2[34] + .5000000000*ep2[28] * e[31] + .5000000000*ep3[31] + .5000000000*e[31] * ep2[32] + e[34] * e[30] * e[33] - .5000000000*e[31] * ep2[27] + .5000000000*e[31] * ep2[30] - .5000000000*e[31] * ep2[33] - .5000000000*e[31] * ep2[29] + e[28] * e[29] * e[32] + e[28] * e[27] * e[30];
	A[101] = e[1] * e[27] * e[30] + e[1] * e[29] * e[32] + e[1] * e[28] * e[31] + e[31] * e[30] * e[3] + e[31] * e[32] * e[5] + e[7] * e[30] * e[33] + e[7] * e[32] * e[35] + e[7] * e[31] * e[34] + e[28] * e[27] * e[3] + e[28] * e[0] * e[30] + e[28] * e[29] * e[5] + e[28] * e[2] * e[32] + e[34] * e[30] * e[6] + e[34] * e[3] * e[33] + e[34] * e[32] * e[8] + e[34] * e[5] * e[35] - 1.*e[31] * e[27] * e[0] - 1.*e[31] * e[33] * e[6] - 1.*e[31] * e[35] * e[8] - 1.*e[31] * e[29] * e[2] + .5000000000*e[4] * ep2[30] + .5000000000*e[4] * ep2[32] + 1.500000000*e[4] * ep2[31] - .5000000000*e[4] * ep2[27] + .5000000000*e[4] * ep2[28] - .5000000000*e[4] * ep2[29] - .5000000000*e[4] * ep2[33] + .5000000000*e[4] * ep2[34] - .5000000000*e[4] * ep2[35];
	A[102] = .5000000000*e[22] * ep2[30] + .5000000000*e[22] * ep2[32] + 1.500000000*e[22] * ep2[31] + .5000000000*e[22] * ep2[34] - .5000000000*e[22] * ep2[27] - .5000000000*e[22] * ep2[29] - .5000000000*e[22] * ep2[33] - .5000000000*e[22] * ep2[35] + e[28] * e[18] * e[30] + e[28] * e[29] * e[23] + e[28] * e[20] * e[32] + e[31] * e[30] * e[21] + e[31] * e[32] * e[23] + e[25] * e[30] * e[33] + e[25] * e[32] * e[35] + e[25] * e[31] * e[34] + e[34] * e[30] * e[24] + e[34] * e[21] * e[33] + e[34] * e[32] * e[26] + e[34] * e[23] * e[35] - 1.*e[31] * e[27] * e[18] - 1.*e[31] * e[33] * e[24] - 1.*e[31] * e[29] * e[20] - 1.*e[31] * e[35] * e[26] + e[19] * e[27] * e[30] + e[19] * e[29] * e[32] + e[19] * e[28] * e[31] + e[28] * e[27] * e[21] + .5000000000*ep2[28] * e[22];
	A[103] = e[16] * e[30] * e[33] + e[16] * e[32] * e[35] + e[10] * e[27] * e[30] + e[10] * e[29] * e[32] + e[10] * e[28] * e[31] + e[34] * e[30] * e[15] + e[34] * e[12] * e[33] + e[34] * e[32] * e[17] + e[34] * e[14] * e[35] + e[34] * e[31] * e[16] + e[28] * e[27] * e[12] + e[28] * e[9] * e[30] + e[28] * e[29] * e[14] + e[28] * e[11] * e[32] - 1.*e[31] * e[27] * e[9] + e[31] * e[30] * e[12] + e[31] * e[32] * e[14] - 1.*e[31] * e[33] * e[15] - 1.*e[31] * e[35] * e[17] - 1.*e[31] * e[29] * e[11] - .5000000000*e[13] * ep2[27] + .5000000000*e[13] * ep2[32] + .5000000000*e[13] * ep2[28] - .5000000000*e[13] * ep2[29] + 1.500000000*e[13] * ep2[31] - .5000000000*e[13] * ep2[33] + .5000000000*e[13] * ep2[30] + .5000000000*e[13] * ep2[34] - .5000000000*e[13] * ep2[35];
	A[96] = e[21] * e[23] * e[14] + e[21] * e[22] * e[13] + e[24] * e[21] * e[15] + e[24] * e[23] * e[17] + e[24] * e[14] * e[26] + e[24] * e[22] * e[16] + e[24] * e[13] * e[25] + e[15] * e[22] * e[25] + e[15] * e[23] * e[26] + e[9] * e[19] * e[22] + e[9] * e[18] * e[21] + e[9] * e[20] * e[23] + e[18] * e[20] * e[14] + e[18] * e[11] * e[23] + e[18] * e[19] * e[13] + e[18] * e[10] * e[22] - 1.*e[21] * e[25] * e[16] - 1.*e[21] * e[26] * e[17] - 1.*e[21] * e[20] * e[11] - 1.*e[21] * e[19] * e[10] + 1.500000000*ep2[21] * e[12] + .5000000000*e[12] * ep2[24] - .5000000000*e[12] * ep2[26] + .5000000000*e[12] * ep2[18] + .5000000000*e[12] * ep2[23] - .5000000000*e[12] * ep2[19] - .5000000000*e[12] * ep2[20] + .5000000000*e[12] * ep2[22] - .5000000000*e[12] * ep2[25];
	A[97] = -1.*e[12] * e[29] * e[20] - 1.*e[12] * e[35] * e[26] - 1.*e[12] * e[28] * e[19] - 1.*e[12] * e[34] * e[25] + e[18] * e[29] * e[14] + e[18] * e[11] * e[32] + e[18] * e[28] * e[13] + e[18] * e[10] * e[31] + e[27] * e[20] * e[14] + e[27] * e[11] * e[23] + e[27] * e[19] * e[13] + e[27] * e[10] * e[22] + e[15] * e[30] * e[24] + e[15] * e[21] * e[33] + e[15] * e[31] * e[25] + e[15] * e[22] * e[34] + e[15] * e[32] * e[26] + e[15] * e[23] * e[35] - 1.*e[21] * e[28] * e[10] - 1.*e[21] * e[34] * e[16] - 1.*e[21] * e[35] * e[17] - 1.*e[21] * e[29] * e[11] - 1.*e[30] * e[25] * e[16] - 1.*e[30] * e[26] * e[17] - 1.*e[30] * e[20] * e[11] - 1.*e[30] * e[19] * e[10] + e[24] * e[32] * e[17] + e[24] * e[14] * e[35] + e[24] * e[31] * e[16] + e[24] * e[13] * e[34] + e[33] * e[23] * e[17] + e[33] * e[14] * e[26] + e[33] * e[22] * e[16] + e[33] * e[13] * e[25] + 3.*e[12] * e[30] * e[21] + e[12] * e[31] * e[22] + e[12] * e[32] * e[23] + e[9] * e[27] * e[21] + e[9] * e[18] * e[30] + e[9] * e[28] * e[22] + e[9] * e[19] * e[31] + e[9] * e[29] * e[23] + e[9] * e[20] * e[32] + e[21] * e[32] * e[14] + e[21] * e[31] * e[13] + e[30] * e[23] * e[14] + e[30] * e[22] * e[13] + e[12] * e[27] * e[18] + e[12] * e[33] * e[24];
	A[98] = e[0] * e[11] * e[5] + e[0] * e[2] * e[14] + e[9] * e[1] * e[4] + e[9] * e[0] * e[3] + e[9] * e[2] * e[5] + e[3] * e[13] * e[4] + e[3] * e[14] * e[5] + e[6] * e[3] * e[15] + e[6] * e[13] * e[7] + e[6] * e[4] * e[16] + e[6] * e[14] * e[8] + e[6] * e[5] * e[17] + e[15] * e[4] * e[7] + e[15] * e[5] * e[8] - 1.*e[3] * e[11] * e[2] - 1.*e[3] * e[10] * e[1] - 1.*e[3] * e[16] * e[7] - 1.*e[3] * e[17] * e[8] + e[0] * e[10] * e[4] + e[0] * e[1] * e[13] + 1.500000000*e[12] * ep2[3] + .5000000000*e[12] * ep2[4] + .5000000000*e[12] * ep2[5] + .5000000000*e[12] * ep2[6] + .5000000000*ep2[0] * e[12] - .5000000000*e[12] * ep2[1] - .5000000000*e[12] * ep2[7] - .5000000000*e[12] * ep2[2] - .5000000000*e[12] * ep2[8];
	A[99] = e[21] * e[24] * e[6] + e[0] * e[19] * e[22] + e[0] * e[20] * e[23] + e[24] * e[22] * e[7] + e[24] * e[4] * e[25] + e[24] * e[23] * e[8] + e[24] * e[5] * e[26] + e[6] * e[22] * e[25] + e[6] * e[23] * e[26] + e[18] * e[0] * e[21] + e[18] * e[19] * e[4] + e[18] * e[1] * e[22] + e[18] * e[20] * e[5] + e[18] * e[2] * e[23] + e[21] * e[22] * e[4] + e[21] * e[23] * e[5] - 1.*e[21] * e[26] * e[8] - 1.*e[21] * e[20] * e[2] - 1.*e[21] * e[19] * e[1] - 1.*e[21] * e[25] * e[7] + 1.500000000*ep2[21] * e[3] + .5000000000*e[3] * ep2[22] + .5000000000*e[3] * ep2[23] + .5000000000*e[3] * ep2[24] - .5000000000*e[3] * ep2[26] - .5000000000*e[3] * ep2[19] - .5000000000*e[3] * ep2[20] - .5000000000*e[3] * ep2[25] + .5000000000*ep2[18] * e[3];
	A[127] = e[11] * e[27] * e[12] + e[11] * e[9] * e[30] + e[11] * e[29] * e[14] + e[11] * e[28] * e[13] + e[11] * e[10] * e[31] + e[29] * e[9] * e[12] + e[29] * e[10] * e[13] + e[14] * e[30] * e[12] + e[14] * e[31] * e[13] + e[17] * e[30] * e[15] + e[17] * e[12] * e[33] + e[17] * e[14] * e[35] + e[17] * e[31] * e[16] + e[17] * e[13] * e[34] + e[35] * e[12] * e[15] + e[35] * e[13] * e[16] - 1.*e[14] * e[27] * e[9] - 1.*e[14] * e[28] * e[10] - 1.*e[14] * e[33] * e[15] - 1.*e[14] * e[34] * e[16] + .5000000000*ep2[11] * e[32] - .5000000000*e[32] * ep2[16] - .5000000000*e[32] * ep2[9] + .5000000000*e[32] * ep2[12] - .5000000000*e[32] * ep2[15] + .5000000000*e[32] * ep2[17] - .5000000000*e[32] * ep2[10] + 1.500000000*e[32] * ep2[14] + .5000000000*e[32] * ep2[13];
	A[126] = e[8] * e[3] * e[6] + .5000000000*ep2[2] * e[5] - .5000000000*e[5] * ep2[0] + .5000000000*e[5] * ep2[4] - .5000000000*e[5] * ep2[6] + .5000000000*e[5] * ep2[8] + e[8] * e[4] * e[7] + .5000000000*ep3[5] + e[2] * e[0] * e[3] + .5000000000*e[5] * ep2[3] - .5000000000*e[5] * ep2[7] + e[2] * e[1] * e[4] - .5000000000*e[5] * ep2[1];
	A[125] = e[2] * e[27] * e[3] + e[2] * e[0] * e[30] + e[2] * e[28] * e[4] + e[2] * e[1] * e[31] + e[2] * e[29] * e[5] - 1.*e[5] * e[27] * e[0] - 1.*e[5] * e[34] * e[7] - 1.*e[5] * e[33] * e[6] + e[5] * e[30] * e[3] + e[5] * e[35] * e[8] - 1.*e[5] * e[28] * e[1] + e[5] * e[31] * e[4] + e[29] * e[1] * e[4] + e[29] * e[0] * e[3] + e[8] * e[30] * e[6] + e[8] * e[3] * e[33] + e[8] * e[31] * e[7] + e[8] * e[4] * e[34] + e[35] * e[4] * e[7] + e[35] * e[3] * e[6] + .5000000000*ep2[2] * e[32] + 1.500000000*e[32] * ep2[5] + .5000000000*e[32] * ep2[4] - .5000000000*e[32] * ep2[0] - .5000000000*e[32] * ep2[6] - .5000000000*e[32] * ep2[1] - .5000000000*e[32] * ep2[7] + .5000000000*e[32] * ep2[3] + .5000000000*e[32] * ep2[8];
	A[124] = -1.*e[14] * e[19] * e[1] + e[14] * e[22] * e[4] - 1.*e[14] * e[18] * e[0] - 1.*e[14] * e[25] * e[7] - 1.*e[14] * e[24] * e[6] - 1.*e[23] * e[10] * e[1] + e[23] * e[13] * e[4] - 1.*e[23] * e[16] * e[7] - 1.*e[23] * e[15] * e[6] - 1.*e[23] * e[9] * e[0] + e[23] * e[12] * e[3] + e[17] * e[21] * e[6] + e[17] * e[3] * e[24] + e[17] * e[22] * e[7] + e[17] * e[4] * e[25] + e[17] * e[5] * e[26] - 1.*e[5] * e[24] * e[15] - 1.*e[5] * e[25] * e[16] - 1.*e[5] * e[18] * e[9] - 1.*e[5] * e[19] * e[10] + e[26] * e[12] * e[6] + e[26] * e[3] * e[15] + e[26] * e[13] * e[7] + e[26] * e[4] * e[16] + e[11] * e[18] * e[3] + e[11] * e[0] * e[21] + e[11] * e[19] * e[4] + e[11] * e[1] * e[22] + e[11] * e[20] * e[5] + e[11] * e[2] * e[23] + e[20] * e[9] * e[3] + e[20] * e[0] * e[12] + e[20] * e[10] * e[4] + e[20] * e[1] * e[13] + e[20] * e[2] * e[14] + e[5] * e[21] * e[12] + 3.*e[5] * e[23] * e[14] + e[5] * e[22] * e[13] + e[8] * e[21] * e[15] + e[8] * e[12] * e[24] + e[8] * e[23] * e[17] + e[8] * e[14] * e[26] + e[8] * e[22] * e[16] + e[8] * e[13] * e[25] + e[2] * e[18] * e[12] + e[2] * e[9] * e[21] + e[2] * e[19] * e[13] + e[2] * e[10] * e[22] + e[14] * e[21] * e[3];
	A[123] = -.5000000000*e[14] * ep2[27] + 1.500000000*e[14] * ep2[32] - .5000000000*e[14] * ep2[28] + .5000000000*e[14] * ep2[29] + .5000000000*e[14] * ep2[31] - .5000000000*e[14] * ep2[33] + .5000000000*e[14] * ep2[30] - .5000000000*e[14] * ep2[34] + .5000000000*e[14] * ep2[35] + e[11] * e[27] * e[30] + e[11] * e[29] * e[32] + e[11] * e[28] * e[31] + e[35] * e[30] * e[15] + e[35] * e[12] * e[33] + e[35] * e[32] * e[17] + e[35] * e[31] * e[16] + e[35] * e[13] * e[34] + e[29] * e[27] * e[12] + e[29] * e[9] * e[30] + e[29] * e[28] * e[13] + e[29] * e[10] * e[31] - 1.*e[32] * e[27] * e[9] + e[32] * e[30] * e[12] - 1.*e[32] * e[28] * e[10] + e[32] * e[31] * e[13] - 1.*e[32] * e[33] * e[15] - 1.*e[32] * e[34] * e[16] + e[17] * e[30] * e[33] + e[17] * e[31] * e[34];
	A[122] = -.5000000000*e[23] * ep2[33] - .5000000000*e[23] * ep2[34] + .5000000000*ep2[29] * e[23] + .5000000000*e[23] * ep2[30] + 1.500000000*e[23] * ep2[32] + .5000000000*e[23] * ep2[31] + .5000000000*e[23] * ep2[35] - .5000000000*e[23] * ep2[27] - .5000000000*e[23] * ep2[28] + e[32] * e[30] * e[21] + e[32] * e[31] * e[22] + e[26] * e[30] * e[33] + e[26] * e[32] * e[35] + e[26] * e[31] * e[34] + e[35] * e[30] * e[24] + e[35] * e[21] * e[33] + e[35] * e[31] * e[25] + e[35] * e[22] * e[34] - 1.*e[32] * e[27] * e[18] - 1.*e[32] * e[33] * e[24] - 1.*e[32] * e[28] * e[19] - 1.*e[32] * e[34] * e[25] + e[20] * e[27] * e[30] + e[20] * e[29] * e[32] + e[20] * e[28] * e[31] + e[29] * e[27] * e[21] + e[29] * e[18] * e[30] + e[29] * e[28] * e[22] + e[29] * e[19] * e[31];
	A[121] = e[2] * e[27] * e[30] + e[2] * e[29] * e[32] + e[2] * e[28] * e[31] + e[32] * e[30] * e[3] + e[32] * e[31] * e[4] + e[8] * e[30] * e[33] + e[8] * e[32] * e[35] + e[8] * e[31] * e[34] + e[29] * e[27] * e[3] + e[29] * e[0] * e[30] + e[29] * e[28] * e[4] + e[29] * e[1] * e[31] + e[35] * e[30] * e[6] + e[35] * e[3] * e[33] + e[35] * e[31] * e[7] + e[35] * e[4] * e[34] - 1.*e[32] * e[27] * e[0] - 1.*e[32] * e[34] * e[7] - 1.*e[32] * e[33] * e[6] - 1.*e[32] * e[28] * e[1] + .5000000000*e[5] * ep2[30] + 1.500000000*e[5] * ep2[32] + .5000000000*e[5] * ep2[31] - .5000000000*e[5] * ep2[27] - .5000000000*e[5] * ep2[28] + .5000000000*e[5] * ep2[29] - .5000000000*e[5] * ep2[33] - .5000000000*e[5] * ep2[34] + .5000000000*e[5] * ep2[35];
	A[120] = .5000000000*e[32] * ep2[31] + .5000000000*e[32] * ep2[35] - .5000000000*e[32] * ep2[27] + e[29] * e[27] * e[30] + e[29] * e[28] * e[31] + e[35] * e[30] * e[33] + e[35] * e[31] * e[34] + .5000000000*ep2[29] * e[32] + .5000000000*ep3[32] - .5000000000*e[32] * ep2[33] - .5000000000*e[32] * ep2[34] + .5000000000*e[32] * ep2[30] - .5000000000*e[32] * ep2[28];
	A[118] = e[10] * e[1] * e[4] + e[10] * e[0] * e[3] + e[10] * e[2] * e[5] + e[4] * e[12] * e[3] + e[4] * e[14] * e[5] + e[7] * e[12] * e[6] + e[7] * e[3] * e[15] + e[7] * e[4] * e[16] + e[7] * e[14] * e[8] + e[7] * e[5] * e[17] + e[16] * e[3] * e[6] + e[16] * e[5] * e[8] - 1.*e[4] * e[11] * e[2] - 1.*e[4] * e[15] * e[6] - 1.*e[4] * e[9] * e[0] - 1.*e[4] * e[17] * e[8] + e[1] * e[9] * e[3] + e[1] * e[0] * e[12] + e[1] * e[11] * e[5] + e[1] * e[2] * e[14] + 1.500000000*e[13] * ep2[4] + .5000000000*e[13] * ep2[3] + .5000000000*e[13] * ep2[5] + .5000000000*e[13] * ep2[7] + .5000000000*ep2[1] * e[13] - .5000000000*e[13] * ep2[0] - .5000000000*e[13] * ep2[6] - .5000000000*e[13] * ep2[2] - .5000000000*e[13] * ep2[8];
	A[119] = e[25] * e[21] * e[6] + e[25] * e[3] * e[24] + e[25] * e[23] * e[8] + e[25] * e[5] * e[26] + e[7] * e[21] * e[24] + e[7] * e[23] * e[26] + e[19] * e[18] * e[3] + e[19] * e[0] * e[21] + e[19] * e[1] * e[22] + e[19] * e[20] * e[5] + e[19] * e[2] * e[23] + e[22] * e[21] * e[3] + e[22] * e[23] * e[5] - 1.*e[22] * e[26] * e[8] - 1.*e[22] * e[20] * e[2] - 1.*e[22] * e[18] * e[0] + e[22] * e[25] * e[7] - 1.*e[22] * e[24] * e[6] + e[1] * e[18] * e[21] + e[1] * e[20] * e[23] + .5000000000*e[4] * ep2[25] - .5000000000*e[4] * ep2[26] - .5000000000*e[4] * ep2[18] - .5000000000*e[4] * ep2[20] - .5000000000*e[4] * ep2[24] + .5000000000*ep2[19] * e[4] + 1.500000000*ep2[22] * e[4] + .5000000000*e[4] * ep2[21] + .5000000000*e[4] * ep2[23];
	A[116] = e[22] * e[21] * e[12] + e[22] * e[23] * e[14] + e[25] * e[21] * e[15] + e[25] * e[12] * e[24] + e[25] * e[23] * e[17] + e[25] * e[14] * e[26] + e[25] * e[22] * e[16] + e[16] * e[21] * e[24] + e[16] * e[23] * e[26] + e[10] * e[19] * e[22] + e[10] * e[18] * e[21] + e[10] * e[20] * e[23] + e[19] * e[18] * e[12] + e[19] * e[9] * e[21] + e[19] * e[20] * e[14] + e[19] * e[11] * e[23] - 1.*e[22] * e[24] * e[15] - 1.*e[22] * e[26] * e[17] - 1.*e[22] * e[20] * e[11] - 1.*e[22] * e[18] * e[9] - .5000000000*e[13] * ep2[26] - .5000000000*e[13] * ep2[18] + .5000000000*e[13] * ep2[23] + .5000000000*e[13] * ep2[19] - .5000000000*e[13] * ep2[20] - .5000000000*e[13] * ep2[24] + .5000000000*e[13] * ep2[21] + 1.500000000*ep2[22] * e[13] + .5000000000*e[13] * ep2[25];
	A[117] = e[13] * e[30] * e[21] + 3.*e[13] * e[31] * e[22] + e[13] * e[32] * e[23] + e[10] * e[27] * e[21] + e[10] * e[18] * e[30] + e[10] * e[28] * e[22] + e[10] * e[19] * e[31] + e[10] * e[29] * e[23] + e[10] * e[20] * e[32] + e[22] * e[30] * e[12] + e[22] * e[32] * e[14] + e[31] * e[21] * e[12] + e[31] * e[23] * e[14] - 1.*e[13] * e[27] * e[18] - 1.*e[13] * e[33] * e[24] - 1.*e[13] * e[29] * e[20] - 1.*e[13] * e[35] * e[26] + e[13] * e[28] * e[19] + e[13] * e[34] * e[25] + e[19] * e[27] * e[12] + e[19] * e[9] * e[30] + e[19] * e[29] * e[14] + e[19] * e[11] * e[32] + e[28] * e[18] * e[12] + e[28] * e[9] * e[21] + e[28] * e[20] * e[14] + e[28] * e[11] * e[23] + e[16] * e[30] * e[24] + e[16] * e[21] * e[33] + e[16] * e[31] * e[25] + e[16] * e[22] * e[34] + e[16] * e[32] * e[26] + e[16] * e[23] * e[35] - 1.*e[22] * e[27] * e[9] - 1.*e[22] * e[33] * e[15] - 1.*e[22] * e[35] * e[17] - 1.*e[22] * e[29] * e[11] - 1.*e[31] * e[24] * e[15] - 1.*e[31] * e[26] * e[17] - 1.*e[31] * e[20] * e[11] - 1.*e[31] * e[18] * e[9] + e[25] * e[30] * e[15] + e[25] * e[12] * e[33] + e[25] * e[32] * e[17] + e[25] * e[14] * e[35] + e[34] * e[21] * e[15] + e[34] * e[12] * e[24] + e[34] * e[23] * e[17] + e[34] * e[14] * e[26];
	A[114] = e[19] * e[11] * e[14] + e[19] * e[9] * e[12] + e[19] * e[10] * e[13] + e[13] * e[21] * e[12] + e[13] * e[23] * e[14] + e[16] * e[21] * e[15] + e[16] * e[12] * e[24] + e[16] * e[23] * e[17] + e[16] * e[14] * e[26] + e[16] * e[13] * e[25] + e[25] * e[14] * e[17] + e[25] * e[12] * e[15] - 1.*e[13] * e[24] * e[15] - 1.*e[13] * e[26] * e[17] - 1.*e[13] * e[20] * e[11] - 1.*e[13] * e[18] * e[9] + e[10] * e[18] * e[12] + e[10] * e[9] * e[21] + e[10] * e[20] * e[14] + e[10] * e[11] * e[23] + 1.500000000*e[22] * ep2[13] + .5000000000*e[22] * ep2[14] + .5000000000*e[22] * ep2[12] + .5000000000*e[22] * ep2[16] + .5000000000*ep2[10] * e[22] - .5000000000*e[22] * ep2[9] - .5000000000*e[22] * ep2[11] - .5000000000*e[22] * ep2[15] - .5000000000*e[22] * ep2[17];
	A[115] = e[13] * e[12] * e[3] + e[13] * e[14] * e[5] + e[16] * e[12] * e[6] + e[16] * e[3] * e[15] + e[16] * e[13] * e[7] + e[16] * e[14] * e[8] + e[16] * e[5] * e[17] + e[7] * e[14] * e[17] + e[7] * e[12] * e[15] + e[1] * e[11] * e[14] + e[1] * e[9] * e[12] + e[1] * e[10] * e[13] + e[10] * e[9] * e[3] + e[10] * e[0] * e[12] + e[10] * e[11] * e[5] + e[10] * e[2] * e[14] - 1.*e[13] * e[11] * e[2] - 1.*e[13] * e[15] * e[6] - 1.*e[13] * e[9] * e[0] - 1.*e[13] * e[17] * e[8] + 1.500000000*ep2[13] * e[4] + .5000000000*e[4] * ep2[16] - .5000000000*e[4] * ep2[9] - .5000000000*e[4] * ep2[11] + .5000000000*e[4] * ep2[12] - .5000000000*e[4] * ep2[15] - .5000000000*e[4] * ep2[17] + .5000000000*e[4] * ep2[10] + .5000000000*e[4] * ep2[14];
	A[112] = e[19] * e[1] * e[4] + e[19] * e[0] * e[3] + e[19] * e[2] * e[5] + e[4] * e[21] * e[3] + e[4] * e[23] * e[5] + e[7] * e[21] * e[6] + e[7] * e[3] * e[24] + e[7] * e[4] * e[25] + e[7] * e[23] * e[8] + e[7] * e[5] * e[26] + e[25] * e[3] * e[6] + e[25] * e[5] * e[8] + e[1] * e[18] * e[3] + e[1] * e[0] * e[21] + e[1] * e[20] * e[5] + e[1] * e[2] * e[23] - 1.*e[4] * e[26] * e[8] - 1.*e[4] * e[20] * e[2] - 1.*e[4] * e[18] * e[0] - 1.*e[4] * e[24] * e[6] + 1.500000000*e[22] * ep2[4] - .5000000000*e[22] * ep2[0] - .5000000000*e[22] * ep2[6] + .5000000000*e[22] * ep2[5] + .5000000000*e[22] * ep2[1] + .5000000000*e[22] * ep2[7] + .5000000000*e[22] * ep2[3] - .5000000000*e[22] * ep2[2] - .5000000000*e[22] * ep2[8];
	A[113] = -1.*e[31] * e[20] * e[2] - 1.*e[31] * e[18] * e[0] + e[31] * e[23] * e[5] - 1.*e[31] * e[24] * e[6] + e[7] * e[30] * e[24] + e[7] * e[21] * e[33] + e[7] * e[32] * e[26] + e[7] * e[23] * e[35] + e[25] * e[30] * e[6] + e[25] * e[3] * e[33] + e[25] * e[31] * e[7] + e[25] * e[4] * e[34] + e[25] * e[32] * e[8] + e[25] * e[5] * e[35] + e[34] * e[21] * e[6] + e[34] * e[3] * e[24] + e[34] * e[22] * e[7] + e[34] * e[23] * e[8] + e[34] * e[5] * e[26] + e[1] * e[27] * e[21] + e[1] * e[18] * e[30] + e[1] * e[28] * e[22] + e[1] * e[19] * e[31] + e[1] * e[29] * e[23] + e[1] * e[20] * e[32] + e[19] * e[27] * e[3] + e[19] * e[0] * e[30] + e[19] * e[28] * e[4] + e[19] * e[29] * e[5] + e[19] * e[2] * e[32] + e[28] * e[18] * e[3] + e[28] * e[0] * e[21] + e[28] * e[20] * e[5] + e[28] * e[2] * e[23] + e[4] * e[30] * e[21] + 3.*e[4] * e[31] * e[22] + e[4] * e[32] * e[23] - 1.*e[4] * e[27] * e[18] - 1.*e[4] * e[33] * e[24] - 1.*e[4] * e[29] * e[20] - 1.*e[4] * e[35] * e[26] - 1.*e[22] * e[27] * e[0] + e[22] * e[32] * e[5] - 1.*e[22] * e[33] * e[6] + e[22] * e[30] * e[3] - 1.*e[22] * e[35] * e[8] - 1.*e[22] * e[29] * e[2] + e[31] * e[21] * e[3] - 1.*e[31] * e[26] * e[8];

	int perm[20] = { 6, 8, 18, 15, 12, 5, 14, 7, 4, 11, 19, 13, 1, 16, 17, 3, 10, 9, 2, 0 };
	double AA[200];
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 10; j++) AA[i + j * 20] = A[perm[i] + j * 20];
	}

	for (int i = 0; i < 200; i++)
	{
		A[i] = AA[i];
	}
}

// Input should be a vector of n 2D points or a Nx2 matrix
Mat findEssentialMat(InputArray _points1, InputArray _points2, Mat K1, Mat K2, int method, double prob, double threshold, int maxIters, OutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);

	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 5 && points2.checkVector(2) == npoints &&
		points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	double f1 = K1.at<double>(0), f2 = K2.at<double>(0), u1 = K1.at<double>(2), v1 = K1.at<double>(4);
	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	// Reshape data to fit opencv ransac function
	points1 = points1.reshape(2, 1);
	points2 = points2.reshape(2, 1);

	Mat E(3, 3, CV_64F);
	CvEMEstimator estimator;

	CvMat p1 = points1;
	CvMat p2 = points2;
	CvMat _E = E;
	CvMat* tempMask = cvCreateMat(1, npoints, CV_8U);

	assert(npoints >= 5);
	threshold /= 0.25*(K1.at<double>(0) + K1.at<double>(4) + K2.at<double>(0) + K2.at<double>(4));
	int count = 1;
	if (npoints == 5)
	{
		E.create(3 * 10, 3, CV_64F);
		_E = E;
		count = estimator.runKernel(&p1, &p2, &_E);
		E = E.rowRange(0, 3 * count) * 1.0;
		Mat(tempMask).setTo(true);
	}
	else if (method == CV_RANSAC)
	{
		estimator.runRANSAC(&p1, &p2, &_E, tempMask, threshold, prob, maxIters);
	}
	else
	{
		estimator.runLMeDS(&p1, &p2, &_E, tempMask, prob);
	}

	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		Mat(tempMask).copyTo(mask);
	}


	return E;

}
void decomposeEssentialMat(const Mat & E, Mat & R1, Mat & R2, Mat & t)
{
	assert(E.cols == 3 && E.rows == 3);
	Mat D, U, Vt;
	SVD::compute(E, D, U, Vt);
	if (determinant(U) < 0) U = -U;
	if (determinant(Vt) < 0) Vt = -Vt;
	Mat W = (Mat_<double>(3, 3) << 0, 1, 0, -1, 0, 0, 0, 0, 1);
	W.convertTo(W, E.type());
	R1 = U * W * Vt;
	R2 = U * W.t() * Vt;
	t = U.col(2) * 1.0;
}
int recoverPose(const Mat & E, InputArray _points1, InputArray _points2, Mat & _R, Mat & _t, Mat K1, Mat K2, InputOutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);
	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 0 && points2.checkVector(2) == npoints &&
		points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	points1 = points1.t();
	points2 = points2.t();

	Mat R1, R2, t;
	decomposeEssentialMat(E, R1, R2, t);
	Mat P0 = Mat::eye(3, 4, R1.type());
	Mat P1(3, 4, R1.type()), P2(3, 4, R1.type()), P3(3, 4, R1.type()), P4(3, 4, R1.type());
	P1(Range::all(), Range(0, 3)) = R1 * 1.0; P1.col(3) = t * 1.0;
	P2(Range::all(), Range(0, 3)) = R2 * 1.0; P2.col(3) = t * 1.0;
	P3(Range::all(), Range(0, 3)) = R1 * 1.0; P3.col(3) = -t * 1.0;
	P4(Range::all(), Range(0, 3)) = R2 * 1.0; P4.col(3) = -t * 1.0;

	// Do the cheirality check. 
	// Notice here a threshold dist is used to filter
	// out far away points (i.e. infinite points) since 
	// there depth may vary between postive and negtive. 
	double dist = 50.0;
	Mat Q;
	triangulatePoints(P0, P1, points1, points2, Q);
	Mat mask1 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask1 = (Q.row(2) < dist) & mask1;
	Q = P1 * Q;
	mask1 = (Q.row(2) > 0) & mask1;
	mask1 = (Q.row(2) < dist) & mask1;

	triangulatePoints(P0, P2, points1, points2, Q);
	Mat mask2 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask2 = (Q.row(2) < dist) & mask2;
	Q = P2 * Q;
	mask2 = (Q.row(2) > 0) & mask2;
	mask2 = (Q.row(2) < dist) & mask2;

	triangulatePoints(P0, P3, points1, points2, Q);
	Mat mask3 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask3 = (Q.row(2) < dist) & mask3;
	Q = P3 * Q;
	mask3 = (Q.row(2) > 0) & mask3;
	mask3 = (Q.row(2) < dist) & mask3;

	triangulatePoints(P0, P4, points1, points2, Q);
	Mat mask4 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask4 = (Q.row(2) < dist) & mask4;
	Q = P4 * Q;
	mask4 = (Q.row(2) > 0) & mask4;
	mask4 = (Q.row(2) < dist) & mask4;

	// If _mask is given, then use it to filter outliers. 
	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		bitwise_and(mask, mask1, mask1);
		bitwise_and(mask, mask2, mask2);
		bitwise_and(mask, mask3, mask3);
		bitwise_and(mask, mask4, mask4);
	}

	int good1 = countNonZero(mask1);
	int good2 = countNonZero(mask2);
	int good3 = countNonZero(mask3);
	int good4 = countNonZero(mask4);
	if (good1 >= good2 && good1 >= good3 && good1 >= good4)
	{
		_R = R1; _t = t;
		if (_mask.needed()) mask1.copyTo(_mask.getMat());
		return good1;
	}
	else if (good2 >= good1 && good2 >= good3 && good2 >= good4)
	{
		_R = R2; _t = t;
		if (_mask.needed()) mask2.copyTo(_mask.getMat());
		return good2;
	}
	else if (good3 >= good1 && good3 >= good2 && good3 >= good4)
	{
		_R = R1; _t = -t;
		if (_mask.needed()) mask3.copyTo(_mask.getMat());
		return good3;
	}
	else
	{
		_R = R2; _t = -t;
		if (_mask.needed()) mask4.copyTo(_mask.getMat());
		return good4;
	}

}
int EMatTest()
{
	int N = 500;
	double bound_2d = 5;

	double focal1 = 300, focal2 = 350, u1 = 0, v1 = 0, u2 = 1, v2 = 2;
	Point2d pp(0, 0);

	Mat rvec = (cv::Mat_<double>(3, 1) << 0.1, 0.2, 0.3);
	Mat tvec = (cv::Mat_<double>(3, 1) << 0.4, 0.5, 0.6);
	normalize(tvec, tvec);
	std::cout << "Expected rvec: " << rvec << std::endl;
	std::cout << "Expected tvec: " << tvec << std::endl;

	Mat rmat;
	Rodrigues(rvec, rmat);

	Mat K1 = (Mat_<double>(3, 3) << focal1, 0, u1, 0, focal1, v1, 0, 0, 1);
	Mat K2 = (Mat_<double>(3, 3) << focal2, 0, u2, 0, focal2, v2, 0, 0, 1);

	RNG rng;
	Mat Xs(N, 3, CV_32F);
	rng.fill(Xs, RNG::UNIFORM, -bound_2d, bound_2d);

	Mat x1s = K1 * Xs.t();
	Mat x2s = rmat * Xs.t();
	for (int j = 0; j < x2s.cols; j++) x2s.col(j) += tvec;
	x2s = K2 * x2s;

	x1s.row(0) /= x1s.row(2);
	x1s.row(1) /= x1s.row(2);
	x1s.row(2) /= x1s.row(2);

	x2s.row(0) /= x2s.row(2);
	x2s.row(1) /= x2s.row(2);
	x2s.row(2) /= x2s.row(2);

	x1s = x1s.t();
	x2s = x2s.t();

	x1s = x1s.colRange(0, 2) * 1.0;
	x2s = x2s.colRange(0, 2) * 1.0;

	double start = omp_get_wtime();
	Mat E = findEssentialMat(x1s, x2s, K1, K2, CV_RANSAC, 0.99, 1, 200, noArray());
	printf("Time: %.6fs\n", omp_get_wtime() - start);

	std::cout << "============================= ========================" << std::endl;
	Mat R1_5pt, R2_5pt, tvec_5pt, rvec1_5pt, rvec2_5pt;
	decomposeEssentialMat(E, R1_5pt, R2_5pt, tvec_5pt);
	Rodrigues(R1_5pt, rvec1_5pt);
	Rodrigues(R2_5pt, rvec2_5pt);
	std::cout << "5-pt-nister rvec: " << std::endl;
	std::cout << rvec1_5pt << std::endl;
	std::cout << rvec2_5pt << std::endl;
	std::cout << "5-pt-nister tvec: " << std::endl;
	std::cout << tvec_5pt << std::endl;
	std::cout << -tvec_5pt << std::endl;


	start = omp_get_wtime();
	Mat R_5pt, rvec_5pt;
	recoverPose(E, x1s, x2s, R_5pt, tvec_5pt, K1, K2, noArray());
	printf("Time: %.6fs\n", omp_get_wtime() - start);

	Rodrigues(R_5pt, rvec_5pt);
	std::cout << "5-pt-nister rvec: " << std::endl;
	std::cout << rvec_5pt << std::endl;
	std::cout << "5-pt-nister tvec: " << std::endl;
	std::cout << tvec_5pt << std::endl;

	return 0;
}

int USAC_FindFundamentalMatrix(ConfigParamsFund cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Fmat, vector<int>&InlierIndicator, int &ninlers)
{
	FundMatrixEstimator* fund = new FundMatrixEstimator;
	fund->initParamsUSAC(cfg);

	// set up the fundamental matrix estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	fund->initDataUSAC(cfg);
	fund->initProblem(cfg, &point_data[0]);
	if (!fund->solve())
		return 1;

	// write out results
	ninlers = fund->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Fmat[3 * i + j] = fund->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(fund->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	fund->cleanupProblem();
	delete fund;

	return 0;
}
int USAC_FindFundamentalDriver(char *Path, int id1, int id2, int timeID)
{
	ConfigParamsFund cfg;
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	/// store common parameters
	cfg.common.confThreshold = 0.99;
	cfg.common.minSampleSize = 7;
	cfg.common.inlierThreshold = 1.5;
	cfg.common.maxHypotheses = 850000;
	cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true;
	cfg.common.prevalidateModel = true;
	cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM;
	cfg.common.verifMethod = USACConfig::VERIF_SPRT;
	cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	// read in PROSAC parameters if required
	if (USEPROSAC)
	{
		cfg.prosac.maxSamples;
		cfg.prosac.beta;
		cfg.prosac.nonRandConf;
		cfg.prosac.minStopLen;
	}

	// read in SPRT parameters if required
	if (USESPRT)
	{
		cfg.sprt.tM = 200.0;
		cfg.sprt.mS = 2.38;
		cfg.sprt.delta = 0.05;
		cfg.sprt.epsilon = 0.15;
	}

	// read in LO parameters if required
	if (USELOSAC)
	{
		cfg.losac.innerSampleSize = 15;
		cfg.losac.innerRansacRepetitions = 5;
		cfg.losac.thresholdMultiplier = 2.0;
		cfg.losac.numStepsIterative = 4;
	}
	cfg.fund.inputFilePath = Path;// "C:/temp/test1/orig_pts.txt";

	// read data from from file
	char Fname[200];

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys1, true))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys2, true))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int npts, pid1, pid2;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot open %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	cfg.common.numDataPoints = npts;

	vector<Point2d>pts1, pts2;
	pts1.reserve(npts); pts2.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
	{
		pts1.push_back(Point2d(Keys1[pid1].pt.x, Keys1[pid1].pt.y));
		pts2.push_back(Point2d(Keys2[pid2].pt.x, Keys2[pid2].pt.y));
	}
	fclose(fp);

	std::vector<unsigned int> prosac_data;
	if (USEPROSAC)
	{
		prosac_data.resize(cfg.common.numDataPoints);
		if (!readPROSACDataFromFile(cfg.prosac.sortedPointsFile, cfg.common.numDataPoints, prosac_data))
			return 1;
		cfg.prosac.sortedPointIndices = &prosac_data[0];
	}
	else
		cfg.prosac.sortedPointIndices = NULL;

	int ninliers = 0;
	double Fmat[9];
	vector<int> InlierIndicator;
	USAC_FindFundamentalMatrix(cfg, pts1, pts2, Fmat, InlierIndicator, ninliers);

	/*sprintf(Fname, "%s/orig_pts.txt", Path); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	fprintf(fp, "%.2f %.2f %.2f %.2f\n", pts1[ii].x, pts1[ii].y, pts2[ii].x, pts2[ii].y);
	fclose(fp);*/

	// write out results
	sprintf(Fname, "%s/F.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Fmat[ii]);
	fclose(fp);

	sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", InlierIndicator[ii]);
	fclose(fp);

	return 0;
}
int USAC_FindHomography(ConfigParamsHomog cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Hmat, vector<int>&InlierIndicator, int &ninlers)
{
	HomogEstimator* homog = new HomogEstimator;
	homog->initParamsUSAC(cfg);

	// set up the homography estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	homog->initDataUSAC(cfg);
	homog->initProblem(cfg, &point_data[0]);
	if (!homog->solve())
		return 1;

	// write out results
	ninlers = homog->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Hmat[3 * i + j] = homog->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(homog->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	homog->cleanupProblem();
	delete homog;

	return 0;
}
int USAC_FindHomographyDriver(char *Path, int id1, int id2, int timeID)
{
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;

	ConfigParamsHomog cfg;
	/// store common parameters
	cfg.common.confThreshold = 0.99;
	cfg.common.minSampleSize = 4;
	cfg.common.inlierThreshold = 2.0;
	cfg.common.maxHypotheses = 850000;
	cfg.common.maxSolutionsPerSample = 1;
	cfg.common.prevalidateSample = true;
	cfg.common.prevalidateModel = true;
	cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM;
	cfg.common.verifMethod = USACConfig::VERIF_SPRT;
	cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	// read in PROSAC parameters if required
	if (USEPROSAC)
	{
		cfg.prosac.maxSamples;
		cfg.prosac.beta;
		cfg.prosac.nonRandConf;
		cfg.prosac.minStopLen;
	}

	// read in SPRT parameters if required
	if (USESPRT)
	{
		cfg.sprt.tM = 100.0;
		cfg.sprt.mS = 1.0;
		cfg.sprt.delta = 0.01;
		cfg.sprt.epsilon = 0.2;
	}

	// read in LO parameters if required
	if (USELOSAC)
	{
		cfg.losac.innerSampleSize = 12;
		cfg.losac.innerRansacRepetitions = 3;
		cfg.losac.thresholdMultiplier = 2.0;
		cfg.losac.numStepsIterative = 4;
	}
	cfg.homog.inputFilePath = Path;// "C:/temp/test1/orig_pts.txt";

	// read data from from file
	char Fname[200];

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys2))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int npts, pid1, pid2;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot open %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	cfg.common.numDataPoints = npts;

	vector<Point2d>pts1, pts2;
	pts1.reserve(npts); pts2.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
	{
		pts1.push_back(Point2d(Keys1[pid1].pt.x, Keys1[pid1].pt.y));
		pts2.push_back(Point2d(Keys2[pid2].pt.x, Keys2[pid2].pt.y));
	}
	fclose(fp);

	std::vector<unsigned int> prosac_data;
	if (USEPROSAC)
	{
		prosac_data.resize(cfg.common.numDataPoints);
		if (!readPROSACDataFromFile(cfg.prosac.sortedPointsFile, cfg.common.numDataPoints, prosac_data))
			return 1;
		cfg.prosac.sortedPointIndices = &prosac_data[0];
	}
	else
		cfg.prosac.sortedPointIndices = NULL;

	int ninliers = 0;
	double Hmat[9];
	vector<int> InlierIndicator;
	USAC_FindHomography(cfg, pts1, pts2, Hmat, InlierIndicator, ninliers);

	/*sprintf(Fname, "%s/orig_pts.txt", Path); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	fprintf(fp, "%.2f %.2f %.2f %.2f\n", pts1[ii].x, pts1[ii].y, pts2[ii].x, pts2[ii].y);
	fclose(fp);*/

	// write out results
	sprintf(Fname, "%s/H.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Hmat[ii]);
	fclose(fp);

	sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", InlierIndicator[ii]);
	fclose(fp);

	return 0;
}

double SearchLK(Point2d From, Point2d &Target, float *Img1Para, float *Img2Para, int nchannels, int width1, int height1, int width2, int height2, LKParameters LKArg, double *Timg = 0, double *T = 0, double *iWp = 0, double *direction = 0, double* iCovariance = 0)
{
	int i, j, k, kk, iii, jjj, ij, i2, j2;
	int hsubset = LKArg.hsubset, DIC_Algo = LKArg.DIC_Algo, Interpolation_Algorithm = LKArg.InterpAlgo;
	int Iter_Max = LKArg.IterMax, Convergence_Criteria = LKArg.Convergence_Criteria, Speed = LKArg.Analysis_Speed;
	double znccThresh = LKArg.ZNCCThreshold, pssdabThresh = LKArg.PSSDab_thresh;

	double ii, jj, II, JJ, a, b, gx, gy, DIC_Coeff, DIC_Coeff_min, t_1, t_2, t_3, t_4, t_5, t_6, m_F, m_G, S[9], p_best[14];
	double conv_crit_1 = 1.0 / pow(10.0, Convergence_Criteria + 2);
	double conv_crit_2 = conv_crit_1*0.01;
	int NN[] = { 3, 7, 4, 8, 9, 13, 10, 14 };
	int jumpStep[2] = { 1, 2 };
	int DIC_Algo2 = DIC_Algo, nn, nExtraParas = 2, _iter = 0;
	int p_jump, p_jump_0 = jumpStep[Speed], p_jump_incr = 1;

	if (DIC_Algo == 4)
	{
		nn = 7, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 1;
	}
	else if (DIC_Algo == 5)
	{
		nn = 7, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 1;
	}
	else if (DIC_Algo == 6)
	{
		nn = 8, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 3;
	}
	else if (DIC_Algo == 7)
	{
		nn = 8, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 3;
	}
	else
		nn = NN[DIC_Algo];

	double AA[196], BB[14], CC[14], p[14];
	for (i = 0; i < nn; i++)
		p[i] = (i == nn - 2 ? 1.0 : 0.0);

	int length1 = width1*height1, length2 = width2*height2, TimgS = 2 * hsubset + 1, Tlength = TimgS*TimgS;

	bool createMem = false;
	if (Timg == NULL)
	{
		Timg = new double[Tlength*nchannels];
		T = new double[2 * Tlength*nchannels];
	}

	for (jjj = -hsubset; jjj <= hsubset; jjj++)
	{
		for (iii = -hsubset; iii <= hsubset; iii++)
		{
			ii = From.x + iii, jj = From.y + jjj;
			for (kk = 0; kk < nchannels; kk++)
			{
				Get_Value_Spline(Img1Para + kk*length1, width1, height1, ii, jj, S, -1, Interpolation_Algorithm);
				Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength] = S[0];
			}
		}
	}

	bool printout = false;
	FILE *fp;
	if (printout)
	{
		fp = fopen("C:/temp/src.txt", "w+");
		for (jjj = -hsubset; jjj <= hsubset; jjj++)
		{
			for (iii = -hsubset; iii <= hsubset; iii++)
				for (kk = 0; kk < nchannels; kk++)
					fprintf(fp, "%.2f ", Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength]);
			fprintf(fp, "\n");
		}
		fclose(fp);
	}

	bool useInitPara = false;
	if (iWp != NULL)
	{
		useInitPara = true;
		p[2] = iWp[0], p[3] = iWp[1], p[4] = iWp[2], p[5] = iWp[3];
	}

	/// Let's start with only translation and only match the at the highest level of the pyramid
	bool Break_Flag = false;
	DIC_Coeff_min = 1e10;
	for (p_jump = p_jump_0; p_jump > 0; p_jump -= 2)
	{
		DIC_Coeff_min = 1e10;
		bool Break_Flag = false;
		for (k = 0; k < Iter_Max; k++)
		{
			t_1 = 0.0;
			t_2 = 0.0;
			for (i = 0; i < 4; i++)
				AA[i] = 0.0;
			for (i = 0; i < 2; i++)
				BB[i] = 0.0;

			if (printout)
				fp = fopen("C:/temp/tar.txt", "w+");

			for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
			{
				for (iii = -hsubset; iii <= hsubset; iii += p_jump)
				{
					if (DIC_Algo == 1 || DIC_Algo == 3)
						II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
					else
						II = Target.x + iii + p[0], JJ = Target.y + jjj + p[1];

					if (II<0.0 || II>(double)(width1 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height1 - 1) - (1e-10))
						continue;

					for (kk = 0; kk < nchannels; kk++)
					{
						Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

						m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
						m_G = S[3 * kk];
						if (printout)
							fprintf(fp, "%.2f ", m_G);
						t_3 = m_G - m_F;
						CC[0] = S[3 * kk + 1], CC[1] = S[3 * kk + 2];

						for (i = 0; i < 2; i++)
							BB[i] += t_3*CC[i];

						for (j = 0; j < 2; j++)
							for (i = j; i < 2; i++)
								AA[j * 2 + i] += CC[i] * CC[j];

						t_1 += t_3*t_3, t_2 += m_F*m_F;
					}
				}
				if (printout)
					fprintf(fp, "\n");
			}
			if (printout)
				fclose(fp);

			DIC_Coeff = t_1 / t_2;
			mat_completeSym(AA, 2);
			QR_Solution_Double(AA, BB, 2, 2);
			for (i = 0; i < 2; i++)
				p[i] -= BB[i];


			if (DIC_Coeff != DIC_Coeff || DIC_Coeff > 50 || abs(p[0]) > hsubset || abs(p[1]) > hsubset)
			{
				if (createMem)
				{
					delete[]T;
					delete[]Timg;
				}
				return 0.0;
			}

			if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
			{
				DIC_Coeff_min = DIC_Coeff;
				p_best[0] = p[0], p_best[1] = p[1];
				if (p[0] != p[0] || p[1] != p[1])
				{
					if (createMem)
					{
						delete[]T;
						delete[]Timg;
					}
					return 0.0;
				}
			}

			if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
				break;
		}
	}
	p[0] = p_best[0], p[1] = p_best[1];

	if (DIC_Algo <= 1)
	{
		p[0] = 0.5*(p[0] / direction[0] + p[1] / direction[1]);
		if (DIC_Algo == 0)
			p[1] = 1.0, p[2] = 0.0;
		else
			p[1] = 0.0, p[2] = 0.0, p[3] = 0.0, p[4] = 0.0;
	}

	if (useInitPara)
	{
		if (DIC_Algo == 1)
			p[1] = iWp[0], p[2] = iWp[1], p[3] = iWp[2], p[4] = iWp[3], p[5] = 1.0, p[6] = 0.0;
		else if (DIC_Algo == 3)
			p[2] = iWp[0], p[3] = iWp[1], p[4] = iWp[2], p[5] = iWp[3], p[6] = 1.0, p[7] = 0.0;
	}

	//Now, do the full DIC
	for (p_jump = p_jump_0; p_jump > 0; p_jump -= p_jump_incr)
	{
		DIC_Coeff_min = 1e10;
		bool Break_Flag = false;

		for (k = 0; k < Iter_Max; k++)
		{
			t_1 = 0.0, t_2 = 0.0;
			for (i = 0; i < nn*nn; i++)
				AA[i] = 0.0;
			for (i = 0; i < nn; i++)
				BB[i] = 0.0;

			if (printout)
				fp = fopen("C:/temp/tar.txt", "w+");

			a = p[nn - 2], b = p[nn - 1];
			for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
			{
				for (iii = -hsubset; iii <= hsubset; iii += p_jump)
				{
					if (DIC_Algo == 0)
					{
						II = Target.x + iii + p[0] * direction[0];
						JJ = Target.y + jjj + p[0] * direction[1];
					}
					else if (DIC_Algo == 1) //afine
					{
						II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj;
						JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj;
					}
					else if (DIC_Algo == 2)
					{
						II = Target.x + iii + p[0];
						JJ = Target.y + jjj + p[1];
					}
					else if (DIC_Algo == 3)
					{
						II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj;
						JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
					}

					if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
						continue;

					for (kk = 0; kk < nchannels; kk++)
					{
						Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

						m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
						m_G = S[3 * kk];

						if (printout)
							fprintf(fp, "%.2f ", m_G);

						gx = S[3 * kk + 1], gy = S[3 * kk + 2];
						t_3 = a*m_G + b - m_F;

						t_4 = a, t_5 = t_4*gx, t_6 = t_4*gy;
						if (DIC_Algo == 0)
						{
							CC[0] = t_5*direction[0] + t_6*direction[1];
							CC[1] = m_G, CC[2] = 1.0;
						}
						else if (DIC_Algo == 1)
						{
							CC[0] = t_5*direction[0] + t_6*direction[1];
							CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
							CC[5] = m_G, CC[6] = 1.0;
						}
						else if (DIC_Algo == 2)
						{
							CC[0] = t_5, CC[1] = t_6;
							CC[2] = m_G, CC[3] = 1.0;
						}
						else if (DIC_Algo == 3)
						{
							CC[0] = t_5, CC[1] = t_6;
							CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
							CC[6] = m_G, CC[7] = 1.0;
						}

						for (j = 0; j < nn; j++)
						{
							BB[j] += t_3*CC[j];
							for (i = j; i < nn; i++)
								AA[j*nn + i] += CC[i] * CC[j];
						}

						t_1 += t_3*t_3;
						t_2 += m_F*m_F;
					}
				}
				if (printout)
					fprintf(fp, "\n");
			}
			if (printout)
				fclose(fp);

			DIC_Coeff = t_1 / t_2;

			mat_completeSym(AA, nn);
			QR_Solution_Double(AA, BB, nn, nn);
			for (i = 0; i < nn; i++)
				p[i] -= BB[i];

			if (DIC_Coeff != DIC_Coeff || DIC_Coeff > 50)
			{
				if (createMem)
					delete[]T, delete[]Timg;
				return 0.0;
			}
			if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
			{
				DIC_Coeff_min = DIC_Coeff;
				for (i = 0; i < nn; i++)
					p_best[i] = p[i];
				if (p[0] != p[0])
				{
					if (createMem)
						delete[]T, delete[]Timg;
					return 0.0;
				}
			}

			if (DIC_Algo <= 1)
			{
				if (abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
				{
					if (createMem)
						delete[]T, delete[]Timg;
					return 0.0;
				}
				if (fabs(BB[0]) < conv_crit_1)
				{
					for (i = 1; i < nn - nExtraParas; i++)
						if (fabs(BB[i]) > conv_crit_2)
							break;
					if (i == nn - nExtraParas)
						Break_Flag = true;
				}
			}
			else
			{
				if (abs(p[0]) > hsubset || abs(p[1]) > hsubset)
				{
					if (createMem)
					{
						delete[]T;
						delete[]Timg;
					}
					return 0.0;
				}
				if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
				{
					for (i = 2; i < nn - nExtraParas; i++)
					{
						if (fabs(BB[i]) > conv_crit_2)
							break;
					}
					if (i == nn - nExtraParas)
						Break_Flag = true;
				}
			}

			if (Break_Flag)
				break;
		}
		_iter += k;
		// In case the iteration converges to "wrong" points, always use the data that lead to the least-square value.
		for (i = 0; i < nn; i++)
			p[i] = p_best[i];
	}

	//Quadratic if needed:
	if (DIC_Algo2 > 3)
	{
		DIC_Algo = DIC_Algo2, nn = NN[DIC_Algo];
		if (DIC_Algo == 4)
		{
			p[7] = p[5], p[8] = p[6];
			for (i = 5; i < 7; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 5)
		{
			p[11] = p[5], p[12] = p[6];
			for (i = 5; i < 11; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 6)
		{
			p[8] = p[6], p[9] = p[7];
			for (i = 6; i < 8; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 7)
		{
			p[12] = p[6], p[13] = p[7];
			for (i = 6; i < 12; i++)
				p[i] = 0.0;
		}

		//p_jump_0 = 1;
		for (p_jump = p_jump_0; p_jump > 0; p_jump -= p_jump_incr)
		{
			DIC_Coeff_min = 1e10;
			bool Break_Flag = false;

			for (k = 0; k < Iter_Max; k++)
			{
				t_1 = 0.0, t_2 = 0.0;
				for (i = 0; i < nn*nn; i++)
					AA[i] = 0.0;
				for (i = 0; i < nn; i++)
					BB[i] = 0.0;

				a = p[nn - 2], b = p[nn - 1];

				if (printout)
					fp = fopen("C:/temp/tar.txt", "w+");

				for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
				{
					for (iii = -hsubset; iii <= hsubset; iii += p_jump)
					{
						if (DIC_Algo == 4) //irregular
						{
							ij = iii*jjj;
							II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij;
							JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij;
						}
						else if (DIC_Algo == 5) //Quadratic
						{
							ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
							II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij + p[7] * i2 + p[8] * j2;
							JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij + p[9] * i2 + p[10] * j2;
						}
						else if (DIC_Algo == 6)
						{
							ij = iii*jjj;
							II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij;
							JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij;
						}
						else if (DIC_Algo == 7)
						{
							ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
							II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij + p[8] * i2 + p[9] * j2;
							JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij + p[10] * i2 + p[11] * j2;
						}

						if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
							continue;

						for (kk = 0; kk < nchannels; kk++)
						{
							Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

							m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
							m_G = S[3 * kk];

							if (printout)
								fprintf(fp, "%.2f ", m_G);

							gx = S[3 * kk + 1], gy = S[3 * kk + 2];
							t_3 = a*m_G + b - m_F;

							t_4 = a, t_5 = t_4*gx, t_6 = t_4*gy;
							if (DIC_Algo == 4) //irregular
							{
								CC[0] = t_5*direction[0] + t_6*direction[1];
								CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
								CC[5] = t_5*ij, CC[6] = t_6*ij;
								CC[7] = m_G, CC[8] = 1.0;
							}
							else if (DIC_Algo == 5) //Quadratic
							{
								CC[0] = t_5*direction[0] + t_6*direction[1];
								CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
								CC[5] = t_5*ij, CC[6] = t_6*ij, CC[7] = t_5*i2, CC[8] = t_5*j2, CC[9] = t_6*i2, CC[10] = t_6*j2;
								CC[11] = m_G, CC[12] = 1.0;
							}
							else if (DIC_Algo == 6)  //irregular
							{
								CC[0] = t_5, CC[1] = t_6;
								CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
								CC[6] = t_5*ij, CC[7] = t_6*ij;
								CC[8] = m_G, CC[9] = 1.0;
							}
							else if (DIC_Algo == 7)
							{
								CC[0] = t_5, CC[1] = t_6;
								CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
								CC[6] = t_5*ij, CC[7] = t_6*ij, CC[8] = t_5*i2, CC[9] = t_5*j2, CC[10] = t_6*i2, CC[11] = t_6*j2;
								CC[12] = m_G, CC[13] = 1.0;
							}

							for (j = 0; j < nn; j++)
							{
								BB[j] += t_3*CC[j];
								for (i = j; i < nn; i++)
									AA[j*nn + i] += CC[i] * CC[j];
							}

							t_1 += t_3*t_3, t_2 += m_F*m_F;
						}
					}
					if (printout)
						fprintf(fp, "\n");
				}
				if (printout)
					fclose(fp);

				DIC_Coeff = t_1 / t_2;
				mat_completeSym(AA, nn);
				QR_Solution_Double(AA, BB, nn, nn);
				for (i = 0; i < nn; i++)
					p[i] -= BB[i];

				if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
				{
					DIC_Coeff_min = DIC_Coeff;
					for (i = 0; i < nn; i++)
						p_best[i] = p[i];
					if (p[0] != p[0])
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
				}

				if (DIC_Algo <= 1)
				{
					if (abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
					if (fabs(BB[0]) < conv_crit_1)
					{
						for (i = 1; i < nn - nExtraParas; i++)
							if (fabs(BB[i]) > conv_crit_2)
								break;
						if (i == nn - nExtraParas)
							Break_Flag = true;
					}
				}
				else
				{
					if (abs(p[0]) > hsubset || abs(p[1]) > hsubset)
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
					if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
					{
						for (i = 2; i < nn - nExtraParas; i++)
							if (fabs(BB[i]) > conv_crit_2)
								break;
						if (i == nn - nExtraParas)
							Break_Flag = true;
					}
				}
				if (Break_Flag)
					break;
			}
			_iter += k;
			// In case the iteration converges to "wrong" points, always use the data that lead to the least-square value.
			for (i = 0; i < nn; i++)
				p[i] = p_best[i];
		}
	}
	/// DIC Iteration: End

	//Now, dont really trust the pssad error too much, compute zncc score instead! They are usually close on convergence, but in case of trouble, zncc is more reliable.
	if (DIC_Coeff_min < pssdabThresh)
	{
		int m = 0;
		double t_1, t_2, t_3, t_4, t_5, t_f = 0.0, t_g = 0.0;
		if (printout)
			fp = fopen("C:/temp/tar.txt", "w+");
		for (jjj = -hsubset; jjj <= hsubset; jjj++)
		{
			for (iii = -hsubset; iii <= hsubset; iii++)
			{
				if (DIC_Algo == 0)
					II = Target.x + iii + p[0] * direction[0], JJ = Target.y + jjj + p[0] * direction[1];
				else if (DIC_Algo == 1)
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj, JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj;
				else if (DIC_Algo == 2)
					II = Target.x + iii + p[0], JJ = Target.y + jjj + p[1];
				else if (DIC_Algo == 3)
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
				else if (DIC_Algo == 4) //irregular
				{
					ij = iii*jjj;
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij;
					JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij;
				}
				else if (DIC_Algo == 5) //Quadratic
				{
					ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij + p[7] * i2 + p[8] * j2;
					JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij + p[9] * i2 + p[10] * j2;
				}
				else if (DIC_Algo == 6)
				{
					ij = iii*jjj;
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij;
				}
				else if (DIC_Algo == 7)
				{
					ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij + p[8] * i2 + p[9] * j2;
					JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij + p[10] * i2 + p[11] * j2;
				}

				if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
					continue;

				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, -1, Interpolation_Algorithm);
					if (printout)
						fprintf(fp, "%.4f ", S[3 * kk]);

					T[2 * m] = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
					T[2 * m + 1] = S[3 * kk];
					t_f += T[2 * m];
					t_g += T[2 * m + 1];
					m++;
				}
			}
			if (printout)
				fprintf(fp, "\n");
		}
		if (printout)
			fclose(fp);

		t_f = t_f / m, t_g = t_g / m;
		t_1 = 0.0, t_2 = 0.0, t_3 = 0.0;
		for (i = 0; i < m; i++)
		{
			t_4 = T[2 * i] - t_f, t_5 = T[2 * i + 1] - t_g;
			t_1 += 1.0*t_4*t_5, t_2 += 1.0*t_4*t_4, t_3 += 1.0*t_5*t_5;
		}

		t_2 = sqrt(t_2*t_3);
		if (t_2 < 1e-10)
			t_2 = 1e-10;

		DIC_Coeff_min = t_1 / t_2; //This is the zncc score
		if (abs(DIC_Coeff_min) > 1.0)
			DIC_Coeff_min = 0.0;
	}

	if (createMem)
	{
		delete[]Timg;
		delete[]T;
	}
	if (DIC_Coeff_min > 1.0)
		return 0.0;

	if (DIC_Algo <= 1)
	{
		if (DIC_Coeff_min< znccThresh || p[0] != p[0] || abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
			return DIC_Coeff_min;
	}
	else
	{
		if (DIC_Coeff_min< znccThresh || p[0] != p[0] || p[1] != p[1] || abs(p[0]) > 2.0*hsubset || abs(p[1]) > 2.0*hsubset)
			return DIC_Coeff_min;
	}

	if (useInitPara)
	{
		if (DIC_Algo == 1 || DIC_Algo == 4 || DIC_Algo == 5)
			iWp[0] = p[1], iWp[1] = p[2], iWp[2] = p[3], iWp[3] = p[4];
		else if (DIC_Algo == 3 || DIC_Algo == 6 || DIC_Algo == 7)
			iWp[0] = p[2], iWp[1] = p[3], iWp[2] = p[4], iWp[3] = p[5];
	}

	if (DIC_Algo < 2 || (DIC_Algo>3 && DIC_Algo < 6))
		Target.x += p[0] * direction[0], Target.y += p[0] * direction[1];
	else
		Target.x += p[0], Target.y += p[1];

	return DIC_Coeff_min;
}
int SparsePointTrackingDriver(char *Path, vector<Point2d> &Tracks, vector<float*> &ImgPara, int viewID, int startF, int stopF, LKParameters LKArg, int &width, int &height, int nchannels)
{
	char Fname[200];

	Mat view;
	char *Img = 0;
	float *sImg = 0;
	if (ImgPara.size() < 3)
	{
		for (int ii = startF; ii <= startF + 1; ii++)//Load the 1st 2 images
		{
			sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, ii, ii, viewID);
			Mat view = imread(Fname, nchannels == 1 ? 0 : 1);
			if (view.data == NULL)
			{
				cout << "Cannot load: " << Fname << endl;
				delete[]Img;
				return 1;
			}
			width = view.cols, height = view.rows;
			int length = width *height*nchannels;
			if (Img == NULL)
				Img = new char[length];
			if (sImg == NULL)
				sImg = new float[length];
			for (int ii = 0; ii < length; ii++)
				Img[ii] = view.data[ii];
			Gaussian_smooth(Img, sImg, height, width, 255.0, 1.0);

			float *Para = new float[width*height*nchannels];
			Generate_Para_Spline(sImg, Para, width, height, LKArg.InterpAlgo);
			ImgPara.push_back(Para);
		}
	}

	//Track:
	int hsubset = LKArg.hsubset + LKArg.nscales * LKArg.scaleStep, orghsubset = LKArg.hsubset;
	int TimgS = 2 * hsubset + 1, Tlength = TimgS*TimgS;
	double *Timg = new double[Tlength*nchannels];
	double *T = new double[2 * Tlength*nchannels];

	double bestDistance = 100;
	Point2d bestfPt;
	for (int st = 0; st < LKArg.nscales; st++)
	{
		LKArg.hsubset = orghsubset + st*LKArg.scaleStep;

		//Forward
		Point2d fPt = Tracks[0];
		double score1 = SearchLK(Tracks[0], fPt, ImgPara[0], ImgPara[1], nchannels, width, height, width, height, LKArg, Timg, T);

		//Backward
		Point2d bPt = fPt;
		double score2 = SearchLK(fPt, bPt, ImgPara[1], ImgPara[0], nchannels, width, height, width, height, LKArg, Timg, T);

		double distance = sqrt(pow(bPt.x - Tracks[0].x, 2) + pow(bPt.y - Tracks[0].y, 2));
		if (distance < bestDistance && score1>0.0 && score2 > 0.0)
		{
			bestfPt = fPt;
			bestDistance = distance;
		}
	}

	if (bestDistance > LKArg.DisplacementThresh)//drifted
	{
		delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
		return 0;
	}
	else
		Tracks.push_back(bestfPt);

	for (int ii = startF + 2; ii <= stopF; ii++)
	{
		printf("%d .. ", ii);
		if (ImgPara.size() < ii - startF + 1)
		{
			//sprintf(Fname, "%s/%d.png", Path, ii);
			sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, ii, ii, viewID);
			Mat view = imread(Fname, nchannels == 1 ? 0 : 1);
			if (view.data == NULL)
			{
				cout << "Cannot load: " << Fname << endl;
				delete[]Img, delete[]Timg, delete[]T;
				return 1;
			}
			width = view.cols, height = view.rows;
			int length = width *height*nchannels;
			if (Img == NULL)
				Img = new char[length];
			if (sImg == NULL)
				sImg = new float[length];
			for (int ii = 0; ii < length; ii++)
				Img[ii] = view.data[ii];
			Gaussian_smooth(Img, sImg, height, width, 255.0, 1.0);

			float *Para = new float[width*height*nchannels];
			Generate_Para_Spline(sImg, Para, width, height, LKArg.InterpAlgo);
			ImgPara.push_back(Para);
		}

		//Run tracking
		bestDistance = 999.0;
		int currentTimeId = ii - startF - 1;
		for (int st = 0; st < LKArg.nscales; st++)
		{
			LKArg.hsubset = orghsubset + st*LKArg.scaleStep;

			//Forward
			Point2d fPt = Tracks[currentTimeId];
			double score1 = SearchLK(Tracks[currentTimeId], fPt, ImgPara[currentTimeId], ImgPara[currentTimeId + 1], nchannels, width, height, width, height, LKArg, Timg, T);

			//Backward
			Point2d bPt = fPt;
			double score2 = SearchLK(fPt, bPt, ImgPara[currentTimeId + 1], ImgPara[currentTimeId], nchannels, width, height, width, height, LKArg, Timg, T);

			double distance = sqrt(pow(bPt.x - Tracks[currentTimeId].x, 2) + pow(bPt.y - Tracks[currentTimeId].y, 2));
			if (distance < bestDistance && score1>0.0 && score2 > 0.0)
			{
				bestfPt = fPt;
				bestDistance = distance;
			}
		}
		if (bestDistance > LKArg.DisplacementThresh)
		{
			delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
			return 0;
		}
		else
			Tracks.push_back(bestfPt);
	}

	delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
	return 0;
}
//The fisheye camera is parameterized using 12 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, 2 for distortion center, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2f> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2d> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(vector<Point2d>&Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double omega, double DistCtrX, double DistCtrY, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int length = width*height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (int kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}



	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int jj = 0; jj < Mheight; jj++)
	{
		for (int ii = 0; ii < Mwidth; ii++)
		{
			double S[3];
			Point2d ImgPt(H[0] * ii + H[1] * jj + H[2], H[3] * ii + H[4] * jj + H[5]);

			FishEyeDistortionPoint(&ImgPt, omega, DistCtrX, DistCtrY, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (int kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (int kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The fisheye camera is parameterized using 10 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x_n, y_n, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x_n = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y_n = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x_n*x_n + y_n*y_n), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x_n, y_u = t*y_n;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double *K, double* invK, double omega, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width*height, Mwidth = width*ImgMag, Mheight = height*ImgMag, Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}


	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			FishEyeDistortionPoint(&ImgPt, K, invK, omega, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The camera is parameterized using 16 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 3 for radial distortion, 2 for tangential distortion, 2 for prism, and 6 for rotation translation.
void LensDistortionPoint(Point2d *img_point, double *K, double *distortion, int npts)
{
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void LensDistortionPoint2(Point2d *img_point, double *Intrinsic, double *distortion, int npts)
{
	double alpha = Intrinsic[0], beta = Intrinsic[1], gamma = Intrinsic[2], u0 = Intrinsic[3], v0 = Intrinsic[4];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void LensDistortionPoint(vector<Point2d> &img_point, double *K, double *distortion)
{
	int npts = img_point.size();
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void CC_Calculate_xcn_ycn_from_i_j(double i, double j, double &xcn, double &ycn, double *A, double *distortion, int Method)
{
	int k;
	double Xcn, Ycn, r2, r4, r6, x2, y2, xy, x0, y0;
	double radial, tangential_x, tangential_y, prism_x, prism_y;
	double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
	double p0 = distortion[3], p1 = distortion[4];
	double s0 = distortion[5], s1 = distortion[6];

	Ycn = (j - A[4]) / A[1];
	Xcn = (i - A[3] - A[2] * Ycn) / A[0];

	xcn = Xcn;
	ycn = Ycn;
	for (k = 0; k < 20; k++)
	{
		x0 = xcn;
		y0 = ycn;
		r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, x2 = xcn*xcn, y2 = ycn*ycn, xy = xcn*ycn;

		radial = 1.0 + a0*r2 + a1*r4 + a2*r6;
		tangential_x = 2.0*p1*xy + p0*(r2 + 2.0*x2);
		tangential_y = p1*(r2 + 2.0*y2) + 2.0*p0*xy;

		prism_x = s0*r2;
		prism_y = s1*r2;

		xcn = (Xcn - tangential_x - prism_x) / radial;
		ycn = (Ycn - tangential_y - prism_y) / radial;

		if (abs((xcn - x0) / xcn) < 1.0e-9 && abs((ycn - y0) / ycn) < 1.0e-9)
			break;
	}
	return;
}
void LensCorrectionPoint(Point2d *uv, double *K, double *distortion, int npts)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2f> &uv, double *K, double *distortion)
{
	double u, v, xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		u = uv[ii].x, v = uv[ii].y;
		CC_Calculate_xcn_ycn_from_i_j(u, v, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2d> &uv, double *K, double *distortion)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensUndistortion(unsigned char *Img, int width, int height, int nchannels, double *K, double *distortion, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width*height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}

	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			LensDistortionPoint(&ImgPt, K, distortion, 1);

			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

int EssentialMatOutliersRemove(char *Path, int timeID, int id1, int id2, int nCams, int cameraToScan, int ninlierThresh, int distortionCorrected, bool needDuplicateRemove)
{
	CameraData *camera = new CameraData[nCams];
	if (ReadIntrinsicResults(Path, camera) != 0)
		return 1;

	if (distortionCorrected == 1)
		for (int ii = 0; ii < nCams; ii++)
			for (int jj = 0; jj < 7; jj++)
				camera[ii].distortion[jj] = 0.0;

	for (int ii = 0; ii < nCams; ii++)
		camera[ii].threshold = 3.0, camera[ii].ninlierThresh = 50;

	char Fname[200];
	vector<Point2i> RawPairWiseMatchID;
	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.txt", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < 40)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFT(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (unsigned int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
		else
			sprintf(Fname, "%s/M%d_%d_%d.txt", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1[ii].x = Keys1.at(id1).pt.x, pts1[ii].y = Keys1.at(id1).pt.y;
		pts2[ii].x = Keys2.at(id2).pt.x, pts2[ii].y = Keys2.at(id2).pt.y;
	}

	if (cameraToScan != -1)
	{
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
			LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
		}
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == FISHEYE)
		{
			FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
			FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
		}
	}
	else
	{
		if (distortionCorrected == 0 && camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion, npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion, npts);
		if (distortionCorrected == 0 && camera[id1].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2], npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts1, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2], npts);
	}

	Mat x1s(npts, 2, CV_64F), x2s(npts, 2, CV_64F);
	for (int ii = 0; ii < npts; ii++)
	{
		x1s.at<double>(ii, 0) = pts1[ii].x, x1s.at<double>(ii, 1) = pts1[ii].y;
		x2s.at<double>(ii, 0) = pts2[ii].x, x2s.at<double>(ii, 1) = pts2[ii].y;
	}

	double start = omp_get_wtime();
	Mat Inliers, E;
	double ProThresh = 0.95, PercentInlier = 0.2;
	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 5)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	if (cameraToScan != -1)
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold, iterMax, Inliers);
	}
	else
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[id1].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[id2].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold, iterMax, Inliers);
	}

	int ninliers = 0;
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			ninliers++;

	if (ninliers < camera[0].ninlierThresh)
	{
#pragma omp critical
		printf("View (%d, %d) fails....%d inliers\n", id1, id2, ninliers);
		return 0;
	}

	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.txt", Path, timeID, id1, id2);
	fp = fopen(Fname, "w+");	fprintf(fp, "%d\n", ninliers);
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
	fclose(fp);

#pragma omp critical
	printf("View (%d, %d) of frame %d...%d matches... %.2fs\n", id1, id2, timeID, ninliers, omp_get_wtime() - start);
	return 0;
}
int FundamentalMatOutliersRemove(char *Path, int timeID, int id1, int id2, int ninlierThresh, int LensType, int distortionCorrected, bool needDuplicateRemove, int nCams, int cameraToScan, int *FrameOffset)
{
	if (FrameOffset == NULL)
	{
		FrameOffset = new int[nCams];
		for (int ii = 0; ii < nCams; ii++)
			FrameOffset[ii] = 0;
	}

	bool noCalibInfo = false;
	CameraData *camera = new CameraData[nCams];
	if (!ReadIntrinsicResults(Path, camera) != 0)
		noCalibInfo = true;
	if (noCalibInfo &&distortionCorrected == 0 && LensType == FISHEYE)
		return 1;

	vector<Point2i> RawPairWiseMatchID;
	char Fname[200];
	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/M%d_%d_%d.txt", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < ninlierThresh)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID + FrameOffset[id1]);
	if (!ReadKPointsBinarySIFT(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID + FrameOffset[id2]);
	if (!ReadKPointsBinarySIFT(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (unsigned int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
		else
			sprintf(Fname, "%s/Dynamic/M%d_%d_%d.txt", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	vector<Point2d> pts1, pts2;
	pts1.reserve(npts), pts2.reserve(npts);
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1.push_back(Point2d(Keys1.at(id1).pt.x, Keys1.at(id1).pt.y));
		pts2.push_back(Point2d(Keys2.at(id2).pt.x, Keys2.at(id2).pt.y));
	}

	if (distortionCorrected == 0 && !noCalibInfo) //only one camera is used to scan the corpus
	{
		if (cameraToScan != -1)
		{
			if (camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion);
				LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion);
			}
			else if (camera[cameraToScan].LensModel == FISHEYE)
			{
				FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
				FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
			}
		}
		else
		{
			if (camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
				LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion);
			else if (camera[id1].LensModel == FISHEYE)
				FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2]);
			if (camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
				LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion);
			else if (camera[id2].LensModel == FISHEYE)
				FishEyeCorrectionPoint(pts2, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2]);
		}
	}
	delete[]camera;

	//USAC config
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	ConfigParamsFund cfg;
	cfg.common.confThreshold = 0.99, cfg.common.minSampleSize = 7, cfg.common.inlierThreshold = noCalibInfo ? 7.5 : 5.0;
	cfg.common.maxHypotheses = 850000, cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true, cfg.common.prevalidateModel = true, cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM, cfg.common.verifMethod = USACConfig::VERIF_SPRT, cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	if (USEPROSAC)
		cfg.prosac.maxSamples, cfg.prosac.beta, cfg.prosac.nonRandConf, cfg.prosac.minStopLen;
	if (USESPRT)
		cfg.sprt.tM = 200.0, cfg.sprt.mS = 2.38, cfg.sprt.delta = 0.05, cfg.sprt.epsilon = 0.15;
	if (USELOSAC)
		cfg.losac.innerSampleSize = 15, cfg.losac.innerRansacRepetitions = 5, cfg.losac.thresholdMultiplier = 2.0, cfg.losac.numStepsIterative = 4;

	int ninliers = 0;
	double Fmat[9];
	vector<int>Inliers; Inliers.reserve(pts1.size());
	cfg.common.numDataPoints = pts1.size();
	USAC_FindFundamentalMatrix(cfg, pts1, pts2, Fmat, Inliers, ninliers);
#pragma omp critical
	if (ninliers < ninlierThresh)
		printf("(%d, %d): failed Fundamental matrix test\n\n", id1, id2);

	if (timeID < 0)
		sprintf(Fname, "%s/Dynamic/M_%d_%d.txt", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/M%d_%d_%d.txt", Path, timeID, id1, id2);
#pragma omp critical
	fp = fopen(Fname, "w+");

	if (ninliers < ninlierThresh)
	{
		fprintf(fp, "%d\n", 0);
		fclose(fp);
	}
	else
	{
		fprintf(fp, "%d\n", ninliers);
		for (int ii = 0; ii < Inliers.size(); ii++)
			if (Inliers[ii] == 1)
				fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

#pragma omp critical
	if (timeID>0)
		printf("(%d, %d) to (%d, %d) ...%d matches...\n", id1, timeID + FrameOffset[id1], id2, timeID + FrameOffset[id2], ninliers);
	else
		printf("%d to  %d ...%d matches...\n", id1, id2, ninliers);

	return 0;
}

void FisheyeProjectandDistort(Point3d WC, Point2d *pts, double *P, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (distortion != NULL)
			FishEyeDistortionPoint(&pts[ii], distortion[7 * ii], distortion[7 * ii + 1], distortion[7 * ii + 2]);
	}

	return;
}
void ProjectandDistort(Point3d WC, Point2d *pts, double *P, double *camera, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (camera != NULL)
			LensDistortionPoint(&pts[ii], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void ProjectandDistort(Point3d WC, vector<Point2d> &pts, double *P, double *camera, double *distortion)
{
	int ii;
	double num1, num2, denum;

	int nviews = (int)pts.size();
	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (camera != NULL)
			LensDistortionPoint(&pts[ii], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void ProjectandDistort(vector<Point3d> WC, Point2d *pts, double *P, double *camera, double *distortion, int nviews)
{
	int ii, jj, npts = WC.size();
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		for (jj = 0; jj < npts; jj++)
		{
			num1 = P[ii * 12 + 0] * WC[jj].x + P[ii * 12 + 1] * WC[jj].y + P[ii * 12 + 2] * WC[jj].z + P[ii * 12 + 3];
			num2 = P[ii * 12 + 4] * WC[jj].x + P[ii * 12 + 5] * WC[jj].y + P[ii * 12 + 6] * WC[jj].z + P[ii * 12 + 7];
			denum = P[ii * 12 + 8] * WC[jj].x + P[ii * 12 + 9] * WC[jj].y + P[ii * 12 + 10] * WC[jj].z + P[ii * 12 + 11];

			pts[ii*npts + jj].x = num1 / denum, pts[ii*npts + jj].y = num2 / denum;
		}
		if (camera != NULL)
			for (jj = 0; jj < npts; jj++)
				LensDistortionPoint(&pts[ii*npts + jj], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void Stereo_Triangulation(Point2d *pts1, Point2d *pts2, double *P1, double *P2, Point3d *WC, int npts)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < npts; ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1*p31;
		A[1] = p12 - u1*p32;
		A[2] = p13 - u1*p33;
		A[3] = p21 - v1*p31;
		A[4] = p22 - v1*p32;
		A[5] = p23 - v1*p33;

		A[6] = P11 - u2*P31;
		A[7] = P12 - u2*P32;
		A[8] = P13 - u2*P33;
		A[9] = P21 - v2*P31;
		A[10] = P22 - v2*P32;
		A[11] = P23 - v2*P33;

		B[0] = u1*p34 - p14;
		B[1] = v1*p34 - p24;
		B[2] = u2*P34 - P14;
		B[3] = v2*P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC[ii].x = B[0];
		WC[ii].y = B[1];
		WC[ii].z = B[2];
	}

	return;
}
void Stereo_Triangulation(vector<Point2d> pts1, vector<Point2d> pts2, double *P1, double *P2, vector<Point3d> &WC)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < (int)pts1.size(); ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1*p31;
		A[1] = p12 - u1*p32;
		A[2] = p13 - u1*p33;
		A[3] = p21 - v1*p31;
		A[4] = p22 - v1*p32;
		A[5] = p23 - v1*p33;

		A[6] = P11 - u2*P31;
		A[7] = P12 - u2*P32;
		A[8] = P13 - u2*P33;
		A[9] = P21 - v2*P31;
		A[10] = P22 - v2*P32;
		A[11] = P23 - v2*P33;

		B[0] = u1*p34 - p14;
		B[1] = v1*p34 - p24;
		B[2] = u2*P34 - P14;
		B[3] = v2*P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC.push_back(Point3d(B[0], B[1], B[2]));
	}

	return;
}
void TwoViewTriangulationQualityCheck(Point2d *pts1, Point2d *pts2, Point3d *WC, double *P1, double *P2, bool *GoodPoints, double thresh, int npts, double *K1, double *K2, double *distortion1, double *distortion2)
{
	double u1, v1, u2, v2, denum, reprojectionError;
	for (int ii = 0; ii < npts; ii++)
	{
		Point2d p1(pts1[ii].x, pts1[ii].y), p2(pts2[ii].x, pts2[ii].y);
		if (distortion1 != NULL)
		{
			LensCorrectionPoint(&p1, K1, distortion1);
			LensCorrectionPoint(&p2, K2, distortion2);
		}

		//Project to 1st view
		denum = P1[8] * WC[ii].x + P1[9] * WC[ii].y + P1[10] * WC[ii].z + P1[11];
		u1 = (P1[0] * WC[ii].x + P1[1] * WC[ii].y + P1[2] * WC[ii].z + P1[3]) / denum;
		v1 = (P1[4] * WC[ii].x + P1[5] * WC[ii].y + P1[6] * WC[ii].z + P1[7]) / denum;

		//Project to 2nd view
		denum = P2[8] * WC[ii].x + P2[9] * WC[ii].y + P2[10] * WC[ii].z + P2[11];
		u2 = (P2[0] * WC[ii].x + P2[1] * WC[ii].y + P2[2] * WC[ii].z + P2[3]) / denum;
		v2 = (P2[4] * WC[ii].x + P2[5] * WC[ii].y + P2[6] * WC[ii].z + P2[7]) / denum;

		reprojectionError = (abs(u2 - p2.x) + abs(v2 - p2.y) + abs(u1 - p1.x) + abs(v1 - p1.y)) / 4.0;
		if (reprojectionError > thresh)
			GoodPoints[ii] = false;
		else
			GoodPoints[ii] = true;
	}
	return;
}
void NviewTriangulation(Point2d *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(vector<Point2d> *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(CameraData *ViewInfo, int nviews, vector <vector<int> > &viewIdAll3D, vector<vector<Point2d> > &uvAll3D, vector<Point3d> &AllP3D, bool CayleyRS)
{
	int count;

	double *P = new double[12 * nviews], *A = new double[6 * nviews], *B = new double[2 * nviews], *points2d = new double[nviews * 2];

	double error, point3d[3];
	Point3d p3d;
	vector<Point2d> p2d;
	for (int ii = 0; ii < (int)viewIdAll3D.size(); ii++)
	{
		if (viewIdAll3D[ii].size() > 1)
		{
			p2d.clear();
			count = 0;
			for (int jj = 0; jj < viewIdAll3D[ii].size(); jj++)
			{
				if (ViewInfo[viewIdAll3D[ii][jj]].valid)
				{
					for (int kk = 0; kk < 12; kk++)
						P[count * 12 + kk] = ViewInfo[viewIdAll3D[ii][jj]].P[kk];
					p2d.push_back(uvAll3D[ii][jj]);

					int viewID = viewIdAll3D[ii][jj];
					LensCorrectionPoint(&p2d[count], ViewInfo[viewID].K, ViewInfo[viewID].distortion);
					count++;
				}
			}

			NviewTriangulation(&p2d, P, &p3d, count, 1, NULL, A, B);

			point3d[0] = p3d.x, point3d[1] = p3d.y, point3d[2] = p3d.z;
			for (int jj = 0; jj < count; jj++)
				points2d[2 * jj] = p2d[jj].x, points2d[2 * jj + 1] = p2d[jj].y;

			if (!CayleyRS)
				NviewTriangulationNonLinear(P, points2d, point3d, &error, count, 1);
			else
				NviewTriangulationNonLinearCayley(ViewInfo, points2d, point3d, &error, nviews, 1);

			AllP3D[ii] = Point3d(point3d[0], point3d[1], point3d[2]);
		}
	}
	delete[]P, delete[]A, delete[]B, delete[]points2d;

	return;
}
double NviewTriangulationRANSAC(Point2d *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
		tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		//Pick a random pair to triangulate
		Point pair;
		bestCount = 0;
		for (kk = 0; kk < MaxRanSacIter; kk++)
		{
			pair.x = int(UniformNoise(nview - 1, 0));
			while (true)
			{
				pair.y = int(UniformNoise(nview - 1, 0));
				if (pair.y != pair.x)
					break;
			}
			Stereo_Triangulation(&pts[ii + pair.x*npts], &pts[ii + pair.y*npts], &P[12 * pair.x], &P[12 * pair.y], &t3D);

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				_pt = pts[ii + jj*npts];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii + jj*npts].x) < threshold && abs(_pt.y - pts[ii + jj*npts].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll<nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount> nview*inlierPercent)
				break;
		}

		int t = nview*inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;
				goodpts2d[count] = pts[jj], goodpts2dbk[count] = pts[jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u*tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u*tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u*tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v*tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v*tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v*tP[12 * jj + 10];
				B[2 * jj + 0] = u*tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v*tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac)
			{
				goodCount = 0; finalerror = 0.0;
				Inliers[ii].clear();
				for (jj = 0; jj < nview; jj++)
				{
					ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
					double difx = _pt.x - pts[ii + jj*npts].x, dify = _pt.y - pts[ii + jj*npts].y, error = pow(difx, 2) + pow(dify, 2);

					if (error < threshold*threshold)
					{
						finalerror += error;
						Inliers[ii].push_back(1);

						GoodViewID[jj] = true;
						tP[12 * goodCount + ll] = P[12 * jj + ll];
						goodpts2dbk[goodCount] = pts[ii + jj*npts];
						P2D[2 * goodCount] = pts[ii + jj*npts].x, P2D[2 * goodCount + 1] = pts[ii + jj*npts].y;
						goodCount++;
					}
					else
						GoodViewID[jj] = false, Inliers[ii].push_back(0);
				}
				finalerror = sqrt(finalerror / goodCount);

				if (goodCount > bestCount)
				{
					NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
					WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

					finalerror = 0.0;
					for (jj = 0; jj < goodCount; jj++)
					{
						ProjectandDistort(WC[ii], goodpts2d, tP + 12 * jj, NULL, NULL, 1);
						finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
					}
					finalerror = sqrt(finalerror / goodCount);
				}
				if (finalerror < threshold)
					PassedTri[ii] = true;
				else
					PassedTri[ii] = false;
			}
		}
	}

	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
double NviewTriangulationRANSAC(vector<Point2d> *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
		tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		//Pick a random pair to triangulate
		Point pair;
		bestCount = 0;
		for (kk = 0; kk < MaxRanSacIter; kk++)
		{
			pair.x = int(UniformNoise(nview - 1, 0));
			while (true)
			{
				pair.y = int(UniformNoise(nview - 1, 0));
				if (pair.y != pair.x)
					break;
			}
			//Stereo_Triangulation(&pts[ii + pair.x*npts], &pts[ii + pair.y*npts], &P[12 * pair.x], &P[12 * pair.y], &t3D);
			Stereo_Triangulation(&pts[ii].at(pair.x), &pts[ii].at(pair.y), &P[12 * pair.x], &P[12 * pair.y], &t3D);

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				//_pt = pts[ii + jj*npts];
				_pt = pts[ii][jj];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii][jj].x) < threshold && abs(_pt.y - pts[ii][jj].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll<nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount> nview*inlierPercent)
				break;
		}

		int t = nview*inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					//pts[ii + jj*npts].x = 0.0, pts[ii + jj*npts].y = 0.0;
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii][jj].x, v = pts[ii][jj].y;
				goodpts2d[count] = pts[ii][jj], goodpts2dbk[count] = pts[ii][jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u*tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u*tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u*tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v*tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v*tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v*tP[12 * jj + 10];
				B[2 * jj + 0] = u*tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v*tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac)
			{
				goodCount = 0; finalerror = 0.0;
				Inliers[ii].clear();
				for (jj = 0; jj < nview; jj++)
				{
					ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
					double difx = _pt.x - pts[ii][jj].x, dify = _pt.y - pts[ii][jj].y, error = pow(difx, 2) + pow(dify, 2);

					if (error < threshold*threshold)
					{
						finalerror += error;
						Inliers[ii].push_back(1);

						GoodViewID[jj] = true;
						tP[12 * goodCount + ll] = P[12 * jj + ll];
						goodpts2dbk[goodCount] = pts[ii][jj];
						P2D[2 * goodCount] = pts[ii][jj].x, P2D[2 * goodCount + 1] = pts[ii][jj].y;
						goodCount++;
					}
					else
						GoodViewID[jj] = false, Inliers[ii].push_back(0);
				}
				finalerror = sqrt(finalerror / goodCount);

				if (goodCount > bestCount)
				{
					NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
					WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

					finalerror = 0.0;
					for (jj = 0; jj < goodCount; jj++)
					{
						ProjectandDistort(WC[ii], goodpts2d, tP + 12 * jj, NULL, NULL, 1);
						finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
					}
					finalerror = sqrt(finalerror / goodCount);
				}
				if (finalerror < threshold)
					PassedTri[ii] = true;
				else
					PassedTri[ii] = false;
			}
		}
	}

	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
void MultiViewQualityCheck(Point2d *Pts, double *Pmat, int LensType, double *K, double *distortion, bool *PassedPoints, int nviews, int npts, double thresh, Point3d *aWC, Point2d *apts, Point2d *bkapts, int *DeviceMask, double *tK, double *tdistortion, double *tP, double *A, double *B)
{
	//Pts: [pts1; pts2; ...; ptsN]: (npts X nviews) matrix
	int ii, jj, kk, devCount;
	Point3d WC;
	bool createMem = false;
	double error;

	if (apts == NULL)
	{
		createMem = true;
		apts = new Point2d[nviews], bkapts = new Point2d[nviews], DeviceMask = new int[nviews];
		tK = new double[9 * nviews], tdistortion = new double[7 * nviews], tP = new double[12 * nviews];
	}

	for (ii = 0; ii < npts; ii++)
	{
		devCount = 0;
		for (jj = 0; jj < nviews; jj++)
		{
			DeviceMask[jj] = 1;
			if (Pts[jj + ii*nviews].x < 1 || Pts[jj + ii*nviews].y < 1)
				DeviceMask[jj] = 0;
			else
			{
				bkapts[devCount].x = Pts[jj + ii*nviews].x, bkapts[devCount].y = Pts[jj + ii*nviews].y;
				apts[devCount].x = bkapts[devCount].x, apts[devCount].y = bkapts[devCount].y;
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					LensCorrectionPoint(&apts[devCount], K + 9 * jj, distortion + 7 * jj);
				else
					FishEyeCorrectionPoint(&apts[devCount], distortion[7 * jj], distortion[7 * jj + 1], distortion[7 * jj + 2]);

				for (kk = 0; kk < 12; kk++)
					tP[12 * devCount + kk] = Pmat[12 * jj + kk];
				for (kk = 0; kk < 9; kk++)
					tK[9 * devCount + kk] = K[9 * jj + kk];
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					for (kk = 0; kk < 7; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				else
					for (kk = 0; kk < 3; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				devCount++;
			}
		}

		NviewTriangulation(apts, tP, &WC, devCount, 1, NULL, A, B);
		aWC[ii] = WC;
		if (LensType == RADIAL_TANGENTIAL_PRISM)
			ProjectandDistort(WC, apts, tP, tK, tdistortion, devCount);
		else
			FisheyeProjectandDistort(WC, apts, tP, tdistortion, devCount);

		error = 0.0;
		for (jj = 0; jj < devCount; jj++)
			error += pow(bkapts[jj].x - apts[jj].x, 2) + pow(bkapts[jj].y - apts[jj].y, 2);
		error = sqrt(error / devCount);
		if (error < thresh)
			PassedPoints[ii] = true;
		else
			PassedPoints[ii] = false;
	}

	if (createMem)
	{
		delete[]apts, delete[]bkapts, delete[]DeviceMask;
		delete[]tK, delete[]tdistortion, delete[]tP;
	}

	return;
}
void NviewTriangulationRANSACDriver(CameraData *AllViewsInfo, vector<int>Selected3DIndex, vector<int> *nSelectedViews, vector<Point2d> *Selected2D, int nviews)
{
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *P = new double[12 * nviews * 2];
	double *tP = new double[12 * nviews * 2];
	int *BestViewID = new int[nviews * 2];
	bool *passedTri = new bool[nviews * 2];

	Point3d t3D;
	for (int ii = 0; ii < Selected3DIndex.size(); ii++)
	{
		int nviewsII = nSelectedViews[ii].size();
		if (nviewsII <= 2 * nviews)
		{
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}

			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);
		}
		else
		{
			double *A = new double[6 * nviewsII];
			double *B = new double[2 * nviewsII];
			double *P = new double[12 * nviewsII];
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}
			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);

			delete[]A, delete[]B, delete[]P;
		}

	}
	delete[]A, delete[]B, delete[]P, delete[]BestViewID;

	return;
}
struct PinholeReprojectionErrorSimpleError {
	PinholeReprojectionErrorSimpleError(double *Pmat, double u, double v)
	{
		P = Pmat, observed_x = u, observed_y = v;
	}

	template <typename T>	bool operator()(const T* const points, T* residuals) 	const
	{
		T numX = (T)P[0] * points[0] + (T)P[1] * points[1] + (T)P[2] * points[2] + (T)P[3];
		T numY = (T)P[4] * points[0] + (T)P[5] * points[1] + (T)P[6] * points[2] + (T)P[7];
		T denum = (T)P[8] * points[0] + (T)P[9] * points[1] + (T)P[10] * points[2] + (T)P[11];

		residuals[0] = numX / denum - T(observed_x);
		residuals[1] = numY / denum - T(observed_y);

		return true;
	}

	static ceres::CostFunction* Create(double *Pmat, const double observed_x, const double observed_y)
	{
		return (new ceres::AutoDiffCostFunction<PinholeReprojectionErrorSimpleError, 2, 3>(new PinholeReprojectionErrorSimpleError(Pmat, observed_x, observed_y)));
	}

	double observed_x, observed_y, *P;
};
double PinholeReprojectionErrorSimpleDebug(double *P, Point3d Point, Point2d uv)
{
	double numX = P[0] * Point.x + P[1] * Point.y + P[2] * Point.z + P[3];
	double numY = P[4] * Point.x + P[5] * Point.y + P[6] * Point.z + P[7];
	double denum = P[8] * Point.x + P[9] * Point.y + P[10] * Point.z + P[11];

	double residual = sqrt(pow(numX / denum - uv.x, 2) + pow(numY / denum - uv.y, 2));
	return residual;
}
void NviewTriangulationNonLinear(double *P, double *Point2D, double *Point3D, double *ReprojectionError, int nviews, int npts)
{
	ceres::Problem problem;

	//printf("Error before: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			ReprojectionError[ii] += PinholeReprojectionErrorSimpleDebug(P + 12 * jj, Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]));
			ceres::CostFunction* cost_function = PinholeReprojectionErrorSimpleError::Create(P + 12 * jj, Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]);
			problem.AddResidualBlock(cost_function, NULL, &Point3D[ii]);
		}
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.FullReport() << "\n";

	//printf("Error after: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
			ReprojectionError[ii] += PinholeReprojectionErrorSimpleDebug(P + 12 * jj, Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]));
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	return;
}

double MinDistanceTwoLines(double *P0, double *u, double *Q0, double *v, double &s, double &t)
{
	//http://geomalgorithms.com/a07-_distance.html
	double w0[] = { P0[0] - Q0[0], P0[1] - Q0[1], P0[2] - Q0[2] };
	double a = dotProduct(u, u), b = dotProduct(u, v), c = dotProduct(v, v), d = dotProduct(u, w0), e = dotProduct(v, w0);
	double denum = a*c - b*b;

	double distance = 0.0;
	if (denum < 0.00001)//Near parallel line
	{
		s = 0.0, t = d / b;
		double Q[] = { Q0[0] + t*v[0], Q0[1] + t*v[1], Q0[2] + t*v[2] };
		distance = sqrt(pow(P0[0] - Q[0], 2) + pow(P0[1] - Q[1], 2) + pow(P0[2] - Q[2], 2));
	}
	else
	{
		s = (b*e - c*d) / denum, t = (a*e - b*d) / denum;
		double P[] = { P0[0] + s*u[0], P0[1] + s*u[1], P0[2] + s*u[2] };
		double Q[] = { Q0[0] + t*v[0], Q0[1] + t*v[1], Q0[2] + t*v[2] };
		distance = sqrt(pow(P[0] - Q[0], 2) + pow(P[1] - Q[1], 2) + pow(P[2] - Q[2], 2));
	}

	return distance;
}

template <typename Type>void Normalize(Point3_<Type>& vect)
{
	double dist = vect.x*vect.x + vect.y*vect.y + vect.z*vect.z;
	dist = std::sqrt(dist);
	vect.x /= (float)dist;
	vect.y /= (float)dist;
	vect.z /= (float)dist;
}
template <typename Type>double Distance(Point3_<Type>& pt_1, Point3_<Type>& pt_2)
{
	double dist = pow(double(pt_1.x - pt_2.x), 2) + pow(double(pt_1.y - pt_2.y), 2) + pow(double(pt_1.z - pt_2.z), 2);
	return sqrt(dist);
}
void Get3DPtfromDist(double *Kinv, double *Rinv, double *T, Point2d& pt, double depth, Point3d &pt3D)
{
	Mat ptMat = Mat::ones(3, 1, CV_64F);
	Mat mKinv(3, 3, CV_64F, Kinv);
	Mat mRinv(3, 3, CV_64F, Rinv);
	Mat mT(3, 1, CV_64F, T);

	ptMat.at<double>(0, 0) = pt.x;
	ptMat.at<double>(1, 0) = pt.y;


	ptMat = mKinv *ptMat;
	ptMat = ptMat / ptMat.at<double>(2, 0);
	ptMat = ptMat * depth;
	ptMat = mRinv * (ptMat - mT);//from cam coord to world coord

	pt3D.x = ptMat.at<double>(0, 0);
	pt3D.y = ptMat.at<double>(1, 0);
	pt3D.z = ptMat.at<double>(2, 0);

	return;
}
bool SelectRefCam_InitPatchFixedScale(Point3d *expansionVec, double &scale3D, Point3d p3D, vector<KeyPoint> pts, vector<CameraData> AllViewsInfo, double PATCH_3D_ARROW_SIZE_WORLD_UNIT)
{
	//reference frame
	double bestScale = -1;
	int bestVisibleIdx = -1;

	//Find the one which has the largest SIFT scale. 
	for (unsigned int i = 0; i < pts.size(); ++i)
	{
		double scale = pts[i].size;		//This is the diameter!!! 
		double patchHalfSize = scale / 2.0;

		double xMax = pts[i].pt.x + scale;
		double xMin = pts[i].pt.x - scale;
		double yMax = pts[i].pt.y + scale;
		double yMin = pts[i].pt.y - scale;

		if (xMin < 10 || yMin < 10 || xMax >= AllViewsInfo[i].width - 10 || yMax >= AllViewsInfo[i].height - 10)
			continue;

		if (scale > bestScale)
		{
			bestScale = scale;
			bestVisibleIdx = i;
		}
	}
	if (bestVisibleIdx < 0)
		return false;

	//X = R*WC+T --> last element of X is dept wrst to that visible camera
	double depth = AllViewsInfo[bestVisibleIdx].R[6] * p3D.x + AllViewsInfo[bestVisibleIdx].R[7] * p3D.y + AllViewsInfo[bestVisibleIdx].R[8] * p3D.z + AllViewsInfo[bestVisibleIdx].T[2];
	Point2d keyPt = pts[bestVisibleIdx].pt;  ///pt should be also located on the ray

	//feature arrow calculation
	double length = pts[bestVisibleIdx].size / 2.0;
	double theta = pts[bestVisibleIdx].angle;//in radian
	Point2d arrowHead1(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);
	theta -= Pi / 2.0;//in radian
	Point2d arrowHead2(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);

	//initialize with patch wich is parallel to reference image
	Point3d PatchCenter;
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, keyPt, depth, PatchCenter);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead1, depth, expansionVec[0]);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead2, depth, expansionVec[1]);

	//Change to the fixed 3D Patch Scale
	Point3d arrow1Direct = expansionVec[0] - PatchCenter;
	Normalize(arrow1Direct);
	expansionVec[0] = PatchCenter + arrow1Direct* PATCH_3D_ARROW_SIZE_WORLD_UNIT;
	Point3d arrow2Direct = expansionVec[1] - PatchCenter;
	Normalize(arrow2Direct);
	expansionVec[1] = PatchCenter + arrow2Direct* PATCH_3D_ARROW_SIZE_WORLD_UNIT;

	scale3D = Distance(PatchCenter, expansionVec[0]);

	return true;
}

int CameraProjector3DReconstructionFmat(CameraData *AllViewsInfo, Point2d *PCcorres, Point3d *ThreeD, int *CameraPair, int nCams, int nProjectors, int nPpts)
{
	int ii, jj;

	//Estimate fundamental matrix
	vector<int> pid;
	vector<Point2f>imgpts1, imgpts2;
	for (ii = 0; ii < nPpts*nProjectors; ii++)
	{
		if (PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].x > 0.0001 && PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].x > 0.0001)
		{
			pid.push_back(ii);
			imgpts1.push_back(Point2f(PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].x, PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].y));
			imgpts2.push_back(Point2f(PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].x, PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].y));
		}
	}
	Mat cvF = findFundamentalMat(imgpts1, imgpts2, FM_8POINT, 0.1, 0.99);

	cout << "Fmat: " << endl;
	cout << cvF << endl << endl;

	//Extract essential matrix
	Mat cvK1(3, 3, CV_64F, AllViewsInfo[CameraPair[0]].K);
	Mat cvK2(3, 3, CV_64F, AllViewsInfo[CameraPair[1]].K);

	Mat cvE = cvK2.t()*cvF*cvK1;
	cout << "Emat: " << endl;
	cout << cvE << endl << endl;

	//Decompose into RT
	SVD svd(cvE, SVD::MODIFY_A);
	double m = (svd.w.at<double>(0) + svd.w.at<double>(1)) / 2;
	double nW[9] = { m, 0, 0, 0, m, 0, 0, 0, 0 };
	Mat cvnW(3, 3, CV_64F, nW);
	Mat cvnE = svd.u*cvnW*svd.vt;
	SVD svd2(cvnE, SVD::MODIFY_A);

	cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = -1.0, cvnW.at<double>(0, 2) = 0.0;
	cvnW.at<double>(1, 0) = 1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
	cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = 1.0;

	//Make sure we return rotation matrices with det(R) == 1
	Mat UWVt = svd2.u*cvnW*svd2.vt;
	if (determinant(UWVt) < 0.0)
	{
		cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = 1.0, cvnW.at<double>(0, 2) = 0.0;
		cvnW.at<double>(1, 0) = -1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
		cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = -1.0;
	}

	UWVt = svd2.u*cvnW*svd2.vt;
	Mat UWtVt = svd2.u*cvnW.t()*svd2.vt;

	double maxU = 0.0;
	for (ii = 0; ii < 3; ii++)
		if (maxU < abs(svd2.u.at<double>(ii, 2)))
			maxU = abs(svd2.u.at<double>(ii, 2));

	//There are 4 possible cases
	double RT2[] = { UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU };

	//Cherality check
	double P1[12], P2[48], RT1[] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };
	mat_mul(AllViewsInfo[CameraPair[0]].K, RT1, P1, 3, 3, 4);
	for (ii = 0; ii < 4; ii++)
		mat_mul(AllViewsInfo[CameraPair[1]].K, RT2 + 12 * ii, P2 + 12 * ii, 3, 3, 4);

	Point2d pt1, pt2; Point3d WC;
	int positivePoints[4] = { 0, 0, 0, 0 }, RTid[4] = { 0, 1, 2, 3 };
	for (ii = 0; ii < imgpts1.size(); ii++)
	{
		pt1.x = imgpts1[ii].x, pt1.y = imgpts1[ii].y;
		pt2.x = imgpts2[ii].x, pt2.y = imgpts2[ii].y;

		for (jj = 0; jj<4; jj++)
		{
			//Stereo_Triangulation2(&pt1, &pt2, P1, P2+12*jj, &WC); 
			if (WC.z > 0.0)
				positivePoints[jj] ++;
		}
	}

	Quick_Sort_Int(positivePoints, RTid, 0, 3);
	if (positivePoints[3] < 10)
	{
		cout << "Something wrong. Only a few points have positve z values" << endl;
		return 1;
	}

	/*for(ii=0; ii<6; ii++)
	AllViewsInfo[CameraPair[0]].rt[ii] = 0.0;

	Mat rvec, Rmat = (Mat_<double>(3,3) << RT2[RTid[3]*12], RT2[RTid[3]*12+1], RT2[RTid[3]*12+2],
	RT2[RTid[3]*12+4], RT2[RTid[3]*12+5], RT2[RTid[3]*12+6],
	RT2[RTid[3]*12+8], RT2[RTid[3]*12+9], RT2[RTid[3]*12+10]);
	Rodrigues( Rmat, rvec);

	for(ii=0; ii<3; ii++)
	{
	AllViewsInfo[CameraPair[1]].RT[ii] = rvec.at<double>(ii);
	AllViewsInfo[CameraPair[1]].RT[ii+3] = RT2[RTid[3]*12+3+4*ii];
	}

	//Triangulate
	for(ii = 0; ii<nPpts*nProjectors; ii++ )
	{
	if(PCcorres[CameraPair[0]+ii*(nProjectors+nCams)].x > 0.0001 && PCcorres[CameraPair[1]+ii*(nProjectors+nCams)].x > 0.0001)
	;//Stereo_Triangulation(&PCcorres[CameraPair[0]+ii*(nProjectors+nCams)], &PCcorres[CameraPair[1]+ii*(nProjectors+nCams)], P1, P2+12*RTid[3], &ThreeD[ii]);
	else
	{
	ThreeD[ii].x = 0.0, ThreeD[ii].y = 0.0, ThreeD[ii].z = 0.0;
	}
	}*/
	return 0;
}
int TwoViewsClean3DReconstructionFmat(CameraData &View1, CameraData &View2, vector<Point2d>imgpts1, vector<Point2d> imgpts2, vector<Point3d> &P3D)
{
	//Assuming correspondences are perfect. Note that points are not undistorted
	int ii, jj;
	int npts = (int)imgpts1.size();

	if (View1.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts1, View1.K, View1.distortion);
	else
		FishEyeCorrectionPoint(imgpts1, View1.distortion[0], View1.distortion[1], View1.distortion[2]);

	if (View2.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts2, View2.K, View2.distortion);
	else
		FishEyeCorrectionPoint(imgpts2, View2.distortion[0], View2.distortion[1], View2.distortion[2]);

	//Estimate fundamental matrix
	vector<int> pid;
	Mat cvF = findFundamentalMat(imgpts1, imgpts2, FM_8POINT, 3.0);

	//cout << "Fmat: " << cvF << endl << endl;

	//Extract essential matrix
	Mat cvK1(3, 3, CV_64F, View1.K);
	Mat cvK2(3, 3, CV_64F, View2.K);

	Mat cvE = cvK2.t()*cvF*cvK1;
	//cout << "Emat: " << cvE << endl << endl;

	//Decompose into RT
	SVD svd(cvE, SVD::MODIFY_A);
	double m = (svd.w.at<double>(0) + svd.w.at<double>(1)) / 2;
	double nW[9] = { m, 0, 0, 0, m, 0, 0, 0, 0 };
	Mat cvnW(3, 3, CV_64F, nW);
	Mat cvnE = svd.u*cvnW*svd.vt;
	SVD svd2(cvnE, SVD::MODIFY_A);

	cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = -1.0, cvnW.at<double>(0, 2) = 0.0;
	cvnW.at<double>(1, 0) = 1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
	cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = 1.0;

	//Make sure we return rotation matrices with det(R) == 1
	Mat UWVt = svd2.u*cvnW*svd2.vt;
	if (determinant(UWVt) < 0.0)
	{
		cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = 1.0, cvnW.at<double>(0, 2) = 0.0;
		cvnW.at<double>(1, 0) = -1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
		cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = -1.0;
	}

	UWVt = svd2.u*cvnW*svd2.vt;
	Mat UWtVt = svd2.u*cvnW.t()*svd2.vt;

	double maxU = 0.0;
	for (ii = 0; ii < 3; ii++)
		if (maxU < abs(svd2.u.at<double>(ii, 2)))
			maxU = abs(svd2.u.at<double>(ii, 2));

	//There are 4 possible cases
	double RT2[] = { UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU };

	//Cherality check
	double P1[12], P2[48], RT1[] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };
	mat_mul(View1.K, RT1, P1, 3, 3, 4);
	for (ii = 0; ii < 4; ii++)
		mat_mul(View2.K, RT2 + 12 * ii, P2 + 12 * ii, 3, 3, 4);

	Point3d p3d;
	int positivePoints[4] = { 0, 0, 0, 0 }, RTid[4] = { 0, 1, 2, 3 };
	for (ii = 0; ii < imgpts1.size(); ii++)
	{
		for (jj = 0; jj<4; jj++)
		{
			Stereo_Triangulation(&imgpts1[ii], &imgpts2[ii], P1, P2 + 12 * jj, &p3d);
			if (p3d.z > 0.0)
				positivePoints[jj] ++;
		}
	}

	Quick_Sort_Int(positivePoints, RTid, 0, 3);
	if (positivePoints[3] < 10)
	{
		cout << "Something wrong. Only a few points have positve z values" << endl;
		return 1;
	}

	//Finalize data
	for (ii = 0; ii < 3; ii++)
		View1.rt[ii] = 0.0, View1.rt[ii + 3] = 0.0;

	Mat rvec, Rmat = (Mat_<double>(3, 3) << RT2[RTid[3] * 12], RT2[RTid[3] * 12 + 1], RT2[RTid[3] * 12 + 2],
		RT2[RTid[3] * 12 + 4], RT2[RTid[3] * 12 + 5], RT2[RTid[3] * 12 + 6],
		RT2[RTid[3] * 12 + 8], RT2[RTid[3] * 12 + 9], RT2[RTid[3] * 12 + 10]);
	Rodrigues(Rmat, rvec);

	for (ii = 0; ii < 3; ii++)
		View2.rt[ii] = rvec.at<double>(ii), View2.rt[ii + 3] = RT2[RTid[3] * 12 + 3 + 4 * ii];

	//Triangulate
	Stereo_Triangulation(imgpts1, imgpts2, P1, P2 + 12 * RTid[3], P3D);

	return 0;
}
int TwoCameraReconstruction(char *Path, CameraData *AllViewsInfo, int nviews, int timeID, vector<int> cumulativePts, vector<int>*PointCorres, vector<int> availViews, Point3d *ThreeD)
{
	vector<int>CorrespondencesID, SelectedIndex;
	vector<KeyPoint>keypoints1, keypoints2;
	CorrespondencesID.reserve(10000), SelectedIndex.reserve(10000), keypoints1.reserve(20000), keypoints1.reserve(20000);
	//GetPoint2DPairCorrespondence(Path, nviews, timeID, cumulativePts, availViews, keypoints1, keypoints2, CorrespondencesID, SelectedIndex, true);

	int npts = CorrespondencesID.size() / 2;
	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = CorrespondencesID.at(2 * ii), id2 = CorrespondencesID.at(2 * ii + 1);
		pts1[ii].x = keypoints1.at(id1).pt.x, pts1[ii].y = keypoints1.at(id1).pt.y;
		pts2[ii].x = keypoints2.at(id2).pt.x, pts2[ii].y = keypoints2.at(id2).pt.y;
	}

	if (AllViewsInfo[availViews.at(0)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		LensCorrectionPoint(pts1, AllViewsInfo[availViews.at(0)].K, AllViewsInfo[availViews.at(0)].distortion, npts);
		LensCorrectionPoint(pts2, AllViewsInfo[availViews.at(1)].K, AllViewsInfo[availViews.at(1)].distortion, npts);
	}

	Mat x1s(npts, 2, CV_64F), x2s(npts, 2, CV_64F);
	for (int ii = 0; ii < npts; ii++)
	{
		x1s.at<double>(ii, 0) = pts1[ii].x, x1s.at<double>(ii, 1) = pts1[ii].y;
		x2s.at<double>(ii, 0) = pts2[ii].x, x2s.at<double>(ii, 1) = pts2[ii].y;
	}

	Mat cvK1 = Mat(3, 3, CV_64F, AllViewsInfo[availViews.at(0)].K);
	Mat cvK2 = Mat(3, 3, CV_64F, AllViewsInfo[availViews.at(1)].K);

	Mat E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, 0.99, 1, 200, noArray());

	Mat R_5pt, rvec_5pt, tvec_5pt;
	recoverPose(E, x1s, x2s, R_5pt, tvec_5pt, cvK1, cvK2, noArray());
	//Rodrigues(R_5pt, rvec_5pt);

	Mat cvP1(3, 4, CV_64F), cvP2(3, 4, CV_64F);
	cvP1 = Mat::eye(3, 4, CV_64F); cvP1 = cvK1*cvP1;
	cvP2(Range::all(), Range(0, 3)) = R_5pt * 1.0; cvP2.col(3) = tvec_5pt * 1.0;  cvP2 = cvK2*cvP2;

	Mat cvThreeD;
	x1s = x1s.t(), x2s = x2s.t();
	triangulatePoints(cvP1, cvP2, x1s, x2s, cvThreeD);

	cvThreeD.row(0) /= cvThreeD.row(3);
	cvThreeD.row(1) /= cvThreeD.row(3);
	cvThreeD.row(2) /= cvThreeD.row(3);
	cvThreeD.row(3) /= cvThreeD.row(3);

	bool *goodPoints = new bool[npts];
	Point3d *t3D = new Point3d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		t3D[ii].x = cvThreeD.at<double>(0, ii);
		t3D[ii].y = cvThreeD.at<double>(1, ii);
		t3D[ii].z = cvThreeD.at<double>(2, ii);
	}

	double P1[12], P2[12];
	for (int ii = 0; ii < 12; ii++)
		P1[ii] = cvP1.at<double>(ii), P2[ii] = cvP2.at<double>(ii);

	double threshold = AllViewsInfo[0].threshold;
	TwoViewTriangulationQualityCheck(pts1, pts2, t3D, P1, P2, goodPoints, threshold, npts, NULL, NULL, NULL, NULL);

	int count = 0;
	for (int ii = 0; ii < npts; ii++)
	{
		if (goodPoints[ii])
		{
			count++;
			int id = SelectedIndex[ii];
			ThreeD[id].x = cvThreeD.at<double>(0, ii);
			ThreeD[id].y = cvThreeD.at<double>(1, ii);
			ThreeD[id].z = cvThreeD.at<double>(2, ii);
			for (int jj = 0; jj < PointCorres[id].size(); jj++)
				ThreeD[PointCorres[id].at(jj)] = ThreeD[id];
		}
	}

	AllViewsInfo[availViews.at(0)].R[0] = 1.0, AllViewsInfo[availViews.at(0)].R[1] = 0.0, AllViewsInfo[availViews.at(0)].R[2] = 0.0, AllViewsInfo[availViews.at(0)].T[0] = 0.0;
	AllViewsInfo[availViews.at(0)].R[3] = 0.0, AllViewsInfo[availViews.at(0)].R[4] = 1.0, AllViewsInfo[availViews.at(0)].R[5] = 0.0, AllViewsInfo[availViews.at(0)].T[1] = 0.0;
	AllViewsInfo[availViews.at(0)].R[6] = 0.0, AllViewsInfo[availViews.at(0)].R[7] = 0.0, AllViewsInfo[availViews.at(0)].R[8] = 1.0, AllViewsInfo[availViews.at(0)].T[2] = 0.0;

	for (int ii = 0; ii < 9; ii++)
		AllViewsInfo[availViews.at(1)].R[ii] = R_5pt.at<double>(ii);
	for (int ii = 0; ii < 3; ii++)
		AllViewsInfo[availViews.at(1)].T[ii] = tvec_5pt.at<double>(ii);

	//Update ViewParas
	GetrtFromRT(AllViewsInfo, availViews);
	GetIntrinsicFromK(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	/*FILE *fp = fopen("C:/temp/2d3D.txt", "w+");
	for (int ii = 0; ii < CorrespondencesID.size() / 2; ii++)
	if (goodPoints[ii])
	fprintf(fp, "%d %d\n", CorrespondencesID.at(2 * ii), SelectedIndex[ii]);
	fclose(fp);

	fp = fopen("C:/temp/2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	if (goodPoints[ii])
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", pts1[ii].x, pts1[ii].y, cvThreeD.at<double>(0, ii), cvThreeD.at<double>(1, ii), cvThreeD.at<double>(2, ii));
	fclose(fp);*/

	delete[]pts1, delete[]pts2, delete[]t3D, delete[]goodPoints;

	if (count < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", availViews.at(0), availViews.at(1), count);
		return 1;
	}
	else
		return 0;
}
void DetermineDevicePose(double *K, double *distortion, int LensModel, double *R, double *T, Point2d *pts, Point3d *ThreeD, int npts, int distortionCorrected, double thresh, int &ninliers)
{
	int ii;
	Mat cvpts(npts, 2, CV_32F), cv3D(npts, 3, CV_32F);

	if (distortionCorrected == 0 && LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(pts, K, distortion, npts);
	else if (distortionCorrected == 0 && LensModel == FISHEYE)
		FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2], npts);

	for (ii = 0; ii < npts; ii++)
	{
		cvpts.at<float>(ii, 0) = pts[ii].x, cvpts.at<float>(ii, 1) = pts[ii].y;
		cv3D.at<float>(ii, 0) = ThreeD[ii].x, cv3D.at<float>(ii, 1) = ThreeD[ii].y, cv3D.at<float>(ii, 2) = ThreeD[ii].z;
	}

	/*FILE *fp = fopen("C:/temp/_2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", cvpts.at<float>(ii, 0), cvpts.at<float>(ii, 1), cv3D.at<float>(ii,0), cv3D.at<float>(ii,1), cv3D.at<float>(ii,2));
	fclose(fp);*/

	Mat cvK = Mat(3, 3, CV_32F), rvec(1, 3, CV_32F), tvec(1, 3, CV_32F);
	for (ii = 0; ii < 9; ii++)
		cvK.at<float>(ii) = (float)K[ii];

	Mat Inliers;
	double ProThresh = 0.995, PercentInlier = 0.4;
	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	solvePnPRansac(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, iterMax, thresh, npts*PercentInlier, Inliers, CV_EPNP);// CV_ITERATIVE);

	ninliers = Inliers.rows;
	//cout << rvec << endl;
	//cout << tvec << endl;

	Mat Rmat(3, 3, CV_64F);
	Rodrigues(rvec, Rmat);
	for (ii = 0; ii < 9; ii++)
		R[ii] = Rmat.at<double>(ii);
	for (ii = 0; ii < 3; ii++)
		T[ii] = tvec.at<double>(ii);

	return;
}
void DetermineDevicePose(double *K, double *distortion, int LensModel, double *R, double *T, vector<Point2d> pts, vector<Point3d> ThreeD, int distortionCorrected, double thresh, int &ninliers, bool directMethod)
{
	int ii, npts = (int)pts.size();
	Mat cvpts(npts, 2, CV_32F), cv3D(npts, 3, CV_32F);

	if (distortionCorrected == 0 && LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(pts, K, distortion);
	else if (distortionCorrected == 0 && LensModel == FISHEYE)
		FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2]);

	for (ii = 0; ii < npts; ii++)
	{
		cvpts.at<float>(ii, 0) = pts[ii].x, cvpts.at<float>(ii, 1) = pts[ii].y;
		cv3D.at<float>(ii, 0) = ThreeD[ii].x, cv3D.at<float>(ii, 1) = ThreeD[ii].y, cv3D.at<float>(ii, 2) = ThreeD[ii].z;
	}

	/*FILE *fp = fopen("C:/temp/_2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", cvpts.at<float>(ii, 0), cvpts.at<float>(ii, 1), cv3D.at<float>(ii,0), cv3D.at<float>(ii,1), cv3D.at<float>(ii,2));
	fclose(fp);*/

	Mat cvK = Mat(3, 3, CV_32F), rvec(1, 3, CV_32F), tvec(1, 3, CV_32F);
	for (ii = 0; ii < 9; ii++)
		cvK.at<float>(ii) = (float)K[ii];

	if (directMethod)
		solvePnP(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, ITERATIVE);
	else
	{
		Mat Inliers;
		double ProThresh = 0.995, PercentInlier = 0.4;
		int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
		solvePnPRansac(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, iterMax, thresh, npts*PercentInlier, Inliers, CV_EPNP);// CV_ITERATIVE);

		ninliers = Inliers.rows;
	}
	cout << rvec << endl << tvec << endl;

	Mat Rmat(3, 3, CV_64F);
	Rodrigues(rvec, Rmat);
	for (ii = 0; ii < 9; ii++)
		R[ii] = Rmat.at<double>(ii);
	for (ii = 0; ii < 3; ii++)
		T[ii] = tvec.at<double>(ii);

	return;
}
int AddNewViewReconstruction(char *Path, CameraData *AllViewsInfo, int nviews, int timeID, vector<int> cumulativePts, vector<int>*PointCorres, Point3d *All3D, double threshold, vector<int> &availViews)
{
	int ii, jj, kk, ll;

	//Determine next view with highest number of correspondences
	int maxPoints = 0;
	vector<int>viewID; viewID.reserve(2); viewID.push_back(0), viewID.push_back(0);
	vector<int>checkedViews; checkedViews.reserve(100);
	for (ii = 0; ii < availViews.size(); ii++)
	{
		for (jj = 0; jj<checkedViews.size(); jj++)
		{
			if (availViews[ii] == checkedViews.at(jj))
				break;
		}

		if (jj == checkedViews.size())
		{
			checkedViews.push_back(availViews[ii]);
			kk = NextViewFinder(Path, nviews, timeID, availViews[ii], ll, availViews);
			if (ll>maxPoints)
				maxPoints = ll, viewID.at(0) = availViews[ii], viewID.at(1) = kk;
		}
	}
	availViews.push_back(viewID.at(1));
	sort(availViews.begin(), availViews.end());
	printf("Adding view %d to the list...", viewID.at(1));

	bool SwapView = viewID.at(0) < viewID.at(1) ? false : true;
	sort(viewID.begin(), viewID.end());

	//Get correspondences and their indices
	vector<KeyPoint> keypoints1, keypoints2;
	vector<int>TwoDcorrespondencesID, ThreeDCorrespondencesID, SelectedIndex;
	keypoints1.reserve(10000), keypoints2.reserve(10000);
	TwoDcorrespondencesID.reserve(10000), ThreeDCorrespondencesID.reserve(10000), SelectedIndex.reserve(10000);

	GetPoint3D2DPairCorrespondence(Path, nviews, timeID, cumulativePts, viewID, All3D, keypoints1, keypoints2, TwoDcorrespondencesID, ThreeDCorrespondencesID, SelectedIndex, SwapView);
	if (ThreeDCorrespondencesID.size() / 2 < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", viewID.at(0), viewID.at(1), ThreeDCorrespondencesID.size() / 2);
		return 1;
	}

	//Run PnP for pose estimation
	int npts = ThreeDCorrespondencesID.size() / 2;
	Point2d *pts = new Point2d[npts];
	Point3d *t3D = new Point3d[npts];

	for (ii = 0; ii < npts; ii++)
	{
		int id1 = ThreeDCorrespondencesID.at(2 * ii), id2 = ThreeDCorrespondencesID.at(2 * ii + 1);
		if (SwapView)
			pts[ii].x = keypoints1.at(id1).pt.x, pts[ii].y = keypoints1.at(id1).pt.y;
		else
			pts[ii].x = keypoints2.at(id1).pt.x, pts[ii].y = keypoints2.at(id1).pt.y;
		t3D[ii] = All3D[id2];
	}

	if (AllViewsInfo[viewID.at(1)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		if (SwapView)
			LensCorrectionPoint(pts, AllViewsInfo[viewID.at(0)].K, AllViewsInfo[viewID.at(0)].distortion, npts);
		else
			LensCorrectionPoint(pts, AllViewsInfo[viewID.at(1)].K, AllViewsInfo[viewID.at(1)].distortion, npts);
	}

	int ninliers, distortionCorrected = 0;
	if (SwapView)
		DetermineDevicePose(AllViewsInfo[viewID.at(0)].K, NULL, AllViewsInfo[viewID.at(0)].LensModel, AllViewsInfo[viewID.at(0)].R, AllViewsInfo[viewID.at(0)].T, pts, t3D, npts, distortionCorrected, AllViewsInfo[0].threshold * 2, ninliers);
	else
		DetermineDevicePose(AllViewsInfo[viewID.at(1)].K, NULL, AllViewsInfo[viewID.at(1)].LensModel, AllViewsInfo[viewID.at(1)].R, AllViewsInfo[viewID.at(1)].T, pts, t3D, npts, distortionCorrected, AllViewsInfo[0].threshold * 2, ninliers);
	delete[]pts, delete[]t3D;

	//Triangulate new points
	npts = TwoDcorrespondencesID.size() / 2;
	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = TwoDcorrespondencesID.at(2 * ii), id2 = TwoDcorrespondencesID.at(2 * ii + 1);
		pts1[ii].x = keypoints1.at(id1).pt.x, pts1[ii].y = keypoints1.at(id1).pt.y;
		pts2[ii].x = keypoints2.at(id2).pt.x, pts2[ii].y = keypoints2.at(id2).pt.y;
	}

	if (AllViewsInfo[viewID.at(0)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		LensCorrectionPoint(pts1, AllViewsInfo[viewID.at(0)].K, AllViewsInfo[viewID.at(0)].distortion, npts);
		LensCorrectionPoint(pts2, AllViewsInfo[viewID.at(1)].K, AllViewsInfo[viewID.at(1)].distortion, npts);
	}

	double P1[12], P2[12], RT1[12], RT2[12];
	AssembleRT(AllViewsInfo[viewID.at(0)].R, AllViewsInfo[viewID.at(0)].T, RT1);
	AssembleRT(AllViewsInfo[viewID.at(1)].R, AllViewsInfo[viewID.at(1)].T, RT2);

	mat_mul(AllViewsInfo[viewID.at(0)].K, RT1, P1, 3, 3, 4);
	mat_mul(AllViewsInfo[viewID.at(1)].K, RT2, P2, 3, 3, 4);

	//Triangulate and remove bad points quality
	bool *goodPoints = new bool[npts];
	Point3d *_t3D = new Point3d[npts];
	Stereo_Triangulation(pts1, pts2, P1, P2, _t3D, npts);
	TwoViewTriangulationQualityCheck(pts1, pts2, _t3D, P1, P2, goodPoints, threshold, npts, NULL, NULL, NULL, NULL);

	int count = 0;
	for (int ii = 0; ii < npts; ii++)
	{
		if (goodPoints[ii])
		{
			count++;
			int id = SelectedIndex[ii];
			All3D[id] = _t3D[ii];
			for (int jj = 0; jj < PointCorres[id].size(); jj++)
				All3D[PointCorres[id].at(jj)] = All3D[id];
		}
	}

	//Update ViewParas
	GetrtFromRT(AllViewsInfo, availViews);
	GetIntrinsicFromK(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	delete[]pts1, delete[]pts2, delete[]_t3D, delete[]goodPoints;

	sort(availViews.begin(), availViews.end());
	if (count < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", viewID.at(0), viewID.at(1), ThreeDCorrespondencesID.size() / 2);
		return 1;
	}
	else
		return 0;
}

struct FOVReprojectionError {
	FOVReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T> bool operator()(const T* const intrinsic, const T* distortion, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to image coordinate
		T xcn = p[0] / p[2], ycn = p[1] / p[2];
		T u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

		//Apply lens distortion
		T omega = distortion[0], DistCtrX = T(distortion[1]), DistCtrY = T(distortion[2]);
		T x = u - DistCtrX, y = v - DistCtrY;
		T ru = sqrt(x*x + y*y), rd = atan(T(2.0)*ru*tan(T(0.5)*omega)) / omega;
		T t = rd / ru;
		T x_u = t*x, y_u = t*y;

		residuals[0] = (x_u + DistCtrX - T(observed_x)) / (T)scale,
			residuals[1] = (y_u + DistCtrY - T(observed_y)) / (T)scale;
		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, const double scale)
	{
		return (new ceres::AutoDiffCostFunction<FOVReprojectionError, 2, 5, 3, 3, 3>(new FOVReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
struct FOVReprojectionError2 {
	FOVReprojectionError2(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T> bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* distortion, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to image coordinate
		T xcn = p[0] / p[2], ycn = p[1] / p[2];
		T u = fxfy[0] * xcn + skew[0] * ycn + uv0[0], v = fxfy[1] * ycn + uv0[1];

		//Apply lens distortion
		T omega = distortion[0], DistCtrX = T(distortion[1]), DistCtrY = T(distortion[2]);
		T x = u - DistCtrX, y = v - DistCtrY;
		T ru = sqrt(x*x + y*y), rd = atan(T(2.0)*ru*tan(T(0.5)*omega)) / omega;
		T t = rd / ru;
		T x_u = t*x, y_u = t*y;

		residuals[0] = (x_u + DistCtrX - T(observed_x)) / (T)scale,
			residuals[1] = (y_u + DistCtrY - T(observed_y)) / (T)scale;
		return true;
	}

	// Factory to hide the construction of the CostFunction object from the client code.
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::AutoDiffCostFunction<FOVReprojectionError2, 2, 2, 1, 2, 3, 6, 3>(new FOVReprojectionError2(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
void FOVReprojectionDistortionDebug(double *intrinsic, double* distortion, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	double u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

	//Apply lens distortion
	double omega = distortion[0], DistCtr[2] = { distortion[1], distortion[2] };
	double x = u - DistCtr[0], y = v - DistCtr[1];
	double ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
	double t = rd / ru;
	double x_u = t*x, y_u = t*y;

	residuals[0] = x_u + DistCtr[0] - observed.x, residuals[1] = y_u + DistCtr[1] - observed.y;
	return;
}

struct PinholeReprojectionError {
	PinholeReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T>	bool operator()(const T* const intrinsic, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xn = p[0] / p[2];
		T yn = p[1] / p[2];

		residuals[0] = (intrinsic[0] * xn + intrinsic[2] * yn + intrinsic[3] - T(observed_x)) / (T)scale;
		residuals[1] = (intrinsic[1] * yn + intrinsic[4] - T(observed_y)) / (T)scale;

		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::AutoDiffCostFunction<PinholeReprojectionError, 2, 5, 6, 3>(new PinholeReprojectionError(observed_x, observed_y, scale)));
	}

	static ceres::CostFunction* CreateNumerDiff(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::NumericDiffCostFunction<PinholeReprojectionError, ceres::CENTRAL, 2, 5, 6, 3>(new PinholeReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
void PinholeReprojectionDebug(double *intrinsic, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	double u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

	residuals[0] = u - observed.x, residuals[1] = v - observed.y;
	return;
}

struct PinholeDistortionReprojectionError {
	PinholeDistortionReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale) {}
	template <typename T>	bool operator()(const T* const intrinsic, const T* const distortion, const T* const RT, const T* const point, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + distortion[0] * r2 + distortion[1] * r4 + distortion[2] * r6;
		T tangentialX = T(2.0)*distortion[4] * xycn + distortion[3] * (r2 + T(2.0)*xcn2);
		T tangentailY = distortion[4] * (r2 + T(2.0)*ycn2) + T(2.0)*distortion[3] * xycn;
		T prismX = distortion[5] * r2;
		T prismY = distortion[6] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = intrinsic[0] * xcn_ + intrinsic[2] * ycn_ + intrinsic[3];
		T predicted_y = intrinsic[1] * ycn_ + intrinsic[4];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError, 2, 5, 7, 6, 3>(new PinholeDistortionReprojectionError(observed_x, observed_y, scale)));
	}
	static ceres::CostFunction* CreateNumerDiff(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 3>(new PinholeDistortionReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
struct PinholeDistortionReprojectionError2 {
	PinholeDistortionReprojectionError2(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}
	template <typename T>	bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* const Radial12, const T* const Tangential12, const T*const Radial3, const T*Prism, const T* const RT, const T* const point, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
		T tangentialX = T(2.0)*Tangential12[1] * xycn + Tangential12[0] * (r2 + T(2.0)*xcn2);
		T tangentailY = Tangential12[1] * (r2 + T(2.0)*ycn2) + T(2.0)*Tangential12[0] * xycn;
		T prismX = Prism[0] * r2;
		T prismY = Prism[1] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + uv0[0];
		T predicted_y = fxfy[1] * ycn_ + uv0[1];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError2, 2, 2, 1, 2, 2, 2, 1, 2, 6, 3>(new PinholeDistortionReprojectionError2(observed_x, observed_y, scale)));
	}
	double observed_x, observed_y, scale;
};
struct PinholeDistortionReprojectionError3 {
	PinholeDistortionReprojectionError3(double observed_x, double observed_y, double X, double Y, double Z, double scale) : observed_x(observed_x), observed_y(observed_y), X(X), Y(Y), Z(Z), scale(scale){}
	template <typename T>	bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* const Radial12, const T* const Tangential12, const T*const Radial3, const T*Prism, const T* const RT, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T point[3] = { T(X), T(Y), T(Z) }, p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
		T tangentialX = T(2.0)*Tangential12[1] * xycn + Tangential12[0] * (r2 + T(2.0)*xcn2);
		T tangentailY = Tangential12[1] * (r2 + T(2.0)*ycn2) + T(2.0)*Tangential12[0] * xycn;
		T prismX = Prism[0] * r2;
		T prismY = Prism[1] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + uv0[0];
		T predicted_y = fxfy[1] * ycn_ + uv0[1];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError3, 2, 2, 1, 2, 2, 2, 1, 2, 6>(new PinholeDistortionReprojectionError3(observed_x, observed_y, X, Y, Z, scale)));
	}
	static ceres::CostFunction* CreateNumDif(const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError3, ceres::CENTRAL, 2, 2, 1, 2, 2, 2, 1, 2, 6>(new PinholeDistortionReprojectionError3(observed_x, observed_y, X, Y, Z, scale)));
	}
	double observed_x, observed_y, X, Y, Z, scale;
};
struct PinholeDistortionReprojectionError4 {
	PinholeDistortionReprojectionError4(double *IntrinsicIn, double observed_x, double observed_y, double X, double Y, double Z, double scale) : observed_x(observed_x), observed_y(observed_y), X(X), Y(Y), Z(Z), scale(scale){ Intrinsic = IntrinsicIn; }
	template <typename T>	bool operator()(const T* const RT, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T point[3] = { T(X), T(Y), T(Z) }, p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Compute final projected point position.
		T predicted_x = (T)Intrinsic[0] * xcn + (T)Intrinsic[2] * ycn + (T)Intrinsic[3];
		T predicted_y = (T)Intrinsic[1] * ycn + (T)Intrinsic[4];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(double *Intrinsic, const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError4, 2, 6>(new PinholeDistortionReprojectionError4(Intrinsic, observed_x, observed_y, X, Y, Z, scale)));
	}
	static ceres::CostFunction* CreateNumDif(double *Intrinsic, const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError4, ceres::CENTRAL, 2, 6>(new PinholeDistortionReprojectionError4(Intrinsic, observed_x, observed_y, X, Y, Z, scale)));
	}
	double *Intrinsic;
	double observed_x, observed_y, X, Y, Z, scale;
};
void PinholeDistortionReprojectionDebug(double *intrinsic, double* distortion, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	Point2d uv(intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], intrinsic[1] * ycn + intrinsic[4]);

	// Deal with distortion
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };
	double distortionParas[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };

	LensDistortionPoint(&uv, K, distortionParas);

	// The error is the difference between the predicted and observed position.
	residuals[0] = uv.x - observed.x, residuals[1] = uv.y - observed.y;

	return;
}
void PinholeDistortionReprojectionDebug2(double *fxfy, double *skew, double* u0v0, double *Radial12, double *Tangential12, double *Radial3, double *Prism, double* rt, Point2d observed, double *point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to normalize coordinate
	double  xcn = p[0] / p[2], ycn = p[1] / p[2];

	// Apply second and fourth order radial distortion.
	double xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
	double radial = 1.0 + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
	double tangentialX = 2.0*Tangential12[1] * xycn + Tangential12[0] * (r2 + 2.0*xcn2);
	double tangentailY = Tangential12[1] * (r2 + 2.0*ycn2) + 2.0*Tangential12[0] * xycn;
	double prismX = Prism[0] * r2;
	double prismY = Prism[1] * r2;
	double xcn_ = radial*xcn + tangentialX + prismX;
	double ycn_ = radial*ycn + tangentailY + prismY;

	// Compute final projected point position.
	double predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + u0v0[0];
	double predicted_y = fxfy[1] * ycn_ + u0v0[1];

	// The error is the difference between the predicted and observed position.
	residuals[0] = predicted_x - observed.x;
	residuals[1] = predicted_y - observed.y;

	return;
}

int CayleyProjection(double *intrinsic, double* rt, double *wt, Point2d &predicted, Point3d Point, int width, int height)
{
	//Solving Eq. (5) of the p6p rolling shutter paper for the row location given all other parameters

	//transformed_X = R(v)*X
	double p[3] = { Point.x, Point.y, Point.z };
	double Rcenter[9];	getRfromr(rt, Rcenter);
	double Tx = rt[3], Ty = rt[4], Tz = rt[5];
	double tx = wt[3], ty = wt[4], tz = wt[5];
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };

	if (0)//abs(wt[0]) + abs(wt[1]) + abs(wt[2]) > 0.5 && (abs(tx) + abs(ty) + abs(tz) > 30))
	{
		double tp[3]; mat_mul(Rcenter, p, tp, 3, 3, 1);
		double X = tp[0], Y = tp[1], Z = tp[2];
		double wx = wt[0], wy = wt[1], wz = wt[2], wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

		//Set up polynomial coefficients (obtained from matlab symbolic)
		double c[5];
		Mat coeffs(1, 5, CV_64F, c);
		c[4] = tz*wz2 + tz*wy2 + tz*wx2;
		c[3] = 2.0 * Y*wyz + 2.0 * X*wxz - ty*wz2 - ty*wy2 - ty*wx2 - Z*wy2 - Z*wx2 + Z*wz2 + Tz*wz2 + Tz*wy2 + Tz*wx2;
		c[2] = -2.0 * Z*wyz - 2.0 * X*wxy - Y*wy2 - Ty*wz2 - Ty*wy2 - Ty*wx2 + 2.0 * Y*wx - 2.0 * X*wy + Y*wz2 + Y*wx2 + tz;
		c[1] = 2.0 * Z*wx - 2.0 * X*wz - ty + Z + Tz;
		c[0] = -Y - Ty;

		std::vector<std::complex<double> > roots;
		solvePoly(coeffs, roots);

		int count = 0;
		for (int ii = 0; ii < roots.size(); ii++)
		{
			if (fabs(roots[ii].imag()) > 1e-10)
				continue;

			double j = roots[ii].real(), j2 = j*j, j3 = j2*j;
			double lamda = (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz) / (j2 * wx2 + j2 * wy2 + j2 * wz2 + 1.0);
			double naiveDepth = Z + Tz;
			if (abs((lamda - naiveDepth) / naiveDepth) > 0.1) //very different from the orginal depth 
				continue;
			double i = (Tx + X + j*tx + Tx*j2 * wx2 + Tx*j2 * wy2 + Tx*j2 * wz2 + X*j2 * wx2 - X*j2 * wy2 - X*j2 * wz2 + j3 * tx*wx2 + j3 * tx*wy2 + j3 * tx*wz2 - 2.0 * Y*j*wz + 2.0 * Z*j*wy + 2.0 * Y*j2 * wxy + 2.0 * Z*j2 * wxz) / (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz);

			Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
			if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
				continue;
			else
			{
				predicted = uv;
				count++;
			}
		}
		return count;
	}
	else
	{
		double wx, wy, wz, wx2, wy2, wz2, wxy, wxz, wyz, denum, Rw[9], R[9], tp[3];

		mat_mul(Rcenter, p, tp, 3, 3, 1);
		tp[1] += Ty, tp[2] += Tz;
		double j = tp[1] / tp[2], j_ = j;

		for (int iter = 0; iter < 40; iter++)
		{
			wx = j*wt[0], wy = j*wt[1], wz = j*wt[2];
			wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

			denum = 1.0 + wx2 + wy2 + wz2;

			Rw[0] = 1.0 + wx2 - wy2 - wz2, Rw[1] = 2.0 * wxy - 2.0 * wz, Rw[2] = 2.0 * wy + 2.0 * wxz,
				Rw[3] = 2.0 * wz + 2.0 * wxy, Rw[4] = 1.0 - wx2 + wy2 - wz2, Rw[5] = 2.0 * wyz - 2.0 * wx,
				Rw[6] = 2.0 * wxz - 2.0 * wy, Rw[7] = 2.0 * wx + 2.0 * wyz, Rw[8] = 1.0 - wx2 - wy2 + wz2;

			for (int ii = 0; ii < 9; ii++)
				Rw[ii] = Rw[ii] / denum;

			mat_mul(Rw, Rcenter, R, 3, 3, 3);
			mat_mul(R, p, tp, 3, 3, 1);
			tp[0] += Tx, tp[1] += Ty, tp[2] += Tz;

			j = (tp[1] + j*ty) / (tp[2] + j*tz);
			if (abs((j - j_) / j_) < 1.0e-9)
				break;
			j_ = j;
		}
		double i = (tp[0] + j*tx) / (tp[2] + j*tz);

		Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
		if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
			return 0;
		else
		{
			predicted = uv;
			return 1;
		}
	}
}
struct CayleyReprojectionError {
	CayleyReprojectionError(double *intrinsicIn, double observed_x, double observed_y, double scale, int width, int height) : observed_x(observed_x), observed_y(observed_y), scale(scale), width(width), height(height)
	{
		intrinsic = intrinsicIn;
	}

	template <typename T>	bool operator()(const double* const rt, const double * const wt, const double* const point, T* residuals) const
	{
		Point2d predicted(0.0, 0.0);
		Point3d p3d(point[0], point[1], point[2]);
		double rt_[6] = { rt[0], rt[1], rt[2], rt[3], rt[4], rt[5] };
		double wt_[6] = { wt[0], wt[1], wt[2], wt[3], wt[4], wt[5] };

		int count = CayleyProjection(intrinsic, rt_, wt_, predicted, p3d, width, height);
		residuals[0] = (predicted.x - observed_x) / scale, residuals[1] = (predicted.y - observed_y) / scale;

		return true;
	}

	static ceres::CostFunction* Create(double *intrinsic, const double observed_x, const double observed_y, double scale, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<CayleyReprojectionError, ceres::CENTRAL, 2, 6, 6, 3>(new CayleyReprojectionError(intrinsic, observed_x, observed_y, scale, width, height)));
	}

	int width, height;
	double *intrinsic, observed_x, observed_y, scale;
};
int CayleyReprojectionDebug(double *intrinsic, double* rt, double *wt, Point2d observed, Point3d Point, int width, int height, double *residuals)
{
	Point2d predicted;
	int count = CayleyProjection(intrinsic, rt, wt, predicted, Point, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return count;
}

int CayleyDistortionProjection(double *intrinsic, double* distortion, double* rt, double *wt, Point2d &predicted, Point3d Point, int width, int height)
{
	//Solving Eq. (5) of the p6p rolling shutter paper for the row location given all other parameters
	double p[3] = { Point.x, Point.y, Point.z };
	double Rcenter[9];	getRfromr(rt, Rcenter);
	double Tx = rt[3], Ty = rt[4], Tz = rt[5];
	double tx = wt[3], ty = wt[4], tz = wt[5];
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };

	if (0)//(abs(wt[0]) + abs(wt[1]) + abs(wt[2]) > 0.5 && (abs(tx) + abs(ty) + abs(tz) > 30))
	{
		//Polynomial solving approach. Not very stable if the rolling shutter is small
		double tp[3]; mat_mul(Rcenter, p, tp, 3, 3, 1);
		double X = tp[0], Y = tp[1], Z = tp[2];
		double wx = wt[0], wy = wt[1], wz = wt[2], wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

		//Set up polynomial coefficients (obtained from matlab symbolic)
		double c[5];
		Mat coeffs(1, 5, CV_64F, c);
		c[4] = tz*wz2 + tz*wy2 + tz*wx2;
		c[3] = 2.0 * Y*wyz + 2.0 * X*wxz - ty*wz2 - ty*wy2 - ty*wx2 - Z*wy2 - Z*wx2 + Z*wz2 + Tz*wz2 + Tz*wy2 + Tz*wx2;
		c[2] = -2.0 * Z*wyz - 2.0 * X*wxy - Y*wy2 - Ty*wz2 - Ty*wy2 - Ty*wx2 + 2.0 * Y*wx - 2.0 * X*wy + Y*wz2 + Y*wx2 + tz;
		c[1] = 2.0 * Z*wx - 2.0 * X*wz - ty + Z + Tz;
		c[0] = -Y - Ty;

		std::vector<std::complex<double> > roots;
		solvePoly(coeffs, roots);

		int count = 0;
		for (int ii = 0; ii < roots.size(); ii++)
		{
			if (fabs(roots[ii].imag()) > 1e-10)
				continue;

			double j = roots[ii].real(), j2 = j*j, j3 = j2*j;
			double lamda = (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz) / (j2 * wx2 + j2 * wy2 + j2 * wz2 + 1.0);
			double naiveDepth = Z + Tz;
			if (abs((lamda - naiveDepth) / naiveDepth) > 0.1) //very different from the orginal depth 
				continue;
			double i = (Tx + X + j*tx + Tx*j2 * wx2 + Tx*j2 * wy2 + Tx*j2 * wz2 + X*j2 * wx2 - X*j2 * wy2 - X*j2 * wz2 + j3 * tx*wx2 + j3 * tx*wy2 + j3 * tx*wz2 - 2.0 * Y*j*wz + 2.0 * Z*j*wy + 2.0 * Y*j2 * wxy + 2.0 * Z*j2 * wxz) / (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz);

			Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
			LensDistortionPoint(&uv, K, distortion);
			if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
				continue;
			else
			{
				predicted = uv;
				count++;
			}
		}
		return count;
	}
	else
	{
		//Fix point iteration approach. Very stable
		double wx, wy, wz, wx2, wy2, wz2, wxy, wxz, wyz, denum, Rw[9], R[9], tp[3];

		mat_mul(Rcenter, p, tp, 3, 3, 1);
		tp[1] += Ty, tp[2] += Tz;
		double j = tp[1] / tp[2], j_ = j;

		for (int iter = 0; iter < 40; iter++)
		{
			wx = j*wt[0], wy = j*wt[1], wz = j*wt[2];
			wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

			denum = 1.0 + wx2 + wy2 + wz2;

			Rw[0] = 1.0 + wx2 - wy2 - wz2, Rw[1] = 2.0 * wxy - 2.0 * wz, Rw[2] = 2.0 * wy + 2.0 * wxz,
				Rw[3] = 2.0 * wz + 2.0 * wxy, Rw[4] = 1.0 - wx2 + wy2 - wz2, Rw[5] = 2.0 * wyz - 2.0 * wx,
				Rw[6] = 2.0 * wxz - 2.0 * wy, Rw[7] = 2.0 * wx + 2.0 * wyz, Rw[8] = 1.0 - wx2 - wy2 + wz2;

			for (int ii = 0; ii < 9; ii++)
				Rw[ii] = Rw[ii] / denum;

			mat_mul(Rw, Rcenter, R, 3, 3, 3);
			mat_mul(R, p, tp, 3, 3, 1);
			tp[0] += Tx, tp[1] += Ty, tp[2] += Tz;

			j = (tp[1] + j*ty) / (tp[2] + j*tz);
			if (abs((j - j_) / j_) < 1.0e-9)
				break;
			j_ = j;
		}
		double i = (tp[0] + j*tx) / (tp[2] + j*tz);

		Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
		LensDistortionPoint(&uv, K, distortion);
		if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
			return 0;
		else
		{
			predicted = uv;
			return 1;
		}
	}
}
struct CayleyDistortionReprojectionError {
	CayleyDistortionReprojectionError(double observed_x, double observed_y, double scale, int width, int height) : observed_x(observed_x), observed_y(observed_y), scale(scale), width(width), height(height) {}
	template <typename T>	bool operator()(const double* const intrinsic, const double* const distortion, const double* const rt, const double * const wt, const double* const point, T* residuals) const
	{
		Point2d predicted(0.0, 0.0);
		Point3d p3d(point[0], point[1], point[2]);
		double intrinsic_[5] = { intrinsic[0], intrinsic[1], intrinsic[2], intrinsic[3], intrinsic[4] };
		double distortion_[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };
		double rt_[6] = { rt[0], rt[1], rt[2], rt[3], rt[4], rt[5] };
		double wt_[6] = { wt[0], wt[1], wt[2], wt[3], wt[4], wt[5] };

		int count = CayleyDistortionProjection(intrinsic_, distortion_, rt_, wt_, predicted, p3d, width, height);
		residuals[0] = (predicted.x - observed_x) / scale, residuals[1] = (predicted.y - observed_y) / scale;

		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<CayleyDistortionReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 6, 3>(new CayleyDistortionReprojectionError(observed_x, observed_y, scale, width, height)));
	}

	int width, height;
	double observed_x, observed_y, scale;
};
int CayleyDistortionReprojectionDebug(double *intrinsic, double* distortion, double* rt, double *wt, Point2d observed, Point3d Point, int width, int height, double *residuals)
{
	Point2d predicted;
	int count = CayleyDistortionProjection(intrinsic, distortion, rt, wt, predicted, Point, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return count;
}
void NviewTriangulationNonLinearCayley(CameraData *camInfo, double *Point2D, double *Point3D, double *ReprojectionError, int nviews, int npts)
{
	ceres::Problem problem;

	//printf("Error before: \n");

	double residuals[2];
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			if (!camInfo[jj].valid)
				continue;

			CayleyReprojectionDebug(camInfo[jj].intrinsic, camInfo[jj].rt, camInfo[jj].wt, Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]), Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), camInfo[jj].width, camInfo[jj].height, residuals);
			ReprojectionError[ii] += residuals[0] * residuals[0] + residuals[1] * residuals[1];

			ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camInfo[jj].intrinsic, Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1], 1.0, camInfo[jj].width, camInfo[jj].height);
			problem.AddResidualBlock(cost_function, NULL, camInfo[jj].rt, camInfo[jj].wt, &Point3D[ii]);

			problem.SetParameterBlockConstant(camInfo[jj].rt);
			problem.SetParameterBlockConstant(camInfo[jj].wt);
		}

		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");


	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.FullReport() << "\n";

	//printf("Error after: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			if (!camInfo[jj].valid)
				continue;

			CayleyReprojectionDebug(camInfo[jj].intrinsic, camInfo[jj].rt, camInfo[jj].wt, Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]), Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), camInfo[jj].width, camInfo[jj].height, residuals);
			ReprojectionError[ii] += residuals[0] * residuals[0] + residuals[1] * residuals[1];
		}
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	return;
}

int IncrementalBA(char *Path, int nviews, int timeID, CameraData *AllViewsInfo, vector<int> availViews, vector<int>*PointCorres, vector<int>mask, vector<int> Selected3DIndex, Point3d *All3D, vector<Point2d> *selected2D, vector<int>*nSelectedViews, int nSelectedPts, int totalPts, bool fixIntrinsic, bool fixDistortion, bool showReProjectionError, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, jj, match, id3d, viewID, npts = Selected3DIndex.size();
	double residuals[2];
	const double scale = 1.0;

	double *seleted3D = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
	{
		id3d = Selected3DIndex[ii];
		seleted3D[3 * ii] = All3D[id3d].x, seleted3D[3 * ii + 1] = All3D[id3d].y, seleted3D[3 * ii + 2] = All3D[id3d].z;
	}

	printf("Set up BA ...");
	ceres::Problem problem;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB_%d.txt", availViews.size()), fp = fopen(Fname, "w+");

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *notGood = new vector<bool>[npts];
	for (int jj = 0; jj < npts; jj++)
		discard3Dpoint[jj] = false, notGood[jj].reserve(nSelectedViews[jj].size());

	vector<int>::iterator it;
	for (int jj = 0; jj < npts; jj++)
	{
		id3d = Selected3DIndex.at(jj);
		if (abs(All3D[id3d].x) > LIMIT3D)
		{
			it = find(mask.begin(), mask.end(), id3d);
			if (it != mask.end())
				continue; //the parent of the points has been processed

			//screening: if there are only 2 points and 1 of them fails, discard the pair
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
			{
				if (selected2D[jj][ii].x < 1 || selected2D[jj][ii].y < 1)
				{
					notGood[jj].push_back(false);
					continue;
				}

				viewID = nSelectedViews[jj][ii];
				PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);
				if (abs(residuals[0]) > 3 * AllViewsInfo[0].threshold || abs(residuals[1]) > 3 * AllViewsInfo[0].threshold)
					notGood[jj].push_back(false);
				else
					notGood[jj].push_back(true);
			}

			//Discard point 
			int count = 0;
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
				if (notGood[jj][ii] == true)
					count++;

			discard3Dpoint[jj] = false;
			if (count < 2)
			{
				discard3Dpoint[jj] = true;
				continue;
			}

			//All good, add point and its 2D projections to Ceres
			bool once = true;
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
			{
				if (!notGood[jj][ii])
					continue;

				viewID = nSelectedViews[jj][ii];
				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(selected2D[jj][ii].x, selected2D[jj][ii].y, scale);
				problem.AddResidualBlock(cost_function, NULL, AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, &seleted3D[3 * jj]);

				if (debug)
				{
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);
					if (once)
					{
						once = false;
						fprintf(fp, "%d %.4f %.4f %.4f ", id3d, All3D[id3d].x, All3D[id3d].y, All3D[id3d].z);
					}
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", viewID, selected2D[jj][ii].x, selected2D[jj][ii].y, residuals[0], residuals[1]);
				}
			}
			if (!once)
				fprintf(fp, "\n");
		}
	}
	if (debug)
		fclose(fp);

	//Set up constant parameters:
	printf("...set up fixed parameters ...");
	for (int ii = 0; ii < availViews.size(); ii++)
	{
		int viewID = availViews[ii];
		if (fixIntrinsic)
			problem.SetParameterBlockConstant(AllViewsInfo[viewID].intrinsic);
		if (fixDistortion)
			problem.SetParameterBlockConstant(AllViewsInfo[viewID].distortion);
	}

	printf("...run BA...\n");
	ceres::Solver::Options options;
	options.num_threads = 1;
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::DENSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.BriefReport() << "\n";

	GetKFromIntrinsic(AllViewsInfo, availViews);
	GetRTFromrt(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	//2d points belong to 1 3D point-> distribute 3D to its 2d matches
	for (ii = 0; ii < npts; ii++)
	{
		id3d = Selected3DIndex[ii];
		All3D[id3d].x = seleted3D[3 * ii], All3D[id3d].y = seleted3D[3 * ii + 1], All3D[id3d].z = seleted3D[3 * ii + 2];
		for (jj = 0; jj < PointCorres[id3d].size(); jj++)
		{
			match = PointCorres[id3d].at(jj);
			All3D[match] = All3D[id3d];
		}
	}

	vector<double> ReProjectionError; ReProjectionError.reserve(npts);
	if (debug || showReProjectionError)
	{
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA_%d.txt", availViews.size()), fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			id3d = Selected3DIndex.at(jj);
			if (abs(All3D[id3d].x) > LIMIT3D && !discard3Dpoint[jj])
			{
				it = find(mask.begin(), mask.end(), id3d);
				if (it != mask.end())
					continue; //the parent of the points has been processed

				bool once = true;
				int validViewcount = 0;
				double pointErr = 0.0;
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;

					viewID = nSelectedViews[jj][ii];
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);

					validViewcount++;
					pointErr += residuals[0] * residuals[0] + residuals[1] * residuals[1];
					if (once && debug)
					{
						once = false;
						fprintf(fp, "%d %.4f %.4f %.4f ", id3d, All3D[id3d].x, All3D[id3d].y, All3D[id3d].z);
					}
					if (debug)
						fprintf(fp, "%d %.4f %.4f %.4f %.4f ", viewID, selected2D[jj][ii].x, selected2D[jj][ii].y, residuals[0], residuals[1]);
				}
				if (!once &&debug)
					fprintf(fp, "\n");

				ReProjectionError.push_back(sqrt(pointErr / validViewcount));
			}
		}
		if (debug)
			fclose(fp);

		if (debug)
			sprintf(Fname, "C:/temp/visSfm_%d.txt", availViews.size()), fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			id3d = Selected3DIndex.at(jj);
			if (abs(All3D[id3d].x) > LIMIT3D && !discard3Dpoint[jj])
			{
				it = find(mask.begin(), mask.end(), id3d);
				if (it != mask.end())
					continue; //the parent of the points has been processed

				bool once = true;
				int validViewcount = 0;
				double pointErr = 0.0;
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;
					validViewcount++;
				}
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;

					viewID = nSelectedViews[jj][ii];
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);

					pointErr += residuals[0] * residuals[0] + residuals[1] * residuals[1];
					if (once && debug)
					{
						once = false;
						fprintf(fp, "%.4f %.4f %.4f 0  255 0 %d ", All3D[id3d].x, All3D[id3d].y, All3D[id3d].z, validViewcount);
					}
					if (debug)
						fprintf(fp, "%d %d %.4f %.4f ", viewID, (int)(UniformNoise(10000, 0)), selected2D[jj][ii].x - 1536, selected2D[jj][ii].y - 1024);
				}
				if (!once &&debug)
					fprintf(fp, "\n");
			}
		}
		if (debug)
			fclose(fp);
	}

	if (showReProjectionError)
	{
		double mini = *min_element(ReProjectionError.begin(), ReProjectionError.end());
		double maxi = *max_element(ReProjectionError.begin(), ReProjectionError.end());
		double avg = MeanArray(ReProjectionError);
		double std = sqrt(VarianceArray(ReProjectionError, avg));
		printf("Reprojection error: %.2f %.2f %.2f %.2f\n", mini, maxi, avg, std);
	}

	delete[]discard3Dpoint, delete[]notGood;
	return 0;
}
void IncrementalBundleAdjustment(char *Path, int nviews, int timeID, int maxKeypoints)
{
	int totalPts;
	vector<int> cumulativePts;
	ReadCumulativePoints(Path, nviews, timeID, cumulativePts);
	totalPts = cumulativePts.at(nviews);

	vector<int>CeresDuplicateAddInMask;
	vector<int>*PointCorres = new vector<int>[totalPts];
	//vector<int>PointCorres[191872];
	ReadPointCorrespondences(Path, nviews, timeID, PointCorres, CeresDuplicateAddInMask, totalPts);

	int viewPair[2];
	BestPairFinder(Path, nviews, timeID, viewPair);

	vector<int> availViews; availViews.reserve(nviews);
	availViews.push_back(viewPair[0]), availViews.push_back(viewPair[1]);
	sort(availViews.begin(), availViews.end());

	int nSelectedPts;
	vector<int>Selected3DIndex; Selected3DIndex.reserve(totalPts);
	vector<Point2d> *Selected2D = new vector<Point2d>[totalPts];
	vector<int> *nSelectedViews = new vector<int>[totalPts];

	CameraData *AllViewsInfo = new CameraData[nviews];
	if (ReadIntrinsicResults(Path, AllViewsInfo) != 0)
		return;
	for (int ii = 0; ii < nviews; ii++)
		AllViewsInfo[ii].LensModel = RADIAL_TANGENTIAL_PRISM, AllViewsInfo[ii].threshold = 2.0, AllViewsInfo[ii].ninlierThresh = 50;

	Point3d *All3D = new Point3d[totalPts];
	for (int ii = 0; ii < totalPts; ii++)
		All3D[ii].x = 0.0, All3D[ii].y = 0.0, All3D[ii].z = 0.0;

	TwoCameraReconstruction(Path, AllViewsInfo, nviews, timeID, cumulativePts, PointCorres, availViews, All3D);
	GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
	NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
	IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, false);

	int startnum = 2, addedDevices = startnum;
	for (int ii = 0; ii < nviews - startnum; ii++)
	{
		if (AddNewViewReconstruction(Path, AllViewsInfo, nviews, timeID, cumulativePts, PointCorres, All3D, AllViewsInfo[0].threshold, availViews) == 0)
		{
			printf("succeed!\n");
			addedDevices++;
		}

		if (addedDevices % 2 == 0) // Do BA after every 2 views being added
		{
			GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
			NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
			IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, false);
		}
	}
	printf("Done!\n");

	//Final BA
	GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
	NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
	IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, true);

	SaveCurrentSfmGL(Path, AllViewsInfo, availViews, All3D, NULL, totalPts);
	SaveCurrentSfmInfo(Path, AllViewsInfo, availViews, All3D, totalPts);
	//saveNVM("C:/temp", "fountain.nvm", AllViewsInfo, availViews);
	delete[]All3D, delete[]Selected2D, delete[]nSelectedViews;

	return;
}
int GlobalShutterBundleAdjustment(char *Path, CameraData *camera, vector<Point3d>  &Vxyz, vector < vector<int> > viewIdAll3D, vector<vector<Point2d> > uvAll3D, vector<vector<double> > scaleAll3D, vector<int> SharedIntrinsicCamID, int nviews, int fixIntrinsic, int fixDistortion, int fixPose, int fixFirstCamPose, int fix3D, int distortionCorrected, int LossType, bool debug, bool silent)
{
	int fixSkew = 1, fixPrism = 1;
	int *fixSkewView = new int[nviews], *fixPrismView = new int[nviews];
	for (int ii = 0; ii < nviews; ii++)
		fixSkewView[ii] = 0, fixPrismView[ii] = 0;

	char Fname[200]; FILE *fp = 0;
	int viewID, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (int ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up BA (%d views) ...\n", nviews);
	ceres::Problem problem;

	ceres::LossFunction *loss_funcion = 0;
	if (LossType == 1) //Huber
		loss_funcion = new ceres::HuberLoss(5.0);

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *Good = new vector<bool>[npts];
	for (int ii = 0; ii < npts; ii++)
		discard3Dpoint[ii] = false, Good[ii].reserve(viewIdAll3D[ii].size());

	int nBadCounts = 0, goodCount = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0;

	int firstCameraInSharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	bool SharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	for (int ii = 0; ii < MaxSharedIntrinsicGroup; ii++)
		SharedIntrinsicGroup[ii] = false;

	int firstValidViewID = -1, refCam = -1, nProjections = 0, nPossibleProjections = 0;
	vector<int> validCamID;
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) < LIMIT3D)
			continue;
		int nvisibles = viewIdAll3D[jj].size();
		for (int ii = 0; ii < nvisibles; ii++)
		{
			viewID = viewIdAll3D[jj][ii];
			if (!camera[viewID].valid)
				Good[jj].push_back(false);
			else
			{
				bool found = false;
				for (int kk = 0; kk < (int)validCamID.size(); kk++)
					if (viewID == validCamID[kk])
					{
						found = true; break;
					}
				if (!found)
					validCamID.push_back(viewID);

				firstValidViewID = viewID;
				if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
				{
					refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
					if (distortionCorrected == 1)
						PinholeReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
						PinholeDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else
						FOVReprojectionDistortionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				}
				else
				{
					if (distortionCorrected == 1)
						PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
						PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else
						FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				}

				if (abs(residuals[0]) > camera[firstValidViewID].threshold || abs(residuals[1]) > camera[firstValidViewID].threshold)
				{
					Good[jj].push_back(false);
					//printf("\n@P %d (%.3f %.3f %.3f):  %.2f %.2f", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], residuals[0], residuals[1]);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
				}
				else
				{
					Good[jj].push_back(true);
					//if (SharedIntrinsicCamID.size() > 0 && refCam == -1)
					if (SharedIntrinsicCamID.size() > 0 && !SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
					{
						SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = true;
						firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = viewID;
						printf("Set group %d master camera to %d\n", SharedIntrinsicCamID[viewID], firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]]);
					}
					goodCount++;
				}
			}
		}

		//Discard point 
		int count = 0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			if (Good[jj][ii] == true)
				count++;

		discard3Dpoint[jj] = false;
		if (count < 2)
		{
			discard3Dpoint[jj] = true;
			continue;
		}

		//add 3D point and its 2D projections to Ceres
		bool once = true;
		int validViewcount = 0;
		double pointErrX = 0.0, pointErrY = 0.0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			if (!Good[jj][ii])
				continue;

			nPossibleProjections++;
			viewID = viewIdAll3D[jj][ii];

			//vector<int>::iterator it;
			//it = find(SharedIntrinsicCamID.begin(), SharedIntrinsicCamID.end(), viewID);
			//if (it == SharedIntrinsicCamID.end()) //not shared cameras
			if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
			{
				refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[viewID].rt, &xyz[3 * jj]);
				}
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}
				else
				{
					ceres::CostFunction* cost_function = FOVReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}

				if (fixIntrinsic)
					problem.SetParameterBlockConstant(camera[refCam].intrinsic);
				if (distortionCorrected == 0 && fixDistortion)
					problem.SetParameterBlockConstant(camera[refCam].distortion);
				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (fixSkew)
				{
					if (fixSkewView[refCam] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(2);
						problem.SetParameterization(camera[refCam].intrinsic, new ceres::SubsetParameterization(5, constant_parameters));
						fixSkewView[refCam] = 1;
					}
				}
				if (fixPrism && camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					if (fixPrismView[refCam] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(5), constant_parameters.push_back(6);
						problem.SetParameterization(camera[refCam].distortion, new ceres::SubsetParameterization(7, constant_parameters));
						fixPrismView[refCam] = 1;
					}
				}

				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
			}
			else
			{
				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].rt, &xyz[3 * jj]);
				}
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}
				else
				{
					ceres::CostFunction* cost_function = FOVReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}

				if (fixIntrinsic)
					problem.SetParameterBlockConstant(camera[viewID].intrinsic);
				if (distortionCorrected == 0 && fixDistortion)
					problem.SetParameterBlockConstant(camera[viewID].distortion);
				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (fixSkew)
				{
					if (fixSkewView[viewID] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(2);
						ceres::LocalParameterization *localParameterization = new ceres::SubsetParameterization(5, constant_parameters);
						problem.SetParameterization(camera[viewID].intrinsic, localParameterization);
						fixSkewView[viewID] = 1;
					}
				}
				if (fixPrism && camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					if (fixPrismView[viewID] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(5), constant_parameters.push_back(6);
						ceres::LocalParameterization *localParameterization = new ceres::SubsetParameterization(7, constant_parameters);
						problem.SetParameterization(camera[viewID].distortion, localParameterization);
						fixPrismView[viewID] = 1;
					}
				}

				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
			}

			validViewcount++;
			pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);

			if (debug)
			{
				if (once)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.2f %.2f\n", residuals[0], residuals[1]);
			}
		}
		if (validViewcount > 1)
		{
			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}

		if (!once)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/Good.txt", Path); fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		fprintf(fp, "%d ", jj);
		for (int ii = 0; ii < Good[jj].size(); ii++)
		{
			if (Good[jj][ii] == false)
				fprintf(fp, "%d ", ii);
		}
		fprintf(fp, "-1\n");
	}
	fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("(%d/%d) bad points with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, nBadCounts + goodCount, maxOutlierX, maxOutlierY);
	printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = silent ? false : true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	for (int ii = 0; ii < (int)validCamID.size() && SharedIntrinsicCamID.size()>0; ii++)
	{
		refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[ii]];
		CopyCamereInfo(camera[refCam], camera[validCamID[ii]], false);
	}
	for (int ii = 0; ii < (int)validCamID.size(); ii++)
	{
		GetKFromIntrinsic(camera[validCamID[ii]]);
		GetRTFromrt(camera[validCamID[ii]]);
		AssembleP(camera[validCamID[ii]].K, camera[validCamID[ii]].R, camera[validCamID[ii]].T, camera[validCamID[ii]].P);
	}
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) > LIMIT3D && !discard3Dpoint[jj])
		{
			bool once = true;
			int validViewcount = 0;
			double pointErrX = 0.0, pointErrY = 0.0;
			for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			{
				if (!Good[jj][ii])
					continue;

				viewID = viewIdAll3D[jj][ii];
				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);

				validViewcount++;
				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
				if (once && debug)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				if (debug)
					fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.2f %.2f\n", residuals[0], residuals[1]);
			}
			if (!once &&debug)
				fprintf(fp, "\n");

			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz, delete[]discard3Dpoint, delete[]Good;
	return 0;
}
int CayleyRollingShutterBundleAdjustment(char *Path, CameraData *camera, vector<Point3d>  &Vxyz, vector < vector<int> > viewIdAll3D, vector<vector<Point2d> > uvAll3D, vector<vector<double> > scaleAll3D, vector<int> SharedIntrinsicCamID, int nviews, int fixIntrinsic, int fixDistortion, int fixPose, int fixFirstCamPose, int fixLocalPose, int fix3D, int distortionCorrected, int LossType, bool debug, bool silent)
{
	int fixSkew = 1, fixPrism = 1;
	int *fixSkewView = new int[nviews], *fixPrismView = new int[nviews];
	for (int ii = 0; ii < nviews; ii++)
		fixSkewView[ii] = 0, fixPrismView[ii] = 0;

	char Fname[200]; FILE *fp = 0;
	int viewID, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (int ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("set up Cayley RS-BA (%d views) ...\n", nviews);
	ceres::Problem problem;

	ceres::LossFunction *loss_funcion = 0;
	if (LossType == 1) //Huber
		loss_funcion = new ceres::HuberLoss(5.0);

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");


	double maxOutlierX = 0.0, maxOutlierY = 0.0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *Good = new vector<bool>[npts];
	for (int ii = 0; ii < npts; ii++)
		discard3Dpoint[ii] = false, Good[ii].reserve(viewIdAll3D[ii].size());

	int firstCameraInSharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	bool SharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	for (int ii = 0; ii < MaxSharedIntrinsicGroup; ii++)
		SharedIntrinsicGroup[ii] = false;

	int nBadCounts = 0, goodCount = 0;
	int firstValidViewID = -1, refCam = -1, nProjections = 0, nPossibleProjections = 0;
	vector<int> validCamID;
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) < LIMIT3D)
			continue;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			viewID = viewIdAll3D[jj][ii];
			if (!camera[viewID].valid)
				Good[jj].push_back(false);
			else
			{
				bool found = false;
				for (int kk = 0; kk < (int)validCamID.size(); kk++)
					if (viewID == validCamID[kk])
					{
						found = true; break;
					}
				if (!found)
					validCamID.push_back(viewID);

				if (firstValidViewID == -1) //just to set the ref pose and determine reprojection threshold 
					firstValidViewID = viewID;

				if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
				{
					refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
					if (distortionCorrected == 0)
						CayleyDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[refCam].width, camera[refCam].height, residuals);
					else
						CayleyReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[refCam].width, camera[refCam].height, residuals);
				}
				else
				{
					if (distortionCorrected == 0)
						CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
					else
						CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (abs(residuals[0]) > camera[firstValidViewID].threshold || abs(residuals[1]) > camera[firstValidViewID].threshold)//because they are not corrected for rolling shutter yet
				{
					Good[jj].push_back(false);
					//printf("\n@P %d (%.3f %.3f %.3f):  %.2f %.2f", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], residuals[0], residuals[1]);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
				}
				else
				{
					Good[jj].push_back(true);
					if (SharedIntrinsicCamID.size() > 0 && !SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
					{
						SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = true;
						firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = viewID;
						printf("Set group %d master camera to %d\n", SharedIntrinsicCamID[viewID], firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]]);
					}
					goodCount++;
				}
			}
		}

		//Discard point 
		int count = 0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			if (Good[jj][ii] == true)
				count++;

		discard3Dpoint[jj] = false;
		if (count < 2)
		{
			discard3Dpoint[jj] = true;
			continue;
		}

		//add 3D point and its 2D projections to Ceres
		bool once = true;
		int validViewcount = 0;
		double pointErrX = 0.0, pointErrY = 0.0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			if (!Good[jj][ii])
				continue;

			nPossibleProjections++;
			viewID = viewIdAll3D[jj][ii];

			if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
			{
				refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
				if (distortionCorrected == 0)
				{
					ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					if (fixIntrinsic)
						problem.SetParameterBlockConstant(camera[refCam].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(camera[refCam].distortion);

					CayleyDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}
				else
				{
					ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera[refCam].intrinsic, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					CayleyReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixLocalPose)
					problem.SetParameterBlockConstant(camera[viewID].wt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (fixSkew)
				{
					if (fixSkewView[refCam] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(2);
						problem.SetParameterization(camera[refCam].intrinsic, new ceres::SubsetParameterization(5, constant_parameters));
						fixSkewView[refCam] = 1;
					}
				}
				if (fixPrism && camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					if (fixPrismView[refCam] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(5), constant_parameters.push_back(6);
						problem.SetParameterization(camera[refCam].distortion, new ceres::SubsetParameterization(7, constant_parameters));
						fixPrismView[refCam] = 1;
					}
				}
			}
			else
			{
				if (distortionCorrected == 0)
				{
					ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					if (fixIntrinsic)
						problem.SetParameterBlockConstant(camera[viewID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(camera[viewID].distortion);

					CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}
				else
				{
					ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera[viewID].intrinsic, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixLocalPose)
					problem.SetParameterBlockConstant(camera[viewID].wt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (fixSkew)
				{
					if (fixSkewView[viewID] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(2);
						problem.SetParameterization(camera[viewID].intrinsic, new ceres::SubsetParameterization(5, constant_parameters));
						fixSkewView[viewID] = 1;
					}
				}
				if (fixPrism && camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					if (fixPrismView[viewID] == 0)
					{
						std::vector<int> constant_parameters;
						constant_parameters.push_back(5), constant_parameters.push_back(6);
						problem.SetParameterization(camera[viewID].distortion, new ceres::SubsetParameterization(7, constant_parameters));
						fixPrismView[viewID] = 1;
					}
				}
			}

			validViewcount++;
			pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
			if (debug)
			{
				if (once)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
			}
		}
		if (validViewcount > 0)
		{
			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}

		if (!once)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/Good.txt", Path); fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		fprintf(fp, "%d ", jj);
		for (int ii = 0; ii < Good[jj].size(); ii++)
		{
			if (Good[jj][ii] == false)
				fprintf(fp, "%d ", ii);
		}
		fprintf(fp, "-1\n");
	}
	fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("(%d/%d) bad points with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, nBadCounts + goodCount, maxOutlierX, maxOutlierY);
	printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	if (validCamID.size() < 1000)
		options.linear_solver_type = ceres::DENSE_SCHUR;
	else
	{
		options.linear_solver_type = ceres::CGNR;
		options.preconditioner_type = ceres::JACOBI;
	}
	options.minimizer_progress_to_stdout = silent ? false : true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	for (int ii = 0; ii < (int)validCamID.size() && SharedIntrinsicCamID.size()>0; ii++)
	{
		refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[ii]];
		CopyCamereInfo(camera[refCam], camera[validCamID[ii]], false);
	}
	for (int ii = 0; ii < (int)validCamID.size(); ii++)
	{
		GetKFromIntrinsic(camera[validCamID[ii]]);
		GetRTFromrt(camera[validCamID[ii]]);
		AssembleP(camera[validCamID[ii]].K, camera[validCamID[ii]].R, camera[validCamID[ii]].T, camera[validCamID[ii]].P);
	}
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);


	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) > LIMIT3D && !discard3Dpoint[jj])
		{
			bool once = true;
			int validViewcount = 0;
			double pointErrX = 0.0, pointErrY = 0.0;
			for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			{
				if (!Good[jj][ii])
					continue;

				viewID = viewIdAll3D[jj][ii];
				if (distortionCorrected == 0)
					CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				else
					CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);

				validViewcount++;
				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
				if (once && debug)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				if (debug)
					fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.3f %.3f\n", residuals[0], residuals[1]);
			}
			if (!once &&debug)
				fprintf(fp, "\n");

			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}
	}
	if (debug)
		fclose(fp);

	if (ReProjectionErrorX.size() == 0 || ReProjectionErrorY.size() == 0)
		printf("Error. The BA gives 0 inliers!");
	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz, delete[]discard3Dpoint;
	delete[]Good;

	return 0;
}

int GlobalShutterBundleAdjustmentDriver(char *Path, int nViews, int distortionCorrected, vector< int> SharedIntrinsicCamID, int LossType)
{
	printf("Reading Corpus and camera info\n");

	Corpus corpusData;
	char Fname[200]; sprintf(Fname, "%s/Corpus", Path);
	ReadCorpusInfo(Fname, corpusData, false, false);

	for (int ii = 0; ii < nViews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0;
		SharedIntrinsicCamID.push_back(0);
	}

	GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, SharedIntrinsicCamID, nViews, true, true, true, false, false, distortionCorrected, LossType, true, false);

	SaveCorpusInfo(Path, corpusData);

	return 0;
}
int CayleyRollingShutterBundleAdjustmentDriver(char *Path, int nViews, int distortionCorrected, vector< int> SharedIntrinsicCamID, int LossType)
{
	printf("Reading Corpus and camera info\n");

	Corpus corpusData;
	char Fname[200]; sprintf(Fname, "%s/Corpus", Path);
	ReadCorpusInfo(Fname, corpusData, false, true);

	for (int ii = 0; ii < nViews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0;
		SharedIntrinsicCamID.push_back(0);
	}

	//Get back the distorted 2d points
	for (int jj = 0; jj < corpusData.n3dPoints; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
		{
			int viewID = corpusData.viewIdAll3D[jj][ii];
			LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
		}
	}

	/*//Simulate 2d points
	double start = omp_get_wtime();

	vector<vector<int> > IdToDel;
	int n3D = (int)corpusData.xyz.size();
	for (int kk = 0; kk < n3D; kk++)
	{
	vector<int> toDel;
	IdToDel.push_back(toDel);
	}

	int numThreads = omp_get_max_threads();
	omp_set_num_threads(numThreads);

	//#pragma omp parallel for
	for (int kk = 0; kk < n3D; kk++)
	{
	vector<int> toDel;
	for (int ll = 0; ll < (int)corpusData.uvAll3D[kk].size(); ll++)
	{
	int viewID = corpusData.viewIdAll3D[kk][ll];
	Point2d uv = corpusData.uvAll3D[kk][ll];
	int nsolution = CayleyDistortionProjection(corpusData.camera[viewID].intrinsic, corpusData.camera[viewID].distortion, corpusData.camera[viewID].rt, corpusData.camera[viewID].wt, uv, corpusData.xyz[kk], corpusData.camera[viewID].width, corpusData.camera[viewID].height);
	if (nsolution != 1)
	{
	#pragma omp critical
	printf("Problem at 3D point %d, view %d \n", kk, ll);
	//toDel.push_back(ll);
	}
	else
	corpusData.uvAll3D[kk][ll] = uv;
	}
	IdToDel[kk] = toDel;

	#pragma omp critical
	if (kk % 1000 == 0 && omp_get_thread_num() == 0)
	printf("@\r# %.2f%% (%.2fs) Simulating rolling shutter 2d points..", 100.0*kk*numThreads / n3D, omp_get_wtime() - start);
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);

	/*for (int jj = 0; jj < (int)IdToDel.size(); jj++)
	{
	for (int ii = (int)IdToDel[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
	{
	int viewID = IdToDel[jj][ii];
	if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
	printf("%d\n", jj);
	else
	{
	corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
	corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
	corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
	corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
	}
	}
	}
	//sprintf(Fname, "%s/Corpus", Path);/SaveCorpusInfo(Fname, corpusData, false, false);*/

	CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, SharedIntrinsicCamID, nViews, true, true, true, false, false, false, distortionCorrected, LossType, true, false);

	SaveCorpusInfo(Path, corpusData, false, false);

	return 0;
}
int BuildCorpus(char *Path, int distortionCorrected, int ShutterModel, int sharedIntrinsic, int NDplus, int LossType)
{
	printf("Reading Corpus and camera info");
	char Fname[200];

	Corpus corpusData;
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	int nviews = corpusData.nCameras;
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0, corpusData.camera[ii].ninlierThresh = 50, corpusData.camera[ii];
		GetrtFromRT(corpusData.camera[ii].rt, corpusData.camera[ii].R, corpusData.camera[ii].T);
		GetIntrinsicFromK(corpusData.camera[ii]);
		AssembleP(corpusData.camera[ii].K, corpusData.camera[ii].R, corpusData.camera[ii].T, corpusData.camera[ii].P);
		if (distortionCorrected == 1)
			for (int jj = 0; jj < 7; jj++)
				corpusData.camera[ii].distortion[jj] = 0.0;
	}
	printf("...Done\n");

	vector<int>Refinement_SharedIntrinsic;
	if (sharedIntrinsic == 1)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	sprintf(Fname, "%s/ViewPM.txt", Path); FILE *fp = fopen(Fname, "r");
	int nviewsi, viewi, n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		for (int ii = 0; ii < nviewsi; ii++)
			fscanf(fp, "%d ", &viewi);
		n3D++;
	}
	fclose(fp);

	vector<int> cumulativePts;
	ReadCumulativePoints(Path, nviews, -1, cumulativePts);
	int totalPts = cumulativePts[nviews];

	vector<int>*PViewIdAll3D = new vector<int>[n3D];
	vector<int>*PuvIdAll3D = new vector<int>[n3D];

	printf("Reading Matching table....");
	sprintf(Fname, "%s/ViewPM.txt", Path); fp = fopen(Fname, "r");
	n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		PViewIdAll3D[n3D].reserve(nviewsi);
		for (int ii = 0; ii < nviewsi; ii++)
		{
			fscanf(fp, "%d ", &viewi);
			PViewIdAll3D[n3D].push_back(viewi);
		}
		n3D++;
	}
	fclose(fp);

	sprintf(Fname, "%s/IDPM.txt", Path); fp = fopen(Fname, "r");
	int np, pi;
	n3D = 0;
	while (fscanf(fp, "%d ", &np) != EOF)
	{
		PuvIdAll3D[n3D].reserve(np);
		for (int ii = 0; ii < np; ii++)
		{
			fscanf(fp, "%d ", &pi);
			PuvIdAll3D[n3D].push_back(pi);
		}
		n3D++;
	}
	fclose(fp);
	printf("...Done\n");

	//Read all sift points
	printf("Reading SIFT keys....");
	vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
	vector<Point3i> *AllRGB = new vector < Point3i >[nviews];
	for (int ii = 0; ii < nviews; ii++)
	{
		sprintf(Fname, "%s/K%d.dat", Path, ii); ReadKPointsBinarySIFT(Fname, AllKeys[ii]);
		sprintf(Fname, "%s/RGB%d.dat", Path, ii); ReadRGBBinarySIFT(Fname, AllRGB[ii]);
	}
	printf("...Done\n");

	//Correct for distortion if needed
	if (distortionCorrected == 0)
	{
		distortionCorrected = 1;
		Point2d pt;
		for (int ii = 0; ii < nviews; ii++)
		{
			int npts = AllKeys[ii].size();
			if (corpusData.camera[ii].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					LensCorrectionPoint(&pt, corpusData.camera[ii].K, corpusData.camera[ii].distortion);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
			else
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					FishEyeCorrectionPoint(&pt, corpusData.camera[ii].distortion[0], corpusData.camera[ii].distortion[1], corpusData.camera[ii].distortion[2]);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
		}
	}

	//Triangulate points from estimated camera poses
	printf("Triangulating the Corpus...");
	Point3d xyz;
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool *passed = new bool[nviews * 2];
	double *Ps = new double[12 * nviews * 2];

	vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
	Point2d *match2Dpts = new Point2d[nviews * 2];
	double *matchScales = new double[nviews * 2];

	corpusData.xyz.reserve(n3D);
	corpusData.rgb.reserve(n3D);
	corpusData.viewIdAll3D.reserve(n3D);
	corpusData.pointIdAll3D.reserve(n3D);

	vector<int>viewIDs, pointIDs, orgId, threeDid;
	vector<Point2d> uvPer3D, uvperView;
	vector<double>scalePer3D, scalePerView;

	for (int ii = 0; ii < n3D; ii++)
	{
		corpusData.viewIdAll3D.push_back(viewIDs), corpusData.viewIdAll3D[ii].reserve(nviews);
		corpusData.pointIdAll3D.push_back(pointIDs), corpusData.pointIdAll3D[ii].reserve(nviews);
		corpusData.uvAll3D.push_back(uvPer3D), corpusData.uvAll3D[ii].reserve(nviews);
		corpusData.scaleAll3D.push_back(scalePer3D), corpusData.scaleAll3D[ii].reserve(nviews);
	}

	printf("Start: \n");
	double ProThresh = 0.99, PercentInlier = 0.25;
	int goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	bool printout = 0;
	double start = omp_get_wtime();
	for (int jj = 0; jj < n3D; jj++)
	{
		if (jj % 1000 == 0)
			printf("@\r# %.2f%% (%.2fs) Triangualating corpus..", 100.0*jj / n3D, omp_get_wtime() - start);
		int nviewsi = PViewIdAll3D[jj].size();
		if (nviewsi >= NDplus)
		{
			Inliers[0].clear();
			for (int ii = 0; ii < nviewsi; ii++)
			{
				viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];
				if (ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = corpusData.camera[viewi].P[kk];
				}
				else
				{
					double *wt = corpusData.camera[viewi].wt;
					double *intrinsic = corpusData.camera[viewi].intrinsic;
					double *Rcenter = corpusData.camera[viewi].R;
					double *Tcenter = corpusData.camera[viewi].T;
					double ycn = (AllKeys[viewi][pi].y - intrinsic[4]) / intrinsic[1];

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(corpusData.camera[viewi].K, R, T, Ps + 12 * ii);
				}

				match2Dpts[ii].x = AllKeys[viewi][pi].x, match2Dpts[ii].y = AllKeys[viewi][pi].y;
				matchScales[ii] = AllKeys[viewi][pi].s;
			}
		}
		else
			continue;
		/*if (printout)
		{
		FILE *fp = fopen("C:/temp/corres.txt", "w+");
		for (int ii = 0; ii < nviewsi; ii++)
		fprintf(fp, "%.1f %.1f\n", match2Dpts[ii].x, match2Dpts[ii].y);
		for (int ii = 0; ii < nviewsi; ii++)
		{
		for (int jj = 0; jj < 12; jj++)
		fprintf(fp, "%.4f ", Ps[jj + ii * 12]);
		fprintf(fp, "\n");
		}
		fclose(fp);
		}*/

		NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, corpusData.camera[0].threshold, A, B, tPs);
		if (passed[0])
		{
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
				if (Inliers[0][ii])
					ninlier++;
			if (ninlier < NDplus)
				continue; //Corpus needs NDplus+ points!
			corpusData.xyz.push_back(xyz);

			for (int ii = 0; ii < nviewsi; ii++)
			{
				if (Inliers[0][ii])
				{
					viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];

					corpusData.viewIdAll3D[goodNDplus].push_back(viewi);
					corpusData.pointIdAll3D[goodNDplus].push_back(pi);
					corpusData.uvAll3D[goodNDplus].push_back((match2Dpts[ii]));//store corrected 2d points into corpus
					corpusData.scaleAll3D[goodNDplus].push_back((matchScales[ii]));//store corrected 2d points into corpus
				}
			}
			goodNDplus++;
		}
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);
	printf("Found %d (%d+) points.\n\n", goodNDplus, NDplus);

	printf("Runing BA on the triangulated points...");
	//Let's reoptimize verything
	bool fixIntrinsic = 0, fixDistortion = 0, fixPose = 0, fix1stCamPose = 1, fix3D = 0;
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 0;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, fix3D, distortionCorrected, LossType);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, false, fix3D, distortionCorrected, LossType, false);

	//Now, can undistort points again
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 1;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensCorrectionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}
	printf("\n");

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	//Get the color info
	Point3i rgb;
	corpusData.rgb.reserve(goodNDplus);
	for (int kk = 0; kk < goodNDplus; kk++)
	{
		viewi = corpusData.viewIdAll3D[kk][0];
		pi = corpusData.pointIdAll3D[kk][0];
		rgb = AllRGB[viewi][pi];
		corpusData.rgb.push_back(rgb);
	}
	vector<int> AvailViews; AvailViews.reserve(nviews);
	for (int ii = 0; ii < nviews; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, corpusData.camera, AvailViews, corpusData.xyz, corpusData.rgb); // OK for visualization

	//Prune corpus for bad points
	printf("Remove not good points ...");
	vector<int> *notGood = new vector<int>[goodNDplus];
	sprintf(Fname, "%s/Good.txt", Path);	fp = fopen(Fname, "r");
	if (fp != NULL)
	{
		for (int jj = 0; jj < goodNDplus; jj++)
		{
			int pid, ii;
			fscanf(fp, "%d %d", &pid, &ii);
			while (ii != -1)
			{
				notGood[jj].push_back(ii);
				fscanf(fp, "%d ", &ii);
			}
		}
		fclose(fp);
	}

	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = notGood[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
		{
			int viewID = notGood[jj][ii];
			if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
				printf("%d\n", jj);
			else
			{
				corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
				corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
				corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
				corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
			}
		}
	}
	delete[]notGood;
	printf("Done!\n");


	//And generate 3D id, uv, sift id for all views
	printf("and generate Corpus visibility info....");
	vector<int> *twoDIdAllViews = new vector<int>[nviews];
	corpusData.threeDIdAllViews = new vector<int>[nviews];
	corpusData.uvAllViews = new vector<Point2d>[nviews];
	corpusData.scaleAllViews = new vector<double>[nviews];

	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.threeDIdAllViews[ii].reserve(10000);
		corpusData.uvAllViews[ii].reserve(10000);
		corpusData.scaleAllViews[ii].reserve(10000);
		twoDIdAllViews[ii].reserve(10000);
	}

	double scale;
	Point2d uv;
	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.viewIdAll3D[jj].size(); ii++)
		{
			viewi = corpusData.viewIdAll3D[jj][ii], pi = corpusData.pointIdAll3D[jj][ii], uv = corpusData.uvAll3D[jj][ii], scale = corpusData.scaleAll3D[jj][ii];

			corpusData.threeDIdAllViews[viewi].push_back(jj);
			corpusData.uvAllViews[viewi].push_back(uv);
			corpusData.scaleAllViews[viewi].push_back(scale);
			twoDIdAllViews[viewi].push_back(pi);
		}
	}
	printf("Done!\n");

	//Get sift matrix for all views
	printf("Prune SIFT descriptors for only Corpus points....");
	int nSift, totalSift = 0, maxSift = 0;
	corpusData.IDCumView.reserve(nviews + 1);
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.IDCumView.push_back(totalSift);
		nSift = twoDIdAllViews[ii].size();
		if (nSift > maxSift)
			maxSift = nSift;
		totalSift += nSift;
	}
	corpusData.IDCumView.push_back(totalSift);

	/*corpusData.SiftDesc.create(totalSift, SIFTBINS, CV_32F);
	vector<float> desc; desc.reserve(maxSift*SIFTBINS);
	for (int ii = 0; ii < nviews; ii++)
	{
	desc.clear();
	sprintf(Fname, "%s/D%d.dat", Path, ii), ReadDescriptorBinarySIFT(Fname, desc);

	int curPid = corpusData.IDCumView[ii], nSift = twoDIdAllViews[ii].size();
	for (int j = 0; j < nSift; ++j)
	{
	int pid = twoDIdAllViews[ii][j];
	for (int i = 0; i < SIFTBINS; i++)
	corpusData.SiftDesc.at<float>(curPid + j, i) = desc[pid*SIFTBINS + i];
	}
	}*/

	FeatureDesc desci;
	vector<float> desc; desc.reserve(maxSift*SIFTBINS);
	corpusData.DescAllViews = new vector<FeatureDesc>[nviews];
	for (int ii = 0; ii < nviews; ii++)
	{
		int nSift = corpusData.uvAllViews[ii].size();

		desc.clear();
		sprintf(Fname, "%s/D%d.dat", Path, ii), ReadDescriptorBinarySIFT(Fname, desc);

		for (int j = 0; j < nSift; ++j)
		{
			int pid = twoDIdAllViews[ii][j];
			for (int i = 0; i < SIFTBINS; i++)
				desci.desc[ii] = desc[pid*SIFTBINS + i];
			corpusData.DescAllViews[ii].push_back(desci);
		}
	}

	printf("...Done\n\n");

	///****NOTE: 2d points in Corpus are corrected***///
	SaveCorpusInfo(Path, corpusData);

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys, delete[]twoDIdAllViews;
	delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts, delete[]matchScales;
	return 0;
}
int BuildCorpusVisualSfm(char *Path, int distortionCorrected, int ShutterModel, int sharedIntrinsic, int NDplus, int LossType)
{
	printf("Reading Corpus and camera info");
	char Fname[200];

	Corpus corpusData;
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	int nviews = corpusData.nCameras;
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0, corpusData.camera[ii].ninlierThresh = 50, corpusData.camera[ii];
		GetrtFromRT(corpusData.camera[ii].rt, corpusData.camera[ii].R, corpusData.camera[ii].T);
		GetIntrinsicFromK(corpusData.camera[ii]);
		AssembleP(corpusData.camera[ii].K, corpusData.camera[ii].R, corpusData.camera[ii].T, corpusData.camera[ii].P);
		if (distortionCorrected == 1)
			for (int jj = 0; jj < 7; jj++)
				corpusData.camera[ii].distortion[jj] = 0.0;
	}

	vector<int>Refinement_SharedIntrinsic;
	if (sharedIntrinsic == 1)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	sprintf(Fname, "%s/ViewPM.txt", Path); FILE *fp = fopen(Fname, "r");
	int nviewsi, viewi, n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		for (int ii = 0; ii < nviewsi; ii++)
			fscanf(fp, "%d ", &viewi);
		n3D++;
	}
	fclose(fp);

	vector<int> cumulativePts;
	ReadCumulativePointsVisualSfm(Path, nviews, cumulativePts);
	int totalPts = cumulativePts[nviews];

	vector<int>*PViewIdAll3D = new vector<int>[n3D];
	vector<int>*PuvIdAll3D = new vector<int>[n3D];

	printf("Reading Matching table....");
	sprintf(Fname, "%s/ViewPM.txt", Path); fp = fopen(Fname, "r");
	n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		PViewIdAll3D[n3D].reserve(nviewsi);
		for (int ii = 0; ii < nviewsi; ii++)
		{
			fscanf(fp, "%d ", &viewi);
			PViewIdAll3D[n3D].push_back(viewi);
		}
		n3D++;
	}
	fclose(fp);

	sprintf(Fname, "%s/IDPM.txt", Path); fp = fopen(Fname, "r");
	int np, pi;
	n3D = 0;
	while (fscanf(fp, "%d ", &np) != EOF)
	{
		PuvIdAll3D[n3D].reserve(np);
		for (int ii = 0; ii < np; ii++)
		{
			fscanf(fp, "%d ", &pi);
			PuvIdAll3D[n3D].push_back(pi);
		}
		n3D++;
	}
	fclose(fp);
	printf("...Done\n");

	//Read all sift points
	printf("Reading SIFT keys....");
	vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
	Mat *AllDesc = new Mat[nviews];
	vector<Point3i> *AllRGB = new vector < Point3i >[nviews];
	Mat cvImg;
	for (int ii = 0; ii < nviews; ii++)
	{
		sprintf(Fname, "%s/%d.sift", Path, ii); readVisualSFMSiftGPU(Fname, AllKeys[ii], AllDesc[ii]);// ReadKPointsBinarySIFT(Fname, AllKeys[ii]);

		sprintf(Fname, "%s/RGB%d.dat", Path, ii);
		if (!ReadRGBBinarySIFT(Fname, AllRGB[ii]))
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii);
			cvImg = imread(Fname, IMREAD_COLOR);

			int nkeys = (int)AllKeys[ii].size();
			AllRGB[ii].reserve(nkeys);
			for (int kk = 0; kk < nkeys; kk++)
			{
				int x = (int)AllKeys[ii][kk].x, y = (int)AllKeys[ii][kk].y;
				int id = x + y*cvImg.cols;
				Point3i rgb;
				rgb.z = cvImg.data[3 * id + 0];//b
				rgb.y = cvImg.data[3 * id + 1];//g
				rgb.x = cvImg.data[3 * id + 2];//r
				AllRGB[ii].push_back(rgb);
			}

			sprintf(Fname, "%s/RGB%d.dat", Path, ii); WriteRGBBinarySIFT(Fname, AllRGB[ii]);
		}
	}
	printf("...Done\n");

	//Correct for distortion if needed
	if (distortionCorrected == 0)
	{
		distortionCorrected = 1;
		Point2d pt;
		for (int ii = 0; ii < nviews; ii++)
		{
			int npts = AllKeys[ii].size();
			if (corpusData.camera[ii].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					LensCorrectionPoint(&pt, corpusData.camera[ii].K, corpusData.camera[ii].distortion);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
			else
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					FishEyeCorrectionPoint(&pt, corpusData.camera[ii].distortion[0], corpusData.camera[ii].distortion[1], corpusData.camera[ii].distortion[2]);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
		}
	}

	//Triangulate points from estimated camera poses
	printf("Triangulating the Corpus...");
	Point3d xyz;
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool *passed = new bool[nviews * 2];
	double *Ps = new double[12 * nviews * 2];

	vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
	Point2d *match2Dpts = new Point2d[nviews * 2];
	double *matchScales = new double[nviews * 2];

	corpusData.xyz.reserve(n3D);
	corpusData.rgb.reserve(n3D);
	corpusData.viewIdAll3D.reserve(n3D);
	corpusData.pointIdAll3D.reserve(n3D);

	vector<int>viewIDs, pointIDs, orgId, threeDid;
	vector<Point2d> uvPer3D, uvperView;
	vector<double>scalePer3D, scalePerView;

	for (int ii = 0; ii < n3D; ii++)
	{
		corpusData.viewIdAll3D.push_back(viewIDs), corpusData.viewIdAll3D[ii].reserve(nviews);
		corpusData.pointIdAll3D.push_back(pointIDs), corpusData.pointIdAll3D[ii].reserve(nviews);
		corpusData.uvAll3D.push_back(uvPer3D), corpusData.uvAll3D[ii].reserve(nviews);
		corpusData.scaleAll3D.push_back(scalePer3D), corpusData.scaleAll3D[ii].reserve(nviews);
	}

	printf("Start: \n");
	double ProThresh = 0.99, PercentInlier = 0.25;
	int goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	bool printout = 0;
	double start = omp_get_wtime();
	for (int jj = 0; jj < n3D; jj++)
	{
		if (jj % 1000 == 0)
			printf("@\r# %.2f%% (%.2fs) Triangualating corpus..", 100.0*jj / n3D, omp_get_wtime() - start);
		int nviewsi = PViewIdAll3D[jj].size();
		if (nviewsi >= NDplus)
		{
			Inliers[0].clear();
			for (int ii = 0; ii < nviewsi; ii++)
			{
				viewi = PViewIdAll3D[jj][ii]; pi = PuvIdAll3D[jj][ii];
				if (ShutterModel == 0)
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = corpusData.camera[viewi].P[kk];
				else
				{
					double *wt = corpusData.camera[viewi].wt;
					double *intrinsic = corpusData.camera[viewi].intrinsic;
					double *Rcenter = corpusData.camera[viewi].R;
					double *Tcenter = corpusData.camera[viewi].T;
					double ycn = (AllKeys[viewi][pi].y - intrinsic[4]) / intrinsic[1];

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(corpusData.camera[viewi].K, R, T, Ps + 12 * ii);
				}

				match2Dpts[ii].x = AllKeys[viewi][pi].x, match2Dpts[ii].y = AllKeys[viewi][pi].y;
				matchScales[ii] = AllKeys[viewi][pi].s;
			}
		}
		else
			continue;
		/*if (printout)
		{
		FILE *fp = fopen("C:/temp/corres.txt", "w+");
		for (int ii = 0; ii < nviewsi; ii++)
		fprintf(fp, "%.1f %.1f\n", match2Dpts[ii].x, match2Dpts[ii].y);
		for (int ii = 0; ii < nviewsi; ii++)
		{
		for (int jj = 0; jj < 12; jj++)
		fprintf(fp, "%.4f ", Ps[jj + ii * 12]);
		fprintf(fp, "\n");
		}
		fclose(fp);
		}*/

		NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, corpusData.camera[0].threshold, A, B, tPs);

		if (passed[0])
		{
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
				if (Inliers[0][ii])
					ninlier++;
			if (ninlier < NDplus)
				continue; //Corpus needs NDplus+ points!
			corpusData.xyz.push_back(xyz);

			for (int ii = 0; ii < nviewsi; ii++)
			{
				if (Inliers[0][ii])
				{
					viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];

					corpusData.viewIdAll3D[goodNDplus].push_back(viewi);
					corpusData.pointIdAll3D[goodNDplus].push_back(pi);
					corpusData.uvAll3D[goodNDplus].push_back((match2Dpts[ii]));//store corrected 2d points into corpus
					corpusData.scaleAll3D[goodNDplus].push_back((matchScales[ii]));//store corrected 2d points into corpus
				}
			}
			goodNDplus++;
		}
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);
	printf("Found %d (%d+) points.\n\n", goodNDplus, NDplus);


	//Let's reoptimize verything
	printf("Runing BA on the triangulated points...");
	bool fixIntrinsic = 0, fixDistortion = 0, fixPose = 0, fix1stCamPose = 1, fix3D = 0;

	if (fixIntrinsic == 0 || fixDistortion == 0)//Get back the distorted points so that the BA can correctly restart
	{
		distortionCorrected = 0;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, fix3D, distortionCorrected, LossType, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, false, fix3D, distortionCorrected, LossType, false, false);

	//Now, can undistort points again
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 1;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensCorrectionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}
	printf("\n");

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	//Get the color info
	Point3i rgb;
	corpusData.rgb.reserve(goodNDplus);
	for (int kk = 0; kk < goodNDplus; kk++)
	{
		viewi = corpusData.viewIdAll3D[kk][0];
		pi = corpusData.pointIdAll3D[kk][0];
		rgb = AllRGB[viewi][pi];
		corpusData.rgb.push_back(rgb);
	}
	vector<int> AvailViews; AvailViews.reserve(nviews);
	for (int ii = 0; ii < nviews; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, corpusData.camera, AvailViews, corpusData.xyz, corpusData.rgb); // OK for visualization

	//Prune corpus for bad points
	printf("Remove not good points ...");
	vector<int> *notGood = new vector<int>[goodNDplus];
	sprintf(Fname, "%s/Good.txt", Path);	fp = fopen(Fname, "r");
	if (fp != NULL)
	{
		for (int jj = 0; jj < goodNDplus; jj++)
		{
			int pid, ii;
			fscanf(fp, "%d %d", &pid, &ii);
			while (ii != -1)
			{
				notGood[jj].push_back(ii);
				fscanf(fp, "%d ", &ii);
			}
		}
		fclose(fp);
	}

	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = notGood[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
		{
			int viewID = notGood[jj][ii];
			if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
				printf("%d\n", jj);
			else
			{
				corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
				corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
				corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
				corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
			}
		}
	}
	delete[]notGood;
	sprintf(Fname, "%s/Good.txt", Path);  remove(Fname);


	//And generate 3D id, uv, sift id for all views
	printf("and generate Corpus visibility info....");
	vector<int> *twoDiDAllViews = new vector<int>[nviews];
	corpusData.threeDIdAllViews = new vector<int>[nviews];
	corpusData.uvAllViews = new vector<Point2d>[nviews];
	corpusData.scaleAllViews = new vector<double>[nviews];
	corpusData.DescAllViews = new vector<FeatureDesc>[nviews];

	for (int ii = 0; ii < nviews; ii++)
	{
		twoDiDAllViews[ii].reserve(10000);
		corpusData.threeDIdAllViews[ii].reserve(10000);
		corpusData.uvAllViews[ii].reserve(10000);
		corpusData.scaleAllViews[ii].reserve(10000);
		corpusData.DescAllViews[ii].reserve(10000);
	}

	double scale;
	Point2d uv;
	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.viewIdAll3D[jj].size(); ii++)
		{
			viewi = corpusData.viewIdAll3D[jj][ii], pi = corpusData.pointIdAll3D[jj][ii], uv = corpusData.uvAll3D[jj][ii], scale = corpusData.scaleAll3D[jj][ii];

			twoDiDAllViews[viewi].push_back(pi);
			corpusData.threeDIdAllViews[viewi].push_back(jj);
			corpusData.uvAllViews[viewi].push_back(uv);
			corpusData.scaleAllViews[viewi].push_back(scale);
		}
	}
	printf("Done!\n");

	//Get sift desc for all views
	printf("Prune SIFT descriptors for only Corpus points....");
	int nSift, totalSift = 0, maxSift = 0;
	corpusData.IDCumView.reserve(nviews + 1);
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.IDCumView.push_back(totalSift);
		nSift = twoDiDAllViews[ii].size();
		if (nSift > maxSift)
			maxSift = nSift;
		totalSift += nSift;
	}
	corpusData.IDCumView.push_back(totalSift);

	FeatureDesc desci;
	for (int ii = 0; ii < nviews; ii++)
	{
		int nSift = corpusData.uvAllViews[ii].size();
		for (int j = 0; j < nSift; ++j)
		{
			int pid = twoDiDAllViews[ii][j];
			for (int i = 0; i < SIFTBINS; i++)
				desci.desc[i] = AllDesc[ii].at<float>(pid, i);
			corpusData.DescAllViews[ii].push_back(desci);
		}
	}

	printf("... Done!\nSaving corpus info\n");
	printf("****NOTE: 2d points in Corpus are corrected***\n");
	SaveCorpusInfo(Path, corpusData);

	printf("... Done\n\n");

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys, delete[]AllDesc, delete[]twoDiDAllViews;
	delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts, delete[]matchScales;

	return 0;
}
int Build3DFromSyncedImages(char *Path, int nviews, int startFrame, int stopFrame, int timeStep, int LensType, int distortionCorrected, int NDplus, double Reprojectionthreshold, double DepthThresh, int *FrameOffset, bool Save2DCorres, bool Gen3DPatchFile, double Patch_World_Unit, bool useRANSAC)
{
	int nFrames = max(MaxnFrames, stopFrame);
	if (FrameOffset == NULL)
	{
		FrameOffset = new int[nviews];
		for (int ii = 0; ii < nviews; ii++)
			FrameOffset[ii] = 0;
	}


	char Fname[200];
	VideoData AllVideoInfo;
	if (ReadVideoData(Path, AllVideoInfo, nviews, startFrame, stopFrame) == 1)
		return 1;

	int totalPts, MAXPTS = 0;
	for (int timeID = startFrame; timeID <= stopFrame; timeID += timeStep)
	{
		sprintf(Fname, "%s/Dynamic/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int nviewsi, viewi, n3D = 0;
		while (fscanf(fp, "%d ", &nviewsi) != EOF)
		{
			for (int ii = 0; ii < nviewsi; ii++)
				fscanf(fp, "%d ", &viewi);
			n3D++;
		}
		fclose(fp);
		if (n3D > MAXPTS)
			MAXPTS = n3D;
	}

	vector<int> cumulativePts; cumulativePts.reserve(nviews);
	vector<int>*PViewIdAll3D = new vector<int>[MAXPTS];
	vector<int>*PuvIdAll3D = new vector<int>[MAXPTS];
	vector<KeyPoint> *AllKeys = new vector < KeyPoint >[nviews];
	vector<Point3i> *RGB = new vector < Point3i >[nviews];
	vector<Point3d> AllXYZ; AllXYZ.reserve(1000);
	vector<Point3i> AllRGB; AllRGB.reserve(1000);

	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool passed;
	double *Ps = new double[12 * nviews * 2];
	Point2d *match2Dpts = new Point2d[nviews * 2], *match2Dpts_BK = new Point2d[nviews * 2];
	Point3i *matchRGB = new Point3i[nviews * 2];

	int width = 1280, height = 720;
	double *Img = new double[1280 * 720 * 8];

	FILE *fp1 = 0, *fp2 = 0, *fp3 = 0, *fp4 = 0, *fp5 = 0;
	for (int timeID = startFrame; timeID <= stopFrame; timeID += timeStep)
	{
		printf("Working on time %d ...\n", timeID);
		cumulativePts.clear(); AllXYZ.clear(), AllRGB.clear();
		if (ReadCumulativePoints(Path, nviews, timeID, cumulativePts) == 1)
			continue;
		totalPts = cumulativePts.at(nviews);

		sprintf(Fname, "%s/Dynamic/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int nviewsi, viewi, n3D = 0;
		while (fscanf(fp, "%d ", &nviewsi) != EOF)
		{
			PViewIdAll3D[n3D].clear(), PViewIdAll3D[n3D].reserve(nviewsi);
			for (int ii = 0; ii < nviewsi; ii++)
			{
				fscanf(fp, "%d ", &viewi);
				PViewIdAll3D[n3D].push_back(viewi);
			}
			n3D++;
		}
		fclose(fp);

		sprintf(Fname, "%s/Dynamic/IDPM_%d.txt", Path, timeID); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int np, pi;
		n3D = 0;
		while (fscanf(fp, "%d ", &np) != EOF)
		{
			PuvIdAll3D[n3D].clear(), PuvIdAll3D[n3D].reserve(np);
			for (int ii = 0; ii < np; ii++)
			{
				fscanf(fp, "%d ", &pi);
				PuvIdAll3D[n3D].push_back(pi);
			}
			n3D++;
		}
		fclose(fp);

		//Read all sift points
		for (int ii = 0; ii < nviews; ii++)
		{
			AllKeys[ii].clear(); RGB[ii].clear();
			sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID + FrameOffset[ii]); ReadKPointsBinarySIFT(Fname, AllKeys[ii]);
			sprintf(Fname, "%s/%d/RGB%d.dat", Path, ii, timeID + FrameOffset[ii]); ReadRGBBinarySIFT(Fname, RGB[ii]);
		}

		//Triangulate points from estimated camera poses
		Point3d xyz;
		vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
		vector<int>viewIDs, pointIDs, orgId, threeDid;
		vector<Point2d> uvPer3D, uvperView;
		Point3d PatchExpansionArrow[2];
		vector<KeyPoint> inlierPts;
		vector<CameraData> inlierViewsInfo;

		sprintf(Fname, "%s/Dynamic/3dGL_%d.xyz", Path, timeID); fp1 = fopen(Fname, "w+");
		if (Save2DCorres)
			sprintf(Fname, "%s/Dynamic/2DCorres_%d.txt", Path, timeID), fp2 = fopen(Fname, "w+");
		if (Gen3DPatchFile)
			sprintf(Fname, "%s/Dynamic/3DMem_%d.txt", Path, timeID), fp3 = fopen(Fname, "w+");

		double ProThresh = 0.99, PercentInlier = 0.25;
		int ninlier, inlierID, goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
		double start = omp_get_wtime();

		sprintf(Fname, "%s/Dynamic/Corres_%d.txt", Path, timeID), fp4 = fopen(Fname, "w+");

		for (int jj = 0; jj < nviews; jj++)
		{
			sprintf(Fname, "%s/%d/bg_%d.png", Path, jj, timeID + FrameOffset[jj]);
			//GrabImage(Fname, Img+jj*width*height, width, height, 1);
		}

		//FILE *fp5 = fopen("C:/temp/id.txt", "w+");
		for (int jj = 0; jj < n3D; jj++)
		{
			int nviewsi = PViewIdAll3D[jj].size();
			if (nviewsi >= NDplus)
			{
				//check for duplication
				bool duplicated = false;
				for (int ii = 1; ii < nviewsi; ii++)
					if (PViewIdAll3D[jj].at(ii - 1) == PViewIdAll3D[jj][ii])
						duplicated = true;
				if (duplicated)
					continue;

				//check for background
				/*bool background = false;
				for (int ii = 1; ii < nviewsi; ii++)
				{
				viewi = PViewIdAll3D[jj][ii];
				pi = PuvIdAll3D[jj][ii];
				match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);
				int x = match2Dpts[ii].x, y = match2Dpts[ii].y;
				if (Img[x + y*width+viewi*width*height] >250)
				background = true;
				}
				if (background)
				continue;

				fprintf(fp4, "%d ", nviewsi);
				for (int ii = 0; ii < nviewsi; ii++)
				{
				viewi = PViewIdAll3D[jj][ii];
				pi = PuvIdAll3D[jj][ii];
				match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);

				fprintf(fp4, "%d %.2f %.2f ", viewi, match2Dpts[ii].x, match2Dpts[ii].y);
				}
				fprintf(fp4, "\n ");*/

				Inliers[0].clear();
				for (int ii = 0; ii < nviewsi; ii++)
				{
					viewi = PViewIdAll3D[jj][ii];
					int fid = timeID + FrameOffset[viewi];
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = AllVideoInfo.VideoInfo[viewi*nFrames + fid].P[kk];

					pi = PuvIdAll3D[jj][ii];

					match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);
					matchRGB[ii] = Point3i(RGB[viewi].at(pi).x, RGB[viewi].at(pi).y, RGB[viewi].at(pi).z);

					if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].LensModel == RADIAL_TANGENTIAL_PRISM)
						LensCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].K, AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion);
					else if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].LensModel == FISHEYE)
						FishEyeCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[0],
						AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[1], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[2]);
				}

				if (useRANSAC)
					NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, &passed, Inliers, nviewsi, 1, nviewsi == 2 ? 1 : iterMax, PercentInlier, Reprojectionthreshold, A, B, tPs);
				else
				{
					NviewTriangulation(match2Dpts, Ps, &xyz, nviewsi, 1, NULL, A, B);
					ProjectandDistort(xyz, match2Dpts_BK, Ps, NULL, NULL, nviewsi);

					double finalerror = 0.0;
					for (int ii = 0; ii < nviewsi; ii++)
						finalerror += pow(match2Dpts_BK[ii].x - match2Dpts[ii].x, 2) + pow(match2Dpts_BK[ii].y - match2Dpts[ii].y, 2);
					finalerror = sqrt(finalerror / nviewsi);
					if (finalerror < Reprojectionthreshold)
						passed = true;
					else
						passed = false;
				}

				if (passed)
				{
					inlierPts.clear();
					inlierViewsInfo.clear();

					if (useRANSAC)
					{
						ninlier = 0;
						for (int ii = 0; ii < Inliers[0].size(); ii++)
						{
							if (Inliers[0][ii])
							{
								inlierID = ii, ninlier++;
								if (Gen3DPatchFile)
								{
									viewi = PViewIdAll3D[jj][ii];
									pi = PuvIdAll3D[jj][ii];
									inlierPts.push_back(AllKeys[viewi].at(pi));
									inlierViewsInfo.push_back(AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]]);
								}
							}
						}
						if (ninlier < NDplus)
							continue; //Corpus needs NDplus+ points!
					}
					else
						inlierID = 0;

					AllXYZ.push_back(xyz);
					AllRGB.push_back(matchRGB[inlierID]);
					if (abs(xyz.x) + abs(xyz.y) + abs(xyz.z) > 0.001)
					{
						//threshold by depth
						double *Center, Dist, minPointCamDistance = 9e9;
						for (int ii = 0; ii < nviews; ii++)
						{
							Center = AllVideoInfo.VideoInfo[ii*nFrames + timeID + FrameOffset[ii]].camCenter;
							Dist = Distance3D(Point3d(Center[0], Center[1], Center[2]), xyz);
							if (Dist < minPointCamDistance)
								minPointCamDistance = Dist;
						}
						if (minPointCamDistance > DepthThresh)
							continue;

						fprintf(fp1, "%.4f %.4f %.4f %d %d %d\n", xyz.x, xyz.y, xyz.z, matchRGB[inlierID].x, matchRGB[inlierID].y, matchRGB[inlierID].z);

						if (Save2DCorres)
						{
							fprintf(fp2, "%d ", ninlier);
							for (int ii = 0; ii < Inliers[0].size(); ii++)
							{
								if (Inliers[0][ii])
								{
									int viewid = PViewIdAll3D[jj][ii];
									LensDistortionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewid*nFrames + timeID + FrameOffset[viewid]].K, AllVideoInfo.VideoInfo[viewid*nFrames + timeID + FrameOffset[viewid]].distortion);
									fprintf(fp2, "%d %f %f ", viewid, match2Dpts[ii].x, match2Dpts[ii].y);
								}
							}
							fprintf(fp2, "\n");
						}

						if (Gen3DPatchFile)
						{
							double scale3D;
							SelectRefCam_InitPatchFixedScale(PatchExpansionArrow, scale3D, xyz, inlierPts, inlierViewsInfo, Patch_World_Unit);
							fprintf(fp3, "Pt3D %d %.4f %.4f %.4f %.4f %.4f %.4f %f %f %f %f %f %f %f\n", goodNDplus, xyz.x, xyz.y, xyz.z, 1.0*matchRGB[inlierID].x / 255.0, 1.0*matchRGB[inlierID].y / 255.0, 1.0*matchRGB[inlierID].z / 255.0,
								scale3D, PatchExpansionArrow[0].x, PatchExpansionArrow[0].y, PatchExpansionArrow[0].z,
								PatchExpansionArrow[1].x, PatchExpansionArrow[1].y, PatchExpansionArrow[1].z);
							fprintf(fp3, "%d ", ninlier);
							for (int ii = 0; ii < Inliers[0].size(); ii++)
							{
								if (Inliers[0][ii])
									fprintf(fp3, "%d %f %f ", PViewIdAll3D[jj][ii], match2Dpts[ii].x, match2Dpts[ii].y);
							}
							fprintf(fp3, "\n");
						}
					}

					goodNDplus++;
				}
			}
		}
		fclose(fp4);

		fclose(fp1);
		if (Save2DCorres)
			fclose(fp2);
		if (Gen3DPatchFile)
			fclose(fp3);
	}

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys;
	delete[]A, delete[]B, delete[]tPs, delete[]Ps, delete[]match2Dpts, delete[]match2Dpts_BK;
	return 0;
}

int MatchCameraToCorpus(char *Path, Corpus &corpusData, CameraData &CamInfoI, int cameraID, int timeID, int distortionCorrected, vector<int> &CorpusViewToMatch, const float nndrRatio, const int ninlierThresh, bool useGPU = true)
{
	//Load image and extract features
	const int descriptorSize = SIFTBINS;

	char Fname[200];
	sprintf(Fname, "%s/%d/%d.png", Path, cameraID, timeID);
	Mat img = imread(Fname, CV_LOAD_IMAGE_COLOR);
	if (img.empty())
	{
		printf("Can't read %s\n", Fname);
		return 1;
	}

	double start = omp_get_wtime();
	if (timeID < 0)
		sprintf(Fname, "%s/%d/K.dat", Path, cameraID);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, cameraID, timeID);

	bool readsucces = false;
	vector<KeyPoint> keypoints1; keypoints1.reserve(MaxNFeatures);
	readsucces = ReadKPointsBinarySIFT(Fname, keypoints1);
	if (!readsucces)
	{
		printf("%s does not have SIFT points. Please precompute it!\n", Fname);
		exit(1);
	}

	//remove distortion if not removed before in case camera is calibrated
	if (distortionCorrected == 0)
	{
		Point2d pt;
		if (CamInfoI.LensModel == RADIAL_TANGENTIAL_PRISM && CamInfoI.notCalibrated == false)
		{
			for (int ii = 0; ii < keypoints1.size(); ii++)
			{
				pt.x = keypoints1[ii].pt.x, pt.y = keypoints1[ii].pt.y;
				LensCorrectionPoint(&pt, CamInfoI.K, CamInfoI.distortion);
				keypoints1[ii].pt.x = pt.x, keypoints1[ii].pt.y = pt.y;
			}
		}
		else if (CamInfoI.LensModel == FISHEYE &&CamInfoI.notCalibrated == false)
		{
			for (int ii = 0; ii < keypoints1.size(); ii++)
			{
				pt.x = keypoints1[ii].pt.x, pt.y = keypoints1[ii].pt.y;
				FishEyeCorrectionPoint(&pt, CamInfoI.distortion[0], CamInfoI.distortion[1], CamInfoI.distortion[2]);
				keypoints1[ii].pt.x = pt.x, keypoints1[ii].pt.y = pt.y;
			}
		}
	}

	if (timeID < 0)
		sprintf(Fname, "%s/D%d.dat", Path, cameraID);
	else
		sprintf(Fname, "%s/%d/D%d.dat", Path, cameraID, timeID);
	Mat descriptors1 = ReadDescriptorBinarySIFT(Fname);
	if (descriptors1.rows == 1)
	{
		printf("%s does not have SIFT points. Please precompute it!\n", Fname);
		exit(1);
	}

	//USAC config
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	ConfigParamsFund cfg;
	cfg.common.confThreshold = 0.99, cfg.common.minSampleSize = 7, cfg.common.inlierThreshold = 3.0;
	cfg.common.maxHypotheses = 850000, cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true, cfg.common.prevalidateModel = true, cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM, cfg.common.verifMethod = USACConfig::VERIF_SPRT, cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	if (USEPROSAC)
		cfg.prosac.maxSamples, cfg.prosac.beta, cfg.prosac.nonRandConf, cfg.prosac.minStopLen;
	if (USESPRT)
		cfg.sprt.tM = 200.0, cfg.sprt.mS = 2.38, cfg.sprt.delta = 0.05, cfg.sprt.epsilon = 0.15;
	if (USELOSAC)
		cfg.losac.innerSampleSize = 15, cfg.losac.innerRansacRepetitions = 5, cfg.losac.thresholdMultiplier = 2.0, cfg.losac.numStepsIterative = 4;

	if (distortionCorrected == 0 && CamInfoI.distortion != NULL) // allow for more error if the image is not corrected and distortion parameters are unknown
		cfg.common.inlierThreshold *= 1.5;

	//Match extracted features with Corpus
	const bool useBFMatcher = false;
	const int knn = 2, ntrees = 4, maxLeafCheck = 128;

	vector<float>Scale; Scale.reserve(5000);
	vector<Point2f> twoD; twoD.reserve(5000);
	vector<int> threeDiD; threeDiD.reserve(5000);
	vector<int>viewID; viewID.reserve(5000);

	//Finding nearest neighbor
	vector<float>Scale1;
	vector<Point2d>key1, key2;
	vector<int>CorrespondencesID;
	double Fmat[9];
	vector<int>cur3Ds, Inliers;
	key1.reserve(5000), key2.reserve(5000);
	Scale1.reserve(5000);
	CorrespondencesID.reserve(5000), cur3Ds.reserve(5000), Inliers.reserve(5000);

	for (int ii = 0; ii < CorpusViewToMatch.size(); ii++)
	{
		key1.clear(), key2.clear();
		cur3Ds.clear(), Inliers.clear(), CorrespondencesID.clear();

		int camera2ID = CorpusViewToMatch[ii];
		/*int startID = corpusData.IDCumView.at(camera2ID), endID = corpusData.IDCumView.at(camera2ID + 1);
		Mat descriptors2(endID - startID, SIFTBINS, CV_32F);

		for (int jj = startID; jj < endID; jj++)
		for (int kk = 0; kk < SIFTBINS; kk++)
		descriptors2.at<float>(jj - startID, kk) = corpusData.SiftDesc.at<float>(jj, kk);*/

		int nsiftInCorpusView = (int)corpusData.DescAllViews[camera2ID].size();
		Mat descriptors2(nsiftInCorpusView, SIFTBINS, CV_32F);

		for (int jj = 0; jj < nsiftInCorpusView; jj++)
			for (int kk = 0; kk < SIFTBINS; kk++)
				descriptors2.at<float>(jj, kk) = corpusData.DescAllViews[camera2ID][jj].desc[kk];

		/*FILE *fp = fopen("C:/temp/cd.txt", "w+");
		for (int jj = 0; jj < nsiftInCorpusView; jj++)
		{
		int id = -1, pid = corpusData.threeDIdAllViews[camera2ID][jj];
		vector<int> a = corpusData.pointIdAll3D[pid], b = corpusData.viewIdAll3D[pid];
		for (int kk = 0; kk < (int)b.size(); kk++)
		if (b[kk] == camera2ID)
		{
		id = kk;
		break;
		}
		if (id != -1)
		fprintf(fp, "%d %.4f %.4f ", a[id], corpusData.uvAllViews[camera2ID][jj].x, corpusData.uvAllViews[camera2ID][jj].y);
		else
		int a = 0;
		for (int kk = 0; kk < SIFTBINS; kk++)
		fprintf(fp, "%f ", corpusData.DescAllViews[camera2ID][jj].desc[kk]);
		fprintf(fp, "\n");
		}
		fclose(fp);

		fp = fopen("C:/temp/ni.txt", "w+");
		for (int jj = 0; jj < keypoints1.size(); jj++)
		{
		fprintf(fp, "%d %.4f %.4f ", jj, keypoints1[jj].pt.x, keypoints1[jj].pt.y);
		for (int kk = 0; kk < SIFTBINS; kk++)
		fprintf(fp, "%f ", descriptors1.at<float>(jj, kk));
		fprintf(fp, "\n");
		}
		fclose(fp);*/

		double start = omp_get_wtime();
		Mat indices, dists;
		vector<vector<DMatch> > matches;
		if (useBFMatcher)
		{
			cv::BFMatcher matcher(cv::NORM_L2);
			matcher.knnMatch(descriptors2, descriptors1, matches, knn);
		}
		else
		{
			cv::flann::Index flannIndex(descriptors1, cv::flann::KDTreeIndexParams(ntrees));//, cvflann::FLANN_DIST_EUCLIDEAN);
			flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams(maxLeafCheck));//Search in desc1 for every desc in 2
		}

		int count = 0;
		if (!useBFMatcher)
		{
			for (int i = 0; i < descriptors2.rows; ++i)
			{
				int ind1 = indices.at<int>(i, 0);
				if (indices.at<int>(i, 0) >= 0 && indices.at<int>(i, 1) >= 0 && dists.at<float>(i, 0) <= nndrRatio * dists.at<float>(i, 1))
				{
					int cur3Did = corpusData.threeDIdAllViews[camera2ID].at(i);
					cur3Ds.push_back(cur3Did);

					key1.push_back(Point2d(keypoints1.at(ind1).pt.x, keypoints1.at(ind1).pt.y));
					Scale1.push_back(keypoints1[ind1].size);
					key2.push_back(corpusData.uvAllViews[camera2ID].at(i));
				}
			}
		}
		else
		{
			for (unsigned int i = 0; i < matches.size(); ++i)
			{
				if (matches.at(i).size() == 2 && matches.at(i).at(0).distance <= nndrRatio * matches.at(i).at(1).distance)
				{
					int cur3Did = corpusData.threeDIdAllViews[camera2ID].at(i);
					cur3Ds.push_back(cur3Did);

					int ind1 = matches.at(i).at(0).trainIdx;
					key1.push_back(Point2d(keypoints1.at(ind1).pt.x, keypoints1.at(ind1).pt.y));
					Scale1.push_back(keypoints1[ind1].size);
					key2.push_back(corpusData.uvAllViews[camera2ID].at(i));
				}
			}
		}

		///****NOTE: 2d points in Corpus are corrected***///
		int ninliers = 0;
		if (key1.size() < ninlierThresh || key2.size() < ninlierThresh)
			continue;
		cfg.common.numDataPoints = key1.size();
		USAC_FindFundamentalMatrix(cfg, key1, key2, Fmat, Inliers, ninliers);

		/*sprintf(Fname, "%s/orig_pts.txt", Path); FILE *fp = fopen(Fname, "w+");
		for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%.2f %.2f %.2f %.2f\n", key1[ii].x, key1[ii].y, key2[ii].x, key2[ii].y);
		fclose(fp);

		sprintf(Fname, "%s/F.txt", Path); fp = fopen(Fname, "w+");
		for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Fmat[ii]);
		fclose(fp);

		sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
		for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", Inliers[ii]);
		fclose(fp);*/

		if (ninliers < ninlierThresh)
		{
			printf("(%d, %d) to Corpus %d: failed Fundamental matrix test\n\n", cameraID, timeID, camera2ID);
			continue;
		}

		//Add matches to 2d-3d list
		for (int jj = 0; jj < Inliers.size(); jj++)
		{
			if (Inliers[jj] == 1)
			{
				int cur3Did = cur3Ds[jj];
				bool used = false;
				for (int kk = 0; kk < threeDiD.size(); kk++)
				{
					if (cur3Did == threeDiD.at(kk))
					{
						used = true;
						break;
					}
				}
				if (used)
					continue;

				twoD.push_back(Point2f(key1[jj].x, key1[jj].y));
				Scale.push_back(Scale1[jj]);
				threeDiD.push_back(cur3Did);
				viewID.push_back(camera2ID);
				count++;
			}
		}

		bool ShowCorrespondence = 0;
		if (ShowCorrespondence)
		{
			int nchannels = 3;
			sprintf(Fname, "%s/%d/%d.png", Path, cameraID, timeID);
			IplImage *Img1 = cvLoadImage(Fname, nchannels == 3 ? 1 : 0);
			if (Img1->imageData == NULL)
			{
				printf("Cannot load %s\n", Fname);
				return 1;
			}
			sprintf(Fname, "%s/Corpus/%d.png", Path, camera2ID);
			IplImage *Img2 = cvLoadImage(Fname, nchannels == 3 ? 1 : 0);
			if (Img2->imageData == NULL)
			{
				printf("Cannot load %s\n", Fname);
				return 1;
			}

			vector<Point2d> _key1, _key2;
			if (distortionCorrected == 0)
			{
				_key1 = key1; _key2 = key2;
				Point2d pt;
				if (CamInfoI.LensModel == RADIAL_TANGENTIAL_PRISM && CamInfoI.notCalibrated == false)
					LensDistortionPoint(_key1, CamInfoI.K, CamInfoI.distortion);
				else  if (CamInfoI.LensModel == FISHEYE && CamInfoI.notCalibrated == false)
				{
					for (int ii = 0; ii < key1.size(); ii++)
						FishEyeDistortionPoint(&_key1[ii], CamInfoI.distortion[0], CamInfoI.distortion[1], CamInfoI.distortion[2]);
				}

				if (corpusData.camera[camera2ID].LensModel == RADIAL_TANGENTIAL_PRISM && corpusData.camera[camera2ID].notCalibrated == false)
					LensDistortionPoint(_key2, corpusData.camera[camera2ID].K, corpusData.camera[camera2ID].distortion);
				else if (corpusData.camera[camera2ID].LensModel == FISHEYE && corpusData.camera[camera2ID].notCalibrated == false)
				{
					for (int ii = 0; ii < key2.size(); ii++)
						FishEyeDistortionPoint(&_key2[ii], corpusData.camera[camera2ID].distortion[0], corpusData.camera[camera2ID].distortion[1], corpusData.camera[camera2ID].distortion[2]);
				}
			}

			CorrespondencesID.clear();
			for (int ii = 0; ii < key1.size(); ii++)
				if (Inliers[ii] == 1)
					CorrespondencesID.push_back(ii), CorrespondencesID.push_back(ii);

			IplImage* correspond = cvCreateImage(cvSize(Img1->width + Img2->width, Img1->height), 8, nchannels);
			cvSetImageROI(correspond, cvRect(0, 0, Img1->width, Img1->height));
			cvCopy(Img1, correspond);
			cvSetImageROI(correspond, cvRect(Img1->width, 0, correspond->width, correspond->height));
			cvCopy(Img2, correspond);
			cvResetImageROI(correspond);
			if (distortionCorrected == 0)
				DisplayImageCorrespondence(correspond, Img1->width, 0, _key1, _key2, CorrespondencesID, .25);
			else
				DisplayImageCorrespondence(correspond, Img1->width, 0, key1, key2, CorrespondencesID, .25);
			cout << "\a";
		}
#pragma omp critical
		printf("(%d, %d) to Corpus %d: %d 3+ points in %.2fs.\n\n", cameraID, timeID, camera2ID, count, omp_get_wtime() - start);
	}

	sprintf(Fname, "%s/%d/3D2D_%d.txt", Path, cameraID, timeID); FILE *fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", threeDiD.size());
	for (int jj = 0; jj < threeDiD.size(); jj++)
		fprintf(fp, "%d %.16f %.16f %.3f\n", threeDiD[jj], twoD[jj].x, twoD[jj].y, Scale[jj]);
	fclose(fp);

	/*sprintf(Fname, "%s/%d/_3D2D_%d.txt", Path, cameraID, timeID); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", threeDiD.size());
	for (int jj = 0; jj < threeDiD.size(); jj++)
	{
	int pid = threeDiD[jj], vid = viewID[jj];
	Point2d twoDCorpus;
	for (int i = 0; i < corpusData.viewIdAll3D[pid].size(); i++)
	{
	if (corpusData.viewIdAll3D[pid].at(i) == vid)
	{
	twoDCorpus = corpusData.uvAll3D[pid].at(i);
	break;
	}
	}
	fprintf(fp, "%d %.2f %.2f %d %.2f %.2f\n", threeDiD[jj], twoD[jj].x, twoD[jj].y, vid, twoDCorpus.x, twoDCorpus.y);
	}
	fclose(fp);*/

	return 0;
}
int CameraPose_GSBA(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> &uvAll3D, vector<double> &scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up Pose BA ...");
	ceres::Problem problem;

	int nBadCounts = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;

	double fxfy[2] = { camera.intrinsic[0], camera.intrinsic[1] };
	double skew = camera.intrinsic[2];
	double uv0[2] = { camera.intrinsic[3], camera.intrinsic[4] };
	double Radial12[2], Tangential[2], Radial3, Prism[2], omega, DistCtr[2];

	if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		Radial12[0] = camera.distortion[0], Radial12[1] = camera.distortion[1];
		Tangential[0] = camera.distortion[3], Tangential[1] = camera.distortion[4];
		Radial3 = camera.distortion[2], Prism[0] = camera.distortion[5], Prism[1] = camera.distortion[6];
	}
	else
		omega = camera.distortion[0], DistCtr[0] = camera.distortion[1], DistCtr[1] = camera.distortion[2];

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (distortionCorrected)
			PinholeReprojectionDebug(camera.intrinsic, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
		else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			PinholeDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
		else
			FOVReprojectionDistortionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);

		if (abs(residuals[0]) > 1.25*camera.threshold || abs(residuals[1]) > 1.25*camera.threshold)
		{
			Good.push_back(false);
			if (abs(residuals[0]) > maxOutlierX)
				maxOutlierX = residuals[0];
			if (abs(residuals[1]) > maxOutlierY)
				maxOutlierY = residuals[1];
			nBadCounts++;
		}
		else
		{
			Good.push_back(true);
			if (distortionCorrected == 1)
			{
				ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, camera.intrinsic, camera.rt, &xyz[3 * jj]);
			}
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError2::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, fxfy, &skew, uv0, Radial12, Tangential, &Radial3, Prism, camera.rt, &xyz[3 * jj]);
			}
			else
			{
				ceres::CostFunction* cost_function = FOVReprojectionError2::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, fxfy, &skew, uv0, camera.distortion, camera.rt, &xyz[3 * jj]);
			}

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			problem.SetParameterBlockConstant(xyz + 3 * jj);
		}

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], uvAll3D[jj].x, uvAll3D[jj].y, abs(residuals[0]), abs(residuals[1]));
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("(%d/%d) bad points detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, npts, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	if (nBadCounts > npts * 80 / 100)
		return 1;

	//Set up constant parameters:
	if (distortionCorrected == 1)
		problem.SetParameterBlockConstant(camera.intrinsic);
	else
	{
		problem.SetParameterBlockConstant(&skew);
		if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			problem.SetParameterBlockConstant(&Radial3), problem.SetParameterBlockConstant(Prism);
	}

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 300;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.BriefReport() << "\n";
	std::cout << summary.BriefReport() << "\n";

	//Store refined parameters
	if (distortionCorrected == 0)
	{
		camera.intrinsic[0] = fxfy[0], camera.intrinsic[1] = fxfy[1];
		camera.intrinsic[2] = skew;
		camera.intrinsic[3] = uv0[0], camera.intrinsic[4] = uv0[1];
		if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			camera.distortion[0] = Radial12[0], camera.distortion[1] = Radial12[1];
			camera.distortion[3] = Tangential[0], camera.distortion[4] = Tangential[1];
			camera.distortion[2] = Radial3, camera.distortion[5] = Prism[0], camera.distortion[6] = Prism[1];
		}
		else
			camera.distortion[0] = omega, camera.distortion[1] = DistCtr[0], camera.distortion[2] = DistCtr[1];
	}

	GetKFromIntrinsic(&camera, 1);
	GetRTFromrt(&camera, 1);
	AssembleP(camera.K, camera.R, camera.T, camera.P);
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int ii = 0; ii < npts; ii++)
	{
		if (abs(xyz[3 * ii]) > LIMIT3D)
		{
			if (!Good[ii])
				continue;

			if (distortionCorrected)
				PinholeReprojectionDebug(camera.intrinsic, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
				PinholeDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);
			else
				FOVReprojectionDistortionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", ii, xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2], uvAll3D[ii].x, uvAll3D[ii].y, abs(residuals[0]), abs(residuals[1]));
		}
	}
	if (debug)
		fclose(fp);


	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz;
	return 0;
}
int CameraPose_RSBA(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> &uvAll3D, vector<double> &scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up Pose BA ...");
	ceres::Problem problem;

	int nBadCounts = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (distortionCorrected)
			CayleyReprojectionDebug(camera.intrinsic, camera.rt, camera.wt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera.width, camera.height, residuals);
		else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			CayleyDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, camera.wt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera.width, camera.height, residuals);

		if (abs(residuals[0]) > 1.25*camera.threshold || abs(residuals[1]) > 1.25*camera.threshold)
		{
			Good.push_back(false);
			if (abs(residuals[0]) > maxOutlierX)
				maxOutlierX = residuals[0];
			if (abs(residuals[1]) > maxOutlierY)
				maxOutlierY = residuals[1];
			nBadCounts++;
		}
		else
		{
			Good.push_back(true);
			if (distortionCorrected == 1)
			{
				ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera.intrinsic, uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj], camera.width, camera.height);
				problem.AddResidualBlock(cost_function, NULL, camera.rt, camera.wt, &xyz[3 * jj]);
			}
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj], camera.width, camera.height);
				problem.AddResidualBlock(cost_function, NULL, camera.intrinsic, camera.distortion, camera.rt, camera.wt, &xyz[3 * jj]);
			}
			problem.SetParameterBlockConstant(&xyz[3 * jj]);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
		}

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], uvAll3D[jj].x, uvAll3D[jj].y, abs(residuals[0]), abs(residuals[1]));
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("(%d/%d) bad points detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, npts, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	if (nBadCounts > npts * 80 / 100)
		return 1;

	//Set up constant parameters:
	if (distortionCorrected == 0)
	{
		if (fixIntrinsic)
			problem.SetParameterBlockConstant(camera.intrinsic);
		if (fixDistortion)
			problem.SetParameterBlockConstant(camera.distortion);
	}

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 300;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.BriefReport() << "\n";


	GetKFromIntrinsic(&camera, 1);
	GetRTFromrt(&camera, 1);
	AssembleP(camera.K, camera.R, camera.T, camera.P);
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int ii = 0; ii < npts; ii++)
	{
		if (abs(xyz[3 * ii]) > LIMIT3D)
		{
			if (!Good[ii])
				continue;

			if (distortionCorrected)
				CayleyReprojectionDebug(camera.intrinsic, camera.rt, camera.wt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), camera.width, camera.height, residuals);
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
				CayleyDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, camera.wt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), camera.width, camera.height, residuals);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", ii, xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2], uvAll3D[ii].x, uvAll3D[ii].y, abs(residuals[0]), abs(residuals[1]));
		}
	}
	if (debug)
		fclose(fp);


	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz;
	return 0;
}
int P6P_RS(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> uvAll3D, vector<double> scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	//TO DO
	return 0;
}
int EstimateCameraPoseFromCorpus(char *Path, Corpus &corpusData, CameraData  &cameraParas, int cameraID, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, int sharedIntriniscOptim, int timeID)
{
	char Fname[200];
	int threeDid, npts, ptsCount = 0;
	double u, v, s = 1.0;

	sprintf(Fname, "%s/%d/3D2D_%d.txt", Path, cameraID, timeID);
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return -1;
	}
	fscanf(fp, "%d ", &npts);
	vector<int> threeDidVec;
	Point2d *pts = new Point2d[npts];
	double *Scale = new double[npts];
	Point3d *t3D = new Point3d[npts];
	while (fscanf(fp, "%d %lf %lf %lf ", &threeDid, &u, &v, &s) != EOF)
	{
		threeDidVec.push_back(threeDid);
		pts[ptsCount].x = u, pts[ptsCount].y = v, Scale[ptsCount] = s;
		t3D[ptsCount].x = corpusData.xyz.at(threeDid).x, t3D[ptsCount].y = corpusData.xyz.at(threeDid).y, t3D[ptsCount].z = corpusData.xyz.at(threeDid).z;
		ptsCount++;
	}
	fclose(fp);


	int ninliers;
	DetermineDevicePose(cameraParas.K, cameraParas.distortion, cameraParas.LensModel, cameraParas.R, cameraParas.T, pts, t3D, npts, distortionCorrected, cameraParas.threshold, ninliers);
	GetrtFromRT(&cameraParas, 1);

	vector<bool> Good; Good.reserve(npts);
	vector<Point3d> Vxyz; Vxyz.reserve(npts);
	vector<Point2d> uv; uv.reserve(npts);
	vector<double>scale; scale.reserve(npts);

	for (int ii = 0; ii < npts; ii++)
	{
		Vxyz.push_back(Point3d(t3D[ii].x, t3D[ii].y, t3D[ii].z));
		uv.push_back(Point2d(pts[ii].x, pts[ii].y));
		scale.push_back(Scale[ii]);
	}

	cameraParas.ShutterModel = 0;
	if (cameraParas.ShutterModel == 0)
	{
		if (CameraPose_GSBA(Path, cameraParas, Vxyz, uv, scale, Good, fixIntrinsic, fixDistortion, distortionCorrected, true) == 1)
			return -1;
	}
	else
	{
		if (CameraPose_RSBA(Path, cameraParas, Vxyz, uv, scale, Good, fixIntrinsic, fixDistortion, distortionCorrected, true) == 1)
			return -1;
		printf("Local RS pose: ");
		for (int ii = 0; ii < 6; ii++)
			printf("%f ", cameraParas.wt[ii]);
		printf("\n");
	}

	if (sharedIntriniscOptim != 0)
	{
		sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, cameraID, timeID);	fp = fopen(Fname, "w+");
		for (int ii = 0; ii < npts; ii++)
			if (Good[ii])
				fprintf(fp, "%d %f %f %f %.6f %.6f %.2f\n", threeDidVec[ii], Vxyz[ii].x, Vxyz[ii].y, Vxyz[ii].z, uv[ii].x, uv[ii].y, scale[ii]);
		fclose(fp);
	}

	if (fixIntrinsic == 0)
		printf("Intrinsic: %.1f %.1f %.1f %.1f %.1f\n", cameraParas.intrinsic[0], cameraParas.intrinsic[1], cameraParas.intrinsic[2], cameraParas.intrinsic[3], cameraParas.intrinsic[4]);
	if (fixDistortion == 0)
	{
		printf("Distortion: ");
		if (cameraParas.LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				printf("%.1e ", cameraParas.distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				printf("%.1e ", cameraParas.distortion[ii]);
		printf("\n");
	}

	sprintf(Fname, "%s/Intrinsic_%d.txt", Path, cameraID);
	fp = fopen(Fname, "a+");
	fprintf(fp, "%d %d %d %d %d ", timeID, cameraParas.LensModel, cameraParas.ShutterModel, cameraParas.width, cameraParas.height);
	for (int ii = 0; ii < 5; ii++)
		fprintf(fp, "%f ", cameraParas.intrinsic[ii]);
	if (cameraParas.LensModel == RADIAL_TANGENTIAL_PRISM)
		for (int ii = 0; ii < 7; ii++)
			fprintf(fp, "%f ", cameraParas.distortion[ii]);
	else
		for (int ii = 0; ii < 3; ii++)
			fprintf(fp, "%f ", cameraParas.distortion[ii]);
	fprintf(fp, "\n");
	fclose(fp);

	ninliers = 0;
	for (int ii = 0; ii < npts; ii++)
		if (Good[ii])
			ninliers++;

	double iR[9], center[3];
	mat_invert(cameraParas.R, iR);

	cameraParas.Rgl[0] = cameraParas.R[0], cameraParas.Rgl[1] = cameraParas.R[1], cameraParas.Rgl[2] = cameraParas.R[2], cameraParas.Rgl[3] = 0.0;
	cameraParas.Rgl[4] = cameraParas.R[3], cameraParas.Rgl[5] = cameraParas.R[4], cameraParas.Rgl[6] = cameraParas.R[5], cameraParas.Rgl[7] = 0.0;
	cameraParas.Rgl[8] = cameraParas.R[6], cameraParas.Rgl[9] = cameraParas.R[7], cameraParas.Rgl[10] = cameraParas.R[8], cameraParas.Rgl[11] = 0.0;
	cameraParas.Rgl[12] = 0, cameraParas.Rgl[13] = 0, cameraParas.Rgl[14] = 0, cameraParas.Rgl[15] = 1.0;

	mat_mul(iR, cameraParas.T, center, 3, 3, 1); //Center = -iR*T 
	cameraParas.camCenter[0] = -center[0], cameraParas.camCenter[1] = -center[1], cameraParas.camCenter[2] = -center[2];

	delete[]pts, delete[]t3D;
	if (ninliers < cameraParas.ninlierThresh)
	{
		printf("Estimated pose for View (%d, %d).. fails ... low inliers (%d/%d). Camera center: %.4f %.4f %.4f \n\n", cameraID, timeID, ninliers, npts, cameraParas.T[0], cameraParas.T[1], cameraParas.T[2]);
		return -1;
	}
	else
	{
		printf("Estimated pose for View (%d, %d).. succeds ... inliers (%d/%d). Camera center: %.4f %.4f %.4f \n\n", cameraID, timeID, ninliers, npts, cameraParas.T[0], cameraParas.T[1], cameraParas.T[2]);
		return ninliers;
	}
}
int VideoPose_GSBA(char *Path, int selectedCamID, int startFrame, int stopFrame, int fixedIntrinisc, int fixDistortion, int fixed3D, int distortionCorrected, double threshold, int lossFunction)
{
	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCamID, startFrame, stopFrame) == 1)
		return 1;

	//Read BA data
	double scale; Point2d uv; Point3d P3d;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = false, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.txt", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCamID, frameID);	FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.txt", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}

	bool setReferenceflag = false;
	int RefFrameID, nBadCounts, validPtsCount;
	double residuals[2], maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);

	double ErrorMultiplier[2] = { 10.0, 3.0 };
	ceres::LossFunction* loss_function = lossFunction == 0 ? NULL : new HuberLoss(threshold);
	for (int iteration = 0; iteration < 2; iteration++)
	{
		ceres::Problem problem;
		nBadCounts = 0, validPtsCount = 0;
		Good.clear(), ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
		{
			for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
			{
				int frameID = frameIDPer3D[pid][fid];
				uv = P2dPer3D[pid][fid];
				scale = scalePer3D[pid][fid];
				P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

				if (!setReferenceflag)
				{
					if (distortionCorrected)
						PinholeReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					else
					{
						if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
							PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
						else
							FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					}
				}
				else
				{
					if (distortionCorrected)
						PinholeReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					else
					{
						if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
							PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
						else
							FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					}
				}

				if (abs(residuals[0]) > ErrorMultiplier[iteration] * threshold || abs(residuals[1]) > ErrorMultiplier[iteration] * threshold)
				{
					Good.push_back(false);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
					continue;
				}
				else
				{
					Good.push_back(true);
					if (!setReferenceflag)
						RefFrameID = frameID, setReferenceflag = true;

					if (distortionCorrected == 0)
					{
						if (!fixed3D)
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError2::Create(uv.x, uv.y, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 2, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3,
								VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[RefFrameID].distortion + 3, VideoInfoI.VideoInfo[RefFrameID].distortion + 2, VideoInfoI.VideoInfo[RefFrameID].distortion + 5,
								VideoInfoI.VideoInfo[frameID].rt, &P3D[3 * pid]);
						}
						else
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError3::Create(uv.x, uv.y, P3d.x, P3d.y, P3d.z, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 2, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3,
								VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[RefFrameID].distortion + 3, VideoInfoI.VideoInfo[RefFrameID].distortion + 2, VideoInfoI.VideoInfo[RefFrameID].distortion + 5,
								VideoInfoI.VideoInfo[frameID].rt);
						}

						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].intrinsic[2]);
						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].distortion[2]);
						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].distortion[5]);

						if (fixedIntrinisc)
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic),
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3);
						if (fixDistortion)
						{
							if (VideoInfoI.VideoInfo[RefFrameID].LensModel == RADIAL_TANGENTIAL_PRISM)
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion),
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion + 3);
							else
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
						}
					}
					else
					{
						if (!fixed3D)
						{
							ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uv.x, uv.y, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, &P3D[3 * pid]);
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
						}
						else
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError4::Create(VideoInfoI.VideoInfo[RefFrameID].intrinsic, uv.x, uv.y, P3d.x, P3d.y, P3d.z, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[frameID].rt);
						}
					}

					validPtsCount++;
					ReProjectionErrorX.push_back(abs(residuals[0]));
					ReProjectionErrorY.push_back(abs(residuals[1]));
				}
			}
		}

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX);
		double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY);
		double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
		{
			printf("\n (%d/%d) bad projections detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
			printf("Reprojection error before BA \nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		}

		ceres::Solver::Options options;
		options.num_threads = omp_get_max_threads();
		options.num_linear_solver_threads = omp_get_max_threads();
		options.max_num_iterations = 30;
		options.linear_solver_type = ceres::SPARSE_SCHUR;
		options.minimizer_progress_to_stdout = false;
		options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		std::cout << "Iterration " << iteration << ": " << summary.BriefReport() << endl;
	}

	//Store refined parameters
	//printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
		GetRTFromrt(&VideoInfoI.VideoInfo[frameID], 1);
		AssembleP(VideoInfoI.VideoInfo[frameID].K, VideoInfoI.VideoInfo[frameID].R, VideoInfoI.VideoInfo[frameID].T, VideoInfoI.VideoInfo[frameID].P);
	}

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	int count = -1;
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			int frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			if (distortionCorrected)
				PinholeReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
			else
			{
				if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
				else
					FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
			}

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
		}
	}

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("\nFinal result: \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/gIntrinsic_%d.txt", Path, selectedCamID); FILE *fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	sprintf(Fname, "%s/gCamPose_%d.txt", Path, selectedCamID); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		//Center = -iR*T 
		GetRCGL(VideoInfoI.VideoInfo[frameID]);

		fprintf(fp, "%d ", frameID);
		for (int jj = 0; jj < 3; jj++)
			fprintf(fp, "%.16f ", VideoInfoI.VideoInfo[frameID].rt[jj]);
		for (int jj = 0; jj < 3; jj++)
			fprintf(fp, "%.16f ", VideoInfoI.VideoInfo[frameID].camCenter[jj]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	return 0;
}
int VideoPose_RS_Cayley_BA(char *Path, int selectedCamID, int startF, int stopF, int fixIntrinsic, int fixDistortion, int fixPose, int fixfirstCamPose, int fix3D, int distortionCorrected, int RobustLoss, bool doubleRefinement, double threshold)
{
	char Fname[200];
	int nframes = stopF - startF + 1;
	printf("Working on camera %d:\n", selectedCamID);
	Corpus CorpusData;
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCamID, startF, stopF) == 1)
		return 1;
	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].ShutterModel = 1;

	int dummy, nPoints, useColor;
	sprintf(Fname, "%s/Corpus/Corpus_3D.txt", Path); FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d %d %d", &dummy, &nPoints, &useColor);
	CorpusData.nCameras = nframes;
	CorpusData.n3dPoints = nPoints;


	Point3d xyz;	Point3i rgb;
	CorpusData.xyz.reserve(nPoints);
	if (useColor)
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf %d %d %d", &xyz.x, &xyz.y, &xyz.z, &rgb.x, &rgb.y, &rgb.z);
			CorpusData.xyz.push_back(xyz);
			CorpusData.rgb.push_back(rgb);
		}
	}
	else
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf ", &xyz.x, &xyz.y, &xyz.z);
			CorpusData.xyz.push_back(xyz);
		}
	}

	//Generate corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D
	vector<int> selectedCamID3D;
	vector<Point2d> uv3D;
	vector<double> scale3D;
	for (int ii = 0; ii < nPoints; ii++)
	{
		CorpusData.viewIdAll3D.push_back(selectedCamID3D); CorpusData.viewIdAll3D.back().reserve(nframes);
		CorpusData.uvAll3D.push_back(uv3D); CorpusData.uvAll3D.back().reserve(nframes);
		CorpusData.scaleAll3D.push_back(scale3D); CorpusData.scaleAll3D.back().reserve(nframes);
	}

	int pid; double s;
	Point2f uv;
	for (int fid = startF; fid <= stopF; fid++)
	{
		sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCamID, fid); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		while (fscanf(fp, "%d %lf %lf %lf %f %f %lf", &pid, &xyz.x, &xyz.y, &xyz.z, &uv.x, &uv.y, &s) != EOF)
		{
			CorpusData.viewIdAll3D[pid].push_back(fid);
			CorpusData.uvAll3D[pid].push_back(uv);
			CorpusData.scaleAll3D[pid].push_back(s);
		}
		fclose(fp);
	}

	if (distortionCorrected == 1 && !fixIntrinsic && !fixDistortion)
	{
		for (int jj = 0; jj < CorpusData.n3dPoints; jj++)
		{
			for (int ii = 0; ii < (int)CorpusData.uvAll3D[jj].size(); ii++)
			{
				int selectedCamID = CorpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&CorpusData.uvAll3D[jj][ii], VideoInfoI.VideoInfo[selectedCamID].K, VideoInfoI.VideoInfo[selectedCamID].distortion);
			}
		}
		distortionCorrected = 0;
	}

	vector<int> Refinement_SharedIntrinsic;
	for (int ii = 0; ii <= stopF; ii++)
		Refinement_SharedIntrinsic.push_back(0);

	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].threshold = !doubleRefinement ? threshold : 100.0; //make sure that most points are inliers
	CayleyRollingShutterBundleAdjustment(Path, VideoInfoI.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
		Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, RobustLoss, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii <= stopF; ii++)
			VideoInfoI.VideoInfo[ii].threshold = threshold;
		CayleyRollingShutterBundleAdjustment(Path, VideoInfoI.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
			Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, RobustLoss, false, false);
	}
	sprintf(Fname, "%s/Good.txt", Path), remove(Fname);

	//write video data
	printf("Writing refined poses ....");
	vector<int> computedTime;
	for (int ii = startF; ii <= stopF; ii++)
		if (VideoInfoI.VideoInfo[ii].valid)
			computedTime.push_back(ii);
	sprintf(Fname, "%s/Intrinsic_RSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraIntrinsic(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);
	sprintf(Fname, "%s/CamPose_RSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraPoses(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);

	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].ShutterModel = 0;
	sprintf(Fname, "%s/CamPose_sRSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraPoses(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);

	//ReSaveBundleAdjustedNVMResults(Fname, CorpusData);
	printf("Done!\n");

	return 0;
}
int AllVideoPose_RS_Cayley_BA(char *Path, int nCams, int startF, int stopF, int fixIntrinsic, int fixDistortion, int fixPose, int fixfirstCamPose, int fix3D, int distortionCorrected, int RobustLoss, bool doubleRefinement, double threshold)
{
	char Fname[200];
	int nframes = stopF - startF + 1;
	printf("Working on all %d cameras\n", nCams);
	Corpus CorpusData;

	VideoData AllVideoInfo;
	if (ReadVideoData(Path, AllVideoInfo, nCams, startF, stopF) == 1)
		return 1;

	int dummy, nPoints, useColor;
	sprintf(Fname, "%s/Corpus/Corpus_3D.txt", Path); FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d %d %d", &dummy, &nPoints, &useColor);
	CorpusData.nCameras = nframes;
	CorpusData.n3dPoints = nPoints;


	Point3d xyz;	Point3i rgb;
	CorpusData.xyz.reserve(nPoints);
	if (useColor)
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf %d %d %d", &xyz.x, &xyz.y, &xyz.z, &rgb.x, &rgb.y, &rgb.z);
			CorpusData.xyz.push_back(xyz);
			CorpusData.rgb.push_back(rgb);
		}
	}
	else
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf ", &xyz.x, &xyz.y, &xyz.z);
			CorpusData.xyz.push_back(xyz);
		}
	}

	//Generate corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D
	vector<int> selectedCamID3D;
	vector<Point2d> uv3D;
	vector<double> scale3D;
	for (int ii = 0; ii < nPoints; ii++)
	{
		CorpusData.viewIdAll3D.push_back(selectedCamID3D); CorpusData.viewIdAll3D.back().reserve(nframes*nCams);
		CorpusData.uvAll3D.push_back(uv3D); CorpusData.uvAll3D.back().reserve(nframes*nCams);
		CorpusData.scaleAll3D.push_back(scale3D); CorpusData.scaleAll3D.back().reserve(nframes*nCams);
	}

	int pid; double s;
	Point2f uv;
	for (int camID = 0; camID < nCams; camID++)
	{
		int videoID = AllVideoInfo.nframesI*camID;
		for (int fid = startF; fid <= stopF; fid++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, camID, fid); fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %f %f %lf", &pid, &xyz.x, &xyz.y, &xyz.z, &uv.x, &uv.y, &s) != EOF)
			{
				CorpusData.viewIdAll3D[pid].push_back(fid + videoID);
				CorpusData.uvAll3D[pid].push_back(uv);
				CorpusData.scaleAll3D[pid].push_back(s);
			}
			fclose(fp);
		}
	}

	if (distortionCorrected == 1 && !fixIntrinsic && !fixDistortion)
	{
		for (int jj = 0; jj < CorpusData.n3dPoints; jj++)
		{
			for (int ii = 0; ii < (int)CorpusData.uvAll3D[jj].size(); ii++)
			{
				int id = CorpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&CorpusData.uvAll3D[jj][ii], AllVideoInfo.VideoInfo[id].K, AllVideoInfo.VideoInfo[id].distortion);
			}
		}
		distortionCorrected = 0;
	}

	vector<int> Refinement_SharedIntrinsic;//size must be equal to the size of AllVideoInfo
	Refinement_SharedIntrinsic.reserve(nCams*AllVideoInfo.nframesI);
	for (int camID = 0; camID < nCams; camID++)
		for (int ii = 0; ii < AllVideoInfo.nframesI; ii++)
			Refinement_SharedIntrinsic.push_back(camID);

	for (int camID = 0; camID < nCams; camID++)
	{
		int videoID = AllVideoInfo.nframesI*camID;
		for (int ii = startF; ii < stopF; ii++)
			AllVideoInfo.VideoInfo[ii + videoID].threshold = !doubleRefinement ? threshold : 100.0; //make sure that most points are inliers
	}
	CayleyRollingShutterBundleAdjustment(Path, AllVideoInfo.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
		Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, RobustLoss, false, false);

	if (doubleRefinement)
	{
		for (int camID = 0; camID < nCams; camID++)
		{
			int videoID = AllVideoInfo.nframesI*camID;
			for (int ii = startF; ii < stopF; ii++)
				AllVideoInfo.VideoInfo[ii + videoID].threshold = threshold;
		}

		CayleyRollingShutterBundleAdjustment(Path, AllVideoInfo.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
			Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, RobustLoss, false, false);
	}
	sprintf(Fname, "%s/Good.txt", Path), remove(Fname);

	//write video data
	printf("Writing refined poses ....");
	for (int camID = 0; camID < nCams; camID++)
	{
		int videoID = AllVideoInfo.nframesI*camID;
		vector<int> computedTime;
		for (int ii = startF; ii <= stopF; ii++)
			if (AllVideoInfo.VideoInfo[ii + videoID].valid)
				computedTime.push_back(ii);
		sprintf(Fname, "%s/Intrinsic_RSCayley_%d.txt", Path, camID);	SaveVideoCameraIntrinsic(Fname, &AllVideoInfo.VideoInfo[videoID], computedTime, camID, 0);
		sprintf(Fname, "%s/CamPose_RSCayley_%d.txt", Path, camID);	SaveVideoCameraPoses(Fname, &AllVideoInfo.VideoInfo[videoID], computedTime, camID, 0);

		for (int ii = 0; ii <= stopF; ii++)
			AllVideoInfo.VideoInfo[ii + videoID].ShutterModel = 0;
		sprintf(Fname, "%s/CamPose_sRSCayley_%d.txt", Path, camID);	SaveVideoCameraPoses(Fname, &AllVideoInfo.VideoInfo[videoID], computedTime, camID, 0);
	}

	//ReSaveBundleAdjustedNVMResults(Fname, CorpusData);
	printf("Done!\n");

	return 0;
}


void RollingShutterSplineProjection(double *intrinsic, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d &predicted, Point3d &point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], tr[6], np[3], p[3] = { point.x, point.y, point.z };

	double *Bi = new double[nCtrl];

	//Get initial estimate of the projected location
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc<KnotLoc[SplineOrder - 1])
		subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
	else if (subframeLoc > KnotLoc[nCtrl])
		subframeLoc = KnotLoc[nCtrl] - 0.5;

	BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

	int nlocalControls = SplineOrder + 2;
	for (int jj = 0; jj < 6; jj++)
	{
		/*for (int ii = 0; ii < nCtrl; ii++)
		{
		double bi = Bi[ii];
		if (bi < 1.0e-6)
		continue;
		int found = 0, foundActingID = 0;
		for (int kk = 0; kk < 6; kk++)
		if (ActingID[kk] == ii)
		{
		foundActingID = kk;
		found++;
		break;
		}
		if (found == 0)
		printf("CP problem @Frame %d \n", frameID);

		twist[jj] += ActingControlPose[jj + 6 * foundActingID] * bi;
		}*/
		if (se3)
		{
			twist[jj] = 0.0;
			for (int ii = 0; ii < nlocalControls; ii++)
				twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
		}
		else
		{
			tr[jj] = 0;
			for (int ii = 0; ii < nlocalControls; ii++)
				tr[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
		}
	}

	if (se3)
		getRTFromTwist(twist, R, T);
	else
	{
		getRfromr(tr + 3, R);
		for (int ii = 0; ii < 3; ii++)
			T[ii] = tr[ii];
	}

	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	int iter, iterMax = 20;
	double dif;
	for (iter = 0; iter < iterMax; iter++)
	{
		subframeLoc = v / height + frameID;
		if (subframeLoc<KnotLoc[SplineOrder - 1])
			subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
		else if (subframeLoc > KnotLoc[nCtrl])
			subframeLoc = KnotLoc[nCtrl] - 0.5;

		BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

		for (int jj = 0; jj < 6; jj++)
		{
			if (se3)
			{
				twist[jj] = 0.0;
				for (int ii = 0; ii < nlocalControls; ii++)
					twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
			}
			else
			{
				tr[jj] = 0;
				for (int ii = 0; ii < nlocalControls; ii++)
					tr[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
			}
		}

		if (se3)
			getRTFromTwist(twist, R, T);
		else
		{
			getRfromr(tr + 3, R);
			for (int ii = 0; ii < 3; ii++)
				T[ii] = tr[ii];
		}

		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		dif = abs((ycn - ycn_) / ycn_);
		if (dif < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	//if (v<-1.0 || v>height)
	//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];
	predicted.x = u, predicted.y = v;

	//if (iter > iterMax - 1 && dif > 1.0e-6)
	//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

	delete[]Bi;

	return;
}
void RollingShutterSplineReprojectionDebug(double *intrinsic, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d &observed, Point3d &point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterSplineProjection(intrinsic, ActingID, ActingControlPose, KnotLoc, nBreak, nCtrl, SplineOrder, se3, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterSplineReprojectionError {
	RollingShutterSplineReprojectionError(double *IntrinsicIn, double *KnotLocIn, int nBreak, int nCtrl, int SplineOrder, bool se3, int *ActingIDIn, Point2d observed2D, double scale, int pid, int frameID, int width, int height) :
		nBreak(nBreak), nCtrl(nCtrl), SplineOrder(SplineOrder), se3(se3), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		KnotLoc = KnotLocIn;
		Intrinsic = IntrinsicIn;
		for (int ii = 0; ii < SplineOrder + 2; ii++)
			ActingID[ii] = ActingIDIn[ii];
	}

	template <typename T>	bool operator()(const double* const ControlPoses0, const double* const ControlPoses1, const double* const ControlPoses2, const double* const ControlPoses3,
		const double* const ControlPoses4, const double* const ControlPoses5, const double* const point, T* residuals) const
	{
		Point3d p3d(point[0], point[1], point[2]);

		double control[36];
		for (int ii = 0; ii < 6; ii++)
			control[ii] = ControlPoses0[ii], control[ii + 6] = ControlPoses1[ii], control[ii + 12] = ControlPoses2[ii],
			control[ii + 18] = ControlPoses3[ii], control[ii + 24] = ControlPoses4[ii], control[ii + 30] = ControlPoses5[ii];

		Point2d predicted2D;
		int *aID = new int[6];
		for (int ii = 0; ii < 6; ii++)
			aID[ii] = ActingID[ii];

		RollingShutterSplineProjection(Intrinsic, aID, control, KnotLoc, nBreak, nCtrl, SplineOrder, se3, predicted2D, p3d, frameID, width, height);

		residuals[0] = (predicted2D.x - observed2D.x) / scale, residuals[1] = (predicted2D.y - observed2D.y) / scale;

		delete[]aID;
		return true;
	}
	static ceres::CostFunction* CreateNumerDiff(double *Intrinsic, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d observed2D, int *ActingID, double scale, int pid, int frameID, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<RollingShutterSplineReprojectionError, ceres::CENTRAL, 2, 6, 6, 6, 6, 6, 6, 3>
			(new RollingShutterSplineReprojectionError(Intrinsic, KnotLoc, nBreak, nCtrl, SplineOrder, se3, ActingID, observed2D, scale, pid, frameID, width, height)));
	}

	bool se3;
	int pid, nBreak, nCtrl, SplineOrder;
	double scale, *Intrinsic, *KnotLoc;
	int width, height, frameID, ActingID[6];
	Point2d observed2D;
};
void RollingShutterDistortionSplineProjection(double *intrinsic, double *distortion, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d &predicted, Point3d point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], np[3], p[3] = { point.x, point.y, point.z };
	double *Bi = new double[nCtrl];

	//Get initial estimate of the projected location
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc<KnotLoc[SplineOrder - 1])
		subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
	else if (subframeLoc > KnotLoc[nCtrl])
		subframeLoc = KnotLoc[nCtrl] - 0.5;

	BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

	int nlocalControls = SplineOrder + 2;
	for (int jj = 0; jj < 6; jj++)
	{
		twist[jj] = 0.0;
		for (int ii = 0; ii < nlocalControls; ii++)
			twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
	}

	getRTFromTwist(twist, R, T);
	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	for (int iter = 0; iter < 40; iter++)
	{
		subframeLoc = 0.5 + frameID;
		if (subframeLoc<KnotLoc[SplineOrder - 1])
			subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
		else if (subframeLoc > KnotLoc[nCtrl])
			subframeLoc = KnotLoc[nCtrl] - 0.5;

		BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

		for (int jj = 0; jj < 6; jj++)
		{
			twist[jj] = 0.0;
			for (int ii = 0; ii < nlocalControls; ii++)
				twist[jj] += ActingControlPose[jj + nlocalControls* ii] * Bi[ActingID[ii]];
		}

		getRTFromTwist(twist, R, T);
		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		if (abs((ycn - ycn_) / ycn_) < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];

	predicted.x = u, predicted.y = v;
	LensDistortionPoint2(&predicted, intrinsic, distortion);

	delete[]Bi;

	return;
}
void RollingShutterDistortionSplineReprojectionDebug(double *intrinsic, double *distortion, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d observed, Point3d point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterDistortionSplineProjection(intrinsic, distortion, ActingID, ActingControlPose, KnotLoc, nBreak, nCtrl, SplineOrder, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterDistortionSplineReprojectionError {
	RollingShutterDistortionSplineReprojectionError(double *KnotLocIn, int nBreak, int nCtrl, int SplineOrder, int *ActingIDIn, Point2d observed2D, double scale, int frameID, int width, int height) :
		nBreak(nBreak), nCtrl(nCtrl), SplineOrder(SplineOrder), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		KnotLoc = KnotLocIn;
		for (int ii = 0; ii < SplineOrder + 2; ii++)
			ActingID[ii] = ActingIDIn[ii];
	}

	template <typename T>	bool operator()(const double* const intrinsic, const double* const distortion,
		const double* const ControlPoses0, const double* const ControlPoses1, const double* const ControlPoses2, const double* const ControlPoses3, const double* const ControlPoses4, const double* const ControlPoses5,
		const double* const point, T* residuals) const
	{
		double intrinsic_[5] = { intrinsic[0], intrinsic[1], intrinsic[2], intrinsic[3], intrinsic[4] };
		double distortion_[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };
		Point3d p3d(point[0], point[1], point[2]);

		double control[36];
		for (int ii = 0; ii < 6; ii++)
			control[ii] = ControlPoses0[ii], control[ii + 6] = ControlPoses1[ii], control[ii + 12] = ControlPoses2[ii],
			control[ii + 18] = ControlPoses3[ii], control[ii + 24] = ControlPoses4[ii], control[ii + 30] = ControlPoses5[ii];

		int *aID = new int[6];
		for (int ii = 0; ii < 6; ii++)
			aID[ii] = ActingID[ii];

		Point2d predicted2D;
		RollingShutterDistortionSplineProjection(intrinsic_, distortion_, aID, control, KnotLoc, nBreak, nCtrl, SplineOrder, predicted2D, p3d, frameID, width, height);

		residuals[0] = (predicted2D.x - observed2D.x) / scale, residuals[1] = (predicted2D.y - observed2D.y) / scale;

		return true;
	}
	static ceres::CostFunction* CreateNumerDiff(double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d observed2D, int *ActingID, double scale, int frameID, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<RollingShutterDistortionSplineReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 6, 6, 6, 6, 6, 3>
			(new RollingShutterDistortionSplineReprojectionError(KnotLoc, nBreak, nCtrl, SplineOrder, ActingID, observed2D, scale, frameID, width, height)));
	}

	int pid, nBreak, nCtrl, SplineOrder;
	double scale, *KnotLoc;
	int width, height, frameID, ActingID[6];
	Point2d observed2D;
};
int VideoSplineRSBA(char *Path, int startFrame, int stopFrame, int selectedCams, int distortionCorrected, int fixedIntrinisc, int fixDistortion, double threshold, int controlStep, int SplineOrder, bool se3, bool debug)
{
	//SplineOrder:  4 (cubic spline)
	if (se3)
		printf("Using se(3) parameterization\n");
	else
		printf("Using so(3) parameterization\n");

	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCams, startFrame, stopFrame) == 1)
		return 1;

	Point2d uv; Point3d P3d;  double scale;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = true, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCams, frameID);	FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}

	//Set up Bspline: Control points are placed every controlStep frame
	int nCtrls = (stopFrame - startFrame) / controlStep + 1, nbreaks = nCtrls - SplineOrder + 2, extraNControls = 2;
	int ActingID[6];
	double breakStep = 1.0*(stopFrame - startFrame) / (nbreaks - 1);

	//Figure out which frame is not available and take value from its neighbor
	int *ControlLoc = new int[nCtrls];
	for (int ii = 0; ii < nCtrls; ii++)
	{
		int fid = controlStep*ii + startFrame;
		if (!VideoInfoI.VideoInfo[fid].valid)
		{
			int searchRange = 1;
			while (true)
			{
				for (int jj = -searchRange; jj <= searchRange; jj++)
				{
					if (jj == 0 || abs(jj) != searchRange)
						continue;
					if (fid + searchRange<startFrame || fid + searchRange>stopFrame || !VideoInfoI.VideoInfo[fid + searchRange].valid)
						continue;
					ControlLoc[ii] = fid + searchRange;
				}
			}
		}
		else
			ControlLoc[ii] = fid;
	}

	//Set open-uniform break points
	double *BreakLoc = new double[nbreaks];
	for (int ii = 0; ii < nbreaks; ii++)
		BreakLoc[ii] = breakStep*ii + startFrame;

	double *KnotLoc = new double[nCtrls + SplineOrder];
	BSplineGetKnots(KnotLoc, BreakLoc, nbreaks, nCtrls, SplineOrder);

	//Init control pose in se3
	double twist[6], tr[6];
	double *ControlPose = new double[6 * nCtrls];//stack of groups of 6 numbers 
	for (int ii = 0; ii < nCtrls; ii++)
	{
		if (se3)
		{
			getTwistFromRT(VideoInfoI.VideoInfo[ControlLoc[ii]].R, VideoInfoI.VideoInfo[ControlLoc[ii]].T, twist);
			for (int jj = 0; jj < 6; jj++)
				ControlPose[jj + 6 * ii] = twist[jj];
		}
		else
		{
			getrFromR(VideoInfoI.VideoInfo[ControlLoc[ii]].R, tr + 3);
			for (int jj = 0; jj < 3; jj++)
				tr[jj] = VideoInfoI.VideoInfo[ControlLoc[ii]].T[jj];
			for (int jj = 0; jj < 6; jj++)
				ControlPose[jj + 6 * ii] = tr[jj];
		}
	}

	//Start solver
	bool setReferenceflag = false;
	int frameID, RefFrameID, nBadCounts = 0, validPtsCount = 0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0, residuals[2];

	ceres::Problem problem;
	//ceres::LossFunction* loss_function = new HuberLoss(3.0*threshold);

	FILE *fp = 0;
	if (debug)
		sprintf(Fname, "%s/reprojectionB.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			//Determine its acting controlPts
			double subframeLoc = 0.5 + frameID;
			if (subframeLoc<KnotLoc[SplineOrder - 1])
				subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
			else if (subframeLoc > KnotLoc[nCtrls])
				subframeLoc = KnotLoc[nCtrls] - 0.5;
			BSplineFindActiveCtrl(ActingID, subframeLoc, KnotLoc, nbreaks, nCtrls, SplineOrder, extraNControls);

			if (!setReferenceflag)
			{
				if (distortionCorrected)
					RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			}
			else
				if (distortionCorrected)
					RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			if (abs(residuals[0]) > 10.0*threshold || abs(residuals[1]) > 10.0*threshold)
			{
				Good.push_back(false);
				if (abs(residuals[0]) > maxOutlierX)
					maxOutlierX = residuals[0];
				if (abs(residuals[1]) > maxOutlierY)
					maxOutlierY = residuals[1];
				nBadCounts++;
				continue;
			}
			else
			{
				Good.push_back(true);
				if (!setReferenceflag)
					RefFrameID = frameID, setReferenceflag = true;

				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = RollingShutterSplineReprojectionError::CreateNumerDiff(VideoInfoI.VideoInfo[RefFrameID].intrinsic, KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
						uv, ActingID, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					problem.AddResidualBlock(cost_function, NULL, &ControlPose[6 * ActingID[0]], &ControlPose[6 * ActingID[1]], &ControlPose[6 * ActingID[2]],
						&ControlPose[6 * ActingID[3]], &ControlPose[6 * ActingID[4]], &ControlPose[6 * ActingID[5]], &P3D[3 * pid]);
				}
				else
				{
					ceres::CostFunction* cost_function = RollingShutterDistortionSplineReprojectionError::CreateNumerDiff(KnotLoc, nbreaks, nCtrls, SplineOrder, uv, ActingID, scale, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					problem.AddResidualBlock(cost_function, NULL, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion,
						&ControlPose[6 * ActingID[0]], &ControlPose[6 * ActingID[1]], &ControlPose[6 * ActingID[2]], &ControlPose[6 * ActingID[3]], &ControlPose[6 * ActingID[4]], &ControlPose[6 * ActingID[5]], &P3D[3 * pid]);

					if (fixedIntrinisc)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
				}

				validPtsCount++;
				ReProjectionErrorX.push_back(abs(residuals[0]));
				ReProjectionErrorY.push_back(abs(residuals[1]));

				if (debug)
					fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
			}
		}
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("\n %d bad points (%d good points) detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	//printf("...run \n");
	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 30;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
	}

	int count = -1;
	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	if (debug)
		sprintf(Fname, "%s/reprojectionA.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			//Determine its acting controlPts
			double subframeLoc = 0.5 + frameID;
			if (subframeLoc<KnotLoc[SplineOrder - 1])
				subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
			else if (subframeLoc > KnotLoc[nCtrls])
				subframeLoc = KnotLoc[nCtrls] - 0.5;
			BSplineFindActiveCtrl(ActingID, subframeLoc, KnotLoc, nbreaks, nCtrls, SplineOrder, extraNControls);

			if (distortionCorrected)
				RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			else
				RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			if (debug)
				fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/IntrinsicS_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	if (se3)
		sprintf(Fname, "%s/CamPoseS_se3_%d.txt", Path, selectedCams);
	else
		sprintf(Fname, "%s/CamPoseS_so3_%d.txt", Path, selectedCams);
	fp = fopen(Fname, "w+");
	fprintf(fp, "%d %d %d %d\n", nCtrls, nbreaks, SplineOrder, se3 ? 1 : 0);
	for (int ii = 0; ii < nCtrls; ii++)
	{
		fprintf(fp, "%d ", ControlLoc[ii]);
		for (int jj = 0; jj < 6; jj++)
			fprintf(fp, "%.8e ", ControlPose[ii * 6 + jj]);
		fprintf(fp, "\n");
	}
	for (int ii = 0; ii < nbreaks; ii++)
		fprintf(fp, "%.16e\n", BreakLoc[ii]);
	fclose(fp);

	delete[]ControlLoc, delete[]BreakLoc, delete[]KnotLoc, delete[]ControlPose;

	return 0;
}

void RollingShutterDCTProjection(double *intrinsic, double *Coeffs0, double *Coeffs1, double *Coeffs2, double *Coeffs3, double *Coeffs4, double *Coeffs5, int nCoeffs, Point2d &predicted, Point3d &point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], np[3], p[3] = { point.x, point.y, point.z };
	double *iB = new double[nCoeffs];

	//Get initial estimate of the projected location: must be in 0->n-1 range
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc > nCoeffs - 1)
		subframeLoc = nCoeffs - 1;

	//Get twist = iB*C;
	GenerateiDCTBasis(iB, nCoeffs, subframeLoc);

	for (int jj = 0; jj < 6; jj++)
		twist[jj] = 0.0;
	for (int ii = 0; ii < nCoeffs; ii++)
	{
		twist[0] += Coeffs0[ii] * iB[ii];
		twist[1] += Coeffs1[ii] * iB[ii];
		twist[2] += Coeffs2[ii] * iB[ii];
		twist[3] += Coeffs3[ii] * iB[ii];
		twist[4] += Coeffs4[ii] * iB[ii];
		twist[5] += Coeffs5[ii] * iB[ii];
	}
	getRTFromTwist(twist, R, T);

	//Initiate projection solver
	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	int iter, iterMax = 20;
	double dif;
	for (iter = 0; iter < iterMax; iter++)
	{
		subframeLoc = v / height + frameID;
		if (subframeLoc > nCoeffs)
			subframeLoc = nCoeffs;

		GenerateiDCTBasis(iB, nCoeffs, subframeLoc);

		for (int jj = 0; jj < 6; jj++)
			twist[jj] = 0.0;
		for (int ii = 0; ii < nCoeffs; ii++)
		{
			twist[0] += Coeffs0[ii] * iB[ii];
			twist[1] += Coeffs1[ii] * iB[ii];
			twist[2] += Coeffs2[ii] * iB[ii];
			twist[3] += Coeffs3[ii] * iB[ii];
			twist[4] += Coeffs4[ii] * iB[ii];
			twist[5] += Coeffs5[ii] * iB[ii];
		}
		getRTFromTwist(twist, R, T);

		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		dif = abs((ycn - ycn_) / ycn_);
		if (dif < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	//if (v<-1.0 || v>height)
	//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];
	predicted.x = u, predicted.y = v;

	//if (iter > iterMax - 1 && dif > 1.0e-6)
	//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

	delete[]iB;

	return;
}
void RollingShutterDCTReprojectionDebug(double *intrinsic, double *Coeffs0, double *Coeffs1, double *Coeffs2, double *Coeffs3, double *Coeffs4, double *Coeffs5, int nCoeffs, Point2d &observed, Point3d &point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterDCTProjection(intrinsic, Coeffs0, Coeffs1, Coeffs2, Coeffs3, Coeffs4, Coeffs5, nCoeffs, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterDCTReprojectionError {
	RollingShutterDCTReprojectionError(double *IntrinsicIn, double *WeightIn, int nCoeffs, Point2d observed2D, double scale, int pid, int frameID, int width, int height) :
		nCoeffs(nCoeffs), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		Intrinsic = IntrinsicIn;
		Weight = WeightIn;
	}

	template <typename T>    bool operator()(T const* const* Parameters, T* residuals)     const
	{
		T R[9], Trans[3], np[3];
		T *iB = new T[nCoeffs];

		//Get initial estimate of the projected location: must be in 0->n-1 range
		T subframeLoc = (T)(0.5 + frameID);
		if (subframeLoc > (T)(nCoeffs - 1))
			subframeLoc = (T)(nCoeffs - 1);

		//GenerateiDCTBasis(iB, nCoeffs, subframeLoc); 	//Get twist = iB*C;
		iB[0] = (T)(sqrt(1.0 / nCoeffs));
		double s = sqrt(2.0 / nCoeffs);
		for (int kk = 1; kk < nCoeffs; kk++)
			iB[kk] = (T)(s)*cos((T)(Pi*kk) *(subframeLoc + (T)0.5) / (T)nCoeffs);

		T twist[6];
		for (int jj = 0; jj < 6; jj++)
		{
			twist[jj] = (T)0.0;
			for (int ii = 0; ii < nCoeffs; ii++)
				twist[jj] += Parameters[jj + 1][ii] * (T)iB[ii];
		}

		//getRTFromTwist(twist, R, Trans);
		T t[3] = { twist[0], twist[1], twist[2] }, w[3] = { twist[3], twist[4], twist[5] };
		T theta = sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]), theta2 = theta* theta;
		T wx2[9], wx[9] = { (T)0.0, -w[2], w[1], w[2], (T)0.0, -w[0], -w[1], w[0], (T)0.0 };
		//mat_mul(wx, wx, wx2, 3, 3, 3);
		for (int ii = 0; ii < 3; ii++)
		{
			for (int jj = 0; jj < 3; jj++)
			{
				wx2[ii * 3 + jj] = (T)0.0;
				for (int kk = 0; kk < 3; kk++)
					wx2[ii * 3 + jj] += wx[ii * 3 + kk] * wx[kk * 3 + jj];
			}
		}

		T V[9] = { (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0 };
		R[0] = (T)1.0, R[1] = (T)0.0, R[2] = (T)0.0, R[3] = (T)0.0, R[4] = (T)1.0, R[5] = (T)0.0, R[6] = (T)0.0, R[7] = (T)0.0, R[8] = (T)1.0;
		if (theta < (T)1.0e-9)
			Trans[0] = t[0], Trans[1] = t[1], Trans[2] = t[2]; //Rotation is idenity
		else
		{
			T A = sin(theta) / theta, B = ((T)1.0 - cos(theta)) / theta2, C = ((T)1.0 - A) / theta2;
			for (int ii = 0; ii < 9; ii++)
			{
				R[ii] += A*wx[ii] + B*wx2[ii];
				V[ii] += B*wx[ii] + C*wx2[ii];
			}

			//mat_mul(V, t, Trans, 3, 3, 1);
			for (int ii = 0; ii < 3; ii++)
			{
				Trans[ii] = (T)0.0;
				for (int kk = 0; kk < 3; kk++)
					Trans[ii] += V[ii * 3 + kk] * t[kk];
			}
		}

		//Initiate projection solver
		np[1] = R[3] * Parameters[0][0] + R[4] * Parameters[0][1] + R[5] * Parameters[0][2] + Trans[1];
		np[2] = R[6] * Parameters[0][0] + R[7] * Parameters[0][1] + R[8] * Parameters[0][2] + Trans[2];
		T ycn = np[1] / np[2], ycn_ = ycn;
		T v = (T)Intrinsic[1] * ycn + (T)Intrinsic[4]; //to get time info

		//Iteratively solve for ycn = P(ycn)*X
		T dif;
		int iter, iterMax = 20;
		for (iter = 0; iter < iterMax; iter++)
		{
			subframeLoc = (T)(0.5 + frameID);
			if (subframeLoc >(T)(nCoeffs - 1))
				subframeLoc = (T)(nCoeffs - 1);

			//GenerateiDCTBasis(iB, nCoeffs, subframeLoc); 	//Get twist = iB*C;
			iB[0] = (T)(sqrt(1.0 / nCoeffs));
			double s = sqrt(2.0 / nCoeffs);
			for (int kk = 1; kk < nCoeffs; kk++)
				iB[kk] = (T)(s)*cos((T)(Pi*kk) *(subframeLoc + (T)0.5) / (T)nCoeffs);

			T twist[6];
			for (int jj = 0; jj < 6; jj++)
			{
				twist[jj] = (T)0.0;
				for (int ii = 0; ii < nCoeffs; ii++)
					twist[jj] += Parameters[jj + 1][ii] * (T)iB[ii];
			}

			//getRTFromTwist(twist, R, Trans);
			T t[3] = { twist[0], twist[1], twist[2] }, w[3] = { twist[3], twist[4], twist[5] };
			T theta = sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]), theta2 = theta* theta;
			T wx2[9], wx[9] = { (T)0.0, -w[2], w[1], w[2], (T)0.0, -w[0], -w[1], w[0], (T)0.0 };
			//mat_mul(wx, wx, wx2, 3, 3, 3);
			for (int ii = 0; ii < 3; ii++)
			{
				for (int jj = 0; jj < 3; jj++)
				{
					wx2[ii * 3 + jj] = (T)0.0;
					for (int kk = 0; kk < 3; kk++)
						wx2[ii * 3 + jj] += wx[ii * 3 + kk] * wx[kk * 3 + jj];
				}
			}

			T V[9] = { (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0 };
			R[0] = (T)1.0, R[1] = (T)0.0, R[2] = (T)0.0, R[3] = (T)0.0, R[4] = (T)1.0, R[5] = (T)0.0, R[6] = (T)0.0, R[7] = (T)0.0, R[8] = (T)1.0;
			if (theta < (T)1.0e-9)
				Trans[0] = t[0], Trans[1] = t[1], Trans[2] = t[2]; //Rotation is idenity
			else
			{
				T A = sin(theta) / theta, B = ((T)1.0 - cos(theta)) / theta2, C = ((T)1.0 - A) / theta2;
				for (int ii = 0; ii < 9; ii++)
				{
					R[ii] += A*wx[ii] + B*wx2[ii];
					V[ii] += B*wx[ii] + C*wx2[ii];
				}

				//mat_mul(V, t, Trans, 3, 3, 1);
				for (int ii = 0; ii < 3; ii++)
				{
					Trans[ii] = (T)0.0;
					for (int kk = 0; kk < 3; kk++)
						Trans[ii] += V[ii * 3 + kk] * t[kk];
				}
			}

			np[1] = R[3] * Parameters[0][0] + R[4] * Parameters[0][1] + R[5] * Parameters[0][2] + Trans[1];
			np[2] = R[6] * Parameters[0][0] + R[7] * Parameters[0][1] + R[8] * Parameters[0][2] + Trans[2];

			ycn = np[1] / np[2];
			v = Intrinsic[1] * ycn + Intrinsic[4];
			dif = abs((ycn - ycn_) / ycn_);
			if (dif < 1.0e-9)
				break;
			ycn_ = ycn;
		}

		//if (v<-1.0 || v>height)
		//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

		np[0] = R[0] * Parameters[0][0] + R[1] * Parameters[0][1] + R[2] * Parameters[0][2] + Trans[0];
		T xcn = np[0] / np[2], u = Intrinsic[0] * xcn + Intrinsic[2] * ycn + Intrinsic[3];

		//if (iter > iterMax - 1 && dif > 1.0e-6)
		//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

		residuals[0] = (u - (T)observed2D.x) / (T)scale, residuals[1] = (v - (T)observed2D.y) / (T)scale;

		delete[]iB;
		return true;
	}

	int width, height, pid, frameID, nCoeffs;
	double scale, *Intrinsic, *Weight;
	Point2d observed2D;
};
struct RollingShutterDCTRegularizationError {
	RollingShutterDCTRegularizationError(double *WeightIn, int nCoeffs, double sqrtlamda) : nCoeffs(nCoeffs), sqrtlamda(sqrtlamda)
	{
		Weight = WeightIn;
	}

	template <typename T>    bool operator()(T const* const* Parameters, T* residuals)     const
	{
		for (int jj = 0; jj < 6; jj++)
			for (int ii = 0; ii < nCoeffs; ii++)
				residuals[ii + 6 * nCoeffs] = (T)sqrtlamda*Parameters[jj][ii] * (T)Weight[ii];

		return true;
	}

	int nCoeffs;
	double sqrtlamda, *Weight;
};
int VideoDCTRSBA(char *Path, int startFrame, int stopFrame, int selectedCams, int distortionCorrected, int fixedIntrinisc, int fixDistortion, double threshold, int sampleStep, double lamda, bool debug)
{
	FILE *fp = 0;
	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCams, startFrame, stopFrame) == 1)
		return 1;

	Point2d uv; Point3d P3d;  double scale;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = true, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCams, frameID);	fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}


	//Set up DCT sampled evenly every sampleStep
	int nCoeffs = (int)((stopFrame - startFrame) / sampleStep + 1);

	double *sqrtWeight = new double[nCoeffs];
	GenerateDCTBasis(nCoeffs, NULL, sqrtWeight);
	for (int ii = 0; ii < nCoeffs; ii++)
		sqrtWeight[ii] = sqrt(-sqrtWeight[ii]); //(1) using precomputed sqrt is better for ceres' squaring residual square nature; (2) weigths are negative, but that does not matter for ctwc optim.

	//Initialize basis coefficients
	int count = 0, nframes = 0;
	for (int ii = startFrame; ii <= stopFrame; ii++)
		if (VideoInfoI.VideoInfo[ii].valid)
			nframes++;

	double twist[6];
	double *FrameTime = new double[nframes], *FramePose = new double[6 * (stopFrame - startFrame + 1)];
	for (int ii = startFrame; ii <= stopFrame; ii++)
	{
		if (VideoInfoI.VideoInfo[ii].valid)
		{
			getTwistFromRT(VideoInfoI.VideoInfo[ii].R, VideoInfoI.VideoInfo[ii].T, twist);
			for (int jj = 0; jj < 6; jj++)
				FramePose[ii + jj * nframes] = twist[jj];

			FrameTime[count - startFrame] = 1.0*(ii - startFrame) / (stopFrame - startFrame)*(nCoeffs - 1);//Normalize to [0, n-1] range
			count++;
		}
	}

	double *iBi = new double[nCoeffs], *iBAll = new double[nframes*nCoeffs];
	for (int ii = 0; ii < nframes; ii++)
		GenerateiDCTBasis(iBAll + ii*nCoeffs, nCoeffs, FrameTime[ii]);


	//Trucated basis solver: iPd(:, 1:activeBasis)*C =  X_d
	double err;
	const int nactiveBasis = 20;
	double *C = new double[6 * nCoeffs];
	Map < Matrix < double, Dynamic, Dynamic, RowMajor > > eiBAll(iBAll, nframes, nCoeffs);
	MatrixXd etiBAll = eiBAll.block(0, 0, nframes, nactiveBasis);
	JacobiSVD<MatrixXd> etiP_svd(etiBAll, ComputeThinU | ComputeThinV);
	for (int ii = 0; ii < 6; ii++)
	{
		Map<VectorXd> eX(FramePose + nframes*ii, nframes);
		Map<VectorXd> eC(C + nCoeffs*ii, nactiveBasis);

		if (eX.norm() < 0.1)// happens for rotation sometimes
		{
			for (int jj = 0; jj < nCoeffs; jj++)
				C[jj + nCoeffs*ii] = 0.0;
			err = (etiBAll*eC - eX).norm();
		}
		else
		{
			eC = etiP_svd.solve(eX);

			for (int jj = nactiveBasis; jj < nCoeffs; jj++)
				C[jj + nCoeffs*ii] = 0.0; //set coeffs outside active basis to 0
			err = (etiBAll*eC - eX).norm() / eX.norm();
		}
	}

	//Start solver
	bool setReferenceflag = false;
	int frameID, RefFrameID, nBadCounts = 0, validPtsCount = 0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0, residuals[2];

	ceres::Problem problem;
	//ceres::LossFunction* loss_function = new HuberLoss(3.0*threshold);

	//Image projection cost
	if (debug)
		sprintf(Fname, "%s/reprojectionB.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			if (!setReferenceflag)
			{
				if (distortionCorrected)
					RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, FramePose + ActingID[0] * 6, KnotLoc, nbreaks, nCtrls, SplineOrder,
				//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			}
			else
				if (distortionCorrected)
					RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, ActingID, FramePose + ActingID[0] * 6, KnotLoc, nbreaks, nCtrls, SplineOrder,
			//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			if (abs(residuals[0]) > 10.0*threshold || abs(residuals[1]) > 10.0*threshold)
			{
				Good.push_back(false);
				if (abs(residuals[0]) > maxOutlierX)
					maxOutlierX = residuals[0];
				if (abs(residuals[1]) > maxOutlierY)
					maxOutlierY = residuals[1];
				nBadCounts++;
				continue;
			}
			else
			{
				Good.push_back(true);
				if (!setReferenceflag)
					RefFrameID = frameID, setReferenceflag = true;

				if (distortionCorrected)
				{
					//ceres::DynamicAutoDiffCostFunction<RollingShutterDCTReprojectionError, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction < RollingShutterDCTReprojectionError, 4 >
					//	(new RollingShutterDCTReprojectionError(VideoInfoI.VideoInfo[RefFrameID].intrinsic, sqrtWeight, nCoeffs, uv, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height));

					ceres::DynamicNumericDiffCostFunction<RollingShutterDCTReprojectionError, ceres::CENTRAL> *cost_function = new ceres::DynamicNumericDiffCostFunction<RollingShutterDCTReprojectionError, ceres::CENTRAL>
						(new RollingShutterDCTReprojectionError(VideoInfoI.VideoInfo[RefFrameID].intrinsic, sqrtWeight, nCoeffs, uv, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height));

					vector<double*> parameter_blocks;
					parameter_blocks.push_back(&P3D[3 * pid]);
					cost_function->AddParameterBlock(3);
					for (int ii = 0; ii < 6; ii++)
					{
						parameter_blocks.push_back(C + ii*nCoeffs);
						cost_function->AddParameterBlock(nCoeffs);
					}
					cost_function->SetNumResiduals(2);

					problem.AddResidualBlock(cost_function, NULL, parameter_blocks);

					//problem.SetParameterBlockConstant(&parameter_blocks[npts][0]);
				}
				else
				{
					//ceres::CostFunction* cost_function = RollingShutterDistortionSplineReprojectionError::CreateNumerDiff(KnotLoc, nbreaks, nCtrls, SplineOrder, uv, ActingID, scale, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					//problem.AddResidualBlock(cost_function, NULL, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion,
					//	&FramePose[6 * ActingID[0]], &FramePose[6 * ActingID[1]], &FramePose[6 * ActingID[2]], &FramePose[6 * ActingID[3]], &FramePose[6 * ActingID[4]], &FramePose[6 * ActingID[5]], &P3D[3 * pid]);

					if (fixedIntrinisc)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
				}

				validPtsCount++;
				ReProjectionErrorX.push_back(abs(residuals[0]));
				ReProjectionErrorY.push_back(abs(residuals[1]));

				if (debug)
					fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
			}
		}
	}
	if (debug)
		fclose(fp);

	//Regularization cost
	ceres::DynamicAutoDiffCostFunction<RollingShutterDCTRegularizationError, 4> *cost_function =
		new ceres::DynamicAutoDiffCostFunction < RollingShutterDCTRegularizationError, 4 >(new RollingShutterDCTRegularizationError(sqrtWeight, nCoeffs, sqrt(lamda)));

	vector<double*> parameter_blocks;
	for (int ii = 0; ii < 6; ii++)
	{
		parameter_blocks.push_back(C + ii*nCoeffs);
		cost_function->AddParameterBlock(nCoeffs);
	}
	cost_function->SetNumResiduals(6 * nCoeffs);
	problem.AddResidualBlock(cost_function, NULL, parameter_blocks);


	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("\n %d bad points (%d good points) detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	//printf("...run \n");
	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 30;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
	}

	count = -1;
	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	if (debug)
		sprintf(Fname, "%s/reprojectionA.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			if (distortionCorrected)
				RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			else
				;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, FramePose + 6 * ActingID[0], KnotLoc, nbreaks, nCtrls, SplineOrder,
			//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			if (debug)
				fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/IntrinsicDCT_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	sprintf(Fname, "%s/CamPoseDCT_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	fprintf(fp, "%d %d %d\n", startFrame, nCoeffs, sampleStep);
	for (int jj = 0; jj < 6; jj++)
	{
		for (int ii = 0; ii < nCoeffs; ii++)
			fprintf(fp, "%.8e ", C[ii + jj*nCoeffs]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	delete[]FrameTime, delete[]FramePose;
	delete[]sqrtWeight, delete[]iBi, delete[]iBAll, delete[]C;

	return 0;
}
int LocalizeCameraToCorpusDriver(char *Path, int startFrame, int stopFrame, int IncreFrame, int module, int nCams, int selectedCams, int distortionCorrected, int GetIntrinsicFromCorpus, int sharedIntriniscOptim, int LensType)
{
	//Required calibrated cameras if Fisheye or lens with large distortion is used.
	char Fname[200];
	const int ninlierThresh = 10;
	const float nndrRatio = 0.7;
	Corpus corpusData;
	sprintf(Fname, "%s/Corpus", Path);
	if (module == 0)
		ReadCorpusInfo(Fname, corpusData, false, false);
	else
		ReadCorpusInfo(Fname, corpusData, false, true);

	///****NOTE: Required calibrated cameras if Fisheye or lens with large distortion is used***///
	bool fixIntrinsic = true, fixDistortion = true;
	CameraData *AllCamInfoI = new CameraData[nCams];
	if (!ReadIntrinsicResults(Path, AllCamInfoI))
	{
		if (GetIntrinsicFromCorpus > 0)
		{
			printf("Calibrated information extracted from Corpus cameras. The output 2D-3D correspondences will be corrected for lens distortion\n");
			for (int ii = 0; ii < nCams; ii++)
			{
				for (int jj = 0; jj < 5; jj++)
					AllCamInfoI[ii].intrinsic[jj] = corpusData.camera[GetIntrinsicFromCorpus].intrinsic[jj];
				GetKFromIntrinsic(AllCamInfoI[ii]);
				AllCamInfoI[ii].notCalibrated = false;

				AllCamInfoI[ii].LensModel = LensType, AllCamInfoI[ii].threshold = 5.0, AllCamInfoI[ii].ninlierThresh = ninlierThresh;
				for (int jj = 0; jj < 7; jj++)
					AllCamInfoI[ii].distortion[jj] = corpusData.camera[GetIntrinsicFromCorpus].distortion[jj];
				AllCamInfoI[ii].width = corpusData.camera[GetIntrinsicFromCorpus].width, AllCamInfoI[ii].height = corpusData.camera[GetIntrinsicFromCorpus].height;
			}
		}
		else
		{
			//Uncalibrated cam-->have to search for focal length + distortion.  For  2d-3d matching, maybe rough intrinsic info is sufficient
			printf("UNCALIBRATED CASE: The output 2D-3D correspondences will NOT be corrected for lens distortion\n");
			fixIntrinsic = false, fixDistortion = false;
			for (int ii = 0; ii < nCams; ii++)
			{
				int width = 1920, height = 1080;
				double focal = 0.91*max(width, height);
				AllCamInfoI[ii].intrinsic[0] = focal, AllCamInfoI[ii].intrinsic[1] = focal, AllCamInfoI[ii].intrinsic[2] = 0,
					AllCamInfoI[ii].intrinsic[3] = width / 2, AllCamInfoI[ii].intrinsic[4] = height / 2;
				GetKFromIntrinsic(AllCamInfoI[ii]);

				AllCamInfoI[ii].notCalibrated = true;
				AllCamInfoI[ii].LensModel = LensType, AllCamInfoI[ii].threshold = 5.0, AllCamInfoI[ii].ninlierThresh = ninlierThresh;
				for (int jj = 0; jj < 7; jj++)
					AllCamInfoI[ii].distortion[jj] = 0.0;
				AllCamInfoI[ii].width = width, AllCamInfoI[ii].height = height;
			}
		}
	}
	else
	{
		printf("CALIBRATED CASE: The output 2D-3D correspondences will be corrected for lens distortion\n");
		for (int ii = 0; ii < nCams; ii++)
			AllCamInfoI[ii].notCalibrated = false, AllCamInfoI[ii].threshold = 5.0, AllCamInfoI[ii].ninlierThresh = 40;
	}

	if (AllCamInfoI[selectedCams].notCalibrated == true && module == 1) //needed when try to run pnp without focal length info
	{
		CameraData CamInfoI;
		int width = 1920, height = 1080, bestFocal = 0, bestInlier = 0;
		for (int range = -10; range <= 10; range++) // search over focal length which gives highest # inliers
		{
			int focal = (1.0 + 0.01*range)*max(width, height);
			CamInfoI.intrinsic[0] = focal, CamInfoI.intrinsic[1] = focal, CamInfoI.intrinsic[2] = 0, CamInfoI.intrinsic[3] = width / 2, CamInfoI.intrinsic[4] = height / 2;
			GetKFromIntrinsic(CamInfoI);

			CamInfoI.notCalibrated = true;
			CamInfoI.LensModel = LensType, CamInfoI.ShutterModel = 0, CamInfoI.threshold = 5.0, CamInfoI.ninlierThresh = ninlierThresh;
			for (int jj = 0; jj < 7; jj++)
				CamInfoI.distortion[jj] = 0.0;
			CamInfoI.width = width, CamInfoI.height = height;

			int ninliers = EstimateCameraPoseFromCorpus(Path, corpusData, CamInfoI, selectedCams, fixIntrinsic, fixDistortion, distortionCorrected, sharedIntriniscOptim, startFrame);
			if (ninliers > bestInlier)
			{
				bestInlier = ninliers;
				bestFocal = CamInfoI.intrinsic[0];
			}
		}
		printf("Best focal: %d, best inliers: %d\n", bestFocal, bestInlier);
		AllCamInfoI[selectedCams].intrinsic[0] = bestFocal, AllCamInfoI[selectedCams].intrinsic[1] = bestFocal, AllCamInfoI[selectedCams].intrinsic[2] = 0,
			AllCamInfoI[selectedCams].intrinsic[3] = width / 2, AllCamInfoI[selectedCams].intrinsic[4] = height / 2;
		GetKFromIntrinsic(AllCamInfoI[selectedCams]);

		if (startFrame == 1 && module == 1)
		{
			sprintf(Fname, "%s/Intrinsic_%d.txt", Path, selectedCams); FILE*fp = fopen(Fname, "w+");	fclose(fp);
			sprintf(Fname, "%s/CamPose_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+"); fclose(fp);
		}
	}


	double start = omp_get_wtime();
	if (module == 0)
	{
#pragma omp parallel for
		for (int frameID = startFrame; frameID <= stopFrame; frameID += IncreFrame)
		{
			vector<int> CorpusViewToMatch;
			CorpusViewToMatch.reserve(corpusData.nCameras);

			int toMatch;
			sprintf(Fname, "%s/%d/ToMatch.txt", Path, selectedCams);
			FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot read %s\n", Fname);
				abort();
			}
			while (fscanf(fp, "%d ", &toMatch) != EOF)
				CorpusViewToMatch.push_back(toMatch);
			fclose(fp);

			///****NOTE: 2d points in Corpus are corrected. 2D points in the image-to-be-localized are not distorted if camera is not calibrated***///
			MatchCameraToCorpus(Path, corpusData, AllCamInfoI[selectedCams], selectedCams, frameID, distortionCorrected, CorpusViewToMatch, nndrRatio, ninlierThresh);
		}

		if (!fixIntrinsic && !fixDistortion)
			printf("UNCALIBRATED CASE. The output 2D-3D correspondences will NOT be corrected for lens distortion\n");
		else
			printf("CALIBRATED CASE: The output 2D-3D correspondences will be corrected for lens distortion\n");
	}
	else
	{
		vector<int> computedTime; computedTime.reserve(stopFrame - startFrame + 1);
		CameraData *SelectedCameraInfo = new CameraData[stopFrame - startFrame + 1];
		for (int frameID = startFrame; frameID <= stopFrame; frameID += IncreFrame)
		{
			computedTime.clear();
			CopyCamereInfo(AllCamInfoI[selectedCams], SelectedCameraInfo[frameID - startFrame]);
			if (AllCamInfoI[selectedCams].notCalibrated == true)
				distortionCorrected = 0;//3D_2D files contain un-corrected data
			else
				distortionCorrected = 1;//3D_2D files contain corrected data

			int ninliers = EstimateCameraPoseFromCorpus(Path, corpusData, SelectedCameraInfo[frameID - startFrame], selectedCams, fixIntrinsic, fixDistortion, distortionCorrected, sharedIntriniscOptim, frameID);
			if (ninliers < AllCamInfoI[selectedCams].ninlierThresh)
				computedTime.push_back(-1);
			else
			{
				computedTime.push_back(frameID - startFrame);
				sprintf(Fname, "%s/CamPose_%d.txt", Path, selectedCams);
				SaveVideoCameraPoses(Fname, SelectedCameraInfo, computedTime, selectedCams, startFrame);
			}
		}
		delete[]AllCamInfoI, delete[]SelectedCameraInfo;
		printf("Finished estimating poses for camera %d\n", selectedCams);
	}

	printf("Total time %d: %.3fs\n", selectedCams, omp_get_wtime() - start);

	return 0;
}

int BundleAdjustDomeTableCorres(char *Path, int startF_HD, int stopF_HD, int startF_VGA, int stopF_VGA, bool fixIntrinsicHD, bool fixDistortionHD, bool fixPoseHD, bool fixIntrinsicVGA, bool fixDistortionVGA, bool fixPoseVGA, bool debug)
{
	double threshold = 15.0;
	const int nHDs = 30, nPanels = 20, nVGAPanel = 24, nVGAs = nPanels*nVGAPanel;
	int nHDUsed = 20, notUsedHD = 14;
	char Fname[200];
	Corpus CorpusData;

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	loadBundleAdjustedNVMResults(Fname, CorpusData);

	//Get 2D corres
	{
		int frameID;
		Point2d *TableHD = new Point2d[(stopF_HD - startF_HD + 1)*nHDs];
		int *frame3D_HD = new int[stopF_HD - startF_HD + 1];
		for (int ii = startF_HD; ii <= stopF_HD; ii++)
		{
			frame3D_HD[ii - startF_HD] = ii;
			for (int jj = 0; jj < nHDs; jj++)
				TableHD[(ii - startF_HD)*nHDs + jj].x = -1, TableHD[(ii - startF_HD)*nHDs + jj].y = -1;
		}

		sprintf(Fname, "%s/Correspondences_HD.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
		{
			frame3D_HD[frameID - startF_HD] = frameID;
			for (int jj = 0; jj < nHDs; jj++)
				fscanf(fp, "%lf %lf ", &TableHD[(frameID - startF_HD)*nHDs + jj].x, &TableHD[(frameID - startF_HD)*nHDs + jj].y);
		}
		fclose(fp);

		//Get 3D init
		double *P3D_HD = new double[3 * (stopF_HD - startF_HD + 1)];
		for (int ii = 0; ii < 3 * (stopF_HD - startF_HD + 1); ii++)
			P3D_HD[ii] = 0.0;

		sprintf(Fname, "%s/C0_0.txt", Path); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
			fscanf(fp, "%lf %lf %lf", &P3D_HD[3 * (frameID - startF_HD)], &P3D_HD[3 * (frameID - startF_HD) + 1], &P3D_HD[3 * (frameID - startF_HD) + 2]);
		fclose(fp);

		printf("Set up BA ...");
		ceres::Problem problem;

		if (debug)
			sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

		vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(stopF_HD - startF_HD + 1);
		vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(stopF_HD - startF_HD + 1);

		int totalProjections = 0, nPossibleProjections = 0, minInliers = 999;
		for (int ii = startF_HD; ii < stopF_HD; ii++)
		{
			if (abs(P3D_HD[3 * (ii - startF_HD)]) + abs(P3D_HD[3 * (ii - startF_HD) + 1]) + abs(P3D_HD[3 * (ii - startF_HD) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]);

			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				nPossibleProjections++;
				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");

			if (minInliers > nvalidViews)
				minInliers = nvalidViews;
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));


			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);

				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, 1.0);
				problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, &P3D_HD[3 * (ii - startF_HD)]);

				if (fixIntrinsicHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].intrinsic);
				if (fixDistortionHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].distortion);
				if (fixPoseHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].rt);
			}
		}
		if (debug)
			fclose(fp);

		printf("Done with problem building\n");

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d. Min inliers: %d\n", totalProjections, nPossibleProjections, minInliers);


		printf("...run BA...\n");
		ceres::Solver::Options options;
		options.num_threads = 4;
		options.max_num_iterations = 30;
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.minimizer_progress_to_stdout = true;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = false;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		//std::cout << summary.BriefReport() << "\n";
		std::cout << summary.FullReport() << "\n";

		totalProjections = 0;
		ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
		for (int ii = startF_HD; ii < stopF_HD; ii++)
		{
			if (abs(P3D_HD[3 * (ii - startF_HD)]) + abs(P3D_HD[3 * (ii - startF_HD) + 1]) + abs(P3D_HD[3 * (ii - startF_HD) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.f %.f %.f ", ii, P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]);
			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);

				if (abs(residuals[0]) + abs(residuals[1]) > threshold * 3)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));
		}
		if (debug)
			fclose(fp);

		miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d\n", totalProjections, nPossibleProjections);

		sprintf(Fname, "%s/BA_Camera_AllParams_after2.txt", Path);
		ReSaveBundleAdjustedNVMResults(Fname, CorpusData, 1.0);

		delete[]P3D_HD, delete[]TableHD, delete[] frame3D_HD;
	}

	{
		int frameID;
		Point2d *TableVGA = new Point2d[(stopF_VGA - startF_VGA + 1)*nVGAs];
		int *frame3D_VGA = new int[stopF_VGA - startF_VGA + 1];
		for (int ii = startF_VGA; ii <= stopF_VGA; ii++)
		{
			frame3D_VGA[ii - startF_VGA] = ii;
			for (int jj = 0; jj < nVGAs; jj++)
				TableVGA[(ii - startF_VGA)*nVGAs + jj].x = -1, TableVGA[(ii - startF_VGA)*nVGAs + jj].y = -1;
		}

		sprintf(Fname, "%s/Correspondences_VGA.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
		{
			frame3D_VGA[frameID - startF_VGA] = frameID;
			for (int jj = 0; jj < nVGAs; jj++)
				fscanf(fp, "%lf %lf ", &TableVGA[(frameID - startF_VGA)*nVGAs + jj].x, &TableVGA[(frameID - startF_VGA)*nVGAs + jj].y);
		}
		fclose(fp);

		//Get 3D init
		double *P3D_VGA = new double[3 * (stopF_VGA - startF_VGA + 1)];
		for (int ii = 0; ii < 3 * (stopF_VGA - startF_VGA + 1); ii++)
			P3D_VGA[ii] = 0.0;

		sprintf(Fname, "%s/C1_0.txt", Path); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
			fscanf(fp, "%lf %lf %lf", &P3D_VGA[3 * (frameID - startF_VGA)], &P3D_VGA[3 * (frameID - startF_VGA) + 1], &P3D_VGA[3 * (frameID - startF_VGA) + 2]);
		fclose(fp);

		printf("Set up BA ...");
		ceres::Problem problem;

		if (debug)
			sprintf(Fname, "C:/temp/reprojectionB2.txt"), fp = fopen(Fname, "w+");

		vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(stopF_VGA - startF_VGA + 1);
		vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(stopF_VGA - startF_VGA + 1);

		int totalProjections = 0, nPossibleProjections = 0, minInliers = 999;
		for (int ii = startF_VGA; ii < stopF_VGA; ii++)
		{
			if (abs(P3D_VGA[3 * (ii - startF_VGA)]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 1]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]);

			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				nPossibleProjections++;
				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				//printf("%d %d %f %f\n", ii, jj, residuals[0], residuals[1]);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");

			if (minInliers > nvalidViews)
				minInliers = nvalidViews;
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));


			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, 1.0);
				problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, &P3D_VGA[3 * (ii - startF_VGA)]);

				if (fixIntrinsicVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].intrinsic);
				if (fixDistortionVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].distortion);
				if (fixPoseVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].rt);
			}
		}
		if (debug)
			fclose(fp);

		printf("Done with problem building\n");

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d. Min inliers: %d\n", totalProjections, nPossibleProjections, minInliers);


		printf("...run BA...\n");
		ceres::Solver::Options options;
		options.num_threads = 4;
		options.max_num_iterations = 15;
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.minimizer_progress_to_stdout = true;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = false;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		//std::cout << summary.BriefReport() << "\n";
		std::cout << summary.FullReport() << "\n";

		totalProjections = 0;
		ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA2.txt"), fp = fopen(Fname, "w+");
		for (int ii = startF_VGA; ii < stopF_VGA; ii++)
		{
			if (abs(P3D_VGA[3 * (ii - startF_VGA)]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 1]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]);
			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				if (abs(residuals[0]) + abs(residuals[1]) > threshold *1.5)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));
		}
		if (debug)
			fclose(fp);

		miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d\n", totalProjections, nPossibleProjections);

		sprintf(Fname, "%s/BA_Camera_AllParams_after3.txt", Path);
		ReSaveBundleAdjustedNVMResults(Fname, CorpusData, 1.0);

		delete[]P3D_VGA, delete[]TableVGA, delete[] frame3D_VGA;
	}

	return 0;
}
int BundleAdjustDomeMultiNVM(char *Path, int nNvm, int maxPtsPerNvM, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool debug)
{
	char Fname[200];
	Corpus CorpusData;

	const int maxCams = 30 + 24 * 20;
	double thresh = 4.0;

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	loadBundleAdjustedNVMResults(Fname, CorpusData);

	printf("Set up BA ...");
	ceres::Problem problem;

	vector<int> *AllViewIDList = new vector<int>[maxPtsPerNvM * nNvm];
	vector<Point2d>* AllUVList = new vector<Point2d>[maxPtsPerNvM * nNvm];

	int nvis, viewID, curPid = 0;
	double u, v;
	FILE *fp = 0;
	for (int nvmID = 1; nvmID <= nNvm; nvmID++)
	{
		//Read correspondences
		sprintf(Fname, "%s/calib%d_corres.txt", Path, nvmID); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d", &nvis) != EOF)
		{
			AllViewIDList[curPid].reserve(nvis), AllUVList[curPid].reserve(nvis);
			for (int ii = 0; ii < nvis; ii++)
			{
				fscanf(fp, "%d %lf %lf", &viewID, &u, &v);
				AllViewIDList[curPid].push_back(viewID);
				AllUVList[curPid].push_back(Point2d(u, v));
			}
			curPid++;
		}
	}
	printf("Finished loading data\n");

	Point3d p3d;
	int minInliers, nLargeErr = 0, curValidPid = 0;
	double minInliersPercent = 1.0, residuals[2];
	double P[12 * maxCams];
	double *A = new double[6 * maxCams], *B = new double[2 * maxCams], *tP = new double[12 * maxCams];
	vector<double> ReProjectionError; ReProjectionError.reserve(curPid);
	double *Allp3D = new double[curPid * 3];
	int *ValidPid = new int[curPid];

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

	vector<int> viewIDList, Inliers;
	vector<Point2d> uvList, uvListUndistorted;
	for (int pid = 0; pid < curPid; pid++)
	{
		ValidPid[pid] = 0;
		nvis = AllViewIDList[pid].size();
		viewIDList.clear(), uvList.clear(), uvListUndistorted.clear();
		for (int ii = 0; ii < nvis; ii++)
		{
			viewIDList.push_back(AllViewIDList[pid][ii]);
			uvList.push_back(AllUVList[pid][ii]);
			uvListUndistorted.push_back(AllUVList[pid][ii]);
		}

		//triangulate
		for (int jj = 0; jj < nvis; jj++)
		{
			int viewID = viewIDList[jj];
			LensCorrectionPoint(&uvListUndistorted[jj], CorpusData.camera[viewID].K, CorpusData.camera[viewID].distortion);
			for (int kk = 0; kk < 12; kk++)
				P[12 * jj + kk] = CorpusData.camera[viewID].P[kk];
		}

		bool passed;
		Inliers.clear();
		double avgerror = NviewTriangulationRANSAC(&uvListUndistorted, P, &p3d, &passed, &Inliers, nvis, 1, 100, 0.7, thresh, A, B, tP, false, false);
		if (!passed)
		{
			nLargeErr++;
			printf("Ave Error is larger than %f at point %d \n", thresh, pid);
			continue;
		}
		else
		{
			int ninlier = 0;
			for (int kk = 0; kk < Inliers.size(); kk++)
				if (Inliers.at(kk))
					ninlier++;

			if (ninlier < 3)
			{
				//printf("Two few matches at point %d \n", pid);
				continue;
			}

			ReProjectionError.push_back(avgerror);
			double inlierPercent = 1.0*ninlier / Inliers.size();
			if (minInliersPercent > inlierPercent)
				minInliersPercent = inlierPercent, minInliers = ninlier;
		}
		Allp3D[pid * 3] = p3d.x, Allp3D[pid * 3 + 1] = p3d.y, Allp3D[pid * 3 + 2] = p3d.z;
		ValidPid[pid] = 1;

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f ", pid, p3d.x, p3d.y, p3d.z);

		for (int jj = 0; jj < nvis; jj++)
		{
			if (Inliers[jj] == 0)
				continue;

			PinholeDistortionReprojectionDebug(CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, uvList[jj], p3d, residuals);
			if (abs(residuals[0]) + abs(residuals[1]) > thresh)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, uvList[jj].x, uvList[jj].y, residuals[0], residuals[1]);

			ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvList[jj].x, uvList[jj].y, 1.0);
			problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, &Allp3D[3 * pid]);

			if (fixIntrinsic)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].intrinsic);
			if (fixDistortion)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].distortion);
			if (fixPose)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].rt);
		}
		curValidPid++;

		if (debug)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	printf("Done with problem building\n");

	double miniE = *min_element(ReProjectionError.begin(), ReProjectionError.end()), maxiE = *max_element(ReProjectionError.begin(), ReProjectionError.end());
	double avgE = MeanArray(ReProjectionError), stdE = sqrt(VarianceArray(ReProjectionError, avgE));
	printf("Reprojection error after BA \nMin: %.2f Max: %.2f Mean: %.2f Std: %.2f\n", miniE, maxiE, avgE, stdE);
	printf("Total points: %d/%d. #Large error: %d. Min inliers: %.2f%% (%d)\n", curValidPid, curPid, nLargeErr, minInliersPercent, minInliers);


	printf("...run BA...\n");
	ceres::Solver::Options options;
	options.num_threads = 4;
	options.max_num_iterations = 50;
	if (CorpusData.nCameras < 200)
	{
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = true;
	}
	else
	{
#ifdef _WIN32
		options.linear_solver_type = ceres::ITERATIVE_SCHUR;
		options.preconditioner_type = ceres::PreconditionerType::JACOBI;
		options.visibility_clustering_type = ceres::VisibilityClusteringType::CANONICAL_VIEWS;
		options.sparse_linear_algebra_library_type = ceres::SUITE_SPARSE;
		options.minimizer_progress_to_stdout = true;
#else
		printf("Error! Only works for windows\n");
#endif
	}

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";


	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");

	ReProjectionError.clear();
	for (int pid = 0; pid < curPid; pid++)
	{
		if (ValidPid[pid] == 0)
			continue;

		nvis = AllViewIDList[pid].size();
		viewIDList.clear(), uvList.clear();
		for (int ii = 0; ii < nvis; ii++)
		{
			viewIDList.push_back(AllViewIDList[pid][ii]);
			uvList.push_back(AllUVList[pid][ii]);
		}
		p3d.x = Allp3D[pid * 3], p3d.y = Allp3D[pid * 3 + 1], p3d.z = Allp3D[pid * 3 + 2];

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f ", pid, Allp3D[pid * 3], Allp3D[pid * 3 + 1], Allp3D[pid * 3 + 2]);

		int jj, nvalidprojections = 0;
		double Error = 0.0;
		for (jj = 0; jj < nvis; jj++)
		{
			PinholeDistortionReprojectionDebug(CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, uvList[jj], p3d, residuals);
			if (abs(residuals[0]) + abs(residuals[1]) > 2 * thresh)
				continue;
			nvalidprojections++;
			Error += residuals[0] * residuals[0] + residuals[1] * residuals[1];

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, uvList[jj].x, uvList[jj].y, residuals[0], residuals[1]);
		}
		if (jj > 0)
			ReProjectionError.push_back(sqrt(Error / nvalidprojections));

		if (debug)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/3Dpts.txt", Path);	fp = fopen(Fname, "w+");
	for (int pid = 0; pid < curPid; pid++)
	{
		if (ValidPid[pid] == 0)
			continue;
		fprintf(fp, "%f %f %f \n", Allp3D[pid * 3], Allp3D[pid * 3 + 1], Allp3D[pid * 3 + 2]);
	}
	fclose(fp);

	miniE = *min_element(ReProjectionError.begin(), ReProjectionError.end()), maxiE = *max_element(ReProjectionError.begin(), ReProjectionError.end());
	avgE = MeanArray(ReProjectionError), stdE = sqrt(VarianceArray(ReProjectionError, avgE));
	printf("Reprojection error after BA \nMin: %.2f Max: %.2f Mean: %.2f Std: %.2f\n", miniE, maxiE, avgE, stdE);
	printf("Total points: %d/%d. Min inliers: %.2f%% (%d)\n", curValidPid, curPid, minInliersPercent, minInliers);

	sprintf(Fname, "%s/BA_Camera_AllParams_after2.txt", Path);
	saveBundleAdjustedNVMResults(Fname, CorpusData);

	delete[]Allp3D, delete[]ValidPid, delete[]A, delete[]B, delete[]tP;
	return 0;
}
int ReCalibratedFromGroundTruthCorrespondences(char *Path, int camID, int startFrame, int stopFrame, int Allnpts, int ShutterModel)
{
	char Fname[1024]; FILE *fp = 0;
	bool fixIntrinsic = true, fixDistortion = true, fixPose = true, fixfirstCamPose = true, distortionCorrected = false;

	Corpus corpusData;
	sprintf(Fname, "%s/Corpus/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	vector<int>AvailableViews;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		if (corpusData.camera[fid].valid)
		{
			AvailableViews.push_back(fid);
			corpusData.camera[fid].threshold = 1000000.0; //make sure that all points are inliers
			corpusData.camera[fid].ShutterModel = ShutterModel;
		}
	}

	//Setup 2d point correspondences for all views according to the frame-level sync result
	vector<Point3d> P3D(Allnpts);
	vector <vector<int> > viewIdAll3D;
	vector<vector<Point2d> > uvAll3D;
	vector<vector<double> > scaleAll3D;

	vector<int>viewID3D;
	vector<double>scale3D;
	for (int fid = startFrame; fid <= stopFrame; fid++)
		viewID3D.push_back(fid),
		scale3D.push_back(1.0);

	int  nframes = stopFrame - startFrame + 1;
	Point2d *Correspondences = new Point2d[Allnpts*nframes];
	vector<int> NotAvail;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		sprintf(Fname, "%s/%d/Corner/CV_%d.txt", Path, camID, fid); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot open %s\n", Fname);

			for (int pid = 0; pid < Allnpts; pid++)
				Correspondences[fid + pid*nframes] = Point2d(-1, -1);

			corpusData.camera[fid].valid = false;
			continue;
		}
		for (int pid = 0; pid < Allnpts; pid++)
			fscanf(fp, "%lf %lf ", &Correspondences[fid + pid*nframes].x, &Correspondences[fid + pid*nframes].y);
		fclose(fp);
	}

	vector<Point2d> uv3D;
	for (int pid = 0; pid < Allnpts; pid++)
	{
		viewIdAll3D.push_back(viewID3D);
		scaleAll3D.push_back(scale3D);

		uv3D.clear();
		for (int fid = 0; fid < nframes; fid++)
			uv3D.push_back(Correspondences[fid + pid*nframes]);

		uvAll3D.push_back(uv3D);
	}

	//Retriangulate, assuming global shutter
	/*double error, point3d[3];
	double *P = new double[12 * nframes], *A = new double[6 * nframes], *B = new double[2 * nframes], *points2d = new double[nframes * 2];

	Point3d p3d;
	vector<Point2d> p2d;
	for (int ii = 0; ii < Allnpts; ii++)
	{
	if (viewIdAll3D[ii].size() > 1)
	{
	p2d.clear();
	int count = 0;
	for (int jj = 0; jj < viewIdAll3D[ii].size(); jj++)
	{
	if (corpusData.camera[viewIdAll3D[ii][jj]].valid)
	{
	for (int kk = 0; kk < 12; kk++)
	P[count * 12 + kk] = corpusData.camera[viewIdAll3D[ii][jj]].P[kk];
	p2d.push_back(uvAll3D[ii][jj]);

	int viewID = viewIdAll3D[ii][jj];
	LensCorrectionPoint(&p2d[count], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
	count++;
	}
	}

	NviewTriangulation(&p2d, P, &p3d, count, 1, NULL, A, B);
	P3D[ii] = p3d;
	}
	}
	delete[]P, delete[]A, delete[]B, delete[]points2d;*/
	NviewTriangulation(corpusData.camera, corpusData.nCameras, viewIdAll3D, uvAll3D, P3D);

	//Re-adjust the bundle
	vector<int>sharedCam;
	for (int ii = 0; ii < nframes; ii++)
		sharedCam.push_back(0);
	vector<bool>GoodPoints;

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, P3D, viewIdAll3D, uvAll3D, scaleAll3D, sharedCam, AvailableViews.size(), fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, P3D, viewIdAll3D, uvAll3D, scaleAll3D, sharedCam, AvailableViews.size(), fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, true, distortionCorrected, 0, false, false);

	//sprintf(Fname, "%s/rBA_Camera_AllParams_after.txt", Path);
	//ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	sprintf(Fname, "%s/Corpus", Path);
	SaveCurrentSfmGL(Fname, corpusData.camera, AvailableViews, P3D, vector<Point3i>());
	visualizationDriver(Path, nframes, startFrame, stopFrame, false, false, false, false, false, false, 0);

	delete[]Correspondences;
	return 0;
}
int RefineVisualSfM2(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement)
{
	char Fname[200];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
				ImgSize.push_back(Point2i(img.cols, img.rows));
			else
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	Corpus corpusData;
	sprintf(Fname, "%s/Corpus/corpus.nvm", Path);
	if (!loadNVM(Fname, corpusData, ImgSize))
		return 1;

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < nimages; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	vector<int>AvailableViews;
	for (int ii = 0; ii < nimages; ii++)
	{
		corpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		corpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			corpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);
	}

	sprintf(Fname, "%s/Corpus/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	sprintf(Fname, "%s/Corpus", Path);
	for (int ii = 0; ii < nimages; ii++)
		AvailableViews.push_back(ii);
	SaveCurrentSfmGL(Fname, corpusData.camera, AvailableViews, corpusData.xyz, vector<Point3i>());

	return 0;
}
int RefineVisualSfM(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement, int LossType)
{
	char Fname[512];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
			else
				ImgSize.push_back(Point2i(img.cols, img.rows));
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	//Fill up the visSfm corpus data. Assume all cameras are reconstructed
	printf("Reading corpus info ....\n");
	Corpus CorpusData;
	sprintf(Fname, "%s/Corpus.nvm", Path);
	loadNVM(Fname, CorpusData, ImgSize, nplus);
	printf("%d %d+ 3D points", CorpusData.n3dPoints, nplus);

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	//Refine visSfm corpus
	printf("... Refine corpus ....\n");
	for (int ii = 0; ii < CorpusData.nCameras; ii++)
	{
		CorpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		CorpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, distortionCorrected, LossType, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, distortionCorrected, LossType, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			CorpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, distortionCorrected, LossType, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, distortionCorrected, LossType, false);
	}

	//write corpusData
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, CorpusData);

	vector<int>AvailViews;
	for (int ii = 0; ii < nimages; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, CorpusData.camera, AvailViews, CorpusData.xyz, CorpusData.rgb);

	return 0;
}
int RefineVisualSfMAndCreateCorpus(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement, bool siftgpu)
{
	char Fname[512];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
			else
				ImgSize.push_back(Point2i(img.cols, img.rows));
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	//read all visualsfm sift. Assume all cameras are reconstructed
	printf("Reading sift points ...");
	vector<KeyPoint> *AllKeyPts = new vector<KeyPoint>[nimages];
	Mat *AllDesc = new Mat[nimages];
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.sift", Path, ii);
		readVisualSFMSiftGPU(Fname, AllKeyPts[ii], AllDesc[ii]);
	}
	printf("\n");

	//Fill up the visSfm corpus data. Assume all cameras are reconstructed
	printf("Reading corpus info ....\n");
	Corpus CorpusData;
	sprintf(Fname, "%s/Corpus.nvm", Path);
	loadNVM(Fname, CorpusData, ImgSize, nplus, AllKeyPts, AllDesc);
	printf("%d %d+ 3D points", CorpusData.n3dPoints, nplus);

	int nSift, totalSift = 0;
	CorpusData.IDCumView.reserve(nimages + 1);
	for (int ii = 0; ii < nimages; ii++)
	{
		CorpusData.IDCumView.push_back(totalSift);
		nSift = (int)CorpusData.uvAllViews[ii].size();
		totalSift += nSift;
	}
	CorpusData.IDCumView.push_back(totalSift);
	printf("\n");

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}


	//Refine visSfm corpus
	printf("Refine corpus ....\n");
	for (int ii = 0; ii < CorpusData.nCameras; ii++)
	{
		CorpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		CorpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			CorpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);
	}
	printf("\n");

	//write corpusData
	printf("Write corpus info ....");
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, CorpusData);

	SaveCorpusInfo(Path, CorpusData);

	vector<int>AvailViews;
	for (int ii = 0; ii < nimages; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, CorpusData.camera, AvailViews, CorpusData.xyz, CorpusData.rgb);

	delete[]AllKeyPts, delete[]AllDesc;

	return 0;
}

double FmatPointError(double *Fmat, Point2d p1, Point2d p2)
{
	//F*p1
	double Fx[3] = { Fmat[0] * p1.x + Fmat[1] * p1.y + Fmat[2],
		Fmat[3] * p1.x + Fmat[4] * p1.y + Fmat[5],
		Fmat[6] * p1.x + Fmat[7] * p1.y + Fmat[8] };

	//F'*p2
	double FTXp[3] = { Fmat[0] * p2.x + Fmat[3] * p2.y + Fmat[6],
		Fmat[1] * p2.x + Fmat[4] * p2.y + Fmat[7],
		Fmat[2] * p2.x + Fmat[5] * p2.y + Fmat[8] };

	double error = pow(p2.x * Fx[0] + p2.y*Fx[1] + Fx[2], 2) *
		(1.0 / (Fx[0] * Fx[0] + Fx[1] * Fx[1])
		+ 1.0 / (FTXp[0] * FTXp[0] + FTXp[1] * FTXp[1]));

	return error;
}
void computeFmat(CameraData Cam1, CameraData Cam2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9] = { Cam1.K[0], Cam1.K[1], Cam1.K[2], 0, Cam1.K[4], Cam1.K[5], 0, 0, 1.0 };
	double K2[9] = { Cam2.K[0], Cam2.K[1], Cam2.K[2], 0, Cam2.K[4], Cam2.K[5], 0, 0, 1.0 };
	double rt1[6] = { Cam1.rt[0], Cam1.rt[1], Cam1.rt[2], Cam1.rt[3], Cam1.rt[4], Cam1.rt[5] };
	double rt2[6] = { Cam2.rt[0], Cam2.rt[1], Cam2.rt[2], Cam2.rt[3], Cam2.rt[4], Cam2.rt[5] };

	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}
void computeFmatfromKRT(CameraData *CameraInfo, int nviews, int *selectedIDs, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9] = { CameraInfo[selectedIDs[0]].K[0], CameraInfo[selectedIDs[0]].K[1], CameraInfo[selectedIDs[0]].K[2],
		0, CameraInfo[selectedIDs[0]].K[4], CameraInfo[selectedIDs[0]].K[5],
		0, 0, 1.0 };
	double K2[9] = { CameraInfo[selectedIDs[1]].K[0], CameraInfo[selectedIDs[1]].K[1], CameraInfo[selectedIDs[1]].K[2],
		0, CameraInfo[selectedIDs[1]].K[4], CameraInfo[selectedIDs[1]].K[5],
		0, 0, 1.0 };
	double rt1[6] = { CameraInfo[selectedIDs[0]].rt[0], CameraInfo[selectedIDs[0]].rt[1], CameraInfo[selectedIDs[0]].rt[2],
		CameraInfo[selectedIDs[0]].rt[3], CameraInfo[selectedIDs[0]].rt[4], CameraInfo[selectedIDs[0]].rt[5] };
	double rt2[6] = { CameraInfo[selectedIDs[1]].rt[0], CameraInfo[selectedIDs[1]].rt[1], CameraInfo[selectedIDs[1]].rt[2],
		CameraInfo[selectedIDs[1]].rt[3], CameraInfo[selectedIDs[1]].rt[4], CameraInfo[selectedIDs[1]].rt[5] };

	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}
//if ChooseCorpusView != -1, selectedCams and seletectedTime will be overwritten
void computeFmatfromKRT(CorpusandVideo &CorpusandVideoInfo, int *selectedCams, int *seletectedTime, int ChooseCorpusView1, int ChooseCorpusView2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9], K2[9], rt1[6], rt2[6];

	if (ChooseCorpusView1 != -1)
	{
		K1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[0], K1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[1], K1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[4], K1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[0], rt1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[1], rt1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[2],
			rt1[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[3], rt1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[4], rt1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[5];
	}
	else
	{
		int ID = selectedCams[0] * MaxnFrames + seletectedTime[0];
		K1[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K1[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K1[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K1[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt1[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt1[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt1[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt1[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt1[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}

	if (ChooseCorpusView2 != -1)
	{
		K2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[0], K2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[1], K2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[4], K2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[0], rt2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[1], rt2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[2],
			rt2[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[3], rt2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[4], rt2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[5];
	}
	else
	{
		int ID = selectedCams[1] * MaxnFrames + seletectedTime[1];
		K2[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K2[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K2[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K2[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt2[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt2[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt2[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt2[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt2[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}


	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}

/*int Trajectory3DGen(char *Path, int nviews, int startTime, int stopTime, int timeID, int LensType, int distortionCorrected, double Reprojectionthreshold)
{
int nFrames = stopTime - startTime + 1;
char Fname[200];
VideoData AllVideoInfo;
if (ReadVideoData(Path, AllVideoInfo, nviews, startTime, stopTime) == 1)
return 1;

//startTime = 0, stopTime = 0;

int totalPts, MAXPTS = 0;
for (int timeID = startTime; timeID <= stopTime; timeID++)
{
sprintf(Fname, "%s/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
continue;
}
int nviewsi, viewi, n3D = 0;
while (fscanf(fp, "%d ", &nviewsi) != EOF)
{
for (int ii = 0; ii < nviewsi; ii++)
fscanf(fp, "%d ", &viewi);
n3D++;
}
fclose(fp);
if (n3D > MAXPTS)
MAXPTS = n3D;
}

vector<int> cumulativePts; cumulativePts.reserve(nviews);
vector<int>*CandiateViewMatch = new vector<int>[MAXPTS];
vector<int>*CandiatePointIDMatch = new vector<int>[MAXPTS];
vector<int> *AllViewID = new vector<int>[MAXPTS];
vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
vector<Point3i> *RGB = new vector < Point3i >[nviews];
vector<Point3d> AllXYZ; AllXYZ.reserve(1000);
vector<Point3i> AllRGB; AllRGB.reserve(1000);

double *A = new double[6 * nviews * 2];
double *B = new double[2 * nviews * 2];
double *tPs = new double[12 * nviews * 2];
bool *passed = new bool[nviews * 2];
double *Ps = new double[12 * nviews * 2];
Point2d *match2Dpts = new Point2d[nviews * 2];
Point3i *matchRGB = new Point3i[nviews * 2];


cumulativePts.clear(); AllXYZ.clear(), AllRGB.clear();
if (ReadCumulativePoints(Path, nviews, timeID, cumulativePts) == 1)
return 1;
totalPts = cumulativePts.at(nviews);

sprintf(Fname, "%s/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
return 1;
}
int nviewsi, viewi, n3D = 0;
while (fscanf(fp, "%d ", &nviewsi) != EOF)
{
CandiateViewMatch[n3D].clear(), CandiateViewMatch[n3D].reserve(nviewsi);
for (int ii = 0; ii < nviewsi; ii++)
{
fscanf(fp, "%d ", &viewi);
CandiateViewMatch[n3D].push_back(viewi);
}
n3D++;
}
fclose(fp);

sprintf(Fname, "%s/IDPM_%d.txt", Path, timeID); fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
return 1;
}
int np, pi;
n3D = 0;
while (fscanf(fp, "%d ", &np) != EOF)
{
CandiatePointIDMatch[n3D].clear(), CandiatePointIDMatch[n3D].reserve(np);
for (int ii = 0; ii < np; ii++)
{
fscanf(fp, "%d ", &pi);
CandiatePointIDMatch[n3D].push_back(pi);
}
n3D++;
}
fclose(fp);

//Read all sift points
for (int ii = 0; ii < nviews; ii++)
{
AllKeys[ii].clear(); RGB[ii].clear();
sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID); ReadKPointsBinarySIFT(Fname, AllKeys[ii]);
sprintf(Fname, "%s/%d/RGB%d.dat", Path, ii, timeID); ReadRGBBinarySIFT(Fname, RGB[ii]);
}

//Triangulate points from estimated camera poses
Point3d xyz;
vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
vector<int>viewIDs, pointIDs, orgId, threeDid;
vector<Point2d> uvPer3D, uvperView;
Point2d X;

double ProThresh = 0.99, PercentInlier = 0.25;
int NDplus = 2, goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
double start = omp_get_wtime();
for (int jj = 0; jj < n3D; jj++)
{
int nviewsi = CandiateViewMatch[jj].size();
if (nviewsi >= NDplus)
{
Inliers[0].clear();
for (int ii = 0; ii < nviewsi; ii++)
{
viewi = CandiateViewMatch[jj][ii];
for (int kk = 0; kk < 12; kk++)
Ps[12 * ii + kk] = AllVideoInfo.VideoInfo[viewi*nFrames + timeID].P[kk];

pi = CandiatePointIDMatch[jj][ii];

X = Point2d(AllKeys[viewi].at(pi).x, AllKeys[viewi].at(pi).y);
match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).x, AllKeys[viewi].at(pi).y);
matchRGB[ii] = Point3i(RGB[viewi].at(pi).x, RGB[viewi].at(pi).y, RGB[viewi].at(pi).z);

if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID].LensModel == RADIAL_TANGENTIAL_PRISM)
LensCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].K, AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion);
else if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID].LensModel == FISHEYE)
FishEyeCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[0],
AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[1], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[2]);
}

NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, Reprojectionthreshold, A, B, tPs);
if (passed[0])
{
int ninlier = 0, inlierID;
for (int ii = 0; ii < Inliers[0].size(); ii++)
if (Inliers[0][ii])
inlierID = ii, ninlier++;
if (ninlier < NDplus)
continue; //Corpus needs NDplus+ points!

for (int ii = 0; ii < Inliers[0].size(); ii++)
if (Inliers[0][ii])
viewIDs.push_back(CandiateViewMatch[jj][ii]);

AllXYZ.push_back(xyz);
AllRGB.push_back(matchRGB[inlierID]);
goodNDplus++;
}
viewIDs.clear();
}
}

//Back project and compute flow until erros grows too large
while (true)
{

}

delete[]CandiateViewMatch, delete[]CandiatePointIDMatch, delete[]AllViewID, delete[]AllKeys;
delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts;
return 0;
}*/
int Evaluate3DTrajectory(char *Path)
{
	//const int nViews = 480;
	//CameraData CameraInfo[nViews];
	//ReadDomeVGACalibFile(Path, CameraInfo);

	TrajectoryData InfoTraj;
	LoadTrackData(Path, 150, InfoTraj, true);

	//vector<int> TrajectUsed;
	//for (int ii = 0; ii < 8000; ii++)
	//	TrajectUsed.push_back(ii);

	return 0;
}

int PrepareTrajectoryInfo(char *Path, VideoData *VideoInfo, PerCamNonRigidTrajectory *CamTraj, double *OffsetInfo, int nCams, int npts, int startFrame, int stopFrame)
{
	char Fname[200];
	int id, nf, frameID;
	//CamCenter Ccenter;
	//RotMatrix Rmat;
	//Quaternion Qmat;
	//KMatrix Kmat;
	//Pmat P;

	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], camID, startFrame, stopFrame) == 1)
			return 1;

	for (int ii = 0; ii < nCams; ii++)
		CamTraj[ii].npts = npts,
		CamTraj[ii].Track2DInfo = new Track2D[npts],
		CamTraj[ii].Track3DInfo = new Track3D[npts];

	Point2d uv;
	vector<Point2d> uvAll;
	vector<int> frameIDAll;
	for (int camID = 0; camID < nCams; camID++)
	{
		sprintf(Fname, "%s/Track2D/C_%d.txt", Path, camID); FILE *fp = fopen(Fname, "r");
		for (int pid = 0; pid < npts; pid++)
		{
			fscanf(fp, "%d %d ", &id, &nf);
			if (id != pid)
				printf("Problem at Point %d of Cam %d", id, camID);

			uvAll.clear(), frameIDAll.clear();
			for (int fid = 0; fid < nf; fid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &uv.x, &uv.y);
				if (frameID < startFrame || frameID>stopFrame)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (uv.x > 0 && uv.y > 0)
				{
					LensCorrectionPoint(&uv, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					uvAll.push_back(uv);
					frameIDAll.push_back(frameID);
				}
			}

			nf = uvAll.size();
			CamTraj[camID].Track2DInfo[pid].nf = nf;
			CamTraj[camID].Track3DInfo[pid].nf = nf;
			CamTraj[camID].Track2DInfo[pid].uv = new Point2d[nf];
			CamTraj[camID].Track3DInfo[pid].xyz = new double[nf * 3];

			for (int kk = 0; kk < nf; kk++)
				CamTraj[camID].Track2DInfo[pid].uv[kk] = uvAll[kk];
		}
		fclose(fp);
	}

	//Triangulate 3D data
	return 0;
}
int FmatSyncBruteForce2DStereo(char *Path, int *SelectedCams, int realStartFrame, int startFrame, int stopFrame, int ntracks, int *OffsetInfo, int LowBound, int UpBound, bool GivenF, bool silent = true)
{
	char Fname[200]; FILE *fp = 0;
	const int nCams = 2;

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startFrame, stopFrame) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startFrame, stopFrame) == 1)
		return 1;

	int id, frameID, nf;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];
	vector<XYZD> *PerCam_XYZ = new vector<XYZD>[nCams], *XYZ = new vector<XYZD>[ntracks], XYZBK;

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		int  FirstValidFrame;
		if (!GivenF)
		{
			for (int fid = startFrame; fid < stopFrame; fid++)
			{
				if (VideoInfo[camID].VideoInfo[fid].valid)
				{
					FirstValidFrame = fid;
					break;
				}
			}
		}

		//sprintf(Fname, "%s/Track2D/C_%d_%d.txt", Path, SelectedCams[camID], realStartFrame); FILE *fp = fopen(Fname, "r");
		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &nf);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int ii = 0; ii < nf; ii++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < startFrame || frameID>stopFrame)
					continue;
				if (GivenF && !VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID;
					if (GivenF)
						LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					else
						LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[FirstValidFrame].K, VideoInfo[camID].VideoInfo[FirstValidFrame].distortion);

					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	//Generate Calib Info
	if (GivenF)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			int count = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
				{
					int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],
						PerCam_UV[camID*ntracks + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];

					for (int kk = 0; kk < 3; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk],
						PerCam_UV[camID*ntracks + trackID][frameID].T[kk] = VideoInfo[camID].VideoInfo[RealFrameID].T[kk];
				}
			}
		}
	}

	//Start sliding
	int *OffsetID = new int[UpBound - LowBound + 1];
	double*AllFmatCost = new double[UpBound - LowBound + 1];

	int BestOffset = 0;
	double minError = 9e9;
	int count = 0;
	for (int off = LowBound; off <= UpBound; off++)
	{
		double Fmat[9], error, cumError = 0.0, usedPointsCount = 0;
		if (GivenF)
		{
			for (int trackID = 0; trackID < ntracks; trackID++)
			{
				for (int pid = 0; pid < PerCam_UV[trackID].size(); pid++)
				{
					int currentFrame = PerCam_UV[trackID][pid].frameID + OffsetInfo[0], otherCameraFrame = currentFrame + off + OffsetInfo[1];

					//see if the corresponding frame in the other camera has point
					error = 0.0;
					for (int pid2 = 0; pid2 < PerCam_UV[ntracks + trackID].size(); pid2++)
					{
						if (PerCam_UV[ntracks + trackID][pid2].frameID == otherCameraFrame)
						{
							computeFmat(VideoInfo[0].VideoInfo[currentFrame], VideoInfo[1].VideoInfo[otherCameraFrame], Fmat);
							error = FmatPointError(Fmat, PerCam_UV[trackID][pid].pt2D, PerCam_UV[ntracks + trackID][pid2].pt2D);
							usedPointsCount++;
							break;
						}
					}
					cumError += error;
				}
			}
		}
		else
		{
			//Compute Fmat
			vector<Point2d> points1, points2;
			for (int fid1 = 0; fid1 < (int)PerCam_UV[0].size(); fid1++)
			{
				for (int fid2 = 0; fid2 < (int)PerCam_UV[ntracks].size(); fid2++)
				{
					if (PerCam_UV[0][fid1].frameID + OffsetInfo[0] == PerCam_UV[ntracks][fid2].frameID + off + OffsetInfo[1])
					{
						for (int i = 0; i < ntracks; i++)
						{
							points1.push_back(PerCam_UV[i][fid1].pt2D);
							points2.push_back(PerCam_UV[i + ntracks][fid2].pt2D);
						}
						break;
					}
				}
			}

			if (points1.size() < 8)
			{
				cumError = 9e9;
				usedPointsCount = 0;
			}
			else
			{
				Mat cvFmat = findFundamentalMat(points1, points2, CV_FM_8POINT, 3, 0.99);

				double Fmat[9];
				for (int ii = 0; ii < 9; ii++)
					Fmat[ii] = cvFmat.at<double>(ii);

				for (int ii = 0; ii < (int)points1.size(); ii++)
					cumError += FmatPointError(Fmat, points1[ii], points2[ii]);
				usedPointsCount = points1.size();
			}
		}
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		AllFmatCost[count] = cumError;
		if (silent)
			printf("@off %d (id: %d): %.5f -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	printf("Pair (%d, %d): %d\n", SelectedCams[0], SelectedCams[1], BestOffset);

	OffsetInfo[1] = BestOffset;

	delete[]PerCam_UV, delete[]PerCam_XYZ;
	delete[]OffsetID, delete[]AllFmatCost;

	return 0;
}
int GeometricConstraintSyncDriver(char *Path, int nCams, int npts, int realStartFrame, int startFrame, int stopTime, int Range, bool GivenF, double *OffsetInfo, bool HasInitOffset)
{
	if (OffsetInfo == NULL)
	{
		OffsetInfo = new double[nCams];
		for (int ii = 0; ii < nCams; ii++)
			OffsetInfo[ii] = 0;
	}
	if (!HasInitOffset)
		for (int ii = 0; ii < nCams; ii++)
			OffsetInfo[ii] = 0;

	printf("Geometric sync:\n");
	char Fname[200]; sprintf(Fname, "%s/GeoSync.txt", Path); 	FILE *fp = fopen(Fname, "w+");
	for (int jj = 0; jj < nCams - 1; jj++)
	{
		for (int ii = jj + 1; ii < nCams; ii++)
		{
			int SelectedCams[2] = { jj, ii }, Offset[] = { OffsetInfo[jj], OffsetInfo[ii] };
			FmatSyncBruteForce2DStereo(Path, SelectedCams, realStartFrame, startFrame, stopTime, npts, Offset, -Range, Range, GivenF);
			printf("Between (%d, %d): %d\n", jj, ii, Offset[0] - Offset[1]);
			fprintf(fp, "%d %d %d\n", jj, ii, Offset[0] - Offset[1]);
		}
	}
	fclose(fp);

	PrismMST(Path, "GeoSync", nCams);
	AssignOffsetFromMST(Path, "GeoSync", nCams, OffsetInfo);
	printf("Done.\n\n***NOTE: FGeoSync is in time stamp format (f = f_ref - offset) ***\n");

	return 0;
}
int FmatSyncBruteForce2DStereo2(char *Path, int *SelectedCams, vector<int> realStartFrame, int startFrame, int stopFrame, int ntracks, int *OffsetInfo, int LowBound, int UpBound, bool GivenF, vector<ImgPtEle> *PerCam_UV, bool silent = true)
{
	char Fname[200]; FILE *fp = 0;
	const int nCams = 2;

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startFrame, stopFrame) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startFrame, stopFrame) == 1)
		return 1;

	int id, frameID, nf;
	int nframes = max(MaxnFrames, stopFrame), nseeds = (int)realStartFrame.size();

	double u, v;
	ImgPtEle ptEle;
	bool createdMem = false;
	if (PerCam_UV == NULL)
	{
		createdMem = true;
		PerCam_UV = new vector<ImgPtEle>[nCams*ntracks*nseeds];
		for (int camID = 0; camID < nCams; camID++)
			for (int trackID = 0; trackID < ntracks*nseeds; trackID++)
				PerCam_UV[camID*ntracks*nseeds + trackID].reserve(stopFrame - startFrame + 1);
	}
	else
	{
		for (int camID = 0; camID < nCams; camID++)
			for (int trackID = 0; trackID < ntracks*nseeds; trackID++)
				PerCam_UV[camID*ntracks*nseeds + trackID].clear();
	}

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		int  FirstValidFrame;
		if (!GivenF)
		{
			for (int fid = startFrame; fid < stopFrame; fid++)
			{
				if (VideoInfo[camID].VideoInfo[fid].valid)
				{
					FirstValidFrame = fid;
					break;
				}
			}
		}

		for (int seedID = 0; seedID < nseeds; seedID++)
		{
			sprintf(Fname, "%s/Track2D/C_%d_%d.txt", Path, SelectedCams[camID], realStartFrame[seedID]); FILE *fp = fopen(Fname, "r");
			for (int trackID = 0; trackID < ntracks; trackID++)
			{
				fscanf(fp, "%d %d ", &id, &nf);
				if (id != trackID)
					printf("Problem at Point %d of Cam %d", id, camID);
				for (int ii = 0; ii < nf; ii++)
				{
					fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
					if (frameID < startFrame || frameID>stopFrame)
						continue;
					if (GivenF && !VideoInfo[camID].VideoInfo[frameID].valid)
						continue; //camera not localized

					if (u > 0 && v > 0)
					{
						ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID;
						if (GivenF)
							LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
						else
							LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[FirstValidFrame].K, VideoInfo[camID].VideoInfo[FirstValidFrame].distortion);

						PerCam_UV[camID*ntracks*nseeds + id].push_back(ptEle);
					}
				}
			}
			fclose(fp);
		}
	}

	//Generate Calib Info
	if (GivenF)
	{
		for (int trackID = 0; trackID < ntracks*nseeds; trackID++)
		{
			int count = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				for (int frameID = 0; frameID < PerCam_UV[camID*ntracks*nseeds + trackID].size(); frameID++)
				{
					int RealFrameID = PerCam_UV[camID*ntracks*nseeds + trackID][frameID].frameID;

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks*nseeds + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],
						PerCam_UV[camID*ntracks*nseeds + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];

					for (int kk = 0; kk < 3; kk++)
						PerCam_UV[camID*ntracks*nseeds + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk],
						PerCam_UV[camID*ntracks*nseeds + trackID][frameID].T[kk] = VideoInfo[camID].VideoInfo[RealFrameID].T[kk];
				}
			}
		}
	}

	//Start sliding
	int *OffsetID = new int[UpBound - LowBound + 1];
	double*AllFmatCost = new double[UpBound - LowBound + 1];

	int BestOffset = 0;
	double minError = 9e9;
	int count = 0;
	for (int off = LowBound; off <= UpBound; off++)
	{
		double Fmat[9], error, cumError = 0.0, usedPointsCount = 0;
		if (GivenF)
		{
			for (int trackID = 0; trackID < ntracks*nseeds; trackID++)
			{
				for (int pid = 0; pid < PerCam_UV[trackID].size(); pid++)
				{
					int currentFrame = PerCam_UV[trackID][pid].frameID + OffsetInfo[0], otherCameraFrame = currentFrame + off + OffsetInfo[1];

					//see if the corresponding frame in the other camera has point
					error = 0.0;
					for (int pid2 = 0; pid2 < PerCam_UV[ntracks*nseeds + trackID].size(); pid2++)
					{
						if (PerCam_UV[ntracks*nseeds + trackID][pid2].frameID == otherCameraFrame)
						{
							computeFmat(VideoInfo[0].VideoInfo[currentFrame], VideoInfo[1].VideoInfo[otherCameraFrame], Fmat);
							error = FmatPointError(Fmat, PerCam_UV[trackID][pid].pt2D, PerCam_UV[ntracks *nseeds + trackID][pid2].pt2D);
							usedPointsCount++;
							break;
						}
					}
					cumError += error;
				}
			}
		}
		else
		{
			//Compute Fmat
			vector<Point2d> points1, points2;
			for (int fid1 = 0; fid1 < (int)PerCam_UV[0].size(); fid1++)
			{
				for (int fid2 = 0; fid2 < (int)PerCam_UV[ntracks*nseeds].size(); fid2++)
				{
					if (PerCam_UV[0][fid1].frameID + OffsetInfo[0] == PerCam_UV[ntracks*nseeds][fid2].frameID + off + OffsetInfo[1])
					{
						for (int i = 0; i < ntracks*nseeds; i++)
						{
							points1.push_back(PerCam_UV[i][fid1].pt2D);
							points2.push_back(PerCam_UV[i + ntracks*nseeds][fid2].pt2D);
						}
						break;
					}
				}
			}

			if (points1.size() < 8)
			{
				cumError = 9e9;
				usedPointsCount = 0;
			}
			else
			{
				Mat cvFmat = findFundamentalMat(points1, points2, CV_FM_8POINT, 3, 0.99);

				double Fmat[9];
				for (int ii = 0; ii < 9; ii++)
					Fmat[ii] = cvFmat.at<double>(ii);

				for (int ii = 0; ii < (int)points1.size(); ii++)
					cumError += FmatPointError(Fmat, points1[ii], points2[ii]);
				usedPointsCount = points1.size();
			}
		}
		cumError = cumError / (0.0000001 + usedPointsCount);
		if (cumError < minError)
			minError = cumError, BestOffset = off;

		AllFmatCost[count] = cumError;
		if (silent)
			printf("@off %d (id: %d): %.5f -- Best offset: %d\n", off, count, cumError, BestOffset);
		count++;
	}
	printf("Pair (%d, %d): %d\n", SelectedCams[0], SelectedCams[1], BestOffset);

	OffsetInfo[1] = BestOffset;

	if (createdMem)
		delete[]PerCam_UV;
	delete[]OffsetID, delete[]AllFmatCost;

	return 0;
}
int GeometricConstraintSyncDriver2(char *Path, int nCams, int npts, vector<int> realStartFrame, int startFrame, int stopFrame, int Range, bool GivenF, double *OffsetInfo, bool HasInitOffset)
{
	if (OffsetInfo == NULL)
	{
		OffsetInfo = new double[nCams];
		for (int ii = 0; ii < nCams; ii++)
			OffsetInfo[ii] = 0;
	}
	if (!HasInitOffset)
		for (int ii = 0; ii < nCams; ii++)
			OffsetInfo[ii] = 0;

	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*npts*(int)realStartFrame.size()];
	for (int camID = 0; camID < nCams; camID++)
		for (int trackID = 0; trackID < npts*(int)realStartFrame.size(); trackID++)
			PerCam_UV[camID*npts*(int)realStartFrame.size() + trackID].reserve(stopFrame - startFrame + 1);

	printf("Geometric sync:\n");
	char Fname[200]; sprintf(Fname, "%s/GeoSync.txt", Path); 	FILE *fp = fopen(Fname, "w+");
	for (int jj = 0; jj < nCams - 1; jj++)
	{
		for (int ii = jj + 1; ii < nCams; ii++)
		{
			int SelectedCams[2] = { jj, ii }, Offset[] = { OffsetInfo[jj], OffsetInfo[ii] };
			FmatSyncBruteForce2DStereo2(Path, SelectedCams, realStartFrame, startFrame, stopFrame, npts, Offset, -Range, Range, GivenF, PerCam_UV);
			printf("Between (%d, %d): %d\n", jj, ii, Offset[1] - Offset[0]);
			fprintf(fp, "%d %d %d\n", jj, ii, Offset[1] - Offset[0]);
		}
	}
	fclose(fp);

	PrismMST(Path, "GeoSync", nCams);
	AssignOffsetFromMST(Path, "GeoSync", nCams, OffsetInfo);
	printf("Done.\n\n***NOTE: FGeoSync is in time delay format (f = f_ref + offset) ***\n");

	delete[]PerCam_UV;

	return 0;
}
int TriangulateFrameSync2DTrajectories(char *Path, vector<int> &SelectedCams, vector<int> &FrameOffset, int startFrame, int stopFrame, int npts, bool CleanCorrespondencesByTriangulationTest, double *GTFrameOffset, double *ialpha, double*Tscale, int realStartFrame)
{
	int nCams = (int)SelectedCams.size();
	bool createdMem = false;
	if (GTFrameOffset == NULL)
	{
		createdMem = true;
		GTFrameOffset = new double[nCams];
		ialpha = new double[1], Tscale = new double[1];
		ialpha[0] = 1.0, Tscale[0] = 1.0;
		for (int ii = 0; ii < nCams; ii++)
			GTFrameOffset[ii] = 0.0;
	}

	char Fname[512];
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
	{
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;
	}

	vector<int> *RealframeID = new vector<int>[MaxnFrames*npts];
	vector<int> *CamID = new vector<int>[MaxnFrames*npts];
	vector<Point2d> *FrameSyncedPoints = new vector<Point2d>[MaxnFrames*npts];
	vector<Pmat> *Pmatrix = new vector<Pmat>[MaxnFrames*npts];

	Pmat Pm;
	Point2d uv;
	int pid, cid, fid, nf;
	for (int ii = 0; ii < nCams; ii++)
	{
		if (realStartFrame == -1)
			realStartFrame = startFrame;
		sprintf(Fname, "%s/Track2D/%d_%d.txt", Path, SelectedCams[ii], realStartFrame);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		int previousPid = 0;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf ", &fid, &uv.x, &uv.y);
				if (fid<0 || fid>MaxnFrames || !VideoInfo[ii].VideoInfo[fid].valid)
					continue;
				LensCorrectionPoint(&uv, VideoInfo[ii].VideoInfo[fid].K, VideoInfo[ii].VideoInfo[fid].distortion);

				if (VideoInfo[ii].VideoInfo[fid].ShutterModel == 0)
				{
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoInfo[ii].VideoInfo[fid].P[ll];
				}
				else if (VideoInfo[ii].VideoInfo[fid].ShutterModel == 1)
				{
					double *K = VideoInfo[ii].VideoInfo[fid].K;
					double ycn = (uv.y - K[5]) / K[4];
					double xcn = (uv.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[ii].VideoInfo[fid].wt;
					double *Rcenter = VideoInfo[ii].VideoInfo[fid].R;
					double *Tcenter = VideoInfo[ii].VideoInfo[fid].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, Pm.P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				int fake_fid = fid - FrameOffset[ii]; //fake the order
				if (fake_fid<0 || fake_fid>MaxnFrames)
					continue;

				CamID[fake_fid + pid*MaxnFrames].push_back(ii);
				RealframeID[fake_fid + pid*MaxnFrames].push_back(fid);
				FrameSyncedPoints[fake_fid + pid*MaxnFrames].push_back(uv);
				Pmatrix[fake_fid + pid*MaxnFrames].push_back(Pm);
			}
		}
		fclose(fp);
	}

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2];
	double *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2];
	double *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];
	vector<int>Inliers[1];  Inliers[0].reserve(nCams * 2);

	vector<int> *CleanFrameSynID;
	vector<Point2d> *CleanedFrameSyncedPoints;
	if (CleanCorrespondencesByTriangulationTest)
		CleanFrameSynID = new vector<int>[nCams*npts], CleanedFrameSyncedPoints = new vector<Point2d>[nCams*npts];

	//sprintf(Fname, "%s/Track3D/frameSynced_Track_%d.txt", Path, startFrame);  FILE *fp = fopen(Fname, "w+");
	sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
	for (pid = 0; pid < npts; pid++)
	{
		sprintf(Fname, "%s/Track3D/frameSynced_Track_%d_%d.txt", Path, pid, realStartFrame);  FILE *fp = NULL;
		for (int kk = 0; kk <= stopFrame - startFrame; kk++)
		{
			int nvis = FrameSyncedPoints[kk + pid*MaxnFrames].size();
			if (nvis < 2)
				continue;
			if (fp == NULL)
				fp = fopen(Fname, "w+");

			vector<int> cameraID, frameID;
			for (int ii = 0; ii < nvis; ii++)
			{
				cameraID.push_back(CamID[kk + pid*MaxnFrames][ii]);
				frameID.push_back(RealframeID[kk + pid*MaxnFrames][ii]);
				uv = FrameSyncedPoints[kk + pid*MaxnFrames][ii];
				pts[ii] = FrameSyncedPoints[kk + pid*MaxnFrames][ii];

				for (int ll = 0; ll < 12; ll++)
					P[12 * ii + ll] = Pmatrix[kk + pid*MaxnFrames][ii].P[ll];
			}

			/*finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 10, 0.5, 10, A, B, tP);
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
			if (Inliers[0].at(ii))
			ninlier++;
			Inliers[0].clear();
			if (ninlier>=5)*/
			NviewTriangulation(pts, P, &P3d, nvis, 1, NULL, A, B);
			ProjectandDistort(P3d, ppts, P, NULL, NULL, nvis);

			int nvalid = 0;
			double finalerror = 0.0;
			for (int ll = 0; ll < nvis; ll++)
				finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2), nvalid++;
			finalerror = sqrt(finalerror / nvis);

			if (finalerror < 1000 && nvalid >= 2)
			{
				for (int ii = 0; ii < nvis; ii++)
				{
					cid = CamID[kk + pid*MaxnFrames][ii], fid = RealframeID[kk + pid*MaxnFrames][ii];
					fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", P3d.x, P3d.y, P3d.z, (GTFrameOffset[cid] + fid)*ialpha[0] * Tscale[0], SelectedCams[cid], fid);
				}

				for (int ii = 0; ii < nvis && CleanCorrespondencesByTriangulationTest; ii++)
				{
					cid = CamID[kk + pid*MaxnFrames][ii], fid = RealframeID[kk + pid*MaxnFrames][ii];
					CleanFrameSynID[cid*npts + pid].push_back(fid);
					CleanedFrameSyncedPoints[cid*npts + pid].push_back(FrameSyncedPoints[kk + pid*MaxnFrames][ii]);
				}
			}
			else
				int a = 0;
		}
		if (fp != NULL)
			fclose(fp);
	}


	for (int ii = 0; ii < nCams &&CleanCorrespondencesByTriangulationTest; ii++)
	{
		sprintf(Fname, "%s/Track2D/C_%d_%d.txt", Path, SelectedCams[ii], startFrame);	FILE *fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			if (CleanedFrameSyncedPoints[ii*npts + jj].size() < 20)
				continue;
			fprintf(fp, "%d %d ", jj, CleanedFrameSyncedPoints[ii*npts + jj].size());
			for (int kk = 0; kk < CleanedFrameSyncedPoints[ii*npts + jj].size(); kk++)
				fprintf(fp, "%d %.4f %.4f ", CleanFrameSynID[ii*npts + jj][kk], CleanedFrameSyncedPoints[ii*npts + jj][kk].x, CleanedFrameSyncedPoints[ii*npts + jj][kk].y);
			fprintf(fp, "\n");
		}
		fclose(fp);
	}

	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	if (createdMem)
		delete[]CleanFrameSynID, delete[]CleanedFrameSyncedPoints;

	return 0;
}
int ReconAndClassifyPointsFromTriangulation(char *Path, vector<int> &SelectedCams, int npts, vector<int> &FrameOffset, int startFrame, int stopFrame, int realStartFrame, int nViewPlus, double TriangThesh, double ZNCCThresh, double stationaryThesh) //3cm
{
	int nCams = (int)SelectedCams.size();

	char Fname[512];
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
	{
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;
	}

	vector<int> *RealframeID = new vector<int>[MaxnFrames*npts];
	vector<int> *CamID = new vector<int>[MaxnFrames*npts];
	vector<Point2d> *FrameSyncedPoints = new vector<Point2d>[MaxnFrames*npts];
	vector<Pmat> *Pmatrix = new vector<Pmat>[MaxnFrames*npts];

	Pmat Pm;
	Point2d uv;
	int pid, cid, fid, nf;
	for (int cid = 0; cid < nCams; cid++)
	{
		if (realStartFrame == -1)
			realStartFrame = startFrame;
		sprintf(Fname, "%s/Track2D/%d_%d.txt", Path, SelectedCams[cid], realStartFrame);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int previousPid = 0;
		while (fscanf(fp, "%d %d ", &pid, &nf) != EOF)
		{
			for (int kk = 0; kk < nf; kk++)
			{
				fscanf(fp, "%d %lf %lf ", &fid, &uv.x, &uv.y);
				if (fid<0 || fid>MaxnFrames || !VideoInfo[cid].VideoInfo[fid].valid)
					continue;
				LensCorrectionPoint(&uv, VideoInfo[cid].VideoInfo[fid].K, VideoInfo[cid].VideoInfo[fid].distortion);

				if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 0)
				{
					for (int ll = 0; ll < 12; ll++)
						Pm.P[ll] = VideoInfo[cid].VideoInfo[fid].P[ll];
				}
				else if (VideoInfo[cid].VideoInfo[fid].ShutterModel == 1)
				{
					double *K = VideoInfo[cid].VideoInfo[fid].K;
					double ycn = (uv.y - K[5]) / K[4];
					double xcn = (uv.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[cid].VideoInfo[fid].wt;
					double *Rcenter = VideoInfo[cid].VideoInfo[fid].R;
					double *Tcenter = VideoInfo[cid].VideoInfo[fid].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, Pm.P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				int fake_fid = fid - FrameOffset[cid]; //fake the order, associated with the ref camera
				if (fake_fid<0 || fake_fid>MaxnFrames)
					continue;

				CamID[fake_fid + pid*MaxnFrames].push_back(cid);
				RealframeID[fake_fid + pid*MaxnFrames].push_back(fid);
				FrameSyncedPoints[fake_fid + pid*MaxnFrames].push_back(uv);
				Pmatrix[fake_fid + pid*MaxnFrames].push_back(Pm);
			}
		}
		fclose(fp);
	}

	Point3d P3d;
	Point2d *pts = new Point2d[nCams * 2], *ppts = new Point2d[nCams * 2];
	double *A = new double[6 * nCams * 2], *B = new double[2 * nCams * 2];
	double *P = new double[12 * nCams * 2], *tP = new double[12 * nCams * 2];
	bool *passed = new bool[nCams * 2];
	vector<int>Inliers[1];  Inliers[0].reserve(nCams * 2);

	vector<Point3d> valid3D;
	vector<int> valid3DFid; //time associate with 3D trajectory
	vector<int> *traject3DFid = new vector<int>[npts];
	vector<Point3d> *traject3D = new vector<Point3d>[npts];

	vector<int> *validFrames = new vector<int>[stopFrame - startFrame + 1],
		*validViews = new vector<int>[stopFrame - startFrame + 1];
	vector<Point2d> *validUV = new vector<Point2d>[stopFrame - startFrame + 1];

	vector<int> *DynamicFeatureFid = new vector<int>[nCams*npts];
	vector<Point2d> *DynamicFeatureUV = new vector<Point2d>[nCams*npts];

	LKParameters LKArg;
	LKArg.hsubset = 8, LKArg.nscales = 1, LKArg.scaleStep = 5, LKArg.DisplacementThresh = 1, LKArg.DIC_Algo = 8, LKArg.InterpAlgo = 1, LKArg.EpipEnforce = 0;
	LKArg.Incomplete_Subset_Handling = 0, LKArg.Convergence_Criteria = 0, LKArg.Analysis_Speed = 0, LKArg.IterMax = 15;
	LKArg.PSSDab_thresh = 0.025, LKArg.ZNCCThreshold = 0.8, LKArg.Gsigma = 1.0, LKArg.ssigThresh = 30.0;

	Mat *Img = new Mat[nCams];
	vector<double *> ImgPara(nCams);
	double *Timg = new double[(2 * LKArg.hsubset + 1)*(2 * LKArg.hsubset + 1)];
	double *CorrelBuf = new double[6 * (2 * LKArg.hsubset + 1)*(2 * LKArg.hsubset + 1)];

	for (int pid = 0; pid < npts; pid++)
	{
		valid3D.clear(), valid3DFid.clear();
		for (int kk = 0; kk <= stopFrame - startFrame; kk++)
		{
			validFrames[kk].clear(), validViews[kk].clear(), validUV[kk].clear(), Inliers[0].clear();
			int nvis = FrameSyncedPoints[kk + pid*MaxnFrames].size();
			if (nvis < nViewPlus)
				continue;

			//Load images incase need to do zncc
			for (int ii = 0; ii < nCams; ii++)
			{
				sprintf(Fname, "%s/%d/%d.png", Path, ii, kk + FrameOffset[ii]); Img[ii] = imread(Fname, 0);
				if (Img[ii].empty())
					printf("Warning: %d/%d.png is not available\n", ii, kk + FrameOffset[ii]);
				else
				{
					if (ImgPara[ii] == NULL)
						ImgPara[ii] = new double[Img[ii].cols* Img[ii].rows];
					Generate_Para_Spline(Img[ii].data, ImgPara[ii], Img[ii].cols, Img[ii].rows, 1);
				}
			}

			if (nvis >= 2 * nViewPlus)
			{
				vector<int> cameraID, frameID;
				for (int ii = 0; ii < nvis; ii++)
				{
					cameraID.push_back(CamID[kk + pid*MaxnFrames][ii]);
					frameID.push_back(RealframeID[kk + pid*MaxnFrames][ii]);
					pts[ii] = FrameSyncedPoints[kk + pid*MaxnFrames][ii];

					for (int ll = 0; ll < 12; ll++)
						P[12 * ii + ll] = Pmatrix[kk + pid*MaxnFrames][ii].P[ll];
				}

				double finalerror = NviewTriangulationRANSAC(pts, P, &P3d, passed, Inliers, nvis, 1, 10, 0.5, TriangThesh, A, B, tP);
				if (finalerror < TriangThesh && (int)Inliers[0].size() >= nViewPlus)
				{
					for (int ii = 0; ii < (int)Inliers[0].size(); ii++)
					{
						if (Inliers[0][ii] == 0)
							continue;
						cid = CamID[kk + pid*MaxnFrames][Inliers[0][ii]], fid = RealframeID[kk + pid*MaxnFrames][ii];
						validViews[kk].push_back(cid), validFrames[kk].push_back(fid);
						validUV[kk].push_back(FrameSyncedPoints[kk + pid*MaxnFrames][ii]);
					}
					valid3D.push_back(P3d);
					valid3DFid.push_back(kk);
				}
				else
					break; //failure in triangulation at the earlier frame means completely wrong tracking afterward*/
			}
			else
			{
				//At the risk of being wrong-->need to do zncc (fmat) check
				/*for (int jj = 0; jj < nvis - 1; jj++)
				{
				for (int ii = jj+1; ii < nvis; ii++)
				{
				int cid1 = CamID[kk + pid*MaxnFrames][ii], cid2 = CamID[kk + pid*MaxnFrames][jj];
				ComputeZNCCImagePatch()
				}
				}*/
				double zncc[6 * 6];
				for (int jj = 0; jj < nvis-1; jj++)
				{
					for (int ii = jj+1; ii < nvis; ii++)
					{
						int cid1 = CamID[kk + pid*MaxnFrames][jj], cid2 = CamID[kk + pid*MaxnFrames][ii];
						Point2d pt1 = FrameSyncedPoints[kk + pid*MaxnFrames][jj], pt2 = FrameSyncedPoints[kk + pid*MaxnFrames][ii];
						//zncc[ii - 1] = ComputeZNCCImagePatch(Img[cid1], Img[cid2], pt1, pt2, 8, 1, CorrelBuf);
						zncc[ii + jj*nvis] = 1.0 - TemplateMatching(ImgPara[cid1], ImgPara[cid2], Img[cid1].cols, Img[cid1].rows, Img[cid2].cols, Img[cid2].rows, 1, pt1, pt2, LKArg, false, Timg, CorrelBuf);
						zncc[jj + ii*nvis] = zncc[ii + jj*nvis];
					}
				}
				//Take the one with the largest set of small cost as ref
				int RefCam = 0;
				double OverallCost, BestOverallCost = 9e9;
				for (int jj = 0; jj < nvis; jj++)
				{
					OverallCost = 0.0;
					for (int ii = 0; ii < nvis; ii++)
					{
						if (ii != jj)
							OverallCost += zncc[ii + jj*nvis];
					}
					if (OverallCost < BestOverallCost)
						BestOverallCost = OverallCost, RefCam = jj;
				}

				int availCount = 0;
				vector<int> cameraID, frameID, availID;
				for (int ii = 0; ii < nvis; ii++)
				{
					if (ii != RefCam && zncc[ii + RefCam*nvis] > 1.0-ZNCCThresh)  //remove the bad one according to the selected ref
						continue;

					cameraID.push_back(CamID[kk + pid*MaxnFrames][ii]);
					frameID.push_back(RealframeID[kk + pid*MaxnFrames][ii]);
					pts[availCount] = FrameSyncedPoints[kk + pid*MaxnFrames][ii];
					availID.push_back(ii);

					for (int ll = 0; ll < 12; ll++)
						P[12 * availCount + ll] = Pmatrix[kk + pid*MaxnFrames][ii].P[ll];
					availCount++;
				}

				NviewTriangulation(pts, P, &P3d, availCount, 1, NULL, A, B);
				ProjectandDistort(P3d, ppts, P, NULL, NULL, availCount);

				int nvalid = 0;
				double finalerror = 0.0;
				for (int ll = 0; ll < availCount; ll++)
					finalerror += pow(ppts[ll].x - pts[ll].x, 2) + pow(ppts[ll].y - pts[ll].y, 2), nvalid++;
				finalerror = sqrt(finalerror / nvalid);

				if (finalerror < TriangThesh && nvalid >= nViewPlus)
				{
					for (int ii = 0; ii < availCount; ii++)
					{
						cid = CamID[kk + pid*MaxnFrames][availID[ii]], fid = RealframeID[kk + pid*MaxnFrames][availID[ii]];
						validViews[kk].push_back(cid), validFrames[kk].push_back(fid);
						validUV[kk].push_back(FrameSyncedPoints[kk + pid*MaxnFrames][availID[ii]]);
					}
					valid3D.push_back(P3d);
					valid3DFid.push_back(kk);
				}
				else
					break; //failure in triangulation at the earlier frame means completely wrong tracking afterward
			}
		}

		//Determine if the point is stationary
		if (valid3D.size() > 20)
		{
			Point3d mean3D(0, 0, 0), var3D(0, 0, 0);
			for (int ii = 0; ii < valid3D.size(); ii++)
				mean3D.x += valid3D[ii].x, mean3D.y += valid3D[ii].y, mean3D.z += valid3D[ii].z;
			mean3D.x = mean3D.x / (int)valid3D.size(), mean3D.y = mean3D.y / (int)valid3D.size(), mean3D.z = mean3D.z / (int)valid3D.size();

			for (int ii = 0; ii < valid3D.size(); ii++)
				var3D.x += pow(valid3D[ii].x - mean3D.x, 2), var3D.y += pow(valid3D[ii].y - mean3D.y, 2), var3D.z += pow(valid3D[ii].z - mean3D.z, 2);
			var3D.x = var3D.x / (int)valid3D.size(), var3D.y = var3D.y / (int)valid3D.size(), var3D.z = var3D.z / (int)valid3D.size();

			if (var3D.x + var3D.y + var3D.z > stationaryThesh)
			{
				for (int jj = 0; jj < (int)valid3D.size(); jj++)
				{
					for (int ii = 0; ii < (int)validViews[jj].size(); ii++)
					{
						cid = validViews[jj][ii], fid = validFrames[jj][ii], uv = validUV[jj][ii];
						LensDistortionPoint(&uv, VideoInfo[cid].VideoInfo[fid].K, VideoInfo[cid].VideoInfo[fid].distortion);

						DynamicFeatureFid[cid*npts + pid].push_back(fid);
						DynamicFeatureUV[cid*npts + pid].push_back(uv);
					}
				}
				traject3D[pid] = valid3D;
				traject3DFid[pid] = valid3DFid;
			}
		}
	}

	sprintf(Fname, "%s/Track3D", Path); makeDir(Fname);
	sprintf(Fname, "%s/Track3D/DynamicFeatures_%d.txt", Path, realStartFrame);  FILE *fp = fopen(Fname, "w+");
	for (int ii = 0; ii < npts; ii++)
	{
		if (traject3D[ii].size() > 20)
		{
			fprintf(fp, "%d %d ", ii, traject3D[ii].size());
			for (int jj = 0; jj < traject3D[ii].size(); jj++)
				fprintf(fp, "%d % .3f %.3f %.3f ", traject3DFid[ii][jj], traject3D[ii][jj].x, traject3D[ii][jj].y, traject3D[ii][jj].z);
			fprintf(fp, "\n");
		}
	}
	fclose(fp);

	for (int cid = 0; cid < nCams; cid++)
	{
		sprintf(Fname, "%s/Track2D/C_%d_%d.txt", Path, SelectedCams[cid], realStartFrame);	FILE *fp = fopen(Fname, "w+");
		fprintf(fp, "%d \n", npts);
		for (int pid = 0; pid < npts; pid++)
		{
			if (DynamicFeatureUV[cid*npts + pid].size() > 20)
			{
				fprintf(fp, "%d %d ", pid, DynamicFeatureUV[cid*npts + pid].size());
				for (int kk = 0; kk < DynamicFeatureUV[cid*npts + pid].size(); kk++)
					fprintf(fp, "%d %.4f %.4f ", DynamicFeatureFid[cid*npts + pid][kk], DynamicFeatureUV[cid*npts + pid][kk].x, DynamicFeatureUV[cid*npts + pid][kk].y);
				fprintf(fp, "\n");
			}
		}
		fclose(fp);
	}

	delete[]A, delete[]B, delete[]P, delete[]tP, delete[]passed;
	delete[]DynamicFeatureFid, delete[]DynamicFeatureUV;
	delete[]traject3DFid, delete[]traject3D, delete[]validFrames, delete[]validViews, delete[]validUV;
	return 0;
}

//Nonlinear Optimization for Temporal Alignement using BA geometric constraint
struct TemporalOptimInterpStationaryCameraCeres {
	TemporalOptimInterpStationaryCameraCeres(double *Pin, double *ParaXin, double *ParaYin, int frameIDin, int nframesIn, int interpAlgoIn)
	{
		P = Pin;
		ParaX = ParaXin, ParaY = ParaYin;
		double x = ParaXin[0], y = ParaX[0];
		frameID = frameIDin, nframes = nframesIn, interpAlgo = interpAlgoIn;
	}

	template <typename T>	bool operator()(const T* const XYZ, const T* const F, T* residuals) 	const
	{
		double Fi = F[0] + frameID;
		double Sx[3], Sy[3];
		if (Fi < 0.0)
			Fi = 0.0;
		if (Fi>nframes - 1)
			Fi = nframes - 1;

		double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];
		double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
		double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];

		Get_Value_Spline(ParaX, nframes, 1, Fi, 0, Sx, -1, interpAlgo);
		Get_Value_Spline(ParaY, nframes, 1, Fi, 0, Sy, -1, interpAlgo);

		residuals[0] = numX / denum - Sx[0];
		residuals[1] = numY / denum - Sy[0];


		return true;
	}

	static ceres::CostFunction* Create(double *Pin, double *ParaXin, double *ParaYin, int frameIDin, int nframesIn, int interpAlgoIn)
	{
		return (new ceres::NumericDiffCostFunction<TemporalOptimInterpStationaryCameraCeres, ceres::CENTRAL, 2, 3, 1>(new TemporalOptimInterpStationaryCameraCeres(Pin, ParaXin, ParaYin, frameIDin, nframesIn, interpAlgoIn)));
	}

	int frameID, nframes, interpAlgo;
	double F;
	double *ParaX, *ParaY, *P;
};
struct TemporalOptimInterpMovingCameraCeres {
	TemporalOptimInterpMovingCameraCeres(double *AllPin, double *AllKin, double *AllQin, double *AllRin, double *AllCin, double *ParaCamCenterXIn, double *ParaCamCenterYIn, double *ParaCamCenterZIn, double *ParaXin, double *ParaYin, int frameIDin, int nframesIn, int interpAlgoIn)
	{
		AllP = AllPin, AllK = AllKin, AllQ = AllQin, AllR = AllRin, AllC = AllCin;
		ParaCamCenterX = ParaCamCenterXIn, ParaCamCenterY = ParaCamCenterYIn, ParaCamCenterZ = ParaCamCenterZIn, ParaX = ParaXin, ParaY = ParaYin;
		frameID = frameIDin, nframes = nframesIn, interpAlgo = interpAlgoIn;
	}

	template <typename T>	bool operator()(const T* const XYZ, const T* const F, T* residuals) 	const
	{
		double Fi = F[0] + frameID;
		if (Fi < 0.0)
			Fi = 0.0;
		if (Fi>nframes - 2)
			Fi = nframes - 2;
		int lFi = (int)Fi, uFi = lFi + 1;
		double fFi = Fi - lFi;

		if (lFi < 0)
		{
			residuals[0] = 0.0;
			residuals[1] = 0.0;
			return true;
		}
		else if (uFi > nframes - 2)
		{
			residuals[0] = 0.0;
			residuals[1] = 0.0;
			return true;
		}

		double K[9], C[3], R[9], RT[12], P[12], Q[4];
		for (int ll = 0; ll < 9; ll++)
			K[ll] = AllK[9 * lFi + ll];

		for (int ll = 0; ll < 3; ll++)
			C[ll] = (1.0 - fFi)*AllC[3 * lFi + ll] + fFi*AllC[3 * uFi + ll]; //linear interpolation
		//Get_Value_Spline(ParaCamCenterX, nframes, 1, Fi, 0, &C[0], -1, interpAlgo);
		//Get_Value_Spline(ParaCamCenterY, nframes, 1, Fi, 0, &C[1], -1, interpAlgo);
		//Get_Value_Spline(ParaCamCenterZ, nframes, 1, Fi, 0, &C[2], -1, interpAlgo);

		for (int ll = 0; ll < 4; ll++)
			Q[ll] = AllQ[4 * lFi + ll];
		//QuaternionLinearInterp(&AllQ[4 * lFi], &AllQ[4 * uFi], Q, fFi);//linear interpolation

		/*//Give good result given 1frame offset--> strange so I use rigorous interplation instead
		lFi = (int)(Fi + 0.5);
		for (int ll = 0; ll < 3; ll++)
		C[ll] = AllC[3 * lFi + ll];
		for (int ll = 0; ll < 4; ll++)
		Q[ll] = AllQ[4 * lFi + ll];*/

		Quaternion2Rotation(Q, R);
		AssembleRT(R, C, RT, true);
		AssembleP(K, RT, P);

		double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
		double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];
		double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];

		double Sx[3], Sy[3];
		Get_Value_Spline(ParaX, nframes, 1, Fi, 0, Sx, -1, interpAlgo);
		Get_Value_Spline(ParaY, nframes, 1, Fi, 0, Sy, -1, interpAlgo);

		residuals[0] = numX / denum - Sx[0];
		residuals[1] = numY / denum - Sy[0];
		if (abs(residuals[0]) > 5 || abs(residuals[1]) > 5)
			int a = 0;
		return true;
	}

	// Factory to hide the construction of the CostFunction object from the client code.
	static ceres::CostFunction* Create(double *AllPin, double *AllKin, double *AllQin, double *AllRin, double *AllCin, double *ParaCamCenterXIn, double *ParaCamCenterYin, double *ParaCamCenterZin, double *ParaXin, double *ParaYin, int frameIDin, int nframesIn, int interpAlgoIn)
	{
		return (new ceres::NumericDiffCostFunction<TemporalOptimInterpMovingCameraCeres, ceres::CENTRAL, 2, 3, 1>(new TemporalOptimInterpMovingCameraCeres(AllPin, AllKin, AllQin, AllRin, AllCin, ParaCamCenterXIn, ParaCamCenterYin, ParaCamCenterZin, ParaXin, ParaYin, frameIDin, nframesIn, interpAlgoIn)));
	}

	int frameID, nframes, interpAlgo;
	double F;
	double *ParaCamCenterX, *ParaCamCenterY, *ParaCamCenterZ, *ParaX, *ParaY;
	double *AllP, *AllK, *AllQ, *AllR, *AllC;
};
int TemporalOptimInterp()
{
	const int nCams = 3, npts = 4;
	PerCamNonRigidTrajectory CamTraj[nCams];

	//PrepareTrajectoryInfo(CamTraj, nCams, npts);

	//Interpolate the trajectory of 2d tracks
	int maxPts = 0;
	for (int ii = 0; ii < npts; ii++)
	{
		for (int jj = 0; jj < nCams; jj++)
		{
			int npts = 0;
			for (int kk = 0; kk < CamTraj[jj].Track3DInfo[ii].nf; kk++)
				npts++;
			if (npts > maxPts)
				maxPts = npts;
		}
	}

	int InterpAlgo = 1;
	double *x = new double[maxPts], *y = new double[maxPts];
	double* AllQuaternion = new double[4 * nCams*maxPts];
	double* AllRotationMat = new double[9 * nCams*maxPts];
	double* AllCamCenter = new double[3 * nCams*maxPts];
	double *AllKMatrix = new double[9 * nCams*maxPts];
	double *AllPMatrix = new double[12 * nCams*maxPts];

	double *z = new double[maxPts];
	double *ParaCamCenterX = new double[nCams*maxPts];
	double *ParaCamCenterY = new double[nCams*maxPts];
	double *ParaCamCenterZ = new double[nCams*maxPts];
	for (int jj = 0; jj < nCams; jj++)
	{
		for (int ii = 0; ii < CamTraj[jj].npts; ii++)
		{
			int nf = CamTraj[jj].Track3DInfo[ii].nf;
			CamTraj[jj].Track2DInfo[ii].ParaX = new double[nf];
			CamTraj[jj].Track2DInfo[ii].ParaY = new double[nf];

			for (int kk = 0; kk < nf; kk++)
				x[kk] = CamTraj[jj].Track2DInfo[ii].uv[kk].x, y[kk] = CamTraj[jj].Track2DInfo[ii].uv[kk].y;
			Generate_Para_Spline(x, CamTraj[jj].Track2DInfo[ii].ParaX, nf, 1, InterpAlgo);
			Generate_Para_Spline(y, CamTraj[jj].Track2DInfo[ii].ParaY, nf, 1, InterpAlgo);
		}
		for (int ii = 0; ii < maxPts; ii++)
		{
			if (ii >= CamTraj[jj].R.size())
				continue;
			for (int kk = 0; kk < 9; kk++)
				AllKMatrix[9 * jj * maxPts + 9 * ii + kk] = CamTraj[jj].K[ii].K[kk];
			for (int kk = 0; kk < 3; kk++)
				AllCamCenter[3 * jj * maxPts + 3 * ii + kk] = CamTraj[jj].C[ii].C[kk];
			for (int kk = 0; kk < 9; kk++)
				AllRotationMat[9 * jj * maxPts + 9 * ii + kk] = CamTraj[jj].R[ii].R[kk];
			for (int kk = 0; kk < 4; kk++)
				AllQuaternion[4 * jj * maxPts + 4 * ii + kk] = CamTraj[jj].Q[ii].quad[kk];
			for (int kk = 0; kk < 12; kk++)
				AllPMatrix[12 * jj * maxPts + 12 * ii + kk] = CamTraj[jj].P[ii].P[kk];
		}

		for (int ii = 0; ii < maxPts; ii++)
		{
			if (ii >= CamTraj[jj].R.size())
				continue;
			x[ii] = AllCamCenter[3 * jj * maxPts + 3 * ii];
			y[ii] = AllCamCenter[3 * jj * maxPts + 3 * ii + 1];
			z[ii] = AllCamCenter[3 * jj * maxPts + 3 * ii + 2];
		}
		Generate_Para_Spline(x, ParaCamCenterX + jj*maxPts, maxPts, 1, InterpAlgo);
		Generate_Para_Spline(y, ParaCamCenterY + jj*maxPts, maxPts, 1, InterpAlgo);
		Generate_Para_Spline(z, ParaCamCenterZ + jj*maxPts, maxPts, 1, InterpAlgo);
	}
	delete[]x, delete[]y;
	delete[]z;

	//Initialize temporal info
	for (int ii = 0; ii < nCams; ii++)
		CamTraj[ii].F = round(10.0*(1.0*rand() / RAND_MAX - 0.5));
	CamTraj[0].F = 0, CamTraj[1].F = -3.0, CamTraj[2].F = 2.0;

	printf("Inital offset: ");
	for (int ii = 0; ii < nCams; ii++)
		printf("%f ", CamTraj[ii].F);
	printf("\n");


	ceres::Problem problem;
	double Error = 0.0;
	for (int ii = 0; ii < npts; ii++)
	{
		//find maxnf
		int maxnf = 0, maxCam = 0;
		for (int jj = 0; jj < nCams; jj++)
			if (maxnf < CamTraj[jj].Track3DInfo[ii].nf)
				maxnf = CamTraj[jj].Track3DInfo[ii].nf, maxCam = jj;

		for (int kk = 0; kk < maxnf; kk++)
		{
			for (int jj = 0; jj < nCams; jj++)
			{
				if (kk>CamTraj[jj].Track3DInfo[ii].nf || kk >= CamTraj[jj].R.size())
					continue;

				double Fi = CamTraj[jj].F + kk;
				if (Fi < 0.0)
					Fi = 0.0;
				if (Fi>CamTraj[jj].Track3DInfo[ii].nf - 2)
					Fi = CamTraj[jj].Track3DInfo[ii].nf - 2;
				int lFi = (int)Fi, uFi = lFi + 1, rFi = (int)(Fi + 0.5);
				double fFi = Fi - lFi;

				double K[9], C[3], Q[4], R[9], RT[12], P[12];
				for (int ll = 0; ll < 9; ll++)
					K[ll] = AllKMatrix[9 * jj*maxPts + 9 * lFi + ll];
				for (int ll = 0; ll < 3; ll++)
					C[ll] = (1.0 - fFi)*AllCamCenter[3 * jj*maxPts + 3 * lFi + ll] + fFi*AllCamCenter[3 * jj*maxPts + 3 * uFi + ll]; //linear interpolation

				for (int ll = 0; ll < 4; ll++)
					Q[ll] = AllQuaternion[4 * jj*maxPts + 4 * lFi + ll];

				//QuaternionLinearInterp(&AllQuaternion[4 * jj*maxPts + 4 * lFi], &AllQuaternion[4 * jj*maxPts + 4 * uFi], Q, fFi);//linear interpolation
				//Get_Value_Spline(ParaCamCenterX + jj*maxPts, maxPts, 1, Fi, 0, &C[0], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterY + jj*maxPts, maxPts, 1, Fi, 0, &C[1], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterZ + jj*maxPts, maxPts, 1, Fi, 0, &C[2], -1, InterpAlgo);

				Quaternion2Rotation(Q, R);
				AssembleRT(R, C, RT, true);
				AssembleP(K, RT, P);

				double XYZ[] = { CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2] };
				double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];
				double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
				double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];

				double Sx, Sy;
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sx, -1, InterpAlgo);
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaY, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sy, -1, InterpAlgo);

				double residualsX = numX / denum - Sx;
				double residualsY = numY / denum - Sy;
				double Residual = residualsX*residualsX + residualsY*residualsY;
				Error += Residual;

				//ceres::CostFunction* cost_function = TemporalOptimInterpStationaryCameraCeres::Create(CamTraj[jj].P[kk].P, CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track2DInfo[ii].ParaY, kk, CamTraj[jj].Track3DInfo[ii].npts, InterpAlgo);
				ceres::CostFunction* cost_function = TemporalOptimInterpMovingCameraCeres::Create(&AllPMatrix[12 * jj*maxPts], &AllKMatrix[9 * jj*maxPts], &AllQuaternion[4 * jj*maxPts], &AllRotationMat[9 * jj*maxPts], &AllCamCenter[3 * jj*maxPts],
					ParaCamCenterX + jj*maxPts, ParaCamCenterY + jj*maxPts, ParaCamCenterZ + jj*maxPts, CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track2DInfo[ii].ParaY, kk, CamTraj[jj].Track3DInfo[ii].nf, InterpAlgo);
				problem.AddResidualBlock(cost_function, NULL, CamTraj[maxCam].Track3DInfo[ii].xyz + 3 * kk, &CamTraj[jj].F);
			}
		}
	}
	printf("Initial error: %.6e\n", Error);

	//printf("Setting fixed parameters...\n");
	problem.SetParameterBlockConstant(&CamTraj[0].F);

	//printf("Running optim..\n");
	ceres::Solver::Options options;
	options.num_threads = 4;
	options.max_num_iterations = 50;
	options.linear_solver_type = ceres::DENSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::DOGLEG;
	options.use_nonmonotonic_steps = true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	Error = 0.0;
	FILE *fp = fopen("C:/temp/Sim/Results.txt", "w+");
	fprintf(fp, "Temporal alignment (ms): ");
	for (int ii = 0; ii < nCams; ii++)
		fprintf(fp, "%f ", CamTraj[ii].F);
	fprintf(fp, "\n");
	for (int ii = 0; ii < npts; ii++)
	{
		//find maxnf
		int maxnf = 0, maxCam = 0;
		for (int jj = 0; jj < nCams; jj++)
			if (maxnf < CamTraj[jj].Track3DInfo[ii].nf)
				maxnf = CamTraj[jj].Track3DInfo[ii].nf, maxCam = jj;

		fprintf(fp, "3D track %d \n", ii);
		for (int kk = 0; kk < maxnf; kk++)
		{
			for (int jj = 0; jj < nCams; jj++)
			{
				if (kk>CamTraj[jj].Track3DInfo[ii].nf || kk >= CamTraj[jj].R.size())
					continue;

				double Fi = CamTraj[jj].F + kk;
				if (Fi < 0.0)
					Fi = 0.0;
				if (Fi>CamTraj[jj].Track3DInfo[ii].nf - 2)
					Fi = CamTraj[jj].Track3DInfo[ii].nf - 2;
				int lFi = (int)Fi, uFi = lFi + 1, rFi = (int)(Fi + 0.5);
				double fFi = Fi - lFi;

				double K[9], C[3], Q[4], R[9], RT[12], P[12];
				for (int ll = 0; ll < 9; ll++)
					K[ll] = AllKMatrix[9 * jj*maxPts + 9 * lFi + ll];
				for (int ll = 0; ll < 3; ll++)
					C[ll] = (1.0 - fFi)*AllCamCenter[3 * jj*maxPts + 3 * lFi + ll] + fFi*AllCamCenter[3 * jj*maxPts + 3 * uFi + ll]; //linear interpolation

				for (int ll = 0; ll < 4; ll++)
					Q[ll] = AllQuaternion[4 * jj*maxPts + 4 * lFi + ll];
				//QuaternionLinearInterp(&AllQuaternion[4 * jj*maxPts + 4 * lFi], &AllQuaternion[4 * jj*maxPts + 4 * uFi], Q, fFi);//linear interpolation
				//Get_Value_Spline(ParaCamCenterX + jj*maxPts, maxPts, 1, Fi, 0, &C[0], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterY + jj*maxPts, maxPts, 1, Fi, 0, &C[1], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterZ + jj*maxPts, maxPts, 1, Fi, 0, &C[2], -1, InterpAlgo);

				Quaternion2Rotation(Q, R);
				AssembleRT(R, C, RT, true);
				AssembleP(K, RT, P);

				double XYZ[] = { CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2] };
				double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];
				double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
				double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];

				double Sx, Sy;
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sx, -1, InterpAlgo);
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaY, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sy, -1, InterpAlgo);

				double residualsX = numX / denum - Sx;
				double residualsY = numY / denum - Sy;
				double Residual = residualsX*residualsX + residualsY*residualsY;
				Error += Residual;

				if (jj == 0)
					fprintf(fp, "%.4f %.4f %.4f ", CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2]);
			}
		}
		fprintf(fp, "\n");
	}
	printf("Final error: %.6e\n", Error);
	printf("Final offset: ");
	for (int ii = 0; ii < nCams; ii++)
		printf("%f ", CamTraj[ii].F);
	printf("\n");

	//printf("Write results ....\n");
	//WriteTrajectory(CamTraj, nCams, npts, 1.0);
	delete[]AllRotationMat, delete[]AllPMatrix, delete[]AllKMatrix, delete[]AllQuaternion, delete[]AllCamCenter;
	delete[]ParaCamCenterX, delete[]ParaCamCenterY, delete[]ParaCamCenterZ;

	return 0;
}
int TemporalOptimInterpNew(char *Path, double *Offset)
{
	const int nCams = 3, npts = 4, startF = 0, stopF = 150;

	VideoData *VideoInfo = new VideoData[nCams];
	PerCamNonRigidTrajectory CamTraj[nCams];
	PrepareTrajectoryInfo(Path, VideoInfo, CamTraj, Offset, nCams, npts, startF, stopF);

	//Initialize temporal info
	for (int ii = 0; ii < nCams; ii++)
		CamTraj[ii].F = Offset[ii];

	int InterpAlgo = 1;
	double *x = new double[stopF], *y = new double[stopF], *z = new double[stopF];
	double* AllQuaternion = new double[4 * nCams*stopF], *AllRotationMat = new double[9 * nCams*stopF], *AllCamCenter = new double[3 * nCams*stopF];
	double *AllKMatrix = new double[9 * nCams*stopF], *AllPMatrix = new double[12 * nCams*stopF];
	double *ParaCamCenterX = new double[nCams*stopF], *ParaCamCenterY = new double[nCams*stopF], *ParaCamCenterZ = new double[nCams*stopF];

	for (int jj = 0; jj < nCams; jj++)
	{
		//Interpolate the trajectory of 2d tracks
		for (int ii = 0; ii < CamTraj[jj].npts; ii++)
		{
			int nf = CamTraj[jj].Track3DInfo[ii].nf;
			CamTraj[jj].Track2DInfo[ii].ParaX = new double[nf];
			CamTraj[jj].Track2DInfo[ii].ParaY = new double[nf];

			for (int kk = 0; kk < nf; kk++)
				x[kk] = CamTraj[jj].Track2DInfo[ii].uv[kk].x, y[kk] = CamTraj[jj].Track2DInfo[ii].uv[kk].y;
			Generate_Para_Spline(x, CamTraj[jj].Track2DInfo[ii].ParaX, nf, 1, InterpAlgo);
			Generate_Para_Spline(y, CamTraj[jj].Track2DInfo[ii].ParaY, nf, 1, InterpAlgo);
		}

		for (int ii = 0; ii < stopF; ii++)
		{
			if (ii >= CamTraj[jj].R.size())
				continue;
			for (int kk = 0; kk < 9; kk++)
				AllKMatrix[9 * jj * stopF + 9 * ii + kk] = CamTraj[jj].K[ii].K[kk];
			for (int kk = 0; kk < 3; kk++)
				AllCamCenter[3 * jj * stopF + 3 * ii + kk] = CamTraj[jj].C[ii].C[kk];
			for (int kk = 0; kk < 9; kk++)
				AllRotationMat[9 * jj * stopF + 9 * ii + kk] = CamTraj[jj].R[ii].R[kk];
			for (int kk = 0; kk < 4; kk++)
				AllQuaternion[4 * jj * stopF + 4 * ii + kk] = CamTraj[jj].Q[ii].quad[kk];
			for (int kk = 0; kk < 12; kk++)
				AllPMatrix[12 * jj * stopF + 12 * ii + kk] = CamTraj[jj].P[ii].P[kk];
		}

		for (int ii = 0; ii < stopF; ii++)
		{
			if (ii >= CamTraj[jj].R.size())
				continue;
			x[ii] = AllCamCenter[3 * jj * stopF + 3 * ii];
			y[ii] = AllCamCenter[3 * jj * stopF + 3 * ii + 1];
			z[ii] = AllCamCenter[3 * jj * stopF + 3 * ii + 2];
		}
		Generate_Para_Spline(x, ParaCamCenterX + jj*stopF, stopF, 1, InterpAlgo);
		Generate_Para_Spline(y, ParaCamCenterY + jj*stopF, stopF, 1, InterpAlgo);
		Generate_Para_Spline(z, ParaCamCenterZ + jj*stopF, stopF, 1, InterpAlgo);
	}
	delete[]x, delete[]y, delete[]z;

	printf("Inital offset: ");
	for (int ii = 0; ii < nCams; ii++)
		printf("%f ", CamTraj[ii].F);
	printf("\n");


	ceres::Problem problem;
	double Error = 0.0;
	for (int ii = 0; ii < npts; ii++)
	{
		//find maxtracks
		int maxTracks = 0, maxCam = 0;
		for (int jj = 0; jj < nCams; jj++)
			if (maxTracks < CamTraj[jj].Track3DInfo[ii].nf)
				maxTracks = CamTraj[jj].Track3DInfo[ii].nf, maxCam = jj;

		for (int kk = 0; kk < maxTracks; kk++)
		{
			for (int jj = 0; jj < nCams; jj++)
			{
				if (kk>CamTraj[jj].Track3DInfo[ii].nf || kk >= CamTraj[jj].R.size())
					continue;

				double Fi = CamTraj[jj].F + kk;
				if (Fi < 0.0)
					Fi = 0.0;
				if (Fi>CamTraj[jj].Track3DInfo[ii].nf - 2)
					Fi = CamTraj[jj].Track3DInfo[ii].nf - 2;
				int lFi = (int)Fi, uFi = lFi + 1, rFi = (int)(Fi + 0.5);
				double fFi = Fi - lFi;

				double K[9], C[3], Q[4], R[9], RT[12], P[12];
				for (int ll = 0; ll < 9; ll++)
					K[ll] = AllKMatrix[9 * jj*stopF + 9 * lFi + ll];
				for (int ll = 0; ll < 3; ll++)
					C[ll] = (1.0 - fFi)*AllCamCenter[3 * jj*stopF + 3 * lFi + ll] + fFi*AllCamCenter[3 * jj*stopF + 3 * uFi + ll]; //linear interpolation

				for (int ll = 0; ll < 4; ll++)
					Q[ll] = AllQuaternion[4 * jj*stopF + 4 * lFi + ll];

				//QuaternionLinearInterp(&AllQuaternion[4 * jj*stopF + 4 * lFi], &AllQuaternion[4 * jj*stopF + 4 * uFi], Q, fFi);//linear interpolation
				//Get_Value_Spline(ParaCamCenterX + jj*stopF, stopF, 1, Fi, 0, &C[0], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterY + jj*stopF, stopF, 1, Fi, 0, &C[1], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterZ + jj*stopF, stopF, 1, Fi, 0, &C[2], -1, InterpAlgo);

				Quaternion2Rotation(Q, R);
				AssembleRT(R, C, RT, true);
				AssembleP(K, RT, P);

				double XYZ[] = { CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2] };
				double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];
				double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
				double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];

				double Sx, Sy;
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sx, -1, InterpAlgo);
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaY, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sy, -1, InterpAlgo);

				double residualsX = numX / denum - Sx;
				double residualsY = numY / denum - Sy;
				double Residual = residualsX*residualsX + residualsY*residualsY;
				Error += Residual;

				//ceres::CostFunction* cost_function = TemporalOptimInterpStationaryCameraCeres::Create(CamTraj[jj].P[kk].P, CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track2DInfo[ii].ParaY, kk, CamTraj[jj].Track3DInfo[ii].nf, InterpAlgo);
				ceres::CostFunction* cost_function = TemporalOptimInterpMovingCameraCeres::Create(&AllPMatrix[12 * jj*stopF], &AllKMatrix[9 * jj*stopF], &AllQuaternion[4 * jj*stopF], &AllRotationMat[9 * jj*stopF], &AllCamCenter[3 * jj*stopF],
					ParaCamCenterX + jj*stopF, ParaCamCenterY + jj*stopF, ParaCamCenterZ + jj*stopF, CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track2DInfo[ii].ParaY, kk, CamTraj[jj].Track3DInfo[ii].nf, InterpAlgo);
				problem.AddResidualBlock(cost_function, NULL, CamTraj[maxCam].Track3DInfo[ii].xyz + 3 * kk, &CamTraj[jj].F);
			}
		}
	}
	printf("Initial error: %.6e\n", Error);

	//printf("Setting fixed parameters...\n");
	problem.SetParameterBlockConstant(&CamTraj[0].F);

	//printf("Running optim..\n");
	ceres::Solver::Options options;
	options.num_threads = 4;
	options.max_num_iterations = 50;
	options.linear_solver_type = ceres::DENSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::DOGLEG;
	options.use_nonmonotonic_steps = true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	Error = 0.0;
	FILE *fp = fopen("C:/temp/Sim/Results.txt", "w+");
	fprintf(fp, "Temporal alignment (ms): ");
	for (int ii = 0; ii < nCams; ii++)
		fprintf(fp, "%f ", CamTraj[ii].F);
	fprintf(fp, "\n");
	for (int ii = 0; ii < npts; ii++)
	{
		//find maxtracks
		int maxTracks = 0, maxCam = 0;
		for (int jj = 0; jj < nCams; jj++)
			if (maxTracks < CamTraj[jj].Track3DInfo[ii].nf)
				maxTracks = CamTraj[jj].Track3DInfo[ii].nf, maxCam = jj;

		fprintf(fp, "3D track %d \n", ii);
		for (int kk = 0; kk < maxTracks; kk++)
		{
			for (int jj = 0; jj < nCams; jj++)
			{
				if (kk>CamTraj[jj].Track3DInfo[ii].nf || kk >= CamTraj[jj].R.size())
					continue;

				double Fi = CamTraj[jj].F + kk;
				if (Fi < 0.0)
					Fi = 0.0;
				if (Fi>CamTraj[jj].Track3DInfo[ii].nf - 2)
					Fi = CamTraj[jj].Track3DInfo[ii].nf - 2;
				int lFi = (int)Fi, uFi = lFi + 1, rFi = (int)(Fi + 0.5);
				double fFi = Fi - lFi;

				double K[9], C[3], Q[4], R[9], RT[12], P[12];
				for (int ll = 0; ll < 9; ll++)
					K[ll] = AllKMatrix[9 * jj*stopF + 9 * lFi + ll];
				for (int ll = 0; ll < 3; ll++)
					C[ll] = (1.0 - fFi)*AllCamCenter[3 * jj*stopF + 3 * lFi + ll] + fFi*AllCamCenter[3 * jj*stopF + 3 * uFi + ll]; //linear interpolation

				for (int ll = 0; ll < 4; ll++)
					Q[ll] = AllQuaternion[4 * jj*stopF + 4 * lFi + ll];
				//QuaternionLinearInterp(&AllQuaternion[4 * jj*stopF + 4 * lFi], &AllQuaternion[4 * jj*stopF + 4 * uFi], Q, fFi);//linear interpolation
				//Get_Value_Spline(ParaCamCenterX + jj*stopF, stopF, 1, Fi, 0, &C[0], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterY + jj*stopF, stopF, 1, Fi, 0, &C[1], -1, InterpAlgo);
				//Get_Value_Spline(ParaCamCenterZ + jj*stopF, stopF, 1, Fi, 0, &C[2], -1, InterpAlgo);

				Quaternion2Rotation(Q, R);
				AssembleRT(R, C, RT, true);
				AssembleP(K, RT, P);

				double XYZ[] = { CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2] };
				double denum = P[8] * XYZ[0] + P[9] * XYZ[1] + P[10] * XYZ[2] + P[11];
				double numX = P[0] * XYZ[0] + P[1] * XYZ[1] + P[2] * XYZ[2] + P[3];
				double numY = P[4] * XYZ[0] + P[5] * XYZ[1] + P[6] * XYZ[2] + P[7];

				double Sx, Sy;
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaX, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sx, -1, InterpAlgo);
				Get_Value_Spline(CamTraj[jj].Track2DInfo[ii].ParaY, CamTraj[jj].Track3DInfo[ii].nf, 1, Fi, 0, &Sy, -1, InterpAlgo);

				double residualsX = numX / denum - Sx;
				double residualsY = numY / denum - Sy;
				double Residual = residualsX*residualsX + residualsY*residualsY;
				Error += Residual;

				if (jj == 0)
					fprintf(fp, "%.4f %.4f %.4f ", CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 1], CamTraj[maxCam].Track3DInfo[ii].xyz[3 * kk + 2]);
			}
		}
		fprintf(fp, "\n");
	}
	printf("Final error: %.6e\n", Error);
	printf("Final offset: ");
	for (int ii = 0; ii < nCams; ii++)
		printf("%f ", CamTraj[ii].F);
	printf("\n");

	//printf("Write results ....\n");
	//WriteTrajectory(CamTraj, nCams, npts, 1.0);
	delete[]AllRotationMat, delete[]AllPMatrix, delete[]AllKMatrix, delete[]AllQuaternion, delete[]AllCamCenter;
	delete[]ParaCamCenterX, delete[]ParaCamCenterY, delete[]ParaCamCenterZ;

	return 0;
}


struct LeastActionCostCeres {
	LeastActionCostCeres(int frameID1, int frameID2, double subf1, double subf2, double ialpha, double Tscale, double epsilon, double lamda, int motionPriorPower) : frameID1(frameID1), frameID2(frameID2), subf1(subf1), subf2(subf2), ialpha(ialpha), Tscale(Tscale), epsilon(epsilon), lamda(lamda), motionPriorPower(motionPriorPower){	}

	template <typename T>	bool operator()(const T* const xyz1, const T* const xyz2, const T* const timeStamp1, const T* const timeStamp2, T* residuals) 	const
	{
		T difX = xyz2[0] - xyz1[0], difY = xyz2[1] - xyz1[1], difZ = xyz2[2] - xyz1[2];
		T  t1 = (T)((timeStamp1[0] + (T)(subf1 + 1.0*frameID1)) * ialpha*Tscale);
		T  t2 = (T)((timeStamp2[0] + (T)(subf2 + 1.0*frameID2)) * ialpha*Tscale);

		T cost;
		if (motionPriorPower == 4)
			cost = pow(difX*difX + difY*difY + difZ*difZ, 2) / abs(pow(t2 - t1, 3) + (T)epsilon); //mv4dt
		else if (motionPriorPower == 2)
			cost = (difX*difX + difY*difY + difZ*difZ) / abs(t2 - t1 + (T)epsilon);
		residuals[0] = sqrt(cost) / (T)lamda;

		return true;
	}
	template <typename T>	bool operator()(const T* const xyz1, const T* const xyz2, const T* const timeStamp, T* residuals) 	const
	{
		T difX = xyz2[0] - xyz1[0], difY = xyz2[1] - xyz1[1], difZ = xyz2[2] - xyz1[2];
		T  t1 = (T)((timeStamp[0] + (T)(subf1 + 1.0*frameID1)) * ialpha*Tscale);
		T  t2 = (T)((timeStamp[0] + (T)(subf2 + 1.0*frameID2)) * ialpha*Tscale);

		T cost;
		if (motionPriorPower == 4)
			cost = pow(difX*difX + difY*difY + difZ*difZ, 2) / abs(pow(t2 - t1, 3) + (T)epsilon); //mv4dt
		else if (motionPriorPower == 2)
			cost = (difX*difX + difY*difY + difZ*difZ) / abs(t2 - t1 + (T)epsilon);
		residuals[0] = sqrt(cost) / (T)lamda;

		return true;
	}
	static ceres::CostFunction* CreateAutoDiff(int frameID1, int frameID2, double subf1, double subf2, double ialpha, double Tscale, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::AutoDiffCostFunction<LeastActionCostCeres, 1, 3, 3, 1, 1>(new LeastActionCostCeres(frameID1, frameID2, subf1, subf2, ialpha, Tscale, epsilon, lamda, motionPriorPower)));
	}
	static ceres::CostFunction* CreateAutoDiffSame(int frameID1, int frameID2, double subf1, double subf2, double ialpha, double Tscale, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::AutoDiffCostFunction<LeastActionCostCeres, 1, 3, 3, 1>(new LeastActionCostCeres(frameID1, frameID2, subf1, subf2, ialpha, Tscale, epsilon, lamda, motionPriorPower)));
	}
	static ceres::CostFunction* CreateNumerDiff(int frameID1, int frameID2, double subf1, double subf2, double ialpha, double Tscale, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::NumericDiffCostFunction<LeastActionCostCeres, ceres::CENTRAL, 1, 3, 3, 1, 1>(new LeastActionCostCeres(frameID1, frameID2, subf1, subf2, ialpha, Tscale, epsilon, lamda, motionPriorPower)));
	}
	static ceres::CostFunction* CreateNumerDiffSame(int frameID1, int frameID2, double subf1, double subf2, double ialpha, double Tscale, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::NumericDiffCostFunction<LeastActionCostCeres, ceres::CENTRAL, 1, 3, 3, 1>(new LeastActionCostCeres(frameID1, frameID2, subf1, subf2, ialpha, Tscale, epsilon, lamda, motionPriorPower)));
	}

	int frameID1, frameID2, motionPriorPower;
	double subf1, subf2, ialpha, Tscale, epsilon, lamda;
};
struct LeastActionCost3DCeres {
	LeastActionCost3DCeres(double timeStamp1, double timeStamp2, double epsilon, double lamda, int motionPriorPower) : timeStamp1(timeStamp1), timeStamp2(timeStamp2), epsilon(epsilon), lamda(lamda), motionPriorPower(motionPriorPower){}

	template <typename T>	bool operator()(const T* const xyz1, const T* const xyz2, T* residuals) 	const
	{
		T difX = xyz2[0] - xyz1[0], difY = xyz2[1] - xyz1[1], difZ = xyz2[2] - xyz1[2];

		T cost;
		if (motionPriorPower == 4)
			cost = pow(difX*difX + difY*difY + difZ*difZ, 2) / abs(pow(timeStamp2 - timeStamp1, 3) + (T)epsilon); //mv4dt
		else if (motionPriorPower == 2)
			cost = (difX*difX + difY*difY + difZ*difZ) / abs(timeStamp2 - timeStamp1 + (T)epsilon);
		residuals[0] = sqrt(cost) / (T)lamda;
		return true;
	}
	static ceres::CostFunction* CreateAutoDiff(double Stamp1, double Stamp2, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::AutoDiffCostFunction<LeastActionCost3DCeres, 1, 3, 3>(new LeastActionCost3DCeres(Stamp1, Stamp2, epsilon, lamda, motionPriorPower)));
	}
	static ceres::CostFunction* CreateNumerDiff(double Stamp1, double Stamp2, double epsilon, double lamda, int motionPriorPower)
	{
		return (new ceres::NumericDiffCostFunction<LeastActionCost3DCeres, ceres::CENTRAL, 1, 3, 3>(new LeastActionCost3DCeres(Stamp1, Stamp2, epsilon, lamda, motionPriorPower)));
	}
	int motionPriorPower;
	double timeStamp1, timeStamp2, epsilon, lamda;
};
struct IdealGeoProjectionCeres {
	IdealGeoProjectionCeres(double *Pmat, Point2d pt2D, double ilamda)
	{
		P = Pmat, observed_x = pt2D.x, observed_y = pt2D.y;
		lamda = ilamda;
	}
	template <typename T>	bool operator()(const T* const pt3D, T* residuals) 	const
	{
		T numX = (T)P[0] * pt3D[0] + (T)P[1] * pt3D[1] + (T)P[2] * pt3D[2] + (T)P[3];
		T numY = (T)P[4] * pt3D[0] + (T)P[5] * pt3D[1] + (T)P[6] * pt3D[2] + (T)P[7];
		T denum = (T)P[8] * pt3D[0] + (T)P[9] * pt3D[1] + (T)P[10] * pt3D[2] + (T)P[11];

		residuals[0] = (numX / denum - T(observed_x)) / (T)(lamda);
		residuals[1] = (numY / denum - T(observed_y)) / (T)(lamda);

		return true;
	}
	static ceres::CostFunction* Create(double *Pmat, const Point2d pt2D, double lamda)
	{
		return (new ceres::AutoDiffCostFunction<IdealGeoProjectionCeres, 2, 3>(new IdealGeoProjectionCeres(Pmat, pt2D, lamda)));
	}
	double observed_x, observed_y, *P, lamda;
};
struct IdealAlgebraicReprojectionCeres {
	IdealAlgebraicReprojectionCeres(double *iQ, double *iU, double ilamda)
	{
		Q = iQ, U = iU;
		lamda = ilamda;
	}
	template <typename T>	bool operator()(const T* const pt3D, T* residuals) 	const
	{
		residuals[0] = (T)(lamda)*(Q[0] * pt3D[0] + Q[1] * pt3D[1] + Q[2] * pt3D[2] - U[0]);
		residuals[1] = (T)(lamda)*(Q[3] * pt3D[0] + Q[4] * pt3D[1] + Q[5] * pt3D[2] - U[1]);

		return true;
	}
	static ceres::CostFunction* Create(double *Qmat, double* Umat, double lamda)
	{
		return (new ceres::AutoDiffCostFunction<IdealAlgebraicReprojectionCeres, 2, 3>(new IdealAlgebraicReprojectionCeres(Qmat, Umat, lamda)));
	}

	double *Q, *U, lamda;
};
struct KineticEnergy {
	KineticEnergy(){}

	template <typename T>	bool operator()(const T* const xy, T* residuals) 	const
	{
		residuals[0] = ((T)1.0 - xy[0]) * ((T)1.0 - xy[0]) + (T)100.0 * (xy[1] - xy[0] * xy[0]) * (xy[1] - xy[0] * xy[0]);

		return true;
	}

	static ceres::CostFunction* Create()
	{
		return (new ceres::AutoDiffCostFunction<KineticEnergy, 1, 2>(new KineticEnergy()));
	}
};
struct PotentialEnergy {
	PotentialEnergy(double g) :g(g){}

	template <typename T>	bool operator()(const T* const Y, T* residuals) 	const
	{
		residuals[0] = ((T)-g)*Y[0];

		return true;
	}

	static ceres::CostFunction* Create(double g)
	{
		return (new ceres::AutoDiffCostFunction<PotentialEnergy, 1, 1>(new PotentialEnergy(g)));
	}
	double g;
};
class LeastActionProblem : public ceres::FirstOrderFunction {
public:
	LeastActionProblem(double *AllQ, double *AllU, int *PtsPerTrack, int totalPts, int nCams, int nPperTracks, int npts, double lamdaI) :lamdaImg(lamdaI), totalPts(totalPts), nCams(nCams), nPperTracks(nPperTracks)
	{
		gravity = 9.88;
		lamdaImg = lamdaI;
		PointsPerTrack = PtsPerTrack;
		AllQmat = AllQ, AllUmat = AllU;
	}
	virtual ~LeastActionProblem() {}

	virtual bool MyEvaluate(const double* parameters, double* cost, double* gradient) const
	{
		/*//Kinetic energy depends on velocity computed at multiple points--> get splited
		for (int trackId = 0; trackId < npts; trackId++)
		{
		for (int pid = 0; pid < PointsPerTrack[trackId]; pid++)
		{
		ceres::CostFunction* cost_functionE = KineticEnergy::Create();
		cost_functionE->Evaluate(&parameters, &cost[0], NULL);
		if (gradient != NULL)
		cost_functionE->Evaluate(&parameters, &cost[0], &gradient);
		}
		}

		//Potential energy
		for (int trackId = 0; trackId < npts; trackId++)
		{
		for (int pid = 0; pid < PointsPerTrack[trackId]; pid++)
		{
		ceres::CostFunction* cost_functionP = PotentialEnergy::Create(gravity);
		cost_functionP->Evaluate(&parameters, &cost[0], NULL);

		if (gradient != NULL)
		cost_functionP->Evaluate(&parameters, &cost[0], &gradient);
		}
		}

		//Potential energy + Image constraint
		int currentPts = 0;
		for (int trackId = 0; trackId < npts; trackId++)
		{
		for (int pid = 0; pid < PointsPerTrack[trackId]; pid++)
		{
		ceres::CostFunction* cost_functionI = IdealAlgebraicReprojectionCeres::Create(&AllQmat[6 * pid], &AllUmat[2 * pid], lamdaImg);

		if (gradient != NULL)
		cost_functionI->Evaluate(&parameters, &cost[currentPts], &gradient);
		else
		cost_functionI->Evaluate(&parameters, &cost[currentPts], NULL);
		currentPts++;
		}
		}*/

		return true;
	}

	virtual int NumParameters() const
	{
		return totalPts + nCams;
	}

	int nCams, totalPts, nPperTracks, npts;
	int *PointsPerTrack;
	double *AllQmat, *AllUmat, lamdaImg, gravity;
};
int CeresLeastActionNonlinearOptim()
{
	int totalPts = 100, nCams = 2, nPperTracks = 100, npts = 1;

	//double *AllQ, *AllU;
	int *PointsPerTrack = new int[npts];


	double lamdaI = 10.0;
	for (int ii = 0; ii < npts; ii++)
		PointsPerTrack[ii] = nPperTracks;

	double *parameters = new double[totalPts * 3 + nCams];

	ceres::GradientProblemSolver::Options options;
	options.minimizer_progress_to_stdout = true;
	options.max_num_iterations = 1000;

	ceres::GradientProblemSolver::Summary summary;
	//ceres::GradientProblem problem(new LeastActionProblem(AllQ, AllU, PointsPerTrack, totalPts, nCams, nPperTracks, npts, lamdaI));
	//ceres::Solve(options, problem, parameters, &summary);

	std::cout << summary.FullReport() << "\n";

	return 0;
}

double LeastActionError(double *xyz1, double *xyz2, double *timeStamp1, double *timeStamp2, double subframe1, double subframe2, int frameID1, int frameID2, double ialpha, double Tscale, double eps, int motionPriorPower)
{
	double difX = xyz2[0] - xyz1[0], difY = xyz2[1] - xyz1[1], difZ = xyz2[2] - xyz1[2];
	double  t1 = (timeStamp1[0] + subframe1 + frameID1) * ialpha*Tscale;
	double  t2 = (timeStamp2[0] + subframe2 + frameID2) * ialpha*Tscale;

	double cost;
	if (motionPriorPower == 4)
		cost = pow(difX*difX + difY*difY + difZ*difZ, 2) / (pow(t2 - t1, 3) + eps); //mv^4*dt
	else if (motionPriorPower == 2)
		cost = (difX*difX + difY*difY + difZ*difZ) / (t2 - t1 + eps); //mv^2*dt

	return cost;
}
double LeastActionError(double *xyz1, double *xyz2, double timeStamp1, double timeStamp2, double eps, int motionPriorPower)
{
	double difX = xyz2[0] - xyz1[0], difY = xyz2[1] - xyz1[1], difZ = xyz2[2] - xyz1[2];
	double cost;
	if (motionPriorPower == 4)
		cost = pow(difX*difX + difY*difY + difZ*difZ, 2) / (pow(timeStamp2 - timeStamp1, 3) + eps); //mv^4*dt
	else if (motionPriorPower == 2)
		cost = (difX*difX + difY*difY + difZ*difZ) / (timeStamp2 - timeStamp1 + eps); //mv^2*dt

	return cost;
}
double LeastActionError(double *xyz1, double *xyz2, double *xyz3, double *timeStamp1, double *timeStamp2, double *timeStamp3, int frameID1, int frameID2, int frameID3, double ialpha, double Tscale, double eps, int motionPriorPower)
{
	double  t1 = (timeStamp1[0] + frameID1) * ialpha*Tscale;
	double  t2 = (timeStamp2[0] + frameID2) * ialpha*Tscale;
	double  t3 = (timeStamp3[0] + frameID3) * ialpha*Tscale;
	Point3d X1(xyz1[0], xyz1[1], xyz1[2]), X2(xyz2[0], xyz2[1], xyz2[2]), X3(xyz3[0], xyz3[1], xyz3[2]);
	Point3d num1 = X2 - X3, denum1 = ProductPoint3d(X1 - X2, X1 - X3),
		num2 = 2.0*X2 - X1 - X3, denum2 = ProductPoint3d(X2 - X1, X2 - X3),
		num3 = X2 - X1, denum3 = ProductPoint3d(X3 - X1, X3 - X2);
	Point3d dv = ProductPoint3d(X1, DividePoint3d(num1, denum1)) + ProductPoint3d(X2, DividePoint3d(num2, denum2)) + ProductPoint3d(X3, DividePoint3d(num3, denum3));

	double cost;
	if (motionPriorPower == 4)
		cost = pow(dv.x*dv.x + dv.y*dv.y + dv.z*dv.z, 2) / (pow(t2 - t1, 3) + eps); //mv^4*dt
	else if (motionPriorPower == 2)
		cost = (dv.x*dv.x + dv.y*dv.y + dv.z*dv.z) / (t2 - t1 + eps); //mv^2*dt

	return cost;
}
double ComputeActionCostDriver(char *Fname, int motionPriorPower = 2)
{
	double x, y, z, t;
	int count = 0;
	const int nframes = 5000;

	int id[nframes];
	Point3d P3dTemp[nframes];
	double timeStamp[nframes], P3d[3 * nframes];

	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	while (fscanf(fp, "%lf %lf %lf %lf", &x, &y, &z, &t) != EOF)
	{
		id[count] = count;
		timeStamp[count] = t;
		P3dTemp[count].x = x, P3dTemp[count].y = y, P3dTemp[count].z = z;
		count++;
	}
	fclose(fp);

	Quick_Sort_Double(timeStamp, id, 0, count - 1);

	for (int ii = 0; ii < count; ii++)
		P3d[3 * ii] = P3dTemp[id[ii]].x, P3d[3 * ii + 1] = P3dTemp[id[ii]].y, P3d[3 * ii + 2] = P3dTemp[id[ii]].z;

	double ActionCost = 0.0, costi;
	for (int ii = 0; ii < count - 1; ii++)
	{
		costi = LeastActionError(&P3d[3 * ii], &P3d[3 * ii + 3], &timeStamp[ii], &timeStamp[ii + 1], 0, 0, 0, 0, 1, 1, 1.0e-6, motionPriorPower);
		ActionCost += costi;
	}
	printf("Ac: %.6e\n", ActionCost);

	return ActionCost;
}
double ComputeActionEnergy(vector<Point3d> traj, vector<double>Time, double eps, double g, int ApproxOrder)
{
	double Cost = 0.0;
	if (ApproxOrder == 1)
	{
		double T = 0.0, V = 0.0;
		for (int ii = 0; ii < traj.size() - 1; ii++)
		{
			double dT = Time[ii + 1] - Time[ii];
			double dx = traj[ii].x - traj[ii + 1].x, dy = traj[ii].y - traj[ii + 1].y, dz = traj[ii].z - traj[ii + 1].z;
			double vx = dx / (dT + eps), vy = dy / (dT + eps), vz = dz / (dT + eps);
			double v = sqrt(vx*vx + vy*vy + vz*vz);
			double cost = pow(v, 2)*(dT + eps);
			T += cost;
		}
		for (int ii = 0; ii < traj.size() - 1; ii++)
		{
			double dT = Time[ii + 1] - Time[ii];
			double cost = g*(traj[ii].y + traj[ii + 1].y)*dT;
			V += cost;
		}
		Cost = T - V;
	}
	else
	{
		/*//Second order approxiamtaion of speed
		Point3d vel[2000];
		for (int ii = 0; ii < traj.size() - 2; ii++)
		{
		double  t1 = Time[ii], t2 = Time[ii + 1], t3 = Time[ii + 2];

		double num1 = t2 - t3, num2 = 2.0*t2 - t1 - t3, num3 = t2 - t1;
		double denum1 = (t1 - t2)*(t1 - t3) + eps, denum2 = (t2 - t1)*(t2 - t3) + eps, denum3 = (t3 - t1)*(t3 - t2) + eps;
		double a1 = num1 / denum1, a2 = num2 / denum2, a3 = num3 / denum3;

		double velX = a1*traj[ii].x + a2*traj[ii + 1].x + a3*traj[ii + 2].x;
		double velY = a1*traj[ii].y + a2*traj[ii + 1].y + a3*traj[ii + 2].y;
		double velZ = a1*traj[ii].z + a2*traj[ii + 1].z + a3*traj[ii + 2].z;

		vel[ii + 1].x = velX, vel[ii + 1].y = velY, vel[ii + 1].z = velZ;
		}
		vel[0] = vel[1]; vel[traj.size() - 1] = vel[traj.size() - 2];

		for (int ii = 0; ii < traj.size() - 1; ii++)
		{
		Point3d vel1 = vel[ii], vel2 = vel[ii + 1];
		double dT = Time[ii + 1] - Time[ii];
		double cost = 0.5*(pow(vel1.x, 2) + pow(vel2.x, 2))*(dT + eps) + 0.5*(pow(vel1.y, 2) + pow(vel2.y, 2))*(dT + eps) + 0.5*(pow(vel1.z, 2) + pow(vel2.z, 2))*(dT + eps);
		Cost += cost;
		}*/

		//accelatiaon via lagrange interpolation
		double accel[2000];
		double t1, t2, t3, denum1, denum3;
		int npts = traj.size();
		t1 = Time[0], t2 = Time[1];
		denum1 = pow(t2 - t1, 2);
		accel[0] = (-traj[0].x + traj[1].x) / denum1 + (-traj[0].y + traj[1].y) / denum1 + (-traj[0].z + traj[1].z) / denum1;

		for (int ii = 1; ii < npts - 1; ii++)
		{
			double  t1 = Time[ii - 1], t2 = Time[ii], t3 = Time[ii + 1];
			double denum1 = (t1 - t2)*(t1 - t3), denum2 = (t2 - t1)*(t2 - t3), denum3 = (t3 - t1)*(t3 - t2);

			double accelX = traj[ii - 1].x / denum1 + traj[ii].x / denum2 + traj[ii + 1].x / denum3;
			double accelY = traj[ii - 1].y / denum1 + traj[ii].y / denum2 + traj[ii + 1].y / denum3;
			double accelZ = traj[ii - 1].z / denum1 + traj[ii].z / denum2 + traj[ii + 1].z / denum3;

			accel[ii] = accelX*accelX + accelY*accelY + accelZ*accelZ;
		}
		t2 = Time[npts - 2], t3 = Time[npts - 1];
		denum3 = pow(t3 - t2, 2);
		accel[npts - 1] = (traj[npts - 2].x - traj[npts - 1].x) / denum3 + (traj[npts - 2].y - traj[npts - 1].y) / denum3 + (traj[npts - 2].z - traj[npts - 1].z) / denum3;

		Cost = 0.0;
		for (int ii = 0; ii <npts - 1; ii++)
			Cost += 0.5*(accel[ii] + accel[ii + 1])*(Time[ii + 1] - Time[ii]);
	}
	return Cost;
}
void RecursiveUpdateCameraOffset(int *currentOffset, int BruteForceTimeWindow, int currentCam, int nCams)
{
	if (currentOffset[currentCam] > BruteForceTimeWindow)
	{
		currentOffset[currentCam] = -BruteForceTimeWindow;
		if (currentCam < nCams - 1)
			currentOffset[currentCam + 1] ++;
		RecursiveUpdateCameraOffset(currentOffset, BruteForceTimeWindow, currentCam + 1, nCams);
	}

	return;
}

void MotionPrior_ML_Weighting(vector<ImgPtEle> *PerCam_UV, int ntracks, int nCams)
{
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int kk = 0; kk < PerCam_UV[camID*ntracks + trackID].size(); kk++)
			{
				ImgPtEle ptEle = PerCam_UV[camID*ntracks + trackID][kk];
				ptEle.K[2] = 0, ptEle.K[5] = 0;

				double Scale = PerCam_UV[camID*ntracks + trackID][kk].scale, canonicalScale = PerCam_UV[camID*ntracks + trackID][kk].canonicalScale;
				double std2d = PerCam_UV[camID*ntracks + trackID][kk].std2D;

				if (Scale >= canonicalScale)
				{
					double sigmaRetina[9], sigma2d[9] = { std2d*Scale / canonicalScale, 0, 0, 0, std2d*Scale / canonicalScale, 0, 0, 0, 1 };

					Map < Matrix < double, 3, 3, RowMajor > > eK(ptEle.K);
					Map < Matrix < double, 3, 3, RowMajor > > esigma2d(sigma2d);
					Map < Matrix < double, 3, 3, RowMajor > > esigmaRetina(sigmaRetina);
					Matrix3d eiK = eK.inverse();
					esigmaRetina = eiK*esigma2d*eiK.transpose();

					double depth = sqrt(pow(ptEle.pt3D.x - ptEle.camcenter[0], 2) + pow(ptEle.pt3D.y - ptEle.camcenter[1], 2) + pow(ptEle.pt3D.z - ptEle.camcenter[2], 2));
					PerCam_UV[camID*ntracks + trackID][kk].std3D = max(sigmaRetina[0], sigmaRetina[4]) * PerCam_UV[camID*ntracks + trackID][kk].pixelSizeToMm*depth;
				}
				else //disregard this point
				{
					PerCam_UV[camID*ntracks + trackID][kk].std2D = 0.0;
					PerCam_UV[camID*ntracks + trackID][kk].std3D = 0.0;
				}
			}
		}
	}

	return;
}
void MotionPrior_Optim_SpatialStructure_NoSimulatenousPoints(char *Path, vector<double*> &Allpt3D, vector<ImgPtEle> *PerCam_UV, vector<int> &PerPoint_nFrames, double *currentOffset, int ntracks, bool non_monotonicDescent, int nCams, int motionPriorPower, double Tscale, double ialpha, double eps, double lamda, double *Cost, bool StillImages, bool silent)
{
	double ActionCost = 0.0, ProjCost = 0.0, costiX, costiY, costi;

	int *currentFrame = new int[nCams], *PerCam_nf = new int[nCams], *currentPID_InTrack = new int[nCams];
	Point3d P3D;
	ImgPtEle ptEle;

	vector<int>triangulatedList;
	vector<double>AllError3D, VectorTime;
	vector<int> *VectorCamID = new vector<int>[ntracks], *VectorFrameID = new vector<int>[ntracks];
	vector<ImgPtEle> *Traj2DAll = new vector<ImgPtEle>[ntracks];


	ceres::Problem problem;

	double earliestTime, currentTime;
	int earliestCamFrameID, frameID, nfinishedCams, earliestCamID;

	int *StillImageTimeOrderID = 0;
	double *StillImageTimeOrder = 0;
	if (StillImages)
	{
		StillImageTimeOrderID = new int[nCams];
		StillImageTimeOrder = new double[nCams];
		for (int camID = 0; camID < nCams; camID++)
		{
			StillImageTimeOrder[camID] = currentOffset[camID];
			StillImageTimeOrderID[camID] = camID;
		}
		Quick_Sort_Double(StillImageTimeOrder, StillImageTimeOrderID, 0, nCams - 1);
	}

	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		if (StillImages)
		{
			VectorTime.clear();

			for (int ii = 0; ii < nCams; ii++)
			{
				int camID = StillImageTimeOrderID[ii];
				double currentTime = StillImageTimeOrder[ii];
				VectorTime.push_back(currentTime);
				VectorCamID[trackID].push_back(camID);
				VectorFrameID[trackID].push_back(0);
				Traj2DAll[trackID].push_back(PerCam_UV[camID*ntracks + trackID][0]);
			}
		}
		else
		{
			for (int camID = 0; camID < nCams; camID++)
				PerCam_nf[camID] = PerCam_UV[camID*ntracks + trackID].size();

			//Assemble trajactory and time from all Cameras
			VectorTime.clear();
			for (int jj = 0; jj < nCams; jj++)
				currentPID_InTrack[jj] = 0;

			while (true)
			{
				//Determine the next camera
				nfinishedCams = 0, earliestCamID, earliestTime = 9e9;
				for (int camID = 0; camID < nCams; camID++)
				{
					if (currentPID_InTrack[camID] == PerCam_nf[camID])
					{
						nfinishedCams++;
						continue;
					}

					//Time:
					frameID = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].frameID;
					currentTime = 1.0*currentOffset[camID] * ialpha*Tscale + 1.0*frameID * ialpha*Tscale;

					if (currentTime < earliestTime)
					{
						earliestTime = currentTime;
						earliestCamID = camID;
						earliestCamFrameID = frameID;
					}
				}

				//If all cameras are done
				if (nfinishedCams == nCams)
					break;

				//Add new point to the sequence
				VectorTime.push_back(earliestTime);
				VectorCamID[trackID].push_back(earliestCamID);
				VectorFrameID[trackID].push_back(earliestCamFrameID);
				Traj2DAll[trackID].push_back(PerCam_UV[earliestCamID*ntracks + trackID][currentPID_InTrack[earliestCamID]]);

				currentPID_InTrack[earliestCamID]++;
			}
		}

		int npts = Traj2DAll[trackID].size();
		Allpt3D[trackID] = new double[3 * npts];
		for (int ll = 0; ll < npts; ll++)
			Allpt3D[trackID][3 * ll] = Traj2DAll[trackID][ll].pt3D.x, Allpt3D[trackID][3 * ll + 1] = Traj2DAll[trackID][ll].pt3D.y, Allpt3D[trackID][3 * ll + 2] = Traj2DAll[trackID][ll].pt3D.z;

		//1st order approx of v
		double *Q1, *Q2, *U1, *U2;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + 1];

			costi = LeastActionError(&Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * ll + 3], &currentOffset[camID1], &currentOffset[camID2], 0, 0, VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += (1.0 - lamda)*costi;
			Q1 = Traj2DAll[trackID][ll].Q, Q2 = Traj2DAll[trackID][ll + 1].Q, U1 = Traj2DAll[trackID][ll].u, U2 = Traj2DAll[trackID][ll + 1].u;

			costiX = sqrt(lamda)*(Q1[0] * Allpt3D[trackID][3 * ll] + Q1[1] * Allpt3D[trackID][3 * ll + 1] + Q1[2] * Allpt3D[trackID][3 * ll + 2] - U1[0]);
			costiY = sqrt(lamda)*(Q1[3] * Allpt3D[trackID][3 * ll] + Q1[4] * Allpt3D[trackID][3 * ll + 1] + Q1[5] * Allpt3D[trackID][3 * ll + 2] - U1[1]);
			costi = sqrt(costiX*costiX + costiY*costiY);
			ProjCost += costi;

			costiX = sqrt(lamda)*(Q2[0] * Allpt3D[trackID][3 * ll + 3] + Q2[1] * Allpt3D[trackID][3 * ll + 4] + Q2[2] * Allpt3D[trackID][3 * ll + 5] - U2[0]);
			costiY = sqrt(lamda)*(Q2[3] * Allpt3D[trackID][3 * ll + 3] + Q2[4] * Allpt3D[trackID][3 * ll + 4] + Q2[5] * Allpt3D[trackID][3 * ll + 5] - U2[1]);
			costi = sqrt(costiX*costiX + costiY*costiY);
			ProjCost += costi;

			double  t1 = (currentOffset[camID1] + VectorFrameID[trackID][ll]) * ialpha*Tscale;
			double  t2 = (currentOffset[camID2] + VectorFrameID[trackID][ll + 1]) * ialpha*Tscale;

			ceres::CostFunction* cost_function = LeastActionCost3DCeres::CreateAutoDiff(t1, t2, eps, sqrt(1.0 - lamda), motionPriorPower);
			//ceres::CostFunction* cost_function = LeastActionCostCeres::CreateNumerDiffSame(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, rate, eps, motionPriorPower);
			problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + 1)]);

			ceres::CostFunction* cost_function2 = IdealAlgebraicReprojectionCeres::Create(Traj2DAll[trackID][ll].Q, Traj2DAll[trackID][ll].u, sqrt(lamda));
			problem.AddResidualBlock(cost_function2, NULL, Allpt3D[trackID] + 3 * ll);

			ceres::CostFunction* cost_function3 = IdealAlgebraicReprojectionCeres::Create(Traj2DAll[trackID][ll + 1].Q, Traj2DAll[trackID][ll + 1].u, sqrt(lamda));
			problem.AddResidualBlock(cost_function3, NULL, Allpt3D[trackID] + 3 * ll + 3);
		}

		/*//Set fixed parameters
		ceres::Solver::Options options;
		options.num_threads = 4;
		options.max_num_iterations = 1000;
		options.linear_solver_type = ceres::SPARSE_SCHUR; //SPARSE_NORMAL_CHOLESKY;
		options.minimizer_progress_to_stdout = false;// silent ? false : true;
		options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
		options.use_nonmonotonic_steps = true;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);

		if (!silent)
		cout << "Point: " << trackID << " (" << npts << ") frames " << summary.BriefReport() << "\n";

		for (int ii = 0; ii < npts; ii++)
		{
		int camID = VectorCamID[trackID][ii], frameID = VectorFrameID[trackID][ii];

		bool found = false;
		for (int kk = 0; kk < PerCam_UV[camID*ntracks + trackID].size(); kk++)
		{
		if (frameID == PerCam_UV[camID*ntracks + trackID][kk].frameID)
		{
		//if (summary.final_cost < 1e7)
		PerCam_UV[camID*ntracks + trackID][kk].pt3D = Point3d(Allpt3D[trackID][3 * ii], Allpt3D[trackID][3 * ii + 1], Allpt3D[trackID][3 * ii + 2]);
		//else
		//	PerCam_UV[camID*ntracks + trackID][kk].pt3D = Point3d(0, 0, 0);
		found = true;
		break;
		}
		}
		if (!found)
		{
		printf("Serious bug in point-camera-frame association\n");
		abort();
		}
		}*/
	}
	for (int trackID = 0; trackID < ntracks; trackID++)
		PerPoint_nFrames.push_back(Traj2DAll[trackID].size());

	ceres::Solver::Options options;
	options.num_threads = 4;
	options.num_linear_solver_threads = 4;
	options.max_num_iterations = 500;
	options.linear_solver_type = ceres::SPARSE_SCHUR; //SPARSE_NORMAL_CHOLESKY;
	options.minimizer_progress_to_stdout = false;// silent ? false : true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (!silent)
		std::cout << summary.FullReport() << "\n";
	else
		std::cout << summary.BriefReport() << "\n";

	//Save data
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		for (int ii = 0; ii < npts; ii++)
		{
			int camID = VectorCamID[trackID][ii], frameID = VectorFrameID[trackID][ii];

			bool found = false;
			for (int kk = 0; kk < PerCam_UV[camID*ntracks + trackID].size(); kk++)
			{
				if (frameID == PerCam_UV[camID*ntracks + trackID][kk].frameID)
				{
					PerCam_UV[camID*ntracks + trackID][kk].pt3D = Point3d(Allpt3D[trackID][3 * ii], Allpt3D[trackID][3 * ii + 1], Allpt3D[trackID][3 * ii + 2]);
					found = true;
					break;
				}
			}
			if (!found)
			{
				printf("Serious bug in point-camera-frame association\n");
				abort();
			}
		}
	}

	//Compute cost after optim
	ActionCost = 0.0, ProjCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = PerPoint_nFrames[trackID];
		double costi;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + 1];

			costi = LeastActionError(&Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * ll + 3], &currentOffset[camID1], &currentOffset[camID2], 0, 0, VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			costiX = sqrt(lamda)*(Traj2DAll[trackID][ll].Q[0] * Allpt3D[trackID][3 * ll] + Traj2DAll[trackID][ll].Q[1] * Allpt3D[trackID][3 * ll + 1] + Traj2DAll[trackID][ll].Q[2] * Allpt3D[trackID][3 * ll + 2] - Traj2DAll[trackID][ll].u[0]);
			costiY = sqrt(lamda)*(Traj2DAll[trackID][ll].Q[3] * Allpt3D[trackID][3 * ll] + Traj2DAll[trackID][ll].Q[4] * Allpt3D[trackID][3 * ll + 1] + Traj2DAll[trackID][ll].Q[5] * Allpt3D[trackID][3 * ll + 2] - Traj2DAll[trackID][ll].u[1]);
			costi = sqrt(costiX*costiX + costiY*costiY);
			ProjCost += costi;

			costiX = sqrt(lamda)*(Traj2DAll[trackID][ll + 1].Q[0] * Allpt3D[trackID][3 * ll + 3] + Traj2DAll[trackID][ll + 1].Q[1] * Allpt3D[trackID][3 * ll + 4] + Traj2DAll[trackID][ll + 1].Q[2] * Allpt3D[trackID][3 * ll + 5] - Traj2DAll[trackID][ll + 1].u[0]);
			costiY = sqrt(lamda)*(Traj2DAll[trackID][ll + 1].Q[3] * Allpt3D[trackID][3 * ll + 3] + Traj2DAll[trackID][ll + 1].Q[4] * Allpt3D[trackID][3 * ll + 4] + Traj2DAll[trackID][ll + 1].Q[5] * Allpt3D[trackID][3 * ll + 5] - Traj2DAll[trackID][ll + 1].u[1]);
			costi = sqrt(costiX*costiX + costiY*costiY);
			ProjCost += costi;
		}
	}

	if (!silent)
		printf("Action cost: %f \nProjection cost: %f ", ActionCost, ProjCost);

	double lengthCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		double costi;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			costi = sqrt(pow(Allpt3D[trackID][3 * ll] - Allpt3D[trackID][3 * ll + 3], 2) + pow(Allpt3D[trackID][3 * ll + 1] - Allpt3D[trackID][3 * ll + 4], 2) + pow(Allpt3D[trackID][3 * ll + 2] - Allpt3D[trackID][3 * ll + 5], 2));
			lengthCost += costi;
		}
	}
	if (!silent)
		printf("Distance Cost: %e\n", lengthCost);

	double directionCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		double direct1[3], direct2[3];
		for (int ll = 0; ll < npts - 2; ll++)
		{
			direct1[0] = Allpt3D[trackID][3 * ll] - Allpt3D[trackID][3 * ll + 3], direct1[1] = Allpt3D[trackID][3 * ll + 1] - Allpt3D[trackID][3 * ll + 4], direct1[2] = Allpt3D[trackID][3 * ll + 2] - Allpt3D[trackID][3 * ll + 5];
			direct2[0] = Allpt3D[trackID][3 * ll + 3] - Allpt3D[trackID][3 * ll + 6], direct2[1] = Allpt3D[trackID][3 * ll + 4] - Allpt3D[trackID][3 * ll + 7], direct2[2] = Allpt3D[trackID][3 * ll + 5] - Allpt3D[trackID][3 * ll + 8];
			normalize(direct1), normalize(direct2);
			directionCost += abs(dotProduct(direct1, direct2));
		}
	}
	if (!silent)
		printf("Direction Cost: %e\n", directionCost);

	Cost[0] = ActionCost, Cost[1] = ProjCost, Cost[2] = lengthCost, Cost[3] = directionCost;

	delete[]VectorCamID, delete[]VectorFrameID, delete[]Traj2DAll;
	delete[]currentFrame, delete[]PerCam_nf;

	return;
}
double MotionPrior_Optim_SpatialStructure_Algebraic(char *Path, vector<double*> &Allpt3D, vector<ImgPtEle> *PerCam_UV, vector<int> &PerPoint_nFrames, double *currentOffset, int ntracks, bool non_monotonicDescent, int nCams, int motionPriorPower, double Tscale, double ialpha, double eps, double lamda, double *Cost, bool StillImages, bool silent)
{
	vector<double> *VectorTime = new vector<double>[ntracks];
	vector<int> *VectorCamID = new vector<int>[ntracks], *VectorFrameID = new vector<int>[ntracks], *simulatneousPoints = new vector<int>[ntracks];
	vector<ImgPtEle> *Traj2DAll = new vector<ImgPtEle>[ntracks];

	int *StillImageTimeOrderID = 0;
	double *StillImageTimeOrder = 0;
	if (StillImages)
	{
		StillImageTimeOrderID = new int[nCams];
		StillImageTimeOrder = new double[nCams];
		for (int camID = 0; camID < nCams; camID++)
		{
			StillImageTimeOrder[camID] = currentOffset[camID];
			StillImageTimeOrderID[camID] = camID;
		}
		Quick_Sort_Double(StillImageTimeOrder, StillImageTimeOrderID, 0, nCams - 1);
	}

	double CeresCost = 0.0;
	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		bool UsedCam[MaxnCams];
		int PerCam_nf[MaxnCams], currentPID_InTrack[MaxnCams];
		Point3d P3D;
		ImgPtEle ptEle;
		double earliestTime, currentTime, RollingShutterOffset;
		int earliestCamFrameID, frameID, nfinishedCams, earliestCamID;

		ceres::Problem problem;
		if (StillImages)
		{
			for (int ii = 0; ii < nCams; ii++)
			{
				int camID = StillImageTimeOrderID[ii];
				double currentTime = StillImageTimeOrder[ii];
				VectorTime[trackID].push_back(currentTime);
				VectorCamID[trackID].push_back(camID);
				VectorFrameID[trackID].push_back(0);
				Traj2DAll[trackID].push_back(PerCam_UV[camID*ntracks + trackID][0]);
			}
		}
		else
		{
			int nopoints = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				PerCam_nf[camID] = PerCam_UV[camID*ntracks + trackID].size();

				if (PerCam_nf[camID] == 0)
					nopoints++;
			}
			if (nopoints > nCams - 2)
				continue;

			//Assemble trajactory and time from all Cameras
			for (int jj = 0; jj < nCams; jj++)
				currentPID_InTrack[jj] = 0;

			while (true)
			{
				//Determine the next camera
				nfinishedCams = 0, earliestCamID, earliestTime = 9e9;
				for (int camID = 0; camID < nCams; camID++)
				{
					if (currentPID_InTrack[camID] == PerCam_nf[camID])
					{
						nfinishedCams++;
						continue;
					}

					//Time:
					RollingShutterOffset = 0.0;
					if (PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].shutterModel != 0)
					{
						double v = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].pt2D.y, h = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].imHeight;
						RollingShutterOffset = v / h;
					}

					frameID = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].frameID;
					currentTime = (currentOffset[camID] + frameID + RollingShutterOffset) * ialpha*Tscale;

					if (currentTime < earliestTime)
					{
						earliestTime = currentTime;
						earliestCamID = camID;
						earliestCamFrameID = frameID;
					}
				}

				//If all cameras are done
				if (nfinishedCams == nCams)
					break;

				//Add new point to the sequence
				VectorTime[trackID].push_back(earliestTime);
				VectorCamID[trackID].push_back(earliestCamID);
				VectorFrameID[trackID].push_back(earliestCamFrameID);
				Traj2DAll[trackID].push_back(PerCam_UV[earliestCamID*ntracks + trackID][currentPID_InTrack[earliestCamID]]);

				currentPID_InTrack[earliestCamID]++;
			}
		}

		int npts = Traj2DAll[trackID].size();
		Allpt3D[trackID] = new double[3 * npts];
		for (int ll = 0; ll < npts; ll++)
			Allpt3D[trackID][3 * ll] = Traj2DAll[trackID][ll].pt3D.x, Allpt3D[trackID][3 * ll + 1] = Traj2DAll[trackID][ll].pt3D.y, Allpt3D[trackID][3 * ll + 2] = Traj2DAll[trackID][ll].pt3D.z;

		//Detect points captured simulatenously
		int groupCount = 0;
		for (int ll = 0; ll < npts; ll++)
			simulatneousPoints[trackID].push_back(-1);

		for (int ll = 0; ll < npts - 1; ll++)
		{
			int naddedPoints = 0; bool found = false;
			for (int kk = ll + 1; kk < npts; kk++)
			{
				naddedPoints++;
				if (VectorTime[trackID][kk] - VectorTime[trackID][ll] > FLT_EPSILON)
					break;
				else
				{
					if (kk - 1 == ll)
						simulatneousPoints[trackID][ll] = groupCount;

					simulatneousPoints[trackID][kk] = groupCount;
					found = true;
				}
			}

			if (found)
			{
				ll += naddedPoints - 1;
				groupCount++;
			}
		}

		double ActionCost = 0, ProjCost = 0;

		//1st order approx of v
		int oldtype = simulatneousPoints[trackID][0];
		for (int ll = 0; ll < nCams; ll++)
			UsedCam[ll] = false;

		for (int ll = 0; ll < npts - 1; ll++)
		{
			int incre = 1;
			while (ll + incre < npts)
			{
				if (simulatneousPoints[trackID][ll + incre] == -1 || simulatneousPoints[trackID][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[trackID][ll + incre];
					break;
				}
				else
				{
					ceres::CostFunction* cost_function3 = IdealAlgebraicReprojectionCeres::Create(Traj2DAll[trackID][ll + incre].Q, Traj2DAll[trackID][ll + incre].u, sqrt(lamda));
					problem.AddResidualBlock(cost_function3, NULL, Allpt3D[trackID] + 3 * ll);
				}
				incre++;
			}
			if (ll + incre == npts)
				break;

			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[trackID][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[trackID][ll].pt2D.y / Traj2DAll[trackID][ll].imHeight, shutterOffset2 = Traj2DAll[trackID][ll + incre].pt2D.y / Traj2DAll[trackID][ll + incre].imHeight;

			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + incre];
			double  t1 = (currentOffset[camID1] + VectorFrameID[trackID][ll] + shutterOffset1) * ialpha*Tscale;
			double  t2 = (currentOffset[camID2] + VectorFrameID[trackID][ll + incre] + shutterOffset2) * ialpha*Tscale;

			ceres::CostFunction* cost_function = LeastActionCost3DCeres::CreateAutoDiff(t1, t2, eps, sqrt(1.0 - lamda), motionPriorPower);
			//ceres::CostFunction* cost_function = LeastActionCostCeres::CreateNumerDiffSame(t1, t2, eps);
			problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + incre)]);

			ceres::CostFunction* cost_function2 = IdealAlgebraicReprojectionCeres::Create(Traj2DAll[trackID][ll].Q, Traj2DAll[trackID][ll].u, sqrt(lamda));
			problem.AddResidualBlock(cost_function2, NULL, &Allpt3D[trackID][3 * ll]);

			ceres::CostFunction* cost_function3 = IdealAlgebraicReprojectionCeres::Create(Traj2DAll[trackID][ll + incre].Q, Traj2DAll[trackID][ll + incre].u, sqrt(lamda));
			problem.AddResidualBlock(cost_function3, NULL, &Allpt3D[trackID][3 * (ll + incre)]);

			ll += incre - 1;
		}

		ceres::Solver::Options options;
		options.num_threads = 2;
		options.num_linear_solver_threads = 2;
		options.max_num_iterations = 100;
		options.linear_solver_type = ceres::SPARSE_SCHUR;
		options.minimizer_progress_to_stdout = false;
		options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
		options.use_nonmonotonic_steps = true;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);

#pragma omp critical
		{
			CeresCost += summary.final_cost;
			if (!silent)
				cout << "Point: " << trackID << " " << summary.BriefReport() << "\n";// cout << "Point: " << trackID << " " << summary.FullReport() << "\n";
		}

		//copy simultaneous triggered points
		for (int ll = 0; ll < npts - 1; ll++)
		{
			if (simulatneousPoints[trackID][ll] != -1)
			{
				int nPoint = 0;
				for (int kk = ll + 1; kk < npts; kk++)
				{
					nPoint++;
					if (simulatneousPoints[trackID][kk] != simulatneousPoints[trackID][ll])
						break;
					else
					{
						Allpt3D[trackID][3 * kk] = Allpt3D[trackID][3 * ll];
						Allpt3D[trackID][3 * kk + 1] = Allpt3D[trackID][3 * ll + 1];
						Allpt3D[trackID][3 * kk + 2] = Allpt3D[trackID][3 * ll + 2];
					}
				}
				ll += nPoint - 1;
			}
		}

		for (int ii = 0; ii < Traj2DAll[trackID].size(); ii++)
		{
			int camID = VectorCamID[trackID][ii], frameID = VectorFrameID[trackID][ii];

			bool found = false;
			for (int kk = 0; kk < PerCam_UV[camID*ntracks + trackID].size(); kk++)
			{
				if (frameID == PerCam_UV[camID*ntracks + trackID][kk].frameID)
				{
					PerCam_UV[camID*ntracks + trackID][kk].pt3D = Point3d(Allpt3D[trackID][3 * ii], Allpt3D[trackID][3 * ii + 1], Allpt3D[trackID][3 * ii + 2]);
					found = true;
					break;
				}
			}
			if (!found)
			{
				printf("Serious bug in point-camera-frame association\n");
				abort();
			}
		}
	}
	//printf("Alge: END\n");
	for (int trackID = 0; trackID < ntracks; trackID++)
		PerPoint_nFrames.push_back(Traj2DAll[trackID].size());

	//Compute cost after optim
	double ActionCost = 0.0, ProjCost = 0.0, lengthCost = 0.0, directionCost = 0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = PerPoint_nFrames[trackID];
		if (npts == 0)
			continue;
		int oldtype = simulatneousPoints[trackID][0];
		for (int ll = 0; ll < npts - 1; ll++)
		{
			int incre = 1;
			while (ll + incre < npts)
			{
				if (simulatneousPoints[trackID][ll + incre] == -1 || simulatneousPoints[trackID][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[trackID][ll + incre];
					break;
				}
				incre++;
			}
			if (ll + incre == npts)
				break;

			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[trackID][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[trackID][ll].pt2D.y / Traj2DAll[trackID][ll].imHeight, shutterOffset2 = Traj2DAll[trackID][ll + incre].pt2D.y / Traj2DAll[trackID][ll + incre].imHeight;
			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + incre];

			double costi = LeastActionError(&Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + incre)],
				&currentOffset[camID1], &currentOffset[camID2], shutterOffset1, shutterOffset2,
				VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + incre], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			ll += incre - 1;
		}
	}
	if (!silent)
		printf("Action cost: %f ", ActionCost);

	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = PerPoint_nFrames[trackID];
		if (npts == 0)
			continue;

		double costi_1, costi_2;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			Point2d P2d_1(Traj2DAll[trackID][ll].pt2D.x, Traj2DAll[trackID][ll].pt2D.y);
			Point3d P3d_1(Allpt3D[trackID][3 * ll], Allpt3D[trackID][3 * ll + 1], Allpt3D[trackID][3 * ll + 2]);
			costi_1 = PinholeReprojectionErrorSimpleDebug(Traj2DAll[trackID][ll].P, P3d_1, P2d_1);
			ProjCost += costi_1;

			Point2d P2d_2(Traj2DAll[trackID][ll].pt2D.x, Traj2DAll[trackID][ll].pt2D.y);
			Point3d P3d_2(Allpt3D[trackID][3 * ll], Allpt3D[trackID][3 * ll + 1], Allpt3D[trackID][3 * ll + 2]);
			costi_2 = PinholeReprojectionErrorSimpleDebug(Traj2DAll[trackID][ll].P, P3d_2, P2d_2);
			ProjCost += costi_2;
		}
	}
	if (!silent)
		printf("Projection cost: %f ", ProjCost);

	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		if (npts == 0)
			continue;
		double costi;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			costi = sqrt(pow(Allpt3D[trackID][3 * ll] - Allpt3D[trackID][3 * ll + 3], 2) + pow(Allpt3D[trackID][3 * ll + 1] - Allpt3D[trackID][3 * ll + 4], 2) + pow(Allpt3D[trackID][3 * ll + 2] - Allpt3D[trackID][3 * ll + 5], 2));
			lengthCost += costi;
		}
	}
	if (!silent)
		printf("Distance Cost: %e.", lengthCost);

	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = PerPoint_nFrames[trackID];
		if (npts == 0)
			continue;
		int oldtype = simulatneousPoints[trackID][0];
		vector<int>Knot;
		Knot.push_back(0);
		for (int ll = 0; ll < npts; ll++)
		{
			int incre = 1;
			while (ll + incre < npts)
			{
				if (simulatneousPoints[trackID][ll + incre] == -1 || simulatneousPoints[trackID][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[trackID][ll + incre];
					break;
				}
				incre++;
			}
			if (ll + incre == npts)
				break;
			Knot.push_back(ll + incre);
			ll += incre - 1;
		}

		for (int ll = 0; ll < Knot.size() - 2; ll++)
		{
			int fid1 = Knot[ll], fid2 = Knot[ll + 1], fid3 = Knot[ll + 2];
			double direct1[] = { Allpt3D[trackID][3 * fid1] - Allpt3D[trackID][3 * fid2], Allpt3D[trackID][3 * fid1 + 1] - Allpt3D[trackID][3 * fid2 + 1], Allpt3D[trackID][3 * fid1 + 2] - Allpt3D[trackID][3 * fid2 + 2] };
			double direct2[] = { Allpt3D[trackID][3 * fid2] - Allpt3D[trackID][3 * fid3], Allpt3D[trackID][3 * fid2 + 1] - Allpt3D[trackID][3 * fid3 + 1], Allpt3D[trackID][3 * fid2 + 2] - Allpt3D[trackID][3 * fid3 + 2] };
			normalize(direct1), normalize(direct2);
			directionCost += abs(dotProduct(direct1, direct2));
		}
	}
	if (!silent)
		printf("Direction Cost: %e\n", directionCost);

	Cost[0] = ActionCost, Cost[1] = ProjCost, Cost[2] = lengthCost, Cost[3] = directionCost;

	delete[]VectorTime, delete[]VectorCamID, delete[]VectorFrameID, delete[]simulatneousPoints, delete[]Traj2DAll;

	return CeresCost;
}
double MotionPrior_Optim_SpatialStructure_Geometric(char *Path, vector<double*> &Allpt3D, vector<ImgPtEle> *PerCam_UV, vector<int> &PerPoint_nFrames, double *currentOffset, int npts, bool non_monotonicDescent, int nCams, int motionPriorPower, double Tscale, double ialpha, double eps, double lamda, double *Cost, bool StillImages, bool silent)
{
	vector<double> *VectorTime = new vector<double>[npts];
	vector<int> *VectorCamID = new vector<int>[npts], *VectorFrameID = new vector<int>[npts], *simulatneousPoints = new vector<int>[npts];
	vector<ImgPtEle> *Traj2DAll = new vector<ImgPtEle>[npts];

	int *StillImageTimeOrderID = 0;
	double *StillImageTimeOrder = 0;
	if (StillImages)
	{
		StillImageTimeOrderID = new int[nCams];
		StillImageTimeOrder = new double[nCams];
		for (int camID = 0; camID < nCams; camID++)
		{
			StillImageTimeOrder[camID] = currentOffset[camID];
			StillImageTimeOrderID[camID] = camID;
		}
		Quick_Sort_Double(StillImageTimeOrder, StillImageTimeOrderID, 0, nCams - 1);
	}

	double CeresCost = 0.0;

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int pid = 0; pid < npts; pid++)
	{
		//printf("%d ... ", pid);
		bool UsedCam[MaxnCams];
		int PerCam_nf[MaxnCams], currentFID_InPoint[MaxnCams];
		Point3d P3D;
		ImgPtEle ptEle;

		double earliestTime, currentTime, RollingShutterOffset;
		int earliestCamFrameID, frameID, nfinishedCams, earliestCamID;

		ceres::Problem problem;
		if (StillImages)
		{
			for (int ii = 0; ii < nCams; ii++)
			{
				int camID = StillImageTimeOrderID[ii];
				double currentTime = StillImageTimeOrder[ii];
				VectorTime[pid].push_back(currentTime);
				VectorCamID[pid].push_back(camID);
				VectorFrameID[pid].push_back(0);
				Traj2DAll[pid].push_back(PerCam_UV[camID*npts + pid][0]);
			}
		}
		else
		{
			int nopoints = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				PerCam_nf[camID] = PerCam_UV[camID*npts + pid].size();

				if (PerCam_nf[camID] == 0)
					nopoints++;
			}
			if (nopoints > nCams - 2)
				continue;

			//Assemble trajactory and time from all Cameras
			for (int jj = 0; jj < nCams; jj++)
				currentFID_InPoint[jj] = 0;

			while (true)
			{
				//Determine the next camera
				nfinishedCams = 0, earliestCamID, earliestTime = 9e9;
				for (int camID = 0; camID < nCams; camID++)
				{
					if (currentFID_InPoint[camID] == PerCam_nf[camID])
					{
						nfinishedCams++;
						continue;
					}

					//Time:
					frameID = PerCam_UV[camID*npts + pid][currentFID_InPoint[camID]].frameID;
					RollingShutterOffset = 0;
					if (PerCam_UV[camID*npts + pid][currentFID_InPoint[camID]].shutterModel != 0)
						RollingShutterOffset = PerCam_UV[camID*npts + pid][currentFID_InPoint[camID]].pt2D.y / PerCam_UV[camID*npts + pid][currentFID_InPoint[camID]].imHeight;
					currentTime = (currentOffset[camID] + frameID + RollingShutterOffset) * ialpha*Tscale;

					if (currentTime < earliestTime)
					{
						earliestTime = currentTime;
						earliestCamID = camID;
						earliestCamFrameID = frameID;
					}
				}

				//If all cameras are done
				if (nfinishedCams == nCams)
					break;

				//Add new point to the sequence
				VectorTime[pid].push_back(earliestTime);
				VectorCamID[pid].push_back(earliestCamID);
				VectorFrameID[pid].push_back(earliestCamFrameID);
				Traj2DAll[pid].push_back(PerCam_UV[earliestCamID*npts + pid][currentFID_InPoint[earliestCamID]]);
				currentFID_InPoint[earliestCamID]++;
			}
		}

		int nf = Traj2DAll[pid].size();
		Allpt3D[pid] = new double[3 * nf];
		for (int ll = 0; ll < nf; ll++)
			Allpt3D[pid][3 * ll] = Traj2DAll[pid][ll].pt3D.x, Allpt3D[pid][3 * ll + 1] = Traj2DAll[pid][ll].pt3D.y, Allpt3D[pid][3 * ll + 2] = Traj2DAll[pid][ll].pt3D.z;

		//Detect points captured simulatenously
		int groupCount = 0;
		for (int ll = 0; ll < nf; ll++)
			simulatneousPoints[pid].push_back(-1);

		for (int ll = 0; ll < nf - 1; ll++)
		{
			int naddedPoints = 0; bool found = false;
			for (int kk = ll + 1; kk < nf; kk++)
			{
				naddedPoints++;
				if (VectorTime[pid][kk] - VectorTime[pid][ll] > FLT_EPSILON)
					break;
				else
				{
					if (kk - 1 == ll)
						simulatneousPoints[pid][ll] = groupCount;

					simulatneousPoints[pid][kk] = groupCount;
					found = true;
				}
			}

			if (found)
			{
				ll += naddedPoints - 1;
				groupCount++;
			}
		}

		//1st order approx of v
		double ActionCost = 0, ProjCost = 0;
		int oldtype = simulatneousPoints[pid][0];
		for (int ll = 0; ll < nCams; ll++)
			UsedCam[ll] = false;

		for (int ll = 0; ll < nf - 1; ll++)
		{
			int incre = 1;
			while (ll + incre < nf)
			{
				if (simulatneousPoints[pid][ll + incre] == -1 || simulatneousPoints[pid][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[pid][ll + incre];
					break;
				}
				else
				{
					if (Traj2DAll[pid][ll + incre].std3D < 0.0)
					{
						ceres::CostFunction* cost_function = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll + incre].P, Traj2DAll[pid][ll + incre].pt2D, 1.0 / sqrt(lamda));
						problem.AddResidualBlock(cost_function, NULL, Allpt3D[pid] + 3 * ll);
					}
					else
					{
						ceres::CostFunction* cost_function = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll + incre].P, Traj2DAll[pid][ll + incre].pt2D, Traj2DAll[pid][ll + incre].std2D);
						problem.AddResidualBlock(cost_function, NULL, Allpt3D[pid] + 3 * ll);
					}
				}
				incre++;
			}
			if (ll + incre == nf)
				break;

			int camID1 = VectorCamID[pid][ll], camID2 = VectorCamID[pid][ll + incre];
			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[pid][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[pid][ll].pt2D.y / Traj2DAll[pid][ll].imHeight, shutterOffset2 = Traj2DAll[pid][ll + incre].pt2D.y / Traj2DAll[pid][ll + incre].imHeight;

			double costi = LeastActionError(&Allpt3D[pid][3 * ll], &Allpt3D[pid][3 * (ll + incre)], &currentOffset[camID1], &currentOffset[camID2],
				shutterOffset1, shutterOffset2, VectorFrameID[pid][ll], VectorFrameID[pid][ll + incre], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			Point2d P2d_1(Traj2DAll[pid][ll].pt2D.x, Traj2DAll[pid][ll].pt2D.y);
			Point3d P3d_1(Allpt3D[pid][3 * ll], Allpt3D[pid][3 * ll + 1], Allpt3D[pid][3 * ll + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[pid][ll].P, P3d_1, P2d_1);
			ProjCost += costi;

			Point2d P2d_2(Traj2DAll[pid][(ll + incre)].pt2D.x, Traj2DAll[pid][(ll + incre)].pt2D.y);
			Point3d P3d_2(Allpt3D[pid][3 * (ll + incre)], Allpt3D[pid][3 * (ll + incre) + 1], Allpt3D[pid][3 * (ll + incre) + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[pid][(ll + incre)].P, P3d_2, P2d_2);
			ProjCost += costi;

			double  t1 = (currentOffset[camID1] + VectorFrameID[pid][ll] + shutterOffset1) * ialpha*Tscale;
			double  t2 = (currentOffset[camID2] + VectorFrameID[pid][ll + incre] + shutterOffset2) * ialpha*Tscale;

			if (Traj2DAll[pid][ll + incre].std3D < 0.0)
			{
				ceres::CostFunction* cost_function = LeastActionCost3DCeres::CreateAutoDiff(t1, t2, eps, 1.0 / sqrt(1.0 - lamda), motionPriorPower);
				//ceres::CostFunction* cost_function = LeastActionCostCeres::CreateNumerDiffSame(VectorFrameID[pid][ll], VectorFrameID[pid][ll + incre], ialpha, Tscale, eps, motionPriorPower);
				problem.AddResidualBlock(cost_function, NULL, &Allpt3D[pid][3 * ll], &Allpt3D[pid][3 * (ll + incre)]);

				ceres::CostFunction* cost_function2 = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll].P, Traj2DAll[pid][ll].pt2D, 1.0 / sqrt(lamda));
				problem.AddResidualBlock(cost_function2, NULL, Allpt3D[pid] + 3 * ll);

				ceres::CostFunction* cost_function3 = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll + incre].P, Traj2DAll[pid][ll + incre].pt2D, 1.0 / sqrt(lamda));
				problem.AddResidualBlock(cost_function3, NULL, Allpt3D[pid] + 3 * (ll + incre));
			}
			else
			{
				ceres::CostFunction* cost_function = LeastActionCost3DCeres::CreateAutoDiff(t1, t2, eps, Traj2DAll[pid][ll].std3D, motionPriorPower);
				problem.AddResidualBlock(cost_function, NULL, &Allpt3D[pid][3 * ll], &Allpt3D[pid][3 * (ll + incre)]);

				ceres::CostFunction* cost_function2 = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll].P, Traj2DAll[pid][ll].pt2D, Traj2DAll[pid][ll].std2D);
				problem.AddResidualBlock(cost_function2, NULL, Allpt3D[pid] + 3 * ll);

				ceres::CostFunction* cost_function3 = IdealGeoProjectionCeres::Create(Traj2DAll[pid][ll + incre].P, Traj2DAll[pid][ll + incre].pt2D, Traj2DAll[pid][(ll + incre)].std2D);
				problem.AddResidualBlock(cost_function3, NULL, Allpt3D[pid] + 3 * (ll + incre));
			}

			ll += incre - 1;
		}

		ceres::Solver::Options options;
		options.num_threads = 2;
		options.num_linear_solver_threads = 2;
		options.max_num_iterations = 500;
		options.linear_solver_type = ceres::SPARSE_SCHUR;
		options.minimizer_progress_to_stdout = false;
		options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
		options.use_nonmonotonic_steps = true;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);

#pragma omp critical
		{
			CeresCost += summary.final_cost;
			if (!silent)
				cout << "Point: " << pid << " " << summary.BriefReport() << "\n";// cout << "Point: " << pid << " " << summary.FullReport() << "\n";
		}

		//copy simultaneous triggered points
		for (int ll = 0; ll < nf - 1; ll++)
		{
			if (simulatneousPoints[pid][ll] != -1)
			{
				int nPoint = 0;
				for (int kk = ll + 1; kk < nf; kk++)
				{
					nPoint++;
					if (simulatneousPoints[pid][kk] != simulatneousPoints[pid][ll])
						break;
					else
					{
						Allpt3D[pid][3 * kk] = Allpt3D[pid][3 * ll];
						Allpt3D[pid][3 * kk + 1] = Allpt3D[pid][3 * ll + 1];
						Allpt3D[pid][3 * kk + 2] = Allpt3D[pid][3 * ll + 2];
					}
				}
				ll += nPoint - 1;
			}
		}

		for (int ii = 0; ii < Traj2DAll[pid].size(); ii++)
		{
			int camID = VectorCamID[pid][ii], frameID = VectorFrameID[pid][ii];

			bool found = false;
			for (int kk = 0; kk < PerCam_UV[camID*npts + pid].size(); kk++)
			{
				if (frameID == PerCam_UV[camID*npts + pid][kk].frameID)
				{
					PerCam_UV[camID*npts + pid][kk].pt3D = Point3d(Allpt3D[pid][3 * ii], Allpt3D[pid][3 * ii + 1], Allpt3D[pid][3 * ii + 2]);
					found = true;
					break;
				}
			}
			if (!found)
			{
				printf("Serious bug in point-camera-frame association\n");
				abort();
			}
		}
	}
	for (int pid = 0; pid < npts; pid++)
		PerPoint_nFrames.push_back(Traj2DAll[pid].size());

	//Compute cost after optim
	double ActionCost = 0.0, ProjCost = 0.0, lengthCost = 0.0, directionCost = 0;
	for (int pid = 0; pid < npts; pid++)
	{
		int nf = PerPoint_nFrames[pid];
		if (nf == 0)
			continue;
		int oldtype = simulatneousPoints[pid][0];
		for (int ll = 0; ll < nf - 1; ll++)
		{
			int incre = 1;
			while (ll + incre < nf)
			{
				if (simulatneousPoints[pid][ll + incre] == -1 || simulatneousPoints[pid][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[pid][ll + incre];
					break;
				}
				incre++;
			}
			if (ll + incre == nf)
				break;

			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[pid][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[pid][ll].pt2D.y / Traj2DAll[pid][ll].imHeight, shutterOffset2 = Traj2DAll[pid][ll + incre].pt2D.y / Traj2DAll[pid][ll + incre].imHeight;
			int camID1 = VectorCamID[pid][ll], camID2 = VectorCamID[pid][ll + incre];

			double costi = LeastActionError(&Allpt3D[pid][3 * ll], &Allpt3D[pid][3 * (ll + incre)], &currentOffset[camID1], &currentOffset[camID2], shutterOffset1, shutterOffset2,
				VectorFrameID[pid][ll], VectorFrameID[pid][ll + incre], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			ll += incre - 1;
		}
	}
	if (!silent)
		printf("Action cost: %f ", ActionCost);

	for (int pid = 0; pid < npts; pid++)
	{
		int nf = PerPoint_nFrames[pid];
		if (nf == 0)
			continue;
		double costi;
		for (int ll = 0; ll < nf - 1; ll++)
		{
			int viewID = Traj2DAll[pid][ll].viewID, frameID = Traj2DAll[pid][ll].frameID;
			Point2d P2d(Traj2DAll[pid][ll].pt2D.x, Traj2DAll[pid][ll].pt2D.y);
			Point3d P3d(Allpt3D[pid][3 * ll], Allpt3D[pid][3 * ll + 1], Allpt3D[pid][3 * ll + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[pid][ll].P, P3d, P2d);
			ProjCost += costi;
		}
	}
	if (!silent)
		printf("Projection cost: %f ", ProjCost);

	for (int pid = 0; pid < npts; pid++)
	{
		int nf = Traj2DAll[pid].size();
		if (nf == 0)
			continue;
		double costi;
		for (int ll = 0; ll < nf - 1; ll++)
		{
			costi = sqrt(pow(Allpt3D[pid][3 * ll] - Allpt3D[pid][3 * ll + 3], 2) + pow(Allpt3D[pid][3 * ll + 1] - Allpt3D[pid][3 * ll + 4], 2) + pow(Allpt3D[pid][3 * ll + 2] - Allpt3D[pid][3 * ll + 5], 2));
			lengthCost += costi;
		}
	}
	if (!silent)
		printf("Distance Cost: %e.", lengthCost);

	for (int pid = 0; pid < npts; pid++)
	{
		int nf = PerPoint_nFrames[pid];
		if (nf == 0)
			continue;
		int oldtype = simulatneousPoints[pid][0];
		vector<int>Knot;
		Knot.push_back(0);
		for (int ll = 0; ll < nf; ll++)
		{
			int incre = 1;
			while (ll + incre < nf)
			{
				if (simulatneousPoints[pid][ll + incre] == -1 || simulatneousPoints[pid][ll + incre] != oldtype)
				{
					oldtype = simulatneousPoints[pid][ll + incre];
					break;
				}
				incre++;
			}
			if (ll + incre == nf)
				break;
			Knot.push_back(ll + incre);
			ll += incre - 1;
		}

		for (int ll = 0; ll < Knot.size() - 2; ll++)
		{
			int fid1 = Knot[ll], fid2 = Knot[ll + 1], fid3 = Knot[ll + 2];
			double direct1[] = { Allpt3D[pid][3 * fid1] - Allpt3D[pid][3 * fid2], Allpt3D[pid][3 * fid1 + 1] - Allpt3D[pid][3 * fid2 + 1], Allpt3D[pid][3 * fid1 + 2] - Allpt3D[pid][3 * fid2 + 2] };
			double direct2[] = { Allpt3D[pid][3 * fid2] - Allpt3D[pid][3 * fid3], Allpt3D[pid][3 * fid2 + 1] - Allpt3D[pid][3 * fid3 + 1], Allpt3D[pid][3 * fid2 + 2] - Allpt3D[pid][3 * fid3 + 2] };
			normalize(direct1), normalize(direct2);
			directionCost += abs(dotProduct(direct1, direct2));
		}
	}
	if (!silent)
		printf("Direction Cost: %e\n", directionCost);

	Cost[0] = ActionCost, Cost[1] = ProjCost, Cost[2] = lengthCost, Cost[3] = directionCost;

	delete[]VectorTime, delete[]VectorCamID, delete[]VectorFrameID, delete[]simulatneousPoints, delete[]Traj2DAll;

	return CeresCost;
}
double MotionPrior_Optim_ST_Geometric(char *Path, vector<double*> &Allpt3D, vector<ImgPtEle> *PerCam_UV, vector<int> &PerPoint_nFrames, double *currentOffset, int ntracks, bool non_monotonicDescent, int nCams, int motionPriorPower, double Tscale, double ialpha, double eps, double lamda, double *Cost, bool StillImages, bool silent)
{
	double ActionCost = 0.0, ProjCost = 0.0, costi;

	int *currentFrame = new int[nCams], *PerCam_nf = new int[nCams], *currentPID_InTrack = new int[nCams];
	Point3d P3D;
	ImgPtEle ptEle;

	vector<double> VectorTime;
	vector<int> *VectorCamID = new vector<int>[ntracks], *VectorFrameID = new vector<int>[ntracks];
	vector<ImgPtEle> *Traj2DAll = new vector<ImgPtEle>[ntracks];

	double earliestTime, currentTime, RollingShutterOffset;
	int earliestCamFrameID, frameID, nfinishedCams, earliestCamID;

	int *StillImageTimeOrderID = 0;
	double *StillImageTimeOrder = 0;
	if (StillImages)
	{
		StillImageTimeOrderID = new int[nCams];
		StillImageTimeOrder = new double[nCams];
		for (int camID = 0; camID < nCams; camID++)
		{
			StillImageTimeOrder[camID] = currentOffset[camID];
			StillImageTimeOrderID[camID] = camID;
		}
		Quick_Sort_Double(StillImageTimeOrder, StillImageTimeOrderID, 0, nCams - 1);
	}

	ceres::Problem problem;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		if (StillImages)
		{
			VectorTime.clear();

			for (int ii = 0; ii < nCams; ii++)
			{
				int camID = StillImageTimeOrderID[ii];
				double currentTime = StillImageTimeOrder[ii];
				VectorTime.push_back(currentTime);
				VectorCamID[trackID].push_back(camID);
				VectorFrameID[trackID].push_back(0);
				Traj2DAll[trackID].push_back(PerCam_UV[camID*ntracks + trackID][0]);
			}
		}
		else
		{
			int nopoints = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				PerCam_nf[camID] = PerCam_UV[camID*ntracks + trackID].size();

				if (PerCam_nf[camID] == 0)
					nopoints++;
			}
			if (nopoints > nCams - 2)
				continue;

			//Assemble trajactory and time from all Cameras
			VectorTime.clear();
			for (int jj = 0; jj < nCams; jj++)
				currentPID_InTrack[jj] = 0;

			while (true)
			{
				//Determine the next camera
				nfinishedCams = 0, earliestCamID, earliestTime = 9e9;
				for (int camID = 0; camID < nCams; camID++)
				{
					if (currentPID_InTrack[camID] == PerCam_nf[camID])
					{
						nfinishedCams++;
						continue;
					}

					//Time:
					RollingShutterOffset = 0;
					if (PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].shutterModel != 0)
						RollingShutterOffset = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].pt2D.y / PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].imHeight;
					frameID = PerCam_UV[camID*ntracks + trackID][currentPID_InTrack[camID]].frameID;
					currentTime = (currentOffset[camID] + frameID + RollingShutterOffset) * ialpha*Tscale;

					if (currentTime < earliestTime)
					{
						earliestTime = currentTime;
						earliestCamID = camID;
						earliestCamFrameID = frameID;
					}
				}

				//If all cameras are done
				if (nfinishedCams == nCams)
					break;

				//Add new point to the sequence
				VectorTime.push_back(earliestTime);
				VectorCamID[trackID].push_back(earliestCamID);
				VectorFrameID[trackID].push_back(earliestCamFrameID);
				Traj2DAll[trackID].push_back(PerCam_UV[earliestCamID*ntracks + trackID][currentPID_InTrack[earliestCamID]]);

				currentPID_InTrack[earliestCamID]++;
			}
		}

		int npts = Traj2DAll[trackID].size();
		Allpt3D[trackID] = new double[3 * npts];
		for (int ll = 0; ll < npts; ll++)
			Allpt3D[trackID][3 * ll] = Traj2DAll[trackID][ll].pt3D.x, Allpt3D[trackID][3 * ll + 1] = Traj2DAll[trackID][ll].pt3D.y, Allpt3D[trackID][3 * ll + 2] = Traj2DAll[trackID][ll].pt3D.z;

		for (int ll = 0; ll < npts - 1; ll++)//1st order approx of v
		{
			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + 1];

			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[trackID][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[trackID][ll].pt2D.y / Traj2DAll[trackID][ll].imHeight, shutterOffset2 = Traj2DAll[trackID][ll + 1].pt2D.y / Traj2DAll[trackID][ll + 1].imHeight;

			costi = LeastActionError(&Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * ll + 3], &currentOffset[camID1], &currentOffset[camID2], shutterOffset1, shutterOffset2,
				VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			if (camID1 == camID2)
			{
				if (Traj2DAll[trackID][ll].std3D < 0.0) //not using scale for determine uncertainty
				{
					ceres::CostFunction* cost_function = LeastActionCostCeres::CreateAutoDiffSame(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], shutterOffset1, shutterOffset2, ialpha, Tscale, eps, 1.0 / sqrt(1.0 - lamda), motionPriorPower);
					//ceres::CostFunction* cost_function = LeastActionCostCeres::CreateNumerDiffSame(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, rate, eps, motionPriorPower);
					problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + 1)], &currentOffset[camID1]);
				}
				else
				{
					ceres::CostFunction* cost_function = LeastActionCostCeres::CreateAutoDiffSame(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], shutterOffset1, shutterOffset2, ialpha, Tscale, eps, Traj2DAll[trackID][ll].std3D, motionPriorPower);
					problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + 1)], &currentOffset[camID1]);
				}
			}
			else
			{
				if (Traj2DAll[trackID][ll].std3D < 0.0)
				{
					ceres::CostFunction* cost_function = LeastActionCostCeres::CreateAutoDiff(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], shutterOffset1, shutterOffset2, ialpha, Tscale, eps, 1.0 / sqrt(1.0 - lamda), motionPriorPower);
					//ceres::CostFunction* cost_function = LeastActionCostCeres::CreateNumerDiff(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, rate, eps, motionPriorPower);
					problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + 1)], &currentOffset[camID1], &currentOffset[camID2]);
				}
				else
				{
					ceres::CostFunction* cost_function = LeastActionCostCeres::CreateAutoDiff(VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], shutterOffset1, shutterOffset2, ialpha, Tscale, eps, Traj2DAll[trackID][ll].std3D, motionPriorPower);
					problem.AddResidualBlock(cost_function, NULL, &Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * (ll + 1)], &currentOffset[camID1], &currentOffset[camID2]);
				}
			}
		}

		for (int ll = 0; ll < npts; ll++)
		{
			Point2d P2d(Traj2DAll[trackID][ll].pt2D.x, Traj2DAll[trackID][ll].pt2D.y);
			Point3d P3d(Allpt3D[trackID][3 * ll], Allpt3D[trackID][3 * ll + 1], Allpt3D[trackID][3 * ll + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[trackID][ll].P, P3d, P2d);
			ProjCost += costi;

			if (Traj2DAll[trackID][ll].std3D < 0.0)
			{
				ceres::CostFunction* cost_function = IdealGeoProjectionCeres::Create(Traj2DAll[trackID][ll].P, Traj2DAll[trackID][ll].pt2D, 1.0 / sqrt(lamda));
				problem.AddResidualBlock(cost_function, NULL, Allpt3D[trackID] + 3 * ll);
			}
			else
			{
				ceres::CostFunction* cost_function = IdealGeoProjectionCeres::Create(Traj2DAll[trackID][ll].P, Traj2DAll[trackID][ll].pt2D, Traj2DAll[trackID][ll].std2D);
				problem.AddResidualBlock(cost_function, NULL, Allpt3D[trackID] + 3 * ll);
			}
		}
	}
	for (int trackID = 0; trackID < ntracks; trackID++)
		PerPoint_nFrames.push_back(Traj2DAll[trackID].size());
	//ceres::LossFunction* loss_function = new ceres::HuberLoss(10.0);

	//Set bound on the time 
	double Initoffset[1000];
	Initoffset[0] = 0;
	for (int camID = 1; camID < nCams; camID++)
	{
		Initoffset[camID] = currentOffset[camID];
		//problem.SetParameterLowerBound(&currentOffset[camID], 0, Initoffset[camID] - 0.5), problem.SetParameterUpperBound(&currentOffset[camID], 0, Initoffset[camID] + 0.5);
		problem.SetParameterLowerBound(&currentOffset[camID], 0, floor(Initoffset[camID])), problem.SetParameterUpperBound(&currentOffset[camID], 0, ceil(Initoffset[camID])); //lock it in the frame
	}

	//Set fixed parameters
	problem.SetParameterBlockConstant(&currentOffset[0]);

	if (!silent)
		printf("Action cost: %e Projection cost: %e\n", ActionCost, ProjCost);

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 3000;
	options.linear_solver_type = ceres::SPARSE_SCHUR;//SPARSE_NORMAL_CHOLESKY
	options.minimizer_progress_to_stdout = !silent;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = non_monotonicDescent;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (!silent)
		std::cout << summary.FullReport() << "\n";
	else
		std::cout << summary.BriefReport() << "\n";

	double CeresCost = summary.final_cost;
	//Save data
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		if (npts == 0)
			continue;

		for (int ii = 0; ii < npts; ii++)
		{
			int camID = VectorCamID[trackID][ii], frameID = VectorFrameID[trackID][ii];

			bool found = false;
			for (int kk = 0; kk < PerCam_UV[camID*ntracks + trackID].size(); kk++)
			{
				if (frameID == PerCam_UV[camID*ntracks + trackID][kk].frameID)
				{
					PerCam_UV[camID*ntracks + trackID][kk].pt3D = Point3d(Allpt3D[trackID][3 * ii], Allpt3D[trackID][3 * ii + 1], Allpt3D[trackID][3 * ii + 2]);
					found = true;
					break;
				}
			}
			if (!found)
			{
				printf("Serious bug in point-camera-frame association\n");
				abort();
			}
		}
	}


	//Compute cost after optim
	ActionCost = 0.0, ProjCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = PerPoint_nFrames[trackID];
		if (npts == 0)
			continue;

		double costi;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			double shutterOffset1 = 0, shutterOffset2 = 0;
			if (Traj2DAll[trackID][ll].shutterModel != 0)
				shutterOffset1 = Traj2DAll[trackID][ll].pt2D.y / Traj2DAll[trackID][ll].imHeight, shutterOffset2 = Traj2DAll[trackID][ll + 1].pt2D.y / Traj2DAll[trackID][ll + 1].imHeight;
			int camID1 = VectorCamID[trackID][ll], camID2 = VectorCamID[trackID][ll + 1];

			costi = LeastActionError(&Allpt3D[trackID][3 * ll], &Allpt3D[trackID][3 * ll + 3], &currentOffset[camID1], &currentOffset[camID2], shutterOffset1, shutterOffset2, VectorFrameID[trackID][ll], VectorFrameID[trackID][ll + 1], ialpha, Tscale, eps, motionPriorPower);
			ActionCost += costi;

			Point2d P2d_1(Traj2DAll[trackID][ll].pt2D.x, Traj2DAll[trackID][ll].pt2D.y);
			Point3d P3d_1(Allpt3D[trackID][3 * ll], Allpt3D[trackID][3 * ll + 1], Allpt3D[trackID][3 * ll + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[trackID][ll].P, P3d_1, P2d_1);
			ProjCost += costi;

			Point2d P2d_2(Traj2DAll[trackID][ll].pt2D.x, Traj2DAll[trackID][ll].pt2D.y);
			Point3d P3d_2(Allpt3D[trackID][3 * ll], Allpt3D[trackID][3 * ll + 1], Allpt3D[trackID][3 * ll + 2]);
			costi = PinholeReprojectionErrorSimpleDebug(Traj2DAll[trackID][ll].P, P3d_2, P2d_2);
			ProjCost += costi;
		}
	}

	double lengthCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		if (npts == 0)
			continue;

		double costi;
		for (int ll = 0; ll < npts - 1; ll++)
		{
			costi = sqrt(pow(Allpt3D[trackID][3 * ll] - Allpt3D[trackID][3 * ll + 3], 2) + pow(Allpt3D[trackID][3 * ll + 1] - Allpt3D[trackID][3 * ll + 4], 2) + pow(Allpt3D[trackID][3 * ll + 2] - Allpt3D[trackID][3 * ll + 5], 2));
			lengthCost += costi;
		}
	}

	double directionCost = 0.0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int npts = Traj2DAll[trackID].size();
		if (npts == 0)
			continue;

		double direct1[3], direct2[3];
		for (int ll = 0; ll < npts - 2; ll++)
		{
			direct1[0] = Allpt3D[trackID][3 * ll] - Allpt3D[trackID][3 * ll + 3], direct1[1] = Allpt3D[trackID][3 * ll + 1] - Allpt3D[trackID][3 * ll + 4], direct1[2] = Allpt3D[trackID][3 * ll + 2] - Allpt3D[trackID][3 * ll + 5];
			direct2[0] = Allpt3D[trackID][3 * ll + 3] - Allpt3D[trackID][3 * ll + 6], direct2[1] = Allpt3D[trackID][3 * ll + 4] - Allpt3D[trackID][3 * ll + 7], direct2[2] = Allpt3D[trackID][3 * ll + 5] - Allpt3D[trackID][3 * ll + 8];
			normalize(direct1), normalize(direct2);
			directionCost += abs(dotProduct(direct1, direct2));
		}
	}

	if (!silent)
		printf("Action cost: %e Projection cost: %e Distance Cost: %e Direction Cost %e\n ", ActionCost, ProjCost, lengthCost, directionCost);

	Cost[0] = ActionCost, Cost[1] = ProjCost, Cost[2] = lengthCost, Cost[3] = directionCost;

	delete[]VectorCamID, delete[]VectorFrameID, delete[]Traj2DAll;
	delete[]currentFrame, delete[]PerCam_nf, delete[]currentPID_InTrack;

	if (StillImages)
		delete[]StillImageTimeOrderID, delete[]StillImageTimeOrder;

	return CeresCost;
}

double LeastActionSyncBruteForce2DStereo(char *Path, vector<int> &SelectedCams, int startFrame, int stopFrame, int ntracks, vector<double> &OffsetInfo, int LowBound, int UpBound, double frameSize, double lamda, int motionPriorPower, int &totalPoints, bool silient)
{
	//Offset is in timestamp format
	const double Tscale = 1000.0, fps = 30, ialpha = 1.0 / fps, eps = 1.0e-6;
	char Fname[200]; FILE *fp = 0;
	const int nCams = 2;

	//Read calib info
	VideoData VideoInfo[2];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startFrame, stopFrame) == 1)
		abort();
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startFrame, stopFrame) == 1)
		abort();

	int id, frameID, npts;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];
	vector<XYZD> *PerCam_XYZ = new vector<XYZD>[nCams], *XYZ = new vector<XYZD>[ntracks], XYZBK;

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			//fscanf(fp, "%d %d ", &id, &npts);
			int id1, id2;
			fscanf(fp, "%d %d %d ", &id1, &id2, &npts); //ARTag
			id = id1 * 4 + id2;
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int pid = 0; pid < npts; pid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < startFrame)
					continue;

				if (abs(VideoInfo[camID].VideoInfo[frameID].camCenter[0]) + abs(VideoInfo[camID].VideoInfo[frameID].camCenter[1]) + abs(VideoInfo[camID].VideoInfo[frameID].camCenter[2]) < 2)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.viewID = camID, ptEle.frameID = frameID;
					ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	//Generate Calib Info
	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		//Get ray direction, Q, U, P
		int count = 0;
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

				if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];
				}
				else if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 1)
				{
					double *K = VideoInfo[camID].VideoInfo[RealFrameID].K;
					double ycn = (PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - K[5]) / K[4];
					double xcn = (PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[camID].VideoInfo[RealFrameID].wt;
					double *Rcenter = VideoInfo[camID].VideoInfo[RealFrameID].R;
					double *Tcenter = VideoInfo[camID].VideoInfo[RealFrameID].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				PerCam_UV[camID*ntracks + trackID][frameID].shutterModel = VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel;
				for (int kk = 0; kk < 12; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].P[kk] = P[kk];
				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk];
				for (int kk = 0; kk < 3; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk];

				//Q, U
				AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*ntracks + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*ntracks + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - bb[1];

				PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(count, count, count);//Interestingly, Ceres does not work if all the input are the same
				count++;
			}
		}
	}

	//Initialize data for optim
	totalPoints = 0;
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(ntracks);
	vector<double*> All3D(ntracks);
	int NTimeInstances, maxNTimeInstances = 0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		NTimeInstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			NTimeInstances += PerCam_UV[camID*ntracks + trackID].size();
		totalPoints += NTimeInstances;

		if (maxNTimeInstances < NTimeInstances)
			maxNTimeInstances = NTimeInstances;

		PerTrackFrameID[trackID] = new int[NTimeInstances];
		All3D[trackID] = new double[3 * NTimeInstances];
	}


	//Start sliding
	double currentOffset[2], APLDCost[4], ceresCost;
	vector<double> VTimeStamp; VTimeStamp.reserve(maxNTimeInstances);
	vector<Point3d> VTrajectory3D; VTrajectory3D.reserve(maxNTimeInstances);
	int *OffsetID = new int[UpBound - LowBound + 1];
	double*AllCost = new double[UpBound - LowBound + 1],
		*AllACost = new double[UpBound - LowBound + 1],
		*AllPCost = new double[UpBound - LowBound + 1],
		*AllLCost = new double[UpBound - LowBound + 1],
		*AllDCost = new double[UpBound - LowBound + 1];

	int count = 0;
	for (int off = LowBound; off <= UpBound; off++)
	{
		OffsetID[off - LowBound] = off;
		currentOffset[0] = OffsetInfo[0], currentOffset[1] = off *frameSize + OffsetInfo[1];

		PointsPerTrack.clear();
		ceresCost = MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);
		MotionPrior_ML_Weighting(PerCam_UV, ntracks, nCams);
		ceresCost = MotionPrior_Optim_SpatialStructure_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);

		if (silient)
			printf("@off %d (id: %d): C: %.5e Ac: %.5e Pc: %.5e Lc: %.5f Dc: %.5f\n", off, count, ceresCost, APLDCost[0], APLDCost[1], APLDCost[2], APLDCost[3]);
		count++;

		//Clean estimated 3D
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			int dummy = 0;
			for (int camID = 0; camID < nCams; camID++)
			{
				for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
				{
					PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(dummy, dummy, dummy);
					dummy++;
				}
			}
		}

		AllCost[off - LowBound] = ceresCost, AllACost[off - LowBound] = APLDCost[0], AllPCost[off - LowBound] = APLDCost[1], AllLCost[off - LowBound] = APLDCost[2], AllDCost[off - LowBound] = APLDCost[3];
	}

	//Compute minium cost
	Quick_Sort_Double(AllCost, OffsetID, 0, count - 1);

	printf("(%d %d): Min Acost: %.5e, Offset: %.4f (id: %d)\n", SelectedCams[0], SelectedCams[1], AllCost[0], frameSize*OffsetID[0] + OffsetInfo[1], OffsetID[0] - LowBound);
	OffsetInfo[1] += frameSize*OffsetID[0];

	double finalCost = AllCost[0];

	delete[]PerCam_UV, delete[]PerCam_XYZ;
	delete[]OffsetID, delete[]AllCost, delete[]AllACost, delete[]AllPCost, delete[]AllLCost, delete[]AllDCost;

	return finalCost;
}
int LeastActionSyncBruteForce2DTriplet(char *Path, vector<int> &SelectedCams, int startFrame, int stopFrame, int ntracks, vector<double> &OffsetInfo, int LowBound, int UpBound, double frameSize, double lamda, int motionPriorPower)
{
	//Offset is in timestamp format
	const double Tscale = 1000.0, fps = 30, ialpha = 1.0 / fps, eps = 1.0e-6;

	char Fname[200]; FILE *fp = 0;
	const int nCams = 3;

	//Read calib info
	VideoData VideoInfo[3];
	if (ReadVideoDataI(Path, VideoInfo[0], SelectedCams[0], startFrame, stopFrame) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[1], SelectedCams[1], startFrame, stopFrame) == 1)
		return 1;
	if (ReadVideoDataI(Path, VideoInfo[2], SelectedCams[2], startFrame, stopFrame) == 1)
		return 1;

	int id, frameID, npts;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	vector<int>VectorCamID, VectorFrameID;
	vector<double> AllError2D;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];
	vector<XYZD> *PerCam_XYZ = new vector<XYZD>[nCams], *XYZ = new vector<XYZD>[ntracks];

	//Get 2D info
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot open %s\n", Fname);
			return 1;
		}
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &npts);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int pid = 0; pid < npts; pid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}


	//Generate Calib Info
	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		//Get ray direction, Q, U, P
		int pcount = 0;
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

				if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];
				}
				else if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 1)
				{
					double *K = VideoInfo[camID].VideoInfo[RealFrameID].K;
					double ycn = (PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - K[5]) / K[4];
					double xcn = (PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[camID].VideoInfo[RealFrameID].wt;
					double *Rcenter = VideoInfo[camID].VideoInfo[RealFrameID].R;
					double *Tcenter = VideoInfo[camID].VideoInfo[RealFrameID].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				PerCam_UV[camID*ntracks + trackID][frameID].shutterModel = VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel;
				for (int kk = 0; kk < 12; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].P[kk] = P[kk];
				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk];
				for (int kk = 0; kk < 3; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk];

				//Q, U
				AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*ntracks + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*ntracks + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - bb[1];

				PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(pcount, pcount, pcount);
				pcount++;
			}
		}
	}

	//Initialize data for optim
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(ntracks);
	vector<double*> All3D(ntracks);
	int ntimeinstances, maxntimeinstances = 0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		ntimeinstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			ntimeinstances += PerCam_UV[camID*ntracks + trackID].size();

		if (maxntimeinstances < ntimeinstances)
			maxntimeinstances = ntimeinstances;

		PerTrackFrameID[trackID] = new int[ntimeinstances];
		All3D[trackID] = new double[3 * ntimeinstances];
	}

	//Start sliding
	double currentOffset[3], APLDCost[4], ceresCost;
	int *OffsetID = new int[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	Point2d *OffsetValue = new Point2d[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	double *AllCost = new double[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	double *AllACost = new double[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	double *AllPCost = new double[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	double *AllLCost = new double[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	double *AllDCost = new double[(UpBound - LowBound + 1)*(UpBound - LowBound + 1)];
	vector<double> VTimeStamp; VTimeStamp.reserve(maxntimeinstances);
	vector<Point3d> VTrajectory3D; VTrajectory3D.reserve(maxntimeinstances);

	int count = 0;
	//for (int lamdaID = 1; lamdaID <= 100; lamdaID++)
	{
		//lamda = lamdaID*0.01;
		for (int off2 = LowBound; off2 <= UpBound; off2++)
		{
			for (int off1 = LowBound; off1 <= UpBound; off1++)
			{
				OffsetID[count] = count;
				OffsetValue[count] = Point2d(off1, off2);
				currentOffset[0] = OffsetInfo[0], currentOffset[1] = off1*frameSize + OffsetInfo[1], currentOffset[2] = off2*frameSize + OffsetInfo[2];

				PointsPerTrack.clear();
				MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);
				MotionPrior_ML_Weighting(PerCam_UV, ntracks, nCams);
				ceresCost = MotionPrior_Optim_SpatialStructure_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);

				/*for (int trackID = 0; trackID < ntracks; trackID++)
				{
				sprintf(Fname, "%s/ATrack_%d_%d.txt", Path, trackID, count);  FILE *fp = fopen(Fname, "w+");
				for (int camID = 0; camID < nCams; camID++)
				for (int fid = 0; fid < PerCam_UV[camID*ntracks + trackID].size(); fid++)
				fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", PerCam_UV[camID*ntracks + trackID][fid].pt3D.x, PerCam_UV[camID*ntracks + trackID][fid].pt3D.y,
				PerCam_UV[camID*ntracks + trackID][fid].pt3D.z, 1.0*OffsetInfo[camID] * ialpha*Tscale + 1.0*PerCam_UV[camID*ntracks + trackID][fid].frameID * ialpha*Tscale, camID, PerCam_UV[camID*ntracks + trackID][fid].frameID);
				fclose(fp);
				}*/

				printf("@(%d, %d) (id: %d): C: %.5e Ac: %.5e Pc: %.5e Lc: %.5f Dc: %.5f\n", off1, off2, count, ceresCost, APLDCost[0], APLDCost[1], APLDCost[2], APLDCost[3]);
				count++;

				//Clean estimated 3D
				for (int trackID = 0; trackID < ntracks; trackID++)
				{
					int pcount = 0;
					for (int camID = 0; camID < nCams; camID++)
					{
						for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
						{
							PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(pcount, pcount, pcount);
							pcount++;
						}
					}
				}

				AllCost[(off1 - LowBound) + (off2 - LowBound)*(UpBound - LowBound + 1)] = ceresCost,
					AllACost[(off1 - LowBound) + (off2 - LowBound)*(UpBound - LowBound + 1)] = APLDCost[0],
					AllPCost[(off1 - LowBound) + (off2 - LowBound)*(UpBound - LowBound + 1)] = APLDCost[1],
					AllLCost[(off1 - LowBound) + (off2 - LowBound)*(UpBound - LowBound + 1)] = APLDCost[2],
					AllDCost[(off1 - LowBound) + (off2 - LowBound)*(UpBound - LowBound + 1)] = APLDCost[3];
			}
		}
	}

	/*fp = fopen("C:/temp/cost.txt", "w+");
	for (int off2 = LowBound; off2 <= UpBound; off2++)
	{
	for (int off1 = LowBound; off1 <= UpBound; off1++)
	{
	int id = off1 - LowBound + (off2 - LowBound)*(UpBound - LowBound + 1);
	fprintf(fp, "%.3f %.3f %.5e %.5e %.5e %.5e %.5e\n", frameSize*OffsetValue[id].x + OffsetInfo[1], frameSize*OffsetValue[id].y + OffsetInfo[2], AllCost[id], AllACost[id], AllPCost[id], AllLCost[id], AllDCost[id]);
	}
	fprintf(fp, "\n");
	}
	fclose(fp);*/

	Quick_Sort_Double(AllCost, OffsetID, 0, count - 1);
	printf("Min Acost of %.5e with Offset of (%.4f, %.4f) (id: %d)\n", AllCost[0], frameSize*OffsetValue[OffsetID[0]].x + OffsetInfo[1], frameSize*OffsetValue[OffsetID[0]].y + OffsetInfo[2], OffsetID[0]);
	OffsetInfo[0] = 0, OffsetInfo[1] += frameSize*OffsetValue[OffsetID[0]].x, OffsetInfo[2] += frameSize*OffsetValue[OffsetID[0]].y;

	delete[]PerCam_UV, delete[]PerCam_XYZ;
	delete[]OffsetID, delete[]AllCost, delete[]AllACost, delete[]AllPCost, delete[]AllLCost, delete[]AllDCost;

	return 0;
}
int IncrementalLeastActionSyncDiscreteContinous2D(char *Path, vector<int> &SelectedCams, int startFrame, int stopFrame, int npts, vector<double> &OffsetInfo, int LowBound, int UpBound, double frameSize, double lamda, int motionPriorPower, bool RefineConsiderOrdering)
{
	//Offset is in timestamp format
	char Fname[200]; FILE *fp = 0;
	const double Tscale = 1000.0, fps = 30, ialpha = 1.0 / fps, eps = 1.0e-9;

	//Read calib info
	int nCams = (int)SelectedCams.size();
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;

	int frameID, id, nf;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	vector<int>VectorCamID, VectorFrameID;
	vector<double> AllError2D;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*npts];
	vector<XYZD> *PerCam_XYZ = new vector<XYZD>[nCams], *XYZ = new vector<XYZD>[npts];

	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < npts; trackID++)
			PerCam_UV[camID*npts + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		for (int trackID = 0; trackID < npts; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &nf);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int fid = 0; fid < nf; fid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*npts + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int trackID = 0; trackID < npts; trackID++)
	{
		int count = 0;
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*npts + trackID].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*npts + trackID][frameID].frameID;

				if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*npts + trackID][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];
				}
				else if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 1)
				{
					double *K = VideoInfo[camID].VideoInfo[RealFrameID].K;
					double ycn = (PerCam_UV[camID*npts + trackID][frameID].pt2D.y - K[5]) / K[4];
					double xcn = (PerCam_UV[camID*npts + trackID][frameID].pt2D.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[camID].VideoInfo[RealFrameID].wt;
					double *Rcenter = VideoInfo[camID].VideoInfo[RealFrameID].R;
					double *Tcenter = VideoInfo[camID].VideoInfo[RealFrameID].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				PerCam_UV[camID*npts + trackID][frameID].shutterModel = VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel;
				for (int kk = 0; kk < 12; kk++)
					PerCam_UV[camID*npts + trackID][frameID].P[kk] = P[kk];
				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*npts + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk];
				for (int kk = 0; kk < 3; kk++)
					PerCam_UV[camID*npts + trackID][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk];

				//Q, U
				AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*npts + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*npts + trackID][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*npts + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*npts + trackID][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*npts + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*npts + trackID][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*npts + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*npts + trackID][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*npts + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*npts + trackID][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*npts + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*npts + trackID][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*npts + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*npts + trackID][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*npts + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*npts + trackID][frameID].pt2D.y - bb[1];

				PerCam_UV[camID*npts + trackID][frameID].pt3D = Point3d(count, count, count);
				count++;
			}
		}
	}

	//Initialize data for optim
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(npts);
	vector<double*> All3D(npts);
	int ntimeinstances, maxntimeinstances = 0;
	for (int trackID = 0; trackID < npts; trackID++)
	{
		ntimeinstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			ntimeinstances += PerCam_UV[camID*npts + trackID].size();

		if (maxntimeinstances < ntimeinstances)
			maxntimeinstances = ntimeinstances;

		PerTrackFrameID[trackID] = new int[ntimeinstances];
		All3D[trackID] = new double[3 * ntimeinstances];
	}

	//Step 1: Start sliding to make sure that you are at frame level accurate
	double APLDCost[4];
	double currentOffset[MaxnCams];
	vector<double> VTimeStamp; VTimeStamp.reserve(maxntimeinstances);
	vector<Point3d> VTrajectory3D; VTrajectory3D.reserve(maxntimeinstances);

	printf("ST estimation for %d camaras ( ", nCams);
	for (int ii = 0; ii < nCams; ii++)
		printf("%d ", SelectedCams[ii]);
	printf("): \n");

	int NotSuccess = 0;
	if (RefineConsiderOrdering)
	{
		//Step 1: brute force search for the best time stamp. May not work well enough if the distrubution of the correct time stamps are dramatically skew
		if (frameSize > FLT_EPSILON)
		{
			int *OffsetID = new int[UpBound - LowBound + 1];
			double*AllACost = new double[UpBound - LowBound + 1],
				*AllPCost = new double[UpBound - LowBound + 1];

			for (int ii = 0; ii < nCams; ii++)
				currentOffset[ii] = OffsetInfo[ii];

			int count = 0;
			for (int off = LowBound; off <= UpBound; off++)
			{
				//Clean estimated 3D for the next trial
				for (int trackID = 0; trackID < npts; trackID++)
					for (int camID = 0; camID < nCams; camID++)
						for (int frameID = 0; frameID < PerCam_UV[camID*npts + trackID].size(); frameID++)
							PerCam_UV[camID*npts + trackID][frameID].pt3D = Point3d(gaussian_noise(0.0, 1), gaussian_noise(0.0, 1), gaussian_noise(0.0, 1));

				OffsetID[count] = off;
				currentOffset[nCams - 1] = off *frameSize + OffsetInfo[nCams - 1];

				PointsPerTrack.clear();
				printf("Trial %d (%.2f): ", off, off *frameSize + OffsetInfo[nCams - 1]);
				MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, npts, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);
				printf("Ac: %.5e Pc: %.5e Lc: %.5f Dc: %.5f\n", APLDCost[0], APLDCost[1], APLDCost[2], APLDCost[3]);

				AllACost[count] = APLDCost[0], AllPCost[count] = APLDCost[1];
				count++;
			}

			if (count > 1)
			{
				Quick_Sort_Double(AllACost, OffsetID, 0, count - 1);
				OffsetInfo[nCams - 1] += frameSize*OffsetID[0];
				printf("@Brute-force: \t Least action cost: %.5e \t Offset: %.4f\n\n", AllACost[0], OffsetInfo[nCams - 1]);
			}
		}


		//Step 2: insert the new camera to the pre-order camears since brute force sliding may not guarantee correct ordering
		int naddedCams = nCams - 1;
		double subframeRemander[MaxnCams], subframeRemander2[MaxnCams];
		int subframeRemanderID[MaxnCams], subframeRemanderID2[MaxnCams];
		for (int ii = 0; ii < naddedCams; ii++)
		{
			subframeRemanderID[ii] = ii;
			subframeRemander[ii] = OffsetInfo[ii] - floor(OffsetInfo[ii]);
		}
		Quick_Sort_Double(subframeRemander, subframeRemanderID, 0, naddedCams - 1);

		double subframeSlots[MaxnCams];
		for (int ii = 0; ii < naddedCams - 1; ii++)
			subframeSlots[ii] = 0.5*(subframeRemander[ii] + subframeRemander[ii + 1]);
		subframeSlots[naddedCams - 1] = 0.5*(subframeRemander[naddedCams - 1] + subframeRemander[0] + 1.0);

		int bestID = 0;
		double CeresCost, bestCeresCost = 9e20, bestAcost = 9e20;
		double *BestOffset = new double[nCams];
		vector<int> iTimeOrdering, fTimeOrdering;
		int NotFlippedTimes = 0;
		for (int kk = LowBound; kk <= UpBound; kk++)
		{
			for (int ii = 0; ii < naddedCams; ii++)//try different slots
			{
				for (int jj = 0; jj < naddedCams; jj++)
					currentOffset[jj] = OffsetInfo[jj];
				currentOffset[nCams - 1] = floor(OffsetInfo[nCams - 1]) + subframeSlots[ii] + kk;

				for (int jj = 0; jj < nCams; jj++)
				{
					subframeRemanderID[jj] = jj;
					subframeRemander[jj] = currentOffset[jj] - floor(currentOffset[jj]);
				}
				Quick_Sort_Double(subframeRemander, subframeRemanderID, 0, nCams - 1);

				printf("Trial %d/%d (%.4f): ", ii + (kk - LowBound)*naddedCams, (UpBound - LowBound + 1)*naddedCams, currentOffset[nCams - 1]);
				MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, npts, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);
				MotionPrior_ML_Weighting(PerCam_UV, npts, nCams);
				CeresCost = MotionPrior_Optim_ST_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, npts, true, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);

				printf("Cost: %.5e Ac: %.5e Pc: %.5e Lc: %.5f Dc: %.5f\nOffsets:", CeresCost, APLDCost[0], APLDCost[1], APLDCost[2], APLDCost[3]);
				for (int jj = 0; jj < nCams; jj++)
					printf("%.4f ", currentOffset[jj]);
				printf("\n");

				//check if time order has been flipped
				for (int jj = 0; jj < nCams; jj++)
				{
					subframeRemanderID2[jj] = jj;
					subframeRemander2[jj] = currentOffset[jj] - floor(currentOffset[jj]);
				}
				Quick_Sort_Double(subframeRemander2, subframeRemanderID2, 0, nCams - 1);

				bool flipped = false;
				for (int jj = 0; jj < nCams; jj++)
				{
					if (subframeRemanderID[jj] != subframeRemanderID2[jj])
					{
						flipped = true;
						break;
					}
				}
				if (flipped)
				{
					printf("Flipping occurs!\n");
					continue;
				}
				else
					NotFlippedTimes++;

				if (bestCeresCost > CeresCost)
				{
					bestID = ii, bestCeresCost = CeresCost;
					for (int jj = 0; jj < nCams; jj++)
						BestOffset[jj] = currentOffset[jj];
				}

				//Clean estimated 3D
				for (int trackID = 0; trackID < npts; trackID++)
					for (int camID = 0; camID < nCams; camID++)
						for (int frameID = 0; frameID < PerCam_UV[camID*npts + trackID].size(); frameID++)
							PerCam_UV[camID*npts + trackID][frameID].pt3D = Point3d(gaussian_noise(0.0, 1), gaussian_noise(0.0, 1), gaussian_noise(0.0, 1));
			}
		}
		if (NotFlippedTimes == 0)
			NotSuccess = 1;

		if (bestCeresCost < 9e20)
			for (int jj = 0; jj < nCams; jj++)
				OffsetInfo[jj] = BestOffset[jj];
	}
	else
	{
		for (int ii = 0; ii < nCams; ii++)
			currentOffset[ii] = OffsetInfo[ii];

		MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, npts, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);
		MotionPrior_ML_Weighting(PerCam_UV, npts, nCams);
		MotionPrior_Optim_ST_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, npts, true, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, true);

		for (int jj = 0; jj < nCams; jj++)
			OffsetInfo[jj] = currentOffset[jj];
	}

	if (NotSuccess == 0)
	{
		printf("Final temporal estimation: ");
		for (int ii = 0; ii < nCams; ii++)
			printf("%.4f ", OffsetInfo[ii]);
		printf("\n\n");
	}
	else
		printf("Flipping occurs for all trials. Start to shuffle the ordering stack and retry.\n");

	return NotSuccess;
}
int TrajectoryTriangulation(char *Path, vector<int> &SelectedCams, vector<double> &TimeStampInfoVector, int npts, int startFrame, int stopFrame, double lamda, int motionPriorPower)
{
	char Fname[200]; FILE *fp = 0;
	const double Tscale = 1000.0, fps = 30.0, ialpha = 1.0 / fps, eps = 1.0e-6;
	//const double Tscale = 10.0, fps = 1.0, ialpha = 1.0 / fps, eps = 1.0e-6;

	//Read calib info
	int nCams = (int)SelectedCams.size();
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;

	int frameID, id, nf;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	vector<int>VectorCamID, VectorFrameID;
	vector<double> AllError2D;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*npts];

	for (int camID = 0; camID < nCams; camID++)
	{
		for (int pid = 0; pid < npts; pid++)
			PerCam_UV[camID*npts + pid].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		for (int pid = 0; pid < npts; pid++)
		{
			fscanf(fp, "%d %d ", &id, &nf);
			if (id != pid)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int fid = 0; fid < nf; fid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.viewID = camID, ptEle.frameID = frameID, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*npts + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	//Generate Calib Info
	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int pid = 0; pid < npts; pid++)
	{
		//Get ray direction, Q, U, P
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*npts + pid].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*npts + pid][frameID].frameID;

				if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*npts + pid][frameID].R[kk] = VideoInfo[camID].VideoInfo[RealFrameID].R[kk];
				}
				else if (VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel == 1)
				{
					double *K = VideoInfo[camID].VideoInfo[RealFrameID].K;
					double ycn = (PerCam_UV[camID*npts + pid][frameID].pt2D.y - K[5]) / K[4];
					double xcn = (PerCam_UV[camID*npts + pid][frameID].pt2D.x - K[2] - K[1] * ycn) / K[0];

					double *wt = VideoInfo[camID].VideoInfo[RealFrameID].wt;
					double *Rcenter = VideoInfo[camID].VideoInfo[RealFrameID].R;
					double *Tcenter = VideoInfo[camID].VideoInfo[RealFrameID].T;

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(K, R, T, P);
				}
				else
					printf("Not supported model for motion prior sync\n");

				PerCam_UV[camID*npts + pid][frameID].shutterModel = VideoInfo[camID].VideoInfo[RealFrameID].ShutterModel;
				for (int kk = 0; kk < 12; kk++)
					PerCam_UV[camID*npts + pid][frameID].P[kk] = P[kk];
				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*npts + pid][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk];
				for (int kk = 0; kk < 3; kk++)
					PerCam_UV[camID*npts + pid][frameID].camcenter[kk] = VideoInfo[camID].VideoInfo[RealFrameID].camCenter[kk];

				//Q, U
				AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*npts + pid][frameID].Q[0] = AA[0] - PerCam_UV[camID*npts + pid][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*npts + pid][frameID].Q[1] = AA[1] - PerCam_UV[camID*npts + pid][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*npts + pid][frameID].Q[2] = AA[2] - PerCam_UV[camID*npts + pid][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*npts + pid][frameID].Q[3] = AA[3] - PerCam_UV[camID*npts + pid][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*npts + pid][frameID].Q[4] = AA[4] - PerCam_UV[camID*npts + pid][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*npts + pid][frameID].Q[5] = AA[5] - PerCam_UV[camID*npts + pid][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*npts + pid][frameID].u[0] = dd[0] * PerCam_UV[camID*npts + pid][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*npts + pid][frameID].u[1] = dd[0] * PerCam_UV[camID*npts + pid][frameID].pt2D.y - bb[1];

				double stdA = 100.0;//Interestingly, Ceres does not work if all the input are the same-->need some random perturbation. 
				PerCam_UV[camID*npts + pid][frameID].pt3D = Point3d(gaussian_noise(0.0, stdA), gaussian_noise(0.0, stdA), gaussian_noise(0.0, stdA));
			}
		}
	}

	//Initialize data for optim
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(npts);
	vector<double*> All3D(npts);
	int ntimeinstances, maxntimeinstances = 0;
	for (int pid = 0; pid < npts; pid++)
	{
		ntimeinstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			ntimeinstances += PerCam_UV[camID*npts + pid].size();

		if (maxntimeinstances < ntimeinstances)
			maxntimeinstances = ntimeinstances;

		PerTrackFrameID[pid] = new int[ntimeinstances];
		All3D[pid] = new double[3 * ntimeinstances];
	}

	double APLDCost[4];
	vector<double> VTimeStamp; VTimeStamp.reserve(maxntimeinstances);
	vector<Point3d> VTrajectory3D; VTrajectory3D.reserve(maxntimeinstances);

	double *OffsetInfo = new double[nCams];
	for (int ii = 0; ii < nCams; ii++)
		OffsetInfo[ii] = TimeStampInfoVector[ii];

	//MotionPrior_Optim_SpatialStructure_NoSimulatenousPoints(Path, All3D, PerCam_UV, PointsPerTrack, OffsetInfo, npts, false, nCams, Tscale, ialpha, eps, lamda, APLDCost, false, false);
	printf("Algrebraic triangulation:\n");
	MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, OffsetInfo, npts, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, false);

	printf("\nGeometric triangulation:\n");
	MotionPrior_ML_Weighting(PerCam_UV, npts, nCams);
	MotionPrior_Optim_SpatialStructure_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, OffsetInfo, npts, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, false);

	for (int pid = 0; pid < npts; pid++)
	{
		sprintf(Fname, "%s/Track3D/OptimizedRaw_Track_%d.txt", Path, pid);  FILE *fp = fopen(Fname, "w+");
		for (int camID = 0; camID < nCams; camID++)
			for (int fid = 0; fid < PerCam_UV[camID*npts + pid].size(); fid++)
				fprintf(fp, "%.8f %.8f %.8f %.4f %d %d\n", PerCam_UV[camID*npts + pid][fid].pt3D.x, PerCam_UV[camID*npts + pid][fid].pt3D.y, PerCam_UV[camID*npts + pid][fid].pt3D.z,
				1.0*OffsetInfo[camID] * ialpha*Tscale + 1.0*PerCam_UV[camID*npts + pid][fid].frameID * ialpha*Tscale, SelectedCams[camID], PerCam_UV[camID*npts + pid][fid].frameID);
		fclose(fp);
	}

	delete[]PerCam_UV, delete[]OffsetInfo;
	return 0;
}

int EvaluateAllPairCost(char *Path, int nCams, int nTracks, int startFrame, int stopFrame, int SearchRange, double SearchStep, double lamda, int motionPriorPower, double *InitialOffset)
{
	char Fname[200];
	int  totalPts;
	double cost;
	vector<int>Pair(2);
	vector<double> PairOffset(2), baseline;

	//Base on cameras' baseline
	VideoData *VideoIInfo = new VideoData[nCams];
	for (int ii = 0; ii < nCams; ii++)
		if (ReadVideoDataI(Path, VideoIInfo[ii], ii, startFrame, stopFrame) == 1)
			abort();

	printf("Motion prior sync:\n");
	sprintf(Fname, "%s/PairwiseCost.txt", Path); FILE *fp = fopen(Fname, "w+");
	for (int ii = 0; ii < nCams - 1; ii++)
	{
		for (int jj = ii + 1; jj < nCams; jj++)
		{
			Pair[0] = ii, Pair[1] = jj;
			PairOffset[0] = InitialOffset[ii], PairOffset[1] = InitialOffset[jj];

			//Base on Motion prior
			cost = LeastActionSyncBruteForce2DStereo(Path, Pair, startFrame, stopFrame, nTracks, PairOffset, -SearchRange, SearchRange, SearchStep, lamda, motionPriorPower, totalPts);

			for (int fid1 = startFrame; fid1 <= stopFrame; fid1++)
			{
				int fid2 = fid1 - (int)(InitialOffset[ii] - InitialOffset[jj] + 0.5);
				if (fid2 < 0 || fid2>stopFrame)
					continue;
				if (VideoIInfo[ii].VideoInfo[fid1].valid && VideoIInfo[jj].VideoInfo[fid2].valid)
					baseline.push_back(Distance3D(VideoIInfo[ii].VideoInfo[fid1].camCenter, VideoIInfo[jj].VideoInfo[fid2].camCenter));
			}
			double avgBaseline = MeanArray(baseline);

			fprintf(fp, "%d %d %d %.3e %.8e %.3f\n", Pair[0], Pair[1], totalPts, avgBaseline, cost, PairOffset[1] - PairOffset[0]);
			baseline.clear();
		}
	}
	fclose(fp);

	printf("\n");
	return 0;
}
int DetermineCameraOrderingForGreedySTBA(char *Path, char *PairwiseSyncFilename, int nCams, vector<int>&CameraOrder, vector<double> &OffsetInfo)
{
	//Offset info is corresponded to the camera order
	typedef boost::adjacency_list < boost::vecS, boost::vecS, boost::undirectedS, boost::property<boost::vertex_distance_t, int>, boost::property < boost::edge_weight_t, double > > Graph;
	typedef boost::graph_traits < Graph >::edge_descriptor Edge;
	typedef boost::graph_traits < Graph >::vertex_descriptor Vertex;
	typedef std::pair < int, int >E;

	int v1, v2, nvalidPts;
	double baseline, TrajCost, offset;
	char Fname[200];
	int *nValidPts = new int[nCams*nCams];
	double *TimeOffset = new double[nCams*nCams],
		*BaseLine = new double[nCams*nCams],
		*Traj3dCost = new double[nCams*nCams];
	for (int ii = 0; ii < nCams*nCams; ii++)
		TimeOffset[ii] = 0, BaseLine[ii] = 0, Traj3dCost[ii] = 0;

	sprintf(Fname, "%s/%s.txt", Path, PairwiseSyncFilename);
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot open %s\n", Fname);
		return 1;
	}
	while (fscanf(fp, "%d %d %d %lf %lf %lf ", &v1, &v2, &nvalidPts, &baseline, &TrajCost, &offset) != EOF)
		TimeOffset[v1 + v2*nCams] = offset, TimeOffset[v2 + v1*nCams] = offset,
		nValidPts[v1 + v2*nCams] = nvalidPts, nValidPts[v2 + v1*nCams] = nvalidPts,
		BaseLine[v1 + v2*nCams] = baseline, BaseLine[v2 + v1*nCams] = baseline,
		Traj3dCost[v1 + v2*nCams] = TrajCost, Traj3dCost[v2 + v1*nCams] = TrajCost;
	fclose(fp);

#ifdef ENABLE_DEBUG_FLAG
	sprintf(Fname, "%s/timeConstrantoffset.txt", Path);	fp = fopen(Fname, "w+");
	for (int kk = 0; kk < nCams; kk++)
	{
		for (int ll = 0; ll < nCams; ll++)
			fprintf(fp, "%.4f ", TimeOffset[kk + ll*nCams]);
		fprintf(fp, "\n");
}
	fclose(fp);
#endif

	//Form edges weight based on the consistency of the triplet
	int num_nodes = nCams, nedges = nCams*(nCams - 1) / 2;
	E *edges = new E[nedges];
	double *weightTable = new double[nCams*nCams];
	double *weights = new double[nedges];
	for (int ii = 0; ii < nCams*nCams; ii++)
		weightTable[ii] = 0;

	int count = 0;
	for (int kk = 0; kk < nCams - 1; kk++)
	{
		for (int ll = kk + 1; ll < nCams; ll++)
		{
			edges[count] = E(kk, ll), weights[count] = 0.0;
			//Consistency_score_kl = sum_j(Offset_kj+Offset_jl);
			for (int jj = 0; jj < nCams; jj++)
			{
				if (jj == ll || jj == kk)
					continue;
				if (jj >= ll) //kl = kj-lj
					weights[count] += abs(TimeOffset[kk + jj*nCams] - TimeOffset[ll + jj*nCams] - TimeOffset[kk + ll*nCams]);
				else if (jj <= kk) //kl = -jk + jl
					weights[count] += abs(-TimeOffset[jj + kk*nCams] + TimeOffset[jj + ll*nCams] - TimeOffset[kk + ll*nCams]);
				else //kl = kj+jl
					weights[count] += abs(TimeOffset[kk + jj*nCams] + TimeOffset[jj + ll*nCams] - TimeOffset[kk + ll*nCams]);
			}

			//Weight them by the # visible points along all trajectories and the average baseline between cameras
			weights[count] = weights[count] / (BaseLine[kk + ll*nCams] * nValidPts[kk + ll*nCams] + DBL_EPSILON);
			weightTable[kk + ll*nCams] = weights[count], weightTable[ll + kk*nCams] = weights[count];
			count++;
		}
	}

#ifdef ENABLE_DEBUG_FLAG
	sprintf(Fname, "%s/weightTable.txt", Path);	fp = fopen(Fname, "w+");
	for (int kk = 0; kk < nCams; kk++)
	{
		for (int ll = 0; ll < nCams; ll++)
			fprintf(fp, "%.4e ", weightTable[kk + ll*nCams]);
		fprintf(fp, "\n");
		}
	fclose(fp);
#endif

	//Estimate incremental camera order by Kruskal MST 
	Graph g(edges, edges + sizeof(E)*nedges / sizeof(E), weights, num_nodes);
	boost::property_map<Graph, boost::edge_weight_t>::type weightmap = get(boost::edge_weight, g);
	std::vector < Edge > spanning_tree;

	boost::kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));

	cout << "Print the edges in the MST:" << endl;
	for (vector < Edge >::iterator ei = spanning_tree.begin(); ei != spanning_tree.end(); ei++)
		cout << source(*ei, g) << " <--> " << target(*ei, g) << " with weight of " << weightmap[*ei] << endl;


	//Store the ordering and subframe offset info. Note that source id is always smaller than target id
	int RootCamera = spanning_tree[0].m_source;
	CameraOrder.push_back(RootCamera); OffsetInfo.push_back(0.0);
	for (int ii = 0; ii < spanning_tree.size(); ii++)
	{
		bool added = false;
		int cam1 = spanning_tree[ii].m_source, cam2 = spanning_tree[ii].m_target;
		for (int jj = 0; jj < (int)CameraOrder.size(); jj++)
		{
			if (CameraOrder[jj] == cam1)
			{
				added = true;
				break;
			}
		}

		if (!added)
		{
			CameraOrder.push_back(cam1);
			if (RootCamera < cam1)
				OffsetInfo.push_back(TimeOffset[RootCamera + cam1*nCams]);
			else
				OffsetInfo.push_back(-TimeOffset[RootCamera + cam1*nCams]);
		}

		added = false;
		for (int jj = 0; jj < (int)CameraOrder.size(); jj++)
		{
			if (CameraOrder[jj] == cam2)
			{
				added = true;
				break;
			}
		}

		if (!added)
		{
			CameraOrder.push_back(cam2);
			if (RootCamera < cam2)
				OffsetInfo.push_back(TimeOffset[RootCamera + cam2*nCams]);
			else
				OffsetInfo.push_back(-TimeOffset[RootCamera + cam2*nCams]);
		}
	}

	sprintf(Fname, "%s/MotionPriorSync.txt", Path);	fp = fopen(Fname, "w+");
	for (int kk = 0; kk < nCams; kk++)
		fprintf(fp, "%d %.4e \n", CameraOrder[kk], OffsetInfo[kk]);
	fclose(fp);

	delete[]weights, delete[]nValidPts, delete[]BaseLine, delete[]Traj3dCost, delete[]weightTable, delete[]TimeOffset, delete[]edges;

	return 0;
	}

int Combine3DStatisticFromRandomSampling(char *Path, int nCams, int ntracks)
{
	vector<int> availFileID;
	char Fname[200];
	for (int ii = 0; ii < 10000; ii++)
	{
		sprintf(Fname, "%s/ATrack_0_%d.txt", Path, ii); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			availFileID.push_back(ii);
			fclose(fp);
		}
	}

	int navailFiles = availFileID.size(), fileCount = 0, nframes;
	double x, y, z, t;
	vector<double> *timeStamp = new vector<double>[ntracks];
	vector<Point3d>*Traject3D_iTrial = new vector<Point3d>[navailFiles*ntracks];
	for (int ii = 0; ii < navailFiles; ii++)
	{
		for (int tid = 0; tid < ntracks; tid++)
		{
			sprintf(Fname, "%s/ATrack_%d_%d.txt", Path, tid, availFileID[ii]); FILE *fp = fopen(Fname, "r");
			nframes = 0;
			while (fscanf(fp, "%lf %lf %lf %lf", &x, &y, &z, &t) != EOF)
			{
				if (fileCount == 0)
					timeStamp[tid].push_back(t);
				else	if (abs(timeStamp[tid][nframes] - t) > 0.1)
				{
					printf("Something wrong with the time stamp!");
					abort();
				}

				Traject3D_iTrial[fileCount*ntracks + tid].push_back(Point3d(x, y, z));
				nframes++;
			}
			fclose(fp);
		}
		fileCount++;
	}

	vector<Point3d> *P3D_Mean = new vector<Point3d>[ntracks], *P3D_STD = new vector<Point3d>[ntracks];
	for (int tid = 0; tid < ntracks; tid++)
		for (int fid = 0; fid < Traject3D_iTrial[tid].size(); fid++)
			P3D_Mean[tid].push_back(Point3d(0, 0, 0)), P3D_STD[tid].push_back(Point3d(0, 0, 0));

	for (int fileCount = 0; fileCount < navailFiles; fileCount++)
		for (int tid = 0; tid < ntracks; tid++)
			for (int fid = 0; fid < Traject3D_iTrial[fileCount*ntracks + tid].size(); fid++)
				P3D_Mean[tid][fid].x += Traject3D_iTrial[fileCount*ntracks + tid][fid].x / navailFiles,
				P3D_Mean[tid][fid].y += Traject3D_iTrial[fileCount*ntracks + tid][fid].y / navailFiles,
				P3D_Mean[tid][fid].z += Traject3D_iTrial[fileCount*ntracks + tid][fid].z / navailFiles;

	for (int fileCount = 0; fileCount < navailFiles; fileCount++)
		for (int tid = 0; tid < ntracks; tid++)
			for (int fid = 0; fid < Traject3D_iTrial[fileCount*ntracks + tid].size(); fid++)
				P3D_STD[tid][fid].x += pow(Traject3D_iTrial[fileCount*ntracks + tid][fid].x - P3D_Mean[tid][fid].x, 2) / (navailFiles - 1),
				P3D_STD[tid][fid].y += pow(Traject3D_iTrial[fileCount*ntracks + tid][fid].y - P3D_Mean[tid][fid].y, 2) / (navailFiles - 1),
				P3D_STD[tid][fid].z += pow(Traject3D_iTrial[fileCount*ntracks + tid][fid].z - P3D_Mean[tid][fid].z, 2) / (navailFiles - 1);


	for (int tid = 0; tid < ntracks; tid++)
	{
		sprintf(Fname, "%s/ATrackMSTD_%d.txt", Path, tid);  FILE *fp = fopen(Fname, "w+");
		for (int fid = 0; fid < P3D_Mean[tid].size(); fid++)
			fprintf(fp, "%.4f %.4f %.4f %.6f %.6f %.6f %.2f\n", P3D_Mean[tid][fid].x, P3D_Mean[tid][fid].y, P3D_Mean[tid][fid].z, sqrt(P3D_STD[tid][fid].x), sqrt(P3D_STD[tid][fid].y), sqrt(P3D_STD[tid][fid].z), timeStamp[tid][fid]);
		fclose(fp);
	}

	return 0;
}
int Generate3DUncertaintyFromRandomSampling(char *Path, vector<int> SelectedCams, vector<double> OffsetInfo, int startFrame, int stopFrame, int ntracks, int startSample, int nSamples, int motionPriorPower)
{
	char Fname[200]; FILE *fp = 0;
	const double Tscale = 1000.0, fps = 60, ialpha = 1.0 / fps, eps = 1.0e-6, rate = 1.0, lamda = .3;

	//Read calib info
	int nCams = (int)SelectedCams.size();
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;

	int frameID, id, npts;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	ImgPtEle ptEle;
	vector<ImgPtEle> *orgPerCam_UV = new vector<ImgPtEle>[nCams*ntracks];

	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			orgPerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/C_%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &npts);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int pid = 0; pid < npts; pid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					orgPerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	//Sample 2d points with gaussian noise
	const double NoiseMag = 0;
	double startTime = omp_get_wtime();

	int numThreads = 1;
	for (int trialID = 0; trialID < nSamples; trialID++)
	{
		vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int trackID = 0; trackID < ntracks; trackID++)
				PerCam_UV[camID*ntracks + trackID].reserve(orgPerCam_UV[camID*ntracks + trackID].size());

			for (int trackID = 0; trackID < ntracks; trackID++)
			{
				for (int pid = 0; pid < orgPerCam_UV[camID*ntracks + trackID].size(); pid++)
				{
					ptEle.pt2D.x = orgPerCam_UV[camID*ntracks + trackID][pid].pt2D.x + max(min(gaussian_noise(0, NoiseMag), 4.0*NoiseMag), -4.0*NoiseMag);
					ptEle.pt2D.y = orgPerCam_UV[camID*ntracks + trackID][pid].pt2D.y + max(min(gaussian_noise(0, NoiseMag), 4.0*NoiseMag), -4.0*NoiseMag);
					ptEle.frameID = orgPerCam_UV[camID*ntracks + trackID][pid].frameID;
					PerCam_UV[camID*ntracks + trackID].push_back(ptEle);
				}
			}
		}

		double P[12], AA[6], bb[2], ccT[3], dd[1];
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			for (int camID = 0; camID < nCams; camID++)
			{
				for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
				{
					int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

					for (int kk = 0; kk < 12; kk++)
					{
						P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];
						PerCam_UV[camID*ntracks + trackID][frameID].P[kk] = P[kk];
					}

					for (int kk = 0; kk < 9; kk++)
						PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],

						//Q, U
						AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
					AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
					ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

					PerCam_UV[camID*ntracks + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[0],
						PerCam_UV[camID*ntracks + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[1],
						PerCam_UV[camID*ntracks + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[2];
					PerCam_UV[camID*ntracks + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[0],
						PerCam_UV[camID*ntracks + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[1],
						PerCam_UV[camID*ntracks + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[2];
					PerCam_UV[camID*ntracks + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - bb[0],
						PerCam_UV[camID*ntracks + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - bb[1];

					double stdA = 100.0;//Interestingly, Ceres does not work if all the input are the same-->need some random perturbation. 
					PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(gaussian_noise(0.0, stdA), gaussian_noise(0.0, stdA), gaussian_noise(0.0, stdA));
				}
			}
		}

		//Initialize data for optim
		vector<int> PointsPerTrack;
		vector<int *> PerTrackFrameID(ntracks);
		vector<double*> All3D(ntracks);
		int ntimeinstances, maxntimeinstances = 0;
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			ntimeinstances = 0;
			for (int camID = 0; camID < nCams; camID++)
				ntimeinstances += PerCam_UV[camID*ntracks + trackID].size();

			if (maxntimeinstances < ntimeinstances)
				maxntimeinstances = ntimeinstances;

			PerTrackFrameID[trackID] = new int[ntimeinstances];
			All3D[trackID] = new double[3 * ntimeinstances];
		}

		double currentOffset[MaxnCams], APLDCost[4];
		for (int ii = 0; ii < nCams; ii++)
			currentOffset[ii] = OffsetInfo[ii];

		MotionPrior_Optim_SpatialStructure_Algebraic(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, motionPriorPower, Tscale, ialpha, eps, lamda, APLDCost, false, false);
		MotionPrior_ML_Weighting(PerCam_UV, ntracks, nCams);
		//MotionPrior_Optim_SpatialStructure_Geometric(Path, All3D, PerCam_UV, PointsPerTrack, currentOffset, ntracks, false, nCams, Tscale, ialpha, eps, lamda, APLDCost, false, false);

		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			sprintf(Fname, "%s/ATrack_%d_%d.txt", Path, trackID, trialID + startSample);  FILE *fp = fopen(Fname, "w+");
			for (int camID = 0; camID < nCams; camID++)
				for (int fid = 0; fid < PerCam_UV[camID*ntracks + trackID].size(); fid++)
					fprintf(fp, "%.4f %.4f %.4f %.2f %d %d\n", PerCam_UV[camID*ntracks + trackID][fid].pt3D.x, PerCam_UV[camID*ntracks + trackID][fid].pt3D.y, PerCam_UV[camID*ntracks + trackID][fid].pt3D.z,
					1.0*currentOffset[camID] * ialpha*Tscale + 1.0*PerCam_UV[camID*ntracks + trackID][fid].frameID * ialpha*Tscale*rate, camID, PerCam_UV[camID*ntracks + trackID][fid].frameID);
			fclose(fp);
		}

		printf("%.1f%% ... TR: %.2fs\n", 100.0*trialID / nSamples, (omp_get_wtime() - startTime) / (trialID + 0.000001)*(nSamples - trialID));
		delete[]PerCam_UV;
	}

	return 0;
}

struct CeresResamplingSpline {
	CeresResamplingSpline(double *XIn, double *PIn, double *PhiDataIn, double *PhiPriorIn, double *TimeStampDatain, double *TimeStampPriorIn, Point2d *pt2DIn, double lamda, int nData, int nResamples, int nCoeffs) :lamda(lamda), nData(nData), nResamples(nResamples), nCoeffs(nCoeffs)
	{
		X = XIn, P = PIn, PhiData = PhiDataIn, PhiPrior = PhiPriorIn, TimeStampData = TimeStampDatain, TimeStampPrior = TimeStampPriorIn, pt2D = pt2DIn;
	}

	template <typename T>    bool operator()(T const* const* C, T* residuals)     const
	{
		//cost = lamda*(PBC-u)^2 + (1-lamda)*Prior
		T x, y, z, numX, numY, denum, sqrtlamda1 = sqrt((T)lamda), lamda2 = (T)1.0 - lamda, lamda3 = (T)2.0;

		//Projection cost 
		for (int ii = 0; ii < nData; ii++)
		{
			x = (T) 0.0, y = (T) 0.0, z = (T)0.0;
			for (int jj = 0; jj < nCoeffs; jj++)
			{
				if (PhiData[jj + ii*nCoeffs] < 0.00001)
					continue;
				x += (T)PhiData[jj + ii*nCoeffs] * C[0][jj],
					y += (T)PhiData[jj + ii*nCoeffs] * C[0][jj + nCoeffs],
					z += (T)PhiData[jj + ii*nCoeffs] * C[0][jj + 2 * nCoeffs];
			}


			numX = (T)P[12 * ii] * x + (T)P[12 * ii + 1] * y + (T)P[12 * ii + 2] * z + (T)P[12 * ii + 3];
			numY = (T)P[12 * ii + 4] * x + (T)P[12 * ii + 5] * y + (T)P[12 * ii + 6] * z + (T)P[12 * ii + 7];
			denum = (T)P[12 * ii + 8] * x + (T)P[12 * ii + 9] * y + (T)P[12 * ii + 10] * z + (T)P[12 * ii + 11];

			residuals[2 * ii] = (T)sqrtlamda1*(numX / denum - (T)pt2D[ii].x);
			residuals[2 * ii + 1] = (T)sqrtlamda1*(numY / denum - (T)pt2D[ii].y);
		}

		//Motion cost 
		/*T xo, yo, zo;
		for (int ii = 0; ii < nResamples; ii++)
		{
		x = (T) 0.0, y = (T) 0.0, z = (T)0.0;
		for (int jj = 0; jj < nCoeffs; jj++)
		{
		if (PhiPrior[jj + ii*nCoeffs] < 0.00001)
		continue;
		x += (T)PhiPrior[jj + ii*nCoeffs] * C[0][jj],
		y += (T)PhiPrior[jj + ii*nCoeffs] * C[0][jj + nCoeffs],
		z += (T)PhiPrior[jj + ii*nCoeffs] * C[0][jj + 2 * nCoeffs];
		}

		if (ii > 0)
		{
		T dx = x - xo, dy = y - yo, dz = z - zo;
		T error = (T)lamda2*(dx*dx + dy*dy + dz*dz) / (T)(TimeStampPrior[ii] - TimeStampPrior[ii - 1]);
		residuals[2 * nData + ii - 1] = sqrt(max((T)(1.0e-16), error));
		}
		xo = x, yo = y, zo = z;
		}*/

		return true;
	}

	int nData, nResamples, nCoeffs;
	double lamda;
	double  *X, *P, *PhiData, *PhiPrior, *TimeStampData, *TimeStampPrior;
	Point2d *pt2D;
};
void ResamplingOf3DTrajectorySpline(vector<ImgPtEle> &Traj3D, bool non_monotonicDescent, double Break_Step, double Resample_Step, double lamda, bool silent = true)
{
	const int SplineOrder = 4;

	double earliest = Traj3D[0].timeStamp, latest = Traj3D.back().timeStamp;
	int nBreaks = (int)(ceil((ceil(latest) - floor(earliest)) / Break_Step)) + 1, nCoeffs = nBreaks + 2, nData = (int)Traj3D.size(), nptsPrior = (int)((latest - earliest) / Resample_Step);

	double*BreakPts = new double[nBreaks], *X = new double[nData * 3];
	double *PhiData = new double[nData*nCoeffs], *PhiPrior = new double[nptsPrior*nCoeffs], *C = new double[3 * nCoeffs];
	double *PmatData = new double[nData * 12], *TimeStampData = new double[nData], *TimeStampPrior = new double[nptsPrior];
	Point2d *pt2dData = new Point2d[nData];

	for (int ii = 0; ii < nBreaks; ii++)
		BreakPts[ii] = floor(earliest) + Break_Step*ii;

	for (int ii = 0; ii < nData; ii++)
	{
		for (int jj = 0; jj < 12; jj++)
			PmatData[12 * ii + jj] = Traj3D[ii].P[jj];

		TimeStampData[ii] = Traj3D[ii].timeStamp;

		pt2dData[ii] = Traj3D[ii].pt2D;

		X[ii] = Traj3D[ii].pt3D.x, X[ii + nData] = Traj3D[ii].pt3D.y, X[ii + 2 * nData] = Traj3D[ii].pt3D.z;
	}

	for (int ii = 0; ii < nptsPrior; ii++)
		TimeStampPrior[ii] = floor(earliest) + Resample_Step*ii;

	//Find and delete breakpts with no data in between (this makes the basis matrix to be ill-condition)
	vector<int>IdToDel;
	for (int ii = 0; ii < nBreaks - 1; ii++)
	{
		bool found = false;
		for (int jj = 0; jj < nData; jj++)
		{
			if ((BreakPts[ii] < TimeStampData[jj] && TimeStampData[jj] < BreakPts[ii + 1]))
			{
				found = true;
				break;
			}
		}
		if (!found)
			IdToDel.push_back(ii + 1);
	}
	if ((int)IdToDel.size() > 0)
	{
		vector<double> tBreakPts;
		for (int ii = 0; ii < nBreaks; ii++)
			tBreakPts.push_back(BreakPts[ii]);

		for (int ii = (int)IdToDel.size() - 1; ii >= 0; ii--)
			tBreakPts.erase(tBreakPts.begin() + IdToDel[ii]);

		nBreaks = (int)tBreakPts.size(), nCoeffs = nBreaks + 2;
		for (int ii = 0; ii < nBreaks; ii++)
			BreakPts[ii] = tBreakPts[ii];
	}

	//Generate Spline Basis
	//GenerateResamplingSplineBasisWithBreakPts(PhiData, TimeStampData, BreakPts, nData, nBreaks, SplineOrder);
	//GenerateResamplingSplineBasisWithBreakPts(PhiPrior, TimeStampPrior, BreakPts, nptsPrior, nBreaks, SplineOrder);
	BSplineGetAllBasis(PhiData, TimeStampData, BreakPts, nData, nBreaks, SplineOrder);
	BSplineGetAllBasis(PhiPrior, TimeStampPrior, BreakPts, nptsPrior, nBreaks, SplineOrder);


	//Initialize basis coefficients: X_data = Phi_data*C
	for (int jj = 0; jj < 3; jj++)
	{
		LS_Solution_Double(PhiData, X + jj*nData, nData, nCoeffs);
		for (int ii = 0; ii < nCoeffs; ii++)
			C[ii + jj*nCoeffs] = X[ii + jj*nData];
	}

#ifdef ENABLE_DEBUG_FLAG
	double ActionCost = 0, ProjCost = 0;
	for (int ii = 0; ii < nData - 1; ii++)
	{
		double xyz1[] = { Traj3D[ii].pt3D.x, Traj3D[ii].pt3D.y, Traj3D[ii].pt3D.z };
		double xyz2[] = { Traj3D[ii + 1].pt3D.x, Traj3D[ii + 1].pt3D.y, Traj3D[ii + 1].pt3D.z };
		double costi = LeastActionError(xyz1, xyz2, Traj3D[ii].timeStamp, Traj3D[ii + 1].timeStamp, 1.0e-6, 2);
		ActionCost += costi;
	}

	for (int ii = 0; ii < nData; ii++)
	{
		int  camID = Traj3D[ii].viewID, frameID = Traj3D[ii].frameID;
		Point2d p2d = Traj3D[ii].pt2D;
		Point3d p3d = Traj3D[ii].pt3D;
		double	err = PinholeReprojectionErrorSimpleDebug(Traj3D[ii].P, Traj3D[ii].pt3D, Traj3D[ii].pt2D);
		ProjCost += err*err;
	}
	printf("(Before Spline: Action cost, projection cost): %.4e %.4e\n", ActionCost, sqrt(ProjCost / nData));

	ProjCost = 0.0;
	for (int ii = 0; ii < nData; ii++)
	{
		double x = 0.0, y = 0.0, z = 0.0;
		for (int jj = 0; jj < nCoeffs; jj++)
		{
			if (PhiData[jj + ii*nCoeffs] < 1e-6)
				continue;
			x += PhiData[jj + ii*nCoeffs] * C[jj],
				y += PhiData[jj + ii*nCoeffs] * C[jj + nCoeffs],
				z += PhiData[jj + ii*nCoeffs] * C[jj + 2 * nCoeffs];
		}

		double numX = PmatData[12 * ii] * x + PmatData[12 * ii + 1] * y + PmatData[12 * ii + 2] * z + PmatData[12 * ii + 3];
		double numY = PmatData[12 * ii + 4] * x + PmatData[12 * ii + 5] * y + PmatData[12 * ii + 6] * z + PmatData[12 * ii + 7];
		double denum = PmatData[12 * ii + 8] * x + PmatData[12 * ii + 9] * y + PmatData[12 * ii + 10] * z + PmatData[12 * ii + 11];

		double errX = (numX / denum - pt2dData[ii].x);
		double errY = (numY / denum - pt2dData[ii].y);
		ProjCost += errX*errX + errY*errY;
	}

	double xo, yo, zo;
	for (int ii = 0; ii < nptsPrior; ii++)
	{
		double x = 0.0, y = 0.0, z = 0.0;
		for (int jj = 0; jj < nCoeffs; jj++)
		{
			if (PhiPrior[jj + ii*nCoeffs] < 1e-6)
				continue;
			x += PhiPrior[jj + ii*nCoeffs] * C[jj],
				y += PhiPrior[jj + ii*nCoeffs] * C[jj + nCoeffs],
				z += PhiPrior[jj + ii*nCoeffs] * C[jj + 2 * nCoeffs];
		}

		if (ii > 0)
			ActionCost += (pow(x - xo, 2) + pow(y - yo, 2) + pow(z - zo, 2)) / (TimeStampPrior[ii] - TimeStampPrior[ii - 1]);
		xo = x, yo = y, zo = z;

	}
	printf("(Spline: Action cost, projection cost, Totalcost): %.4e %.4e %.4e\n", ActionCost, sqrt(ProjCost / nData), lamda*ProjCost + (1.0 - lamda)*ActionCost);
#endif

	for (int ii = 0; ii < nData; ii++)
		X[ii] = Traj3D[ii].pt3D.x, X[ii + nData] = Traj3D[ii].pt3D.y, X[ii + 2 * nData] = Traj3D[ii].pt3D.z;

	//Run ceres optimization
	ceres::Problem problem;

	vector<double*> parameter_blocks;
	parameter_blocks.push_back(C);
	ceres::DynamicAutoDiffCostFunction<CeresResamplingSpline, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction<CeresResamplingSpline, 4>(new CeresResamplingSpline(X, PmatData, PhiData, PhiPrior, TimeStampData, TimeStampPrior, pt2dData, lamda, nData, nptsPrior, nCoeffs));
	//ceres::DynamicNumericDiffCostFunction<CeresResamplingSpline, ceres::CENTRAL> *cost_function = new ceres::DynamicNumericDiffCostFunction<CeresResamplingSpline, ceres::CENTRAL>(new CeresResamplingSpline(X, PmatData, PhiData, PhiPrior, TimeStampData, TimeStampPrior, pt2dData, lamda, nData, nptsPrior, nCoeffs));
	cost_function->AddParameterBlock(3 * nCoeffs);
	//cost_function->SetNumResiduals(2 * nData + nptsPrior - 1);
	cost_function->SetNumResiduals(2 * nData);
	problem.AddResidualBlock(cost_function, NULL, parameter_blocks);

	ceres::Solver::Options options;
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::DENSE_QR;
	options.minimizer_progress_to_stdout = silent ? false : true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
#pragma omp critical
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

	//Final curve
	mat_mul(PhiData, C, X, nData, nCoeffs, 1);
	mat_mul(PhiData, C + nCoeffs, X + nData, nData, nCoeffs, 1);
	mat_mul(PhiData, C + 2 * nCoeffs, X + 2 * nData, nData, nCoeffs, 1);

	for (int ii = 0; ii < nData; ii++)
		Traj3D[ii].pt3D.x = X[ii], Traj3D[ii].pt3D.y = X[ii + nData], Traj3D[ii].pt3D.z = X[ii + 2 * nData];

#ifdef ENABLE_DEBUG_FLAG 
	{double ProjCost = 0.0;
	for (int ii = 0; ii < nData; ii++)
	{
		double x = 0.0, y = 0.0, z = 0.0;
		for (int jj = 0; jj < nCoeffs; jj++)
		{
			if (PhiData[jj + ii*nCoeffs] < 1e-6)
				continue;
			x += PhiData[jj + ii*nCoeffs] * C[jj],
				y += PhiData[jj + ii*nCoeffs] * C[jj + nCoeffs],
				z += PhiData[jj + ii*nCoeffs] * C[jj + 2 * nCoeffs];
		}

		double numX = PmatData[12 * ii] * x + PmatData[12 * ii + 1] * y + PmatData[12 * ii + 2] * z + PmatData[12 * ii + 3];
		double numY = PmatData[12 * ii + 4] * x + PmatData[12 * ii + 5] * y + PmatData[12 * ii + 6] * z + PmatData[12 * ii + 7];
		double denum = PmatData[12 * ii + 8] * x + PmatData[12 * ii + 9] * y + PmatData[12 * ii + 10] * z + PmatData[12 * ii + 11];

		double errX = (numX / denum - pt2dData[ii].x);
		double errY = (numY / denum - pt2dData[ii].y);
		ProjCost += errX*errX + errY*errY;
	}

	double xo, yo, zo, ActionCost = 0.0;
	for (int ii = 0; ii < nptsPrior; ii++)
	{
		double x = 0.0, y = 0.0, z = 0.0;
		for (int jj = 0; jj < nCoeffs; jj++)
		{
			if (PhiPrior[jj + ii*nCoeffs] < 1e-6)
				continue;
			x += PhiPrior[jj + ii*nCoeffs] * C[jj],
				y += PhiPrior[jj + ii*nCoeffs] * C[jj + nCoeffs],
				z += PhiPrior[jj + ii*nCoeffs] * C[jj + 2 * nCoeffs];
		}

		if (ii > 0)
			ActionCost += (pow(x - xo, 2) + pow(y - yo, 2) + pow(z - zo, 2)) / (TimeStampPrior[ii] - TimeStampPrior[ii - 1]);
		xo = x, yo = y, zo = z;

}
	printf("(After Spline: Action cost, projection cost, Totalcost): %.4e %.4e %.4e\n", ActionCost, sqrt(ProjCost / nData), lamda*ProjCost + (1.0 - lamda)*ActionCost);
}
#endif

	delete[]X, delete[]BreakPts, delete[]PhiData, delete[]PhiPrior, delete[]C;
	delete[]PmatData, delete[]TimeStampData, delete[]pt2dData;

	return;
}
int ResamplingOf3DTrajectorySplineDriver(char *Path, vector<int> &SelectedCams, vector<double> &OffsetInfo, int startFrame, int stopFrame, int ntracks, double lamda)
{
	char Fname[200]; FILE *fp = 0;
	const double Tscale = 1000.0, fps = 60.0, ialpha = 1.0 / fps;

	//Read calib info
	int nCams = (int)SelectedCams.size();
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;

	int frameID, id, npts;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	vector<int>VectorCamID, VectorFrameID;
	vector<double> AllError2D;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];

	printf("Get 2D ...");
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &npts);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int pid = 0; pid < npts; pid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	printf("Get rays info ....");
	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int count = 0;
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

				for (int kk = 0; kk < 12; kk++)
				{
					P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];
					PerCam_UV[camID*ntracks + trackID][frameID].P[kk] = P[kk];
				}

				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],

					AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*ntracks + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*ntracks + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - bb[1];

				PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(count, count, count);//Interestingly, Ceres does not work if all the input are the same
				count++;
			}
		}
	}

	//Initialize data for optim
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(ntracks);
	vector<double*> All3D(ntracks);
	int ntimeinstances, maxntimeinstances = 0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		ntimeinstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			ntimeinstances += PerCam_UV[camID*ntracks + trackID].size();

		if (maxntimeinstances < ntimeinstances)
			maxntimeinstances = ntimeinstances;

		PerTrackFrameID[trackID] = new int[ntimeinstances];
		All3D[trackID] = new double[3 * ntimeinstances];
	}

	vector<int> VisCamID, VisLocalFrameID;
	vector<double> TimeStamp;
	vector<Point3d> T3D;
	vector<ImgPtEle> *Traj3D = new vector<ImgPtEle>[ntracks];
	int cID, fID;
	double x, y, z, t;
	int dummy[10000];
	double ts[10000];
	ImgPtEle iele;

	printf("Get 3D data:\n");
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		TimeStamp.clear(), T3D.clear(), VisCamID.clear(), VisLocalFrameID.clear();

		sprintf(Fname, "%s/OptimizedRaw_Track_%d.txt", Path, trackID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			break;
		}
		while (fscanf(fp, "%lf %lf %lf %lf %d %d", &x, &y, &z, &t, &cID, &fID) != EOF)
		{
			TimeStamp.push_back(t), VisCamID.push_back(cID), VisLocalFrameID.push_back(fID);
			T3D.push_back(Point3d(x, y, z));
		}
		fclose(fp);

		for (int ii = 0; ii < (int)TimeStamp.size(); ii++)
			ts[ii] = TimeStamp[ii], dummy[ii] = ii;
		Quick_Sort_Double(ts, dummy, 0, (int)TimeStamp.size() - 1);

		for (int ii = 0; ii < (int)TimeStamp.size(); ii++)
		{
			int id = dummy[ii], camID = VisCamID[id], frameID = VisLocalFrameID[id];
			iele.viewID = camID, iele.frameID = frameID, iele.timeStamp = TimeStamp[id];

			iele.pt3D = T3D[id];
			for (int fid = 0; fid < (int)PerCam_UV[camID*ntracks + trackID].size(); fid++)
			{
				if (PerCam_UV[camID*ntracks + trackID][fid].frameID == frameID)
				{
					iele.pt2D = PerCam_UV[camID*ntracks + trackID][fid].pt2D;
					for (int jj = 0; jj < 12; jj++)
						iele.P[jj] = PerCam_UV[camID*ntracks + trackID][fid].P[jj];
					break;
				}
			}
			Traj3D[trackID].push_back(iele);
		}
	}

	printf("Cubic Bspline resampling:\n");

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
#pragma omp critical
		printf("%d: ", trackID);

		ResamplingOf3DTrajectorySpline(Traj3D[trackID], true, ialpha *Tscale, ialpha *Tscale / nCams, lamda);

#pragma omp critical
		{
			sprintf(Fname, "%s/Track3D/SplineResampled_Track_%d.txt", Path, trackID); remove(Fname);
			fp = fopen(Fname, "w+");
			for (int ii = 0; ii < (int)Traj3D[trackID].size(); ii++)
				fprintf(fp, "%.4f %.4f %.4f %.4f %d %d\n", Traj3D[trackID][ii].pt3D.x, Traj3D[trackID][ii].pt3D.y, Traj3D[trackID][ii].pt3D.z, Traj3D[trackID][ii].timeStamp, Traj3D[trackID][ii].viewID, Traj3D[trackID][ii].frameID);
			fclose(fp);
		}
	}
	printf("Done!\n\n");

	delete[]VideoInfo;
	delete[]PerCam_UV;
	delete[]Traj3D;

	return 0;
}
struct CeresResamplingDCT {
	CeresResamplingDCT(double *XIn, double *PIn, double *iBDataIn, double *sqrtWeightIn, Point2d *pt2DIn, double lamda1, double lamda2, int nData, int nResamples) :lamda1(lamda1), lamda2(lamda2), nData(nData), nResamples(nResamples)
	{
		X = XIn, P = PIn, iBData = iBDataIn, sqrtWeight = sqrtWeightIn, pt2D = pt2DIn;
	}

	template <typename T>    bool operator()(T const* const* C, T* residuals)     const
	{
		//cost = lamda1*(PiBC-u)^2 + lamda2*Prior
		T x, y, z, numX, numY, denum, sqrtlamda1 = sqrt((T)lamda1), sqrtlamda2 = sqrt((T)lamda2);

		//Projection cost : lamda1*(PiBC-u)^2
		for (int ii = 0; ii < nData; ii++)
		{
			//X = iB*C
			x = (T) 0.0, y = (T) 0.0, z = (T)0.0;
			for (int jj = 0; jj < nResamples; jj++)
			{
				x += (T)iBData[jj + ii*nResamples] * C[0][jj],
					y += (T)iBData[jj + ii*nResamples] * C[0][jj + nResamples],
					z += (T)iBData[jj + ii*nResamples] * C[0][jj + 2 * nResamples];
			}

			numX = (T)P[12 * ii] * x + (T)P[12 * ii + 1] * y + (T)P[12 * ii + 2] * z + (T)P[12 * ii + 3];
			numY = (T)P[12 * ii + 4] * x + (T)P[12 * ii + 5] * y + (T)P[12 * ii + 6] * z + (T)P[12 * ii + 7];
			denum = (T)P[12 * ii + 8] * x + (T)P[12 * ii + 9] * y + (T)P[12 * ii + 10] * z + (T)P[12 * ii + 11];

			residuals[2 * ii] = (T)sqrtlamda1*(numX / denum - (T)pt2D[ii].x);
			residuals[2 * ii + 1] = (T)sqrtlamda1*(numY / denum - (T)pt2D[ii].y);
		}

		//Motion prior in DCT form: CT*W*C
		for (int ii = 0; ii < nResamples; ii++)
		{
			T lamdaW = sqrtlamda2* sqrtWeight[ii];
			residuals[2 * nData + 3 * ii] = lamdaW* C[0][ii];
			residuals[2 * nData + 3 * ii + 1] = lamdaW * C[0][ii + nResamples];
			residuals[2 * nData + 3 * ii + 2] = lamdaW * C[0][ii + 2 * nResamples];
		}

		return true;
	}

	int nData, nResamples;
	double  *X, *P, *iBData, *sqrtWeight, lamda1, lamda2;
	Point2d *pt2D;
};
void ResamplingOf3DTrajectoryDCT(vector<ImgPtEle> &Traj3D, int PriorOrder, bool non_monotonicDescent, double Resample_Step, double lamda1, double lamda2, bool silent = true)
{
	double earliest = Traj3D[0].timeStamp, latest = Traj3D.back().timeStamp;
	int nData = (int)Traj3D.size(), nResamples = (int)((latest - earliest) / Resample_Step);

	//if (PriorOrder == 1)
	//	lamda2 = lamda2*Resample_Step;//scale the weight to take into account the temporal integration of uniformedly sampled motion prior 

	double *X = new double[nData * 3], *C = new double[3 * nResamples];
	double *iBData = new double[nData*nResamples], *BResampled = new double[nResamples*nResamples], *sqrtWeight = new double[nResamples];
	double *PmatData = new double[nData * 12], *TimeStampData = new double[nData];
	Point2d *pt2dData = new Point2d[nData];

	for (int ii = 0; ii < nData; ii++)
	{
		for (int jj = 0; jj < 12; jj++)
			PmatData[12 * ii + jj] = Traj3D[ii].P[jj];

		pt2dData[ii] = Traj3D[ii].pt2D;
		X[ii] = Traj3D[ii].pt3D.x, X[ii + nData] = Traj3D[ii].pt3D.y, X[ii + 2 * nData] = Traj3D[ii].pt3D.z;
		TimeStampData[ii] = (Traj3D[ii].timeStamp - earliest) / (latest - earliest)*(nResamples - 1);//Normalize to [0, n-1] range
	}

	//Generate DCT Basis
	GenerateDCTBasis(nResamples, BResampled, sqrtWeight);
	for (int ii = 0; ii < nResamples; ii++)
		if (PriorOrder == 1)
			sqrtWeight[ii] = sqrt(-sqrtWeight[ii]); //(1) using precomputed sqrt is better for ceres' squaring residual square nature; (2) weigths are negative, but that does not matter for ctwc optim.
		else
			sqrtWeight[ii] = -sqrtWeight[ii]; //ctw.^2c-->ceres: residuals = c*W;

	for (int ii = 0; ii < nData; ii++)
		GenerateiDCTBasis(iBData + ii*nResamples, nResamples, TimeStampData[ii]);

	//Initialize basis coefficients: iBd(:, 1:activeBasis)*C =  X_d
	const int nactiveBasis = 20;
	Map < Matrix < double, Dynamic, Dynamic, RowMajor > > eiBData(iBData, nData, nResamples);
	MatrixXd etiBData = eiBData.block(0, 0, nData, nactiveBasis);
	JacobiSVD<MatrixXd> etiP_svd(etiBData, ComputeThinU | ComputeThinV);
	for (int ii = 0; ii < 3; ii++)
	{
		for (int jj = nactiveBasis; jj < nResamples; jj++)
			C[jj + nResamples*ii] = 0.0; //set coeffs outside active basis to 0

		Map<VectorXd> eX(X + nData*ii, nData);
		Map<VectorXd> eC(C + nResamples*ii, nactiveBasis);
		eC = etiP_svd.solve(eX);
	}

#ifdef ENABLE_DEBUG_FLAG
	{
		double x, y, z, numX, numY, denum;

		//Projection cost : (PiBC-u)^2
		double projectionCost = 0.0;
		for (int ii = 0; ii < nData; ii++)
		{
			//X = iB*C
			x = 0.0, y = 0.0, z = 0.0;
			for (int jj = 0; jj < nResamples; jj++)
			{
				x += iBData[jj + ii*nResamples] * C[jj],
					y += iBData[jj + ii*nResamples] * C[jj + nResamples],
					z += iBData[jj + ii*nResamples] * C[jj + 2 * nResamples];
			}

			numX = PmatData[12 * ii] * x + PmatData[12 * ii + 1] * y + PmatData[12 * ii + 2] * z + PmatData[12 * ii + 3];
			numY = PmatData[12 * ii + 4] * x + PmatData[12 * ii + 5] * y + PmatData[12 * ii + 6] * z + PmatData[12 * ii + 7];
			denum = PmatData[12 * ii + 8] * x + PmatData[12 * ii + 9] * y + PmatData[12 * ii + 10] * z + PmatData[12 * ii + 11];

			projectionCost += (pow(numX / denum - pt2dData[ii].x, 2) + pow(numY / denum - pt2dData[ii].y, 2));
		}

		//Motion prior in DCT form: CT*W*C
		double MotionPrior = 0.0;
		for (int ii = 0; ii < nResamples; ii++)
			MotionPrior += pow(sqrtWeight[ii], 2)*(pow(C[ii], 2) + pow(C[ii + nResamples], 2) + pow(C[ii + 2 * nResamples], 2));

#pragma omp critical
		printf("(DCT before: Motion cost, projection cost, Totalcost): %.4e %.4e %.4e\n", MotionPrior, sqrt(projectionCost / nData), lamda1*projectionCost + lamda2*MotionPrior);
	}
#endif

	//Run ceres optimization
	ceres::Problem problem;

	vector<double*> parameter_blocks;
	parameter_blocks.push_back(C);
	ceres::DynamicAutoDiffCostFunction<CeresResamplingDCT, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction<CeresResamplingDCT, 4>(
		new CeresResamplingDCT(X, PmatData, iBData, sqrtWeight, pt2dData, lamda1, lamda2, nData, nResamples));
	cost_function->AddParameterBlock(3 * nResamples);
	cost_function->SetNumResiduals(2 * nData + 3 * nResamples);
	problem.AddResidualBlock(cost_function, NULL, parameter_blocks);

	ceres::Solver::Options options;
	options.max_num_iterations = 100;
	//options.num_threads = omp_get_max_threads();
	options.linear_solver_type = ceres::DENSE_QR;
	options.minimizer_progress_to_stdout = silent ? false : true;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);

#pragma omp critical
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

#ifdef ENABLE_DEBUG_FLAG
	{double x, y, z, numX, numY, denum;

	//Projection cost : (PiBC-u)^2
	double projectionCost = 0.0;
	for (int ii = 0; ii < nData; ii++)
	{
		//X = iB*C
		x = 0.0, y = 0.0, z = 0.0;
		for (int jj = 0; jj < nResamples; jj++)
		{
			x += iBData[jj + ii*nResamples] * C[jj],
				y += iBData[jj + ii*nResamples] * C[jj + nResamples],
				z += iBData[jj + ii*nResamples] * C[jj + 2 * nResamples];
		}

		numX = PmatData[12 * ii] * x + PmatData[12 * ii + 1] * y + PmatData[12 * ii + 2] * z + PmatData[12 * ii + 3];
		numY = PmatData[12 * ii + 4] * x + PmatData[12 * ii + 5] * y + PmatData[12 * ii + 6] * z + PmatData[12 * ii + 7];
		denum = PmatData[12 * ii + 8] * x + PmatData[12 * ii + 9] * y + PmatData[12 * ii + 10] * z + PmatData[12 * ii + 11];

		projectionCost += (pow(numX / denum - pt2dData[ii].x, 2) + pow(numY / denum - pt2dData[ii].y, 2));
	}

	//Motion prior in DCT form: CT*W*C
	double MotionPrior = 0.0;
	for (int ii = 0; ii < nResamples; ii++)
		MotionPrior += pow(sqrtWeight[ii], 2)*(pow(C[ii], 2) + pow(C[ii + nResamples], 2) + pow(C[ii + 2 * nResamples], 2));

#pragma omp critical
	printf("(DCT after: Motion cost, projection cost, Totalcost): %.4e %.4e %.4e\n\n", MotionPrior, sqrt(projectionCost / nData), lamda1*projectionCost + lamda2*MotionPrior);
}
#endif

	//Final curve: iB*C =  X
	for (int ii = 0; ii < 3; ii++)
	{
		Map<VectorXd> eX(X + nData*ii, nData);
		Map<VectorXd> eC(C + nResamples*ii, nResamples);
		eX = eiBData*eC;
	}

	for (int ii = 0; ii < nData; ii++)
		Traj3D[ii].pt3D.x = X[ii], Traj3D[ii].pt3D.y = X[ii + nData], Traj3D[ii].pt3D.z = X[ii + 2 * nData];

	delete[]X, delete[]iBData, delete[]BResampled, delete[]C;
	delete[]PmatData, delete[]TimeStampData, delete[]pt2dData;

	return;
}
int ResamplingOf3DTrajectoryDCTDriver(char *Path, vector<int> &SelectedCams, vector<double> &OffsetInfo, int PriorOrder, int startFrame, int stopFrame, int ntracks, double lamda1, double lamda2)
{
	char Fname[200]; FILE *fp = 0;

	//Read calib info
	int nCams = (int)SelectedCams.size();
	VideoData *VideoInfo = new VideoData[nCams];
	for (int camID = 0; camID < nCams; camID++)
		if (ReadVideoDataI(Path, VideoInfo[camID], SelectedCams[camID], startFrame, stopFrame) == 1)
			return 1;

	int frameID, id, npts;
	int nframes = max(MaxnFrames, stopFrame);

	double u, v;
	vector<int>VectorCamID, VectorFrameID;
	vector<double> AllError2D;
	ImgPtEle ptEle;
	vector<ImgPtEle> *PerCam_UV = new vector<ImgPtEle>[nCams*ntracks];

	printf("Get 2D ...");
	for (int camID = 0; camID < nCams; camID++)
	{
		for (int trackID = 0; trackID < ntracks; trackID++)
			PerCam_UV[camID*ntracks + trackID].reserve(stopFrame - startFrame + 1);

		sprintf(Fname, "%s/Track2D/%d.txt", Path, SelectedCams[camID]); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		for (int trackID = 0; trackID < ntracks; trackID++)
		{
			fscanf(fp, "%d %d ", &id, &npts);
			if (id != trackID)
				printf("Problem at Point %d of Cam %d", id, camID);
			for (int pid = 0; pid < npts; pid++)
			{
				fscanf(fp, "%d %lf %lf ", &frameID, &u, &v);
				if (frameID < 0)
					continue;
				if (!VideoInfo[camID].VideoInfo[frameID].valid)
					continue; //camera not localized

				if (u > 0 && v > 0)
				{
					ptEle.pt2D.x = u, ptEle.pt2D.y = v, ptEle.frameID = frameID, ptEle.imWidth = VideoInfo[camID].VideoInfo[frameID].width, ptEle.imHeight = VideoInfo[camID].VideoInfo[frameID].height;
					LensCorrectionPoint(&ptEle.pt2D, VideoInfo[camID].VideoInfo[frameID].K, VideoInfo[camID].VideoInfo[frameID].distortion);
					PerCam_UV[camID*ntracks + id].push_back(ptEle);
				}
			}
		}
		fclose(fp);
	}

	printf("Get rays info ....");
	double P[12], AA[6], bb[2], ccT[3], dd[1];
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		int count = 0;
		for (int camID = 0; camID < nCams; camID++)
		{
			for (int frameID = 0; frameID < PerCam_UV[camID*ntracks + trackID].size(); frameID++)
			{
				int RealFrameID = PerCam_UV[camID*ntracks + trackID][frameID].frameID;

				for (int kk = 0; kk < 12; kk++)
				{
					P[kk] = VideoInfo[camID].VideoInfo[RealFrameID].P[kk];
					PerCam_UV[camID*ntracks + trackID][frameID].P[kk] = P[kk];
				}

				for (int kk = 0; kk < 9; kk++)
					PerCam_UV[camID*ntracks + trackID][frameID].K[kk] = VideoInfo[camID].VideoInfo[RealFrameID].K[kk],

					AA[0] = P[0], AA[1] = P[1], AA[2] = P[2], bb[0] = P[3];
				AA[3] = P[4], AA[4] = P[5], AA[5] = P[6], bb[1] = P[7];
				ccT[0] = P[8], ccT[1] = P[9], ccT[2] = P[10], dd[0] = P[11];

				PerCam_UV[camID*ntracks + trackID][frameID].Q[0] = AA[0] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[1] = AA[1] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[2] = AA[2] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].Q[3] = AA[3] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[0],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[4] = AA[4] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[1],
					PerCam_UV[camID*ntracks + trackID][frameID].Q[5] = AA[5] - PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y*ccT[2];
				PerCam_UV[camID*ntracks + trackID][frameID].u[0] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.x - bb[0],
					PerCam_UV[camID*ntracks + trackID][frameID].u[1] = dd[0] * PerCam_UV[camID*ntracks + trackID][frameID].pt2D.y - bb[1];

				PerCam_UV[camID*ntracks + trackID][frameID].pt3D = Point3d(count, count, count);//Interestingly, Ceres does not work if all the input are the same
				count++;
			}
		}
	}

	//Initialize data for optim
	vector<int> PointsPerTrack;
	vector<int *> PerTrackFrameID(ntracks);
	vector<double*> All3D(ntracks);
	int ntimeinstances, maxntimeinstances = 0;
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		ntimeinstances = 0;
		for (int camID = 0; camID < nCams; camID++)
			ntimeinstances += PerCam_UV[camID*ntracks + trackID].size();

		if (maxntimeinstances < ntimeinstances)
			maxntimeinstances = ntimeinstances;

		PerTrackFrameID[trackID] = new int[ntimeinstances];
		All3D[trackID] = new double[3 * ntimeinstances];
	}

	vector<int> VisCamID, VisLocalFrameID;
	vector<double> TimeStamp;
	vector<Point3d> T3D;
	vector<ImgPtEle> *Traj3D = new vector<ImgPtEle>[ntracks];
	int cID, fID;
	double x, y, z, t;
	int dummy[10000];
	double ts[10000];
	ImgPtEle iele;

	printf("Get 3D data:\n");
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
		TimeStamp.clear(), T3D.clear(), VisCamID.clear(), VisLocalFrameID.clear();

		sprintf(Fname, "%s/OptimizedRaw_Track_%d.txt", Path, trackID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			break;
		}
		while (fscanf(fp, "%lf %lf %lf %lf %d %d", &x, &y, &z, &t, &cID, &fID) != EOF)
		{
			TimeStamp.push_back(t), VisCamID.push_back(cID), VisLocalFrameID.push_back(fID);
			T3D.push_back(Point3d(x, y, z));
		}
		fclose(fp);

		for (int ii = 0; ii < (int)TimeStamp.size(); ii++)
			ts[ii] = TimeStamp[ii], dummy[ii] = ii;
		Quick_Sort_Double(ts, dummy, 0, (int)TimeStamp.size() - 1);

		for (int ii = 0; ii < (int)TimeStamp.size(); ii++)
		{
			int id = dummy[ii], camID = VisCamID[id], frameID = VisLocalFrameID[id];
			iele.viewID = camID, iele.frameID = frameID, iele.timeStamp = TimeStamp[id];

			iele.pt3D = T3D[id];
			for (int fid = 0; fid < (int)PerCam_UV[camID*ntracks + trackID].size(); fid++)
			{
				if (PerCam_UV[camID*ntracks + trackID][fid].frameID == frameID)
				{
					iele.pt2D = PerCam_UV[camID*ntracks + trackID][fid].pt2D;
					for (int jj = 0; jj < 12; jj++)
						iele.P[jj] = PerCam_UV[camID*ntracks + trackID][fid].P[jj];
					break;
				}
			}
			Traj3D[trackID].push_back(iele);
		}
	}

	printf("DCT-based resampling:\n");
	//for (int trial = 0; trial <= 50; trial++)
	//{
	//	lamda1 = 0.1 + 0.9 / 50 * trial; lamda2 = 1.0 - lamda2;

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int trackID = 0; trackID < ntracks; trackID++)
	{
#pragma omp critical
		printf("%d: ", trackID);

		double earliest = Traj3D[trackID][0].timeStamp, latest = Traj3D[trackID].back().timeStamp;
		int nData = (int)Traj3D[trackID].size();
		double resamplingStep = (latest - earliest) / nData;

		double lamda2_ = lamda2*resamplingStep;
		ResamplingOf3DTrajectoryDCT(Traj3D[trackID], PriorOrder, true, resamplingStep, lamda1, lamda2_, true);

#pragma omp critical
		{
			sprintf(Fname, "%s/Track3D/DCTResampled_Track_%d.txt", Path, trackID); remove(Fname);
			fp = fopen(Fname, "w+");
			for (int ii = 0; ii < (int)Traj3D[trackID].size(); ii++)
				fprintf(fp, "%.4f %.4f %.4f %.4f %d %d\n", Traj3D[trackID][ii].pt3D.x, Traj3D[trackID][ii].pt3D.y, Traj3D[trackID][ii].pt3D.z, Traj3D[trackID][ii].timeStamp, Traj3D[trackID][ii].viewID, Traj3D[trackID][ii].frameID);
			fclose(fp);
		}
	}
	//}
	printf("Done!\n\n");

	delete[]VideoInfo;
	delete[]PerCam_UV;
	delete[]Traj3D;

	return 0;
}

int GenerateCheckerBoardFreeImage(char *Path, int camID, int npts, int startFrame, int stopFrame)
{
	char Fname[200];

	int width = 0, height = 0;
	Mat cvImg;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		sprintf(Fname, "%s/%d/%d.png", Path, camID, fid); cvImg = imread(Fname, 0);
		if (!cvImg.empty())
		{
			width = cvImg.cols, height = cvImg.rows;
			break;
		}
	}

	if (width == 0 || height == 0)
	{
		printf("Found no images\n");
		return 1;
	}

	int *PixelCount = new int[width*height];
	double *AvgImage = new double[width*height];
	for (int ii = 0; ii < width*height; ii++)
		PixelCount[ii] = 0, AvgImage[ii] = 0.0;

	float x, y;
	int maxX, minX, maxY, minY;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		sprintf(Fname, "%s/%d/Corner/CV2_%d.txt", Path, camID, fid); 	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
			continue;

		maxX = 0, minX = width, maxY = 0, minY = height;
		for (int ii = 0; ii < npts; ii++)
		{
			fscanf(fp, "%f %f ", &x, &y);
			if (x > maxX)
				maxX = min((int)x, width - 1);
			if (x < minX)
				minX = max((int)x, 0);
			if (y > maxY)
				maxY = min((int)y, height - 1);
			if (y < minY)
				minY = max((int)y, 0);
		}

		sprintf(Fname, "%s/%d/%d.png", Path, camID, fid); cvImg = imread(Fname, 0);
		if (!cvImg.empty())
			continue;

		for (int jj = 0; jj < height; jj++)
		{
			for (int ii = 0; ii < width; ii++)
			{
				if (ii>minX && ii <maxX && jj>minY && jj < maxY)
					continue;
				AvgImage[ii + jj*width] += (double)(int)cvImg.data[ii + jj*width];
				PixelCount[ii + jj*width]++;
			}
		}
	}


	for (int ii = 0; ii < width*height; ii++)
		AvgImage[ii] = AvgImage[ii] / PixelCount[ii];

	sprintf(Fname, "%s/Corpus/", Path); makeDir(Fname);
	sprintf(Fname, "%s/Corpus/%d.png", Path, camID);
	SaveDataToImage(Fname, AvgImage, width, height, 1);

	delete[]PixelCount, delete[]AvgImage;
	return 0;
}
int CheckerBoardMultiviewSpatialTemporalCalibration(char *Path, int nCams, int startFrame, int stopFrame, int STCalibration)
{
	const double square_size = 50.8;
	const int width = 1920, height = 1080, bh = 8, bw = 11, npts = bh*bw, TemporalSearchRange = 30, LossType = 0; //Huber loss
	bool fixIntrinsic = true, fixDistortion = true, fixPose = false, fixfirstCamPose = true, distortionCorrected = false;

	//Input Parameters
	const int PriorOrder = 1, motionPriorPower = 2, SearchRange = 10;
	double lamdaData = 0.85, lamdaPrior = 1.0 - lamdaData, SearchStep = 0.1;

	char Fname[512]; sprintf(Fname, "%s/Track3D", Path), makeDir(Fname);

	double startTime = omp_get_wtime();
	if (STCalibration == 1)
	{
		/*printf("Estimate camera instrinsic parameters: ");
		int sampleCalibFrameStep = 1;
		if (stopFrame - startFrame > 100)
		sampleCalibFrameStep = (stopFrame - startFrame) / 50;

		omp_set_num_threads(omp_get_max_threads());
		#pragma omp parallel for
		for (int camID = 0; camID < nCams; camID++)
		SingleCameraCalibration(Path, camID, startFrame, stopFrame, bw, bh, true, sampleCalibFrameStep, square_size, 1, width, height);

		printf("Generating checkerboard free images ... ");
		omp_set_num_threads(omp_get_max_threads());
		#pragma omp parallel for
		for (int camID = 0; camID < nCams; camID++)
		GenerateCheckerBoardFreeImage(Path, camID, bh*bw, startFrame, stopFrame);
		printf("Done. \n");

		printf("Create 2D trajectories from detected checkerboard corners ...");
		for (int camID = 0; camID < nCams; camID++)
		CleanCheckBoardDetection(Path, camID, startFrame, stopFrame);
		printf("Done. \n");*/

		double FrameLevelOffsetInfo[MaxnCams];
		GeometricConstraintSyncDriver(Path, nCams, npts, startFrame, startFrame, stopFrame, 3 * SearchRange, true, FrameLevelOffsetInfo, false);

		//Convert between time-delay format and time-stamp format
		for (int ii = 0; ii < nCams; ii++)
			FrameLevelOffsetInfo[ii] = -FrameLevelOffsetInfo[ii];

		//for some reasons, only work with motionPriorPower = 2
		EvaluateAllPairCost(Path, nCams, npts, startFrame, stopFrame, SearchRange, SearchStep, lamdaData, motionPriorPower, FrameLevelOffsetInfo);

		vector<int>cameraOrdering;
		vector<double> InitTimeStampInfoVector;
		DetermineCameraOrderingForGreedySTBA(Path, "PairwiseCost", nCams, cameraOrdering, InitTimeStampInfoVector);

		vector<int> SelectedCamera;
		vector<double>TimeStampInfoVector;
		for (int ii = 0; ii < 3; ii++)
			SelectedCamera.push_back(cameraOrdering[ii]), TimeStampInfoVector.push_back(InitTimeStampInfoVector[ii]);

		printf("\nCoarse ST estimation for 3 cameras (%d, %d, %d):\n", SelectedCamera[0], SelectedCamera[1], SelectedCamera[2]);
		LeastActionSyncBruteForce2DTriplet(Path, SelectedCamera, 0, stopFrame, npts, TimeStampInfoVector, -SearchRange / 2, SearchRange / 2, SearchStep, lamdaData, motionPriorPower);
		printf("Coarse ST estimation for 3 cameras (%d, %d, %d): %.4f %.4f %.4f \n\n", SelectedCamera[0], SelectedCamera[1], SelectedCamera[2], TimeStampInfoVector[0], TimeStampInfoVector[1], TimeStampInfoVector[2]);

		IncrementalLeastActionSyncDiscreteContinous2D(Path, SelectedCamera, startFrame, stopFrame, npts, TimeStampInfoVector, 0, 0, 0, lamdaData, motionPriorPower, false);

		char Fname[200]; sprintf(Fname, "%s/MotionPriorSyncProgress.txt", Path);	FILE *fp = fopen(Fname, "w+");
		fprintf(fp, "%d %d %d %d %.4f %.4f %.4f \n", 3, SelectedCamera[0], SelectedCamera[1], SelectedCamera[2], TimeStampInfoVector[0], TimeStampInfoVector[1], TimeStampInfoVector[2]);

		int orderingChangeTrials = 0;
		for (int currentCamID = 3; currentCamID < nCams; currentCamID++)
		{
			SelectedCamera.push_back(cameraOrdering[currentCamID]);
			TimeStampInfoVector.push_back(InitTimeStampInfoVector[currentCamID]);
			int NotSuccess = IncrementalLeastActionSyncDiscreteContinous2D(Path, SelectedCamera, startFrame, stopFrame, npts, TimeStampInfoVector, -(int)(SearchStep* SearchRange), (int)(SearchStep* SearchRange), 0.0, lamdaData, motionPriorPower);

			//Push the current ordering ID to the end of the stack
			if (NotSuccess == 1)
			{
				SelectedCamera.erase(SelectedCamera.end() - 1);
				TimeStampInfoVector.erase(TimeStampInfoVector.end() - 1);

				//Nothing can be done with this last camera
				if (currentCamID == nCams - 1)
					break;

				std::vector<int>::iterator it1;
				it1 = cameraOrdering.end();
				cameraOrdering.insert(it1, cameraOrdering[currentCamID]);
				cameraOrdering.erase(cameraOrdering.begin() + currentCamID);

				std::vector<double>::iterator it2;
				it2 = InitTimeStampInfoVector.end();
				InitTimeStampInfoVector.insert(it2, InitTimeStampInfoVector[currentCamID]);
				InitTimeStampInfoVector.erase(InitTimeStampInfoVector.begin() + currentCamID);

				currentCamID--;

				orderingChangeTrials++;
				if (orderingChangeTrials == nCams - 3) //Already tried other ordering options but failed
					break;
			}
			else
			{
				fprintf(fp, "%d ", (int)SelectedCamera.size());
				for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
					fprintf(fp, "%d ", SelectedCamera[ii]);
				for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
					fprintf(fp, "%.4f ", TimeStampInfoVector[ii]);
				fprintf(fp, "\n");
			}
		}
		fclose(fp);

		//Resort the time with the earliest camera placed first
		vector<int> SortedSelectedCamera;
		vector<double> SortedTimeStampInfoVector = TimeStampInfoVector;
		sort(SortedTimeStampInfoVector.begin(), SortedTimeStampInfoVector.end());
		for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
		{
			for (int jj = 0; jj < (int)SelectedCamera.size(); jj++)
			{
				if (TimeStampInfoVector[jj] == SortedTimeStampInfoVector[ii])
				{
					SortedSelectedCamera.push_back(SelectedCamera[jj]);
					break;
				}
			}
		}
		for (int ii = (int)SortedSelectedCamera.size() - 1; ii >= 0; ii--)
			SortedTimeStampInfoVector[ii] -= SortedTimeStampInfoVector[0];

		//Triangulate trajectories
		TrajectoryTriangulation(Path, SortedSelectedCamera, SortedTimeStampInfoVector, npts, startFrame, stopFrame, lamdaData, motionPriorPower);
		//ResamplingOf3DTrajectorySplineDriver(Path, SortedSelectedCamera, SortedTimeStampInfoVector, startFrame, stopFrame, npts, lamdaData);
		ResamplingOf3DTrajectoryDCTDriver(Path, SortedSelectedCamera, SortedTimeStampInfoVector, PriorOrder, startFrame, stopFrame, npts, lamdaData, lamdaPrior);

		sprintf(Fname, "%s/FMotionPriorSync.txt", Path);	fp = fopen(Fname, "w+");
		for (int ii = 0; ii < (int)SortedSelectedCamera.size(); ii++)
			fprintf(fp, "%d %.4f\n", SortedSelectedCamera[ii], SortedTimeStampInfoVector[ii]);
		fclose(fp);

		printf("Total time: %.2fs\n\n", omp_get_wtime() - startTime);
	}
	else if (STCalibration > 1 && STCalibration < 6)
	{
		vector<int> SelectedCamera;
		vector<double> TimeStampInfoVector;

		char Fname[200]; sprintf(Fname, "%s/FMotionPriorSync.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n. Abort!", Fname);
			abort();
		}
		int selected; double offsetValue;
		while (fscanf(fp, "%d %lf ", &selected, &offsetValue) != EOF)
			SelectedCamera.push_back(selected), TimeStampInfoVector.push_back(offsetValue);
		fclose(fp);

		int nCams = (int)SelectedCamera.size();
		vector<int>  sortedSelectedCamera(nCams);
		vector<double> sortedTimeStampInfoVector(nCams);
		for (int ii = 0; ii < nCams; ii++)
			sortedSelectedCamera[ii] = SelectedCamera[ii],
			sortedTimeStampInfoVector[ii] = TimeStampInfoVector[ii];

		if (STCalibration == 2)
			TrajectoryTriangulation(Path, sortedSelectedCamera, sortedTimeStampInfoVector, npts, startFrame, stopFrame, lamdaData, motionPriorPower);
		else if (STCalibration == 3)
			ResamplingOf3DTrajectorySplineDriver(Path, sortedSelectedCamera, sortedTimeStampInfoVector, startFrame, stopFrame, npts, lamdaData);
		else if (STCalibration == 4)
			ResamplingOf3DTrajectoryDCTDriver(Path, sortedSelectedCamera, sortedTimeStampInfoVector, PriorOrder, startFrame, stopFrame, npts, lamdaData, lamdaPrior);
		else if (STCalibration == 4)
			Generate3DUncertaintyFromRandomSampling(Path, sortedSelectedCamera, sortedTimeStampInfoVector, startFrame, stopFrame, npts, 0, 100, motionPriorPower);
	}
	else if (STCalibration == 6)
	{
		vector<int> SelectedCamera, DelayInfoVector;
		char Fname[200]; sprintf(Fname, "%s/FGeoSync.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n. Abort!", Fname);
			abort();
		}
		int selected; double offsetValue;
		while (fscanf(fp, "%d %lf ", &selected, &offsetValue) != EOF)
			SelectedCamera.push_back(selected), DelayInfoVector.push_back(offsetValue);
		fclose(fp);

		double Rate = 1.0, ialpha = 1.0;
		double GTFrameTimeStamp[10];
		for (int ii = 0; ii < (int)DelayInfoVector.size(); ii++)
			//GTFrameTimeStamp[ii] = -DelayInfoVector[ii];
			GTFrameTimeStamp[ii] = DelayInfoVector[ii];

		TriangulateFrameSync2DTrajectories(Path, SelectedCamera, DelayInfoVector, startFrame, stopFrame, npts, false, GTFrameTimeStamp, &ialpha, &Rate);
	}
	printf("Total time: %.2fs\n\n", omp_get_wtime() - startTime);

	visualizationDriver(Path, nCams, startFrame, stopFrame, true, false, true, false, false, false, 0);
	return 0;
}
int SpatialTemporalCalibration(char *Path, int nCams, int startFrame, int stopFrame, int STCalibration)
{
	const int width = 1920, height = 1080, npts = 164, TemporalSearchRange = 30, LossType = 0; //Huber loss
	bool fixIntrinsic = true, fixDistortion = true, fixPose = false, fixfirstCamPose = true, distortionCorrected = false;

	//Input Parameters
	const int PriorOrder = 1, motionPriorPower = 2, SearchRange = 10;
	double lamdaData = 0.85, lamdaPrior = 1.0 - lamdaData, SearchStep = 0.1;

	char Fname[200]; FILE *fp = 0;
	sprintf(Fname, "%s/Track3D", Path), makeDir(Fname);

	double startTime = omp_get_wtime();
	if (STCalibration == 1)
	{
		double FrameLevelOffsetInfo[MaxnCams];
		GeometricConstraintSyncDriver(Path, nCams, npts, startFrame, startFrame, stopFrame, 3 * SearchRange, true, FrameLevelOffsetInfo, false);
		sprintf(Fname, "%s/FGeoSync.txt", Path);	fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n. Abort!", Fname);
			abort();
		}
		int selected;
		for (int ii = 0; ii < nCams; ii++)
			fscanf(fp, "%d %lf ", &selected, &FrameLevelOffsetInfo[ii]);
		fclose(fp);

		//Convert between time-delay format and time-stamp format
		//for (int ii = 0; ii < nCams; ii++)
		//	FrameLevelOffsetInfo[ii] = -FrameLevelOffsetInfo[ii];

		//for some reasons, only work with motionPriorPower = 2
		EvaluateAllPairCost(Path, nCams, npts, startFrame, stopFrame, SearchRange, SearchStep, lamdaData, motionPriorPower, FrameLevelOffsetInfo);

		vector<int>cameraOrdering;
		vector<double> InitTimeStampInfoVector;
		DetermineCameraOrderingForGreedySTBA(Path, "PairwiseCost", nCams, cameraOrdering, InitTimeStampInfoVector);

		vector<int> SelectedCamera;
		vector<double>TimeStampInfoVector;
		for (int ii = 0; ii < 3; ii++)
			SelectedCamera.push_back(cameraOrdering[ii]), TimeStampInfoVector.push_back(InitTimeStampInfoVector[ii]);

		printf("\nCoarse ST estimation for 3 cameras (%d, %d, %d):\n", SelectedCamera[0], SelectedCamera[1], SelectedCamera[2]);
		LeastActionSyncBruteForce2DTriplet(Path, SelectedCamera, 0, stopFrame, npts, TimeStampInfoVector, -SearchRange / 2, SearchRange / 2, SearchStep, lamdaData, motionPriorPower);
		printf("Coarse ST estimation for 3 cameras (%d, %d, %d): %.4f %.4f %.4f \n\n", SelectedCamera[0], SelectedCamera[1], SelectedCamera[2], TimeStampInfoVector[0], TimeStampInfoVector[1], TimeStampInfoVector[2]);

		IncrementalLeastActionSyncDiscreteContinous2D(Path, SelectedCamera, startFrame, stopFrame, npts, TimeStampInfoVector, 0, 0, 0, lamdaData, motionPriorPower, false);

		printf(Fname, "%s/MotionPriorSyncProgress.txt", Path);	fp = fopen(Fname, "w+");
		fprintf(fp, "%d %d %d %d %.4f %.4f %.4f \n", 3, SelectedCamera[0], SelectedCamera[1], SelectedCamera[2], TimeStampInfoVector[0], TimeStampInfoVector[1], TimeStampInfoVector[2]);

		int orderingChangeTrials = 0;
		for (int currentCamID = 3; currentCamID < nCams; currentCamID++)
		{
			SelectedCamera.push_back(cameraOrdering[currentCamID]);
			TimeStampInfoVector.push_back(InitTimeStampInfoVector[currentCamID]);
			int NotSuccess = IncrementalLeastActionSyncDiscreteContinous2D(Path, SelectedCamera, startFrame, stopFrame, npts, TimeStampInfoVector, -(int)(SearchStep* SearchRange), (int)(SearchStep* SearchRange), 0.0, lamdaData, motionPriorPower);

			//Push the current ordering ID to the end of the stack
			if (NotSuccess == 1)
			{
				SelectedCamera.erase(SelectedCamera.end() - 1);
				TimeStampInfoVector.erase(TimeStampInfoVector.end() - 1);

				//Nothing can be done with this last camera
				if (currentCamID == nCams - 1)
					break;

				std::vector<int>::iterator it1;
				it1 = cameraOrdering.end();
				cameraOrdering.insert(it1, cameraOrdering[currentCamID]);
				cameraOrdering.erase(cameraOrdering.begin() + currentCamID);

				std::vector<double>::iterator it2;
				it2 = InitTimeStampInfoVector.end();
				InitTimeStampInfoVector.insert(it2, InitTimeStampInfoVector[currentCamID]);
				InitTimeStampInfoVector.erase(InitTimeStampInfoVector.begin() + currentCamID);

				currentCamID--;

				orderingChangeTrials++;
				if (orderingChangeTrials == nCams - 3) //Already tried other ordering options but failed
					break;
			}
			else
			{
				fprintf(fp, "%d ", (int)SelectedCamera.size());
				for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
					fprintf(fp, "%d ", SelectedCamera[ii]);
				for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
					fprintf(fp, "%.4f ", TimeStampInfoVector[ii]);
				fprintf(fp, "\n");
			}
		}
		fclose(fp);

		//Resort the time with the earliest camera placed first
		vector<int> SortedSelectedCamera;
		vector<double> SortedTimeStampInfoVector = TimeStampInfoVector;
		sort(SortedTimeStampInfoVector.begin(), SortedTimeStampInfoVector.end());
		for (int ii = 0; ii < (int)SelectedCamera.size(); ii++)
		{
			for (int jj = 0; jj < (int)SelectedCamera.size(); jj++)
			{
				if (TimeStampInfoVector[jj] == SortedTimeStampInfoVector[ii])
				{
					SortedSelectedCamera.push_back(SelectedCamera[jj]);
					break;
				}
			}
		}
		for (int ii = (int)SortedSelectedCamera.size() - 1; ii >= 0; ii--)
			SortedTimeStampInfoVector[ii] -= SortedTimeStampInfoVector[0];

		//Triangulate trajectories
		TrajectoryTriangulation(Path, SortedSelectedCamera, SortedTimeStampInfoVector, npts, startFrame, stopFrame, lamdaData, motionPriorPower);
		//ResamplingOf3DTrajectorySplineDriver(Path, SortedSelectedCamera, SortedTimeStampInfoVector, startFrame, stopFrame, npts, lamdaData);
		ResamplingOf3DTrajectoryDCTDriver(Path, SortedSelectedCamera, SortedTimeStampInfoVector, PriorOrder, startFrame, stopFrame, npts, lamdaData, lamdaPrior);

		sprintf(Fname, "%s/FMotionPriorSync.txt", Path);	fp = fopen(Fname, "w+");
		for (int ii = 0; ii < (int)SortedSelectedCamera.size(); ii++)
			fprintf(fp, "%d %.4f\n", SortedSelectedCamera[ii], SortedTimeStampInfoVector[ii]);
		fclose(fp);
	}
	else if (STCalibration > 1 && STCalibration < 6)
	{
		vector<int> SelectedCamera;
		vector<double> TimeStampInfoVector;

		char Fname[200]; sprintf(Fname, "%s/FMotionPriorSync.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n. Abort!", Fname);
			abort();
		}
		int selected; double offsetValue;
		while (fscanf(fp, "%d %lf ", &selected, &offsetValue) != EOF)
			SelectedCamera.push_back(selected), TimeStampInfoVector.push_back(offsetValue);
		fclose(fp);

		int nCams = (int)SelectedCamera.size();
		vector<int>  sortedSelectedCamera(nCams);
		vector<double> sortedTimeStampInfoVector(nCams);
		for (int ii = 0; ii < nCams; ii++)
			sortedSelectedCamera[ii] = SelectedCamera[ii],
			sortedTimeStampInfoVector[ii] = TimeStampInfoVector[ii];

		if (STCalibration == 2)
			TrajectoryTriangulation(Path, sortedSelectedCamera, sortedTimeStampInfoVector, npts, startFrame, stopFrame, lamdaData, motionPriorPower);
		else if (STCalibration == 3)
			ResamplingOf3DTrajectorySplineDriver(Path, sortedSelectedCamera, sortedTimeStampInfoVector, startFrame, stopFrame, npts, lamdaData);
		else if (STCalibration == 4)
			ResamplingOf3DTrajectoryDCTDriver(Path, sortedSelectedCamera, sortedTimeStampInfoVector, PriorOrder, startFrame, stopFrame, npts, lamdaData, lamdaPrior);
		else if (STCalibration == 4)
			Generate3DUncertaintyFromRandomSampling(Path, sortedSelectedCamera, sortedTimeStampInfoVector, startFrame, stopFrame, npts, 0, 100, motionPriorPower);
	}
	else if (STCalibration == 6)
	{
		vector<int> SelectedCamera, DelayInfoVector;
		char Fname[200]; sprintf(Fname, "%s/FGeoSync.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n. Abort!", Fname);
			abort();
		}
		int selected; double offsetValue;
		while (fscanf(fp, "%d %lf ", &selected, &offsetValue) != EOF)
			SelectedCamera.push_back(selected), DelayInfoVector.push_back(offsetValue);
		fclose(fp);

		double Rate = 1.0, ialpha = 1.0;
		double GTFrameTimeStamp[10];
		for (int ii = 0; ii < (int)DelayInfoVector.size(); ii++)
			//GTFrameTimeStamp[ii] = -DelayInfoVector[ii];
			GTFrameTimeStamp[ii] = DelayInfoVector[ii];

		TriangulateFrameSync2DTrajectories(Path, SelectedCamera, DelayInfoVector, startFrame, stopFrame, npts, false, GTFrameTimeStamp, &ialpha, &Rate);
	}
	printf("Total time: %.2fs\n\n", omp_get_wtime() - startTime);


	visualizationDriver(Path, nCams, startFrame, stopFrame, true, false, true, false, false, true, 0);
	return 0;
}

