int runsiftopencv()
{
	char Fname[200];
	FILE *fp = 0;
	int ii, jj, totalPts = 0;

	bool useBFMatcher = true, BinaryDesc = false;

	int minHessian = 10000, descriptorSize = 128;
	SiftFeatureDetector detector(50000);
	SiftDescriptorExtractor extractor;

	Mat descriptors1, descriptors2, img, imgGray, equalizedImg;
	vector<KeyPoint> keypoints1, keypoints2; keypoints1.reserve(50000), keypoints1.reserve(50000);
	Mat indices, dists;
	vector<vector<DMatch> > matches; matches.reserve(50000);

	double start = omp_get_wtime();

	for (int times = 0; times < 10; times++)
	{
		keypoints1.clear(), keypoints2.clear();
		matches.clear();
		sprintf(Fname, "C:/temp/Data/_4.ppm");
		img = imread(Fname, CV_LOAD_IMAGE_COLOR);
		if (img.empty())
			printf("Can't read %s\n", Fname);
		detector.detect(img, keypoints1);
		extractor.compute(img, keypoints1, descriptors1);

		sprintf(Fname, "C:/temp/Data/_5.ppm");
		img = imread(Fname, CV_LOAD_IMAGE_COLOR);
		if (img.empty())
			printf("Can't read %s\n", Fname);
		detector.detect(img, keypoints2);
		extractor.compute(img, keypoints2, descriptors2);

		//printf("Extracting key points and descriptor for view %d frame %d ", ii + 1, timeID);
		printf("Obtain %d points %d points", keypoints1.size(), keypoints2.size());
		//printf("Finished extracting feature points ... in %.2fs\n", omp_get_wtime() - start);

		// NEAREST NEIGHBOR MATCHING USING FLANN LIBRARY :  match descriptor2 to descriptor1
		vector<int> *MatchingMatrix = new vector<int>[totalPts];

		bool useBFMatcher = false; // SET TO TRUE TO USE BRUTE FORCE MATCHER
		const int knn = 2, ntrees = 4, maxLeafCheck = 128;
		const float nndrRatio = 0.8f;

		if (useBFMatcher)
		{
			cv::BFMatcher matcher(cv::NORM_L2);
			matcher.knnMatch(descriptors2, descriptors1, matches, knn);
		}
		else
		{
			// Create Flann KDTree index
			cv::flann::Index flannIndex(descriptors1, cv::flann::KDTreeIndexParams(ntrees));//, cvflann::FLANN_DIST_EUCLIDEAN);
			//printf("Time creating FLANN KDTree index = %.2fs\n", omp_get_wtime() - start);

			flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams(maxLeafCheck));
		}
		//printf("Time nearest neighbor search = %.2fs\n", omp_get_wtime() - start);

		// Find correspondences by NNDR (Nearest Neighbor Distance Ratio)
		int count = 0;
		if (!useBFMatcher)
		{
			for (int i = 0; i < descriptors2.rows; ++i)
			{
				int ind1 = indices.at<int>(i, 0);
				if (indices.at<int>(i, 0) >= 0 && indices.at<int>(i, 1) >= 0 && dists.at<float>(i, 0) <= nndrRatio * dists.at<float>(i, 1))
					count++;
			}
		}
		else
		{
			for (unsigned int i = 0; i < matches.size(); ++i)
				if (matches.at(i).size() == 2 && matches.at(i).at(0).distance <= nndrRatio * matches.at(i).at(1).distance)
					count++;
		}
		printf("matching %d points\n", count);
	}
	printf("Finished matching  ... in %.2fs\n", omp_get_wtime() - start);

	return 0;
}