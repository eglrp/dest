#include "Geometry.h"
#include "Ultility.h"
#include "Visualization.h"


using ceres::AutoDiffCostFunction;
using ceres::CostFunction;
using ceres::CauchyLoss;
using ceres::SoftLOneLoss;
using ceres::HuberLoss;
using ceres::Problem;
using ceres::Solver;

using namespace std;
using namespace cv;
using namespace Eigen;

bool useGPU = true;
//SiftGPU 
#define SIFTGPU_DLL_RUNTIME// Load at runtime if the above macro defined comment the macro above to use static linking
#ifdef _WIN32
#ifdef SIFTGPU_DLL_RUNTIME
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#define FREE_MYLIB FreeLibrary
#define GET_MYPROC GetProcAddress
#endif
#else
#ifdef SIFTGPU_DLL_RUNTIME
#include <dlfcn.h>
#define FREE_MYLIB dlclose
#define GET_MYPROC dlsym
#endif
#endif

class CvEMEstimator : public CvModelEstimator2
{
public:
	CvEMEstimator();
	virtual int runKernel(const CvMat* m1, const CvMat* m2, CvMat* model);
	virtual int run5Point(const CvMat* _q1, const CvMat* _q2, CvMat* _ematrix);
	//protected: 
	bool reliable(const CvMat* m1, const CvMat* m2, const CvMat* model);
	virtual void getCoeffMat(double *eet, double* a);
	virtual void computeReprojError(const CvMat* m1, const CvMat* m2,
		const CvMat* model, CvMat* error);
};

CvEMEstimator::CvEMEstimator()
	: CvModelEstimator2(5, cvSize(3, 3), 10)
{
}
int CvEMEstimator::runKernel(const CvMat* m1, const CvMat* m2, CvMat* model)
{
	return run5Point(m1, m2, model);
}
// Notice to keep compatibility with opencv ransac, q1 and q2 have to be of 1 row x n col x 2 channel. 
int CvEMEstimator::run5Point(const CvMat* q1, const CvMat* q2, CvMat* ematrix)
{
	Mat Q1 = Mat(q1).reshape(1, q1->cols);
	Mat Q2 = Mat(q2).reshape(1, q2->cols);

	int n = Q1.rows;
	Mat Q(n, 9, CV_64F);
	Q.col(0) = Q1.col(0).mul(Q2.col(0));
	Q.col(1) = Q1.col(1).mul(Q2.col(0));
	Q.col(2) = Q2.col(0) * 1.0;
	Q.col(3) = Q1.col(0).mul(Q2.col(1));
	Q.col(4) = Q1.col(1).mul(Q2.col(1));
	Q.col(5) = Q2.col(1) * 1.0;
	Q.col(6) = Q1.col(0) * 1.0;
	Q.col(7) = Q1.col(1) * 1.0;
	Q.col(8) = 1.0;

	Mat U, W, Vt;
	SVD::compute(Q, W, U, Vt, SVD::MODIFY_A | SVD::FULL_UV);

	Mat EE = Mat(Vt.t()).colRange(5, 9) * 1.0;
	Mat A(10, 20, CV_64F);
	EE = EE.t();
	getCoeffMat((double*)EE.data, (double*)A.data);
	EE = EE.t();

	A = A.colRange(0, 10).inv() * A.colRange(10, 20);

	double b[3 * 13];
	Mat B(3, 13, CV_64F, b);
	for (int i = 0; i < 3; i++)
	{
		Mat arow1 = A.row(i * 2 + 4) * 1.0;
		Mat arow2 = A.row(i * 2 + 5) * 1.0;
		Mat row1(1, 13, CV_64F, Scalar(0.0));
		Mat row2(1, 13, CV_64F, Scalar(0.0));

		row1.colRange(1, 4) = arow1.colRange(0, 3) * 1.0;
		row1.colRange(5, 8) = arow1.colRange(3, 6) * 1.0;
		row1.colRange(9, 13) = arow1.colRange(6, 10) * 1.0;

		row2.colRange(0, 3) = arow2.colRange(0, 3) * 1.0;
		row2.colRange(4, 7) = arow2.colRange(3, 6) * 1.0;
		row2.colRange(8, 12) = arow2.colRange(6, 10) * 1.0;

		B.row(i) = row1 - row2;
	}

	double c[11];
	Mat coeffs(1, 11, CV_64F, c);
	c[10] = (b[0] * b[17] * b[34] + b[26] * b[4] * b[21] - b[26] * b[17] * b[8] - b[13] * b[4] * b[34] - b[0] * b[21] * b[30] + b[13] * b[30] * b[8]);
	c[9] = (b[26] * b[4] * b[22] + b[14] * b[30] * b[8] + b[13] * b[31] * b[8] + b[1] * b[17] * b[34] - b[13] * b[5] * b[34] + b[26] * b[5] * b[21] - b[0] * b[21] * b[31] - b[26] * b[17] * b[9] - b[1] * b[21] * b[30] + b[27] * b[4] * b[21] + b[0] * b[17] * b[35] - b[0] * b[22] * b[30] + b[13] * b[30] * b[9] + b[0] * b[18] * b[34] - b[27] * b[17] * b[8] - b[14] * b[4] * b[34] - b[13] * b[4] * b[35] - b[26] * b[18] * b[8]);
	c[8] = (b[14] * b[30] * b[9] + b[14] * b[31] * b[8] + b[13] * b[31] * b[9] - b[13] * b[4] * b[36] - b[13] * b[5] * b[35] + b[15] * b[30] * b[8] - b[13] * b[6] * b[34] + b[13] * b[30] * b[10] + b[13] * b[32] * b[8] - b[14] * b[4] * b[35] - b[14] * b[5] * b[34] + b[26] * b[4] * b[23] + b[26] * b[5] * b[22] + b[26] * b[6] * b[21] - b[26] * b[17] * b[10] - b[15] * b[4] * b[34] - b[26] * b[18] * b[9] - b[26] * b[19] * b[8] + b[27] * b[4] * b[22] + b[27] * b[5] * b[21] - b[27] * b[17] * b[9] - b[27] * b[18] * b[8] - b[1] * b[21] * b[31] - b[0] * b[23] * b[30] - b[0] * b[21] * b[32] + b[28] * b[4] * b[21] - b[28] * b[17] * b[8] + b[2] * b[17] * b[34] + b[0] * b[18] * b[35] - b[0] * b[22] * b[31] + b[0] * b[17] * b[36] + b[0] * b[19] * b[34] - b[1] * b[22] * b[30] + b[1] * b[18] * b[34] + b[1] * b[17] * b[35] - b[2] * b[21] * b[30]);
	c[7] = (b[14] * b[30] * b[10] + b[14] * b[32] * b[8] - b[3] * b[21] * b[30] + b[3] * b[17] * b[34] + b[13] * b[32] * b[9] + b[13] * b[33] * b[8] - b[13] * b[4] * b[37] - b[13] * b[5] * b[36] + b[15] * b[30] * b[9] + b[15] * b[31] * b[8] - b[16] * b[4] * b[34] - b[13] * b[6] * b[35] - b[13] * b[7] * b[34] + b[13] * b[30] * b[11] + b[13] * b[31] * b[10] + b[14] * b[31] * b[9] - b[14] * b[4] * b[36] - b[14] * b[5] * b[35] - b[14] * b[6] * b[34] + b[16] * b[30] * b[8] - b[26] * b[20] * b[8] + b[26] * b[4] * b[24] + b[26] * b[5] * b[23] + b[26] * b[6] * b[22] + b[26] * b[7] * b[21] - b[26] * b[17] * b[11] - b[15] * b[4] * b[35] - b[15] * b[5] * b[34] - b[26] * b[18] * b[10] - b[26] * b[19] * b[9] + b[27] * b[4] * b[23] + b[27] * b[5] * b[22] + b[27] * b[6] * b[21] - b[27] * b[17] * b[10] - b[27] * b[18] * b[9] - b[27] * b[19] * b[8] + b[0] * b[17] * b[37] - b[0] * b[23] * b[31] - b[0] * b[24] * b[30] - b[0] * b[21] * b[33] - b[29] * b[17] * b[8] + b[28] * b[4] * b[22] + b[28] * b[5] * b[21] - b[28] * b[17] * b[9] - b[28] * b[18] * b[8] + b[29] * b[4] * b[21] + b[1] * b[19] * b[34] - b[2] * b[21] * b[31] + b[0] * b[20] * b[34] + b[0] * b[19] * b[35] + b[0] * b[18] * b[36] - b[0] * b[22] * b[32] - b[1] * b[23] * b[30] - b[1] * b[21] * b[32] + b[1] * b[18] * b[35] - b[1] * b[22] * b[31] - b[2] * b[22] * b[30] + b[2] * b[17] * b[35] + b[1] * b[17] * b[36] + b[2] * b[18] * b[34]);
	c[6] = (-b[14] * b[6] * b[35] - b[14] * b[7] * b[34] - b[3] * b[22] * b[30] - b[3] * b[21] * b[31] + b[3] * b[17] * b[35] + b[3] * b[18] * b[34] + b[13] * b[32] * b[10] + b[13] * b[33] * b[9] - b[13] * b[4] * b[38] - b[13] * b[5] * b[37] - b[15] * b[6] * b[34] + b[15] * b[30] * b[10] + b[15] * b[32] * b[8] - b[16] * b[4] * b[35] - b[13] * b[6] * b[36] - b[13] * b[7] * b[35] + b[13] * b[31] * b[11] + b[13] * b[30] * b[12] + b[14] * b[32] * b[9] + b[14] * b[33] * b[8] - b[14] * b[4] * b[37] - b[14] * b[5] * b[36] + b[16] * b[30] * b[9] + b[16] * b[31] * b[8] - b[26] * b[20] * b[9] + b[26] * b[4] * b[25] + b[26] * b[5] * b[24] + b[26] * b[6] * b[23] + b[26] * b[7] * b[22] - b[26] * b[17] * b[12] + b[14] * b[30] * b[11] + b[14] * b[31] * b[10] + b[15] * b[31] * b[9] - b[15] * b[4] * b[36] - b[15] * b[5] * b[35] - b[26] * b[18] * b[11] - b[26] * b[19] * b[10] - b[27] * b[20] * b[8] + b[27] * b[4] * b[24] + b[27] * b[5] * b[23] + b[27] * b[6] * b[22] + b[27] * b[7] * b[21] - b[27] * b[17] * b[11] - b[27] * b[18] * b[10] - b[27] * b[19] * b[9] - b[16] * b[5] * b[34] - b[29] * b[17] * b[9] - b[29] * b[18] * b[8] + b[28] * b[4] * b[23] + b[28] * b[5] * b[22] + b[28] * b[6] * b[21] - b[28] * b[17] * b[10] - b[28] * b[18] * b[9] - b[28] * b[19] * b[8] + b[29] * b[4] * b[22] + b[29] * b[5] * b[21] - b[2] * b[23] * b[30] + b[2] * b[18] * b[35] - b[1] * b[22] * b[32] - b[2] * b[21] * b[32] + b[2] * b[19] * b[34] + b[0] * b[19] * b[36] - b[0] * b[22] * b[33] + b[0] * b[20] * b[35] - b[0] * b[23] * b[32] - b[0] * b[25] * b[30] + b[0] * b[17] * b[38] + b[0] * b[18] * b[37] - b[0] * b[24] * b[31] + b[1] * b[17] * b[37] - b[1] * b[23] * b[31] - b[1] * b[24] * b[30] - b[1] * b[21] * b[33] + b[1] * b[20] * b[34] + b[1] * b[19] * b[35] + b[1] * b[18] * b[36] + b[2] * b[17] * b[36] - b[2] * b[22] * b[31]);
	c[5] = (-b[14] * b[6] * b[36] - b[14] * b[7] * b[35] + b[14] * b[31] * b[11] - b[3] * b[23] * b[30] - b[3] * b[21] * b[32] + b[3] * b[18] * b[35] - b[3] * b[22] * b[31] + b[3] * b[17] * b[36] + b[3] * b[19] * b[34] + b[13] * b[32] * b[11] + b[13] * b[33] * b[10] - b[13] * b[5] * b[38] - b[15] * b[6] * b[35] - b[15] * b[7] * b[34] + b[15] * b[30] * b[11] + b[15] * b[31] * b[10] + b[16] * b[31] * b[9] - b[13] * b[6] * b[37] - b[13] * b[7] * b[36] + b[13] * b[31] * b[12] + b[14] * b[32] * b[10] + b[14] * b[33] * b[9] - b[14] * b[4] * b[38] - b[14] * b[5] * b[37] - b[16] * b[6] * b[34] + b[16] * b[30] * b[10] + b[16] * b[32] * b[8] - b[26] * b[20] * b[10] + b[26] * b[5] * b[25] + b[26] * b[6] * b[24] + b[26] * b[7] * b[23] + b[14] * b[30] * b[12] + b[15] * b[32] * b[9] + b[15] * b[33] * b[8] - b[15] * b[4] * b[37] - b[15] * b[5] * b[36] + b[29] * b[5] * b[22] + b[29] * b[6] * b[21] - b[26] * b[18] * b[12] - b[26] * b[19] * b[11] - b[27] * b[20] * b[9] + b[27] * b[4] * b[25] + b[27] * b[5] * b[24] + b[27] * b[6] * b[23] + b[27] * b[7] * b[22] - b[27] * b[17] * b[12] - b[27] * b[18] * b[11] - b[27] * b[19] * b[10] - b[28] * b[20] * b[8] - b[16] * b[4] * b[36] - b[16] * b[5] * b[35] - b[29] * b[17] * b[10] - b[29] * b[18] * b[9] - b[29] * b[19] * b[8] + b[28] * b[4] * b[24] + b[28] * b[5] * b[23] + b[28] * b[6] * b[22] + b[28] * b[7] * b[21] - b[28] * b[17] * b[11] - b[28] * b[18] * b[10] - b[28] * b[19] * b[9] + b[29] * b[4] * b[23] - b[2] * b[22] * b[32] - b[2] * b[21] * b[33] - b[1] * b[24] * b[31] + b[0] * b[18] * b[38] - b[0] * b[24] * b[32] + b[0] * b[19] * b[37] + b[0] * b[20] * b[36] - b[0] * b[25] * b[31] - b[0] * b[23] * b[33] + b[1] * b[19] * b[36] - b[1] * b[22] * b[33] + b[1] * b[20] * b[35] + b[2] * b[19] * b[35] - b[2] * b[24] * b[30] - b[2] * b[23] * b[31] + b[2] * b[20] * b[34] + b[2] * b[17] * b[37] - b[1] * b[25] * b[30] + b[1] * b[18] * b[37] + b[1] * b[17] * b[38] - b[1] * b[23] * b[32] + b[2] * b[18] * b[36]);
	c[4] = (-b[14] * b[6] * b[37] - b[14] * b[7] * b[36] + b[14] * b[31] * b[12] + b[3] * b[17] * b[37] - b[3] * b[23] * b[31] - b[3] * b[24] * b[30] - b[3] * b[21] * b[33] + b[3] * b[20] * b[34] + b[3] * b[19] * b[35] + b[3] * b[18] * b[36] - b[3] * b[22] * b[32] + b[13] * b[32] * b[12] + b[13] * b[33] * b[11] - b[15] * b[6] * b[36] - b[15] * b[7] * b[35] + b[15] * b[31] * b[11] + b[15] * b[30] * b[12] + b[16] * b[32] * b[9] + b[16] * b[33] * b[8] - b[13] * b[6] * b[38] - b[13] * b[7] * b[37] + b[14] * b[32] * b[11] + b[14] * b[33] * b[10] - b[14] * b[5] * b[38] - b[16] * b[6] * b[35] - b[16] * b[7] * b[34] + b[16] * b[30] * b[11] + b[16] * b[31] * b[10] - b[26] * b[19] * b[12] - b[26] * b[20] * b[11] + b[26] * b[6] * b[25] + b[26] * b[7] * b[24] + b[15] * b[32] * b[10] + b[15] * b[33] * b[9] - b[15] * b[4] * b[38] - b[15] * b[5] * b[37] + b[29] * b[5] * b[23] + b[29] * b[6] * b[22] + b[29] * b[7] * b[21] - b[27] * b[20] * b[10] + b[27] * b[5] * b[25] + b[27] * b[6] * b[24] + b[27] * b[7] * b[23] - b[27] * b[18] * b[12] - b[27] * b[19] * b[11] - b[28] * b[20] * b[9] - b[16] * b[4] * b[37] - b[16] * b[5] * b[36] + b[0] * b[19] * b[38] - b[0] * b[24] * b[33] + b[0] * b[20] * b[37] - b[29] * b[17] * b[11] - b[29] * b[18] * b[10] - b[29] * b[19] * b[9] + b[28] * b[4] * b[25] + b[28] * b[5] * b[24] + b[28] * b[6] * b[23] + b[28] * b[7] * b[22] - b[28] * b[17] * b[12] - b[28] * b[18] * b[11] - b[28] * b[19] * b[10] - b[29] * b[20] * b[8] + b[29] * b[4] * b[24] + b[2] * b[18] * b[37] - b[0] * b[25] * b[32] + b[1] * b[18] * b[38] - b[1] * b[24] * b[32] + b[1] * b[19] * b[37] + b[1] * b[20] * b[36] - b[1] * b[25] * b[31] + b[2] * b[17] * b[38] + b[2] * b[19] * b[36] - b[2] * b[24] * b[31] - b[2] * b[22] * b[33] - b[2] * b[23] * b[32] + b[2] * b[20] * b[35] - b[1] * b[23] * b[33] - b[2] * b[25] * b[30]);
	c[3] = (-b[14] * b[6] * b[38] - b[14] * b[7] * b[37] + b[3] * b[19] * b[36] - b[3] * b[22] * b[33] + b[3] * b[20] * b[35] - b[3] * b[23] * b[32] - b[3] * b[25] * b[30] + b[3] * b[17] * b[38] + b[3] * b[18] * b[37] - b[3] * b[24] * b[31] - b[15] * b[6] * b[37] - b[15] * b[7] * b[36] + b[15] * b[31] * b[12] + b[16] * b[32] * b[10] + b[16] * b[33] * b[9] + b[13] * b[33] * b[12] - b[13] * b[7] * b[38] + b[14] * b[32] * b[12] + b[14] * b[33] * b[11] - b[16] * b[6] * b[36] - b[16] * b[7] * b[35] + b[16] * b[31] * b[11] + b[16] * b[30] * b[12] + b[15] * b[32] * b[11] + b[15] * b[33] * b[10] - b[15] * b[5] * b[38] + b[29] * b[5] * b[24] + b[29] * b[6] * b[23] - b[26] * b[20] * b[12] + b[26] * b[7] * b[25] - b[27] * b[19] * b[12] - b[27] * b[20] * b[11] + b[27] * b[6] * b[25] + b[27] * b[7] * b[24] - b[28] * b[20] * b[10] - b[16] * b[4] * b[38] - b[16] * b[5] * b[37] + b[29] * b[7] * b[22] - b[29] * b[17] * b[12] - b[29] * b[18] * b[11] - b[29] * b[19] * b[10] + b[28] * b[5] * b[25] + b[28] * b[6] * b[24] + b[28] * b[7] * b[23] - b[28] * b[18] * b[12] - b[28] * b[19] * b[11] - b[29] * b[20] * b[9] + b[29] * b[4] * b[25] - b[2] * b[24] * b[32] + b[0] * b[20] * b[38] - b[0] * b[25] * b[33] + b[1] * b[19] * b[38] - b[1] * b[24] * b[33] + b[1] * b[20] * b[37] - b[2] * b[25] * b[31] + b[2] * b[20] * b[36] - b[1] * b[25] * b[32] + b[2] * b[19] * b[37] + b[2] * b[18] * b[38] - b[2] * b[23] * b[33]);
	c[2] = (b[3] * b[18] * b[38] - b[3] * b[24] * b[32] + b[3] * b[19] * b[37] + b[3] * b[20] * b[36] - b[3] * b[25] * b[31] - b[3] * b[23] * b[33] - b[15] * b[6] * b[38] - b[15] * b[7] * b[37] + b[16] * b[32] * b[11] + b[16] * b[33] * b[10] - b[16] * b[5] * b[38] - b[16] * b[6] * b[37] - b[16] * b[7] * b[36] + b[16] * b[31] * b[12] + b[14] * b[33] * b[12] - b[14] * b[7] * b[38] + b[15] * b[32] * b[12] + b[15] * b[33] * b[11] + b[29] * b[5] * b[25] + b[29] * b[6] * b[24] - b[27] * b[20] * b[12] + b[27] * b[7] * b[25] - b[28] * b[19] * b[12] - b[28] * b[20] * b[11] + b[29] * b[7] * b[23] - b[29] * b[18] * b[12] - b[29] * b[19] * b[11] + b[28] * b[6] * b[25] + b[28] * b[7] * b[24] - b[29] * b[20] * b[10] + b[2] * b[19] * b[38] - b[1] * b[25] * b[33] + b[2] * b[20] * b[37] - b[2] * b[24] * b[33] - b[2] * b[25] * b[32] + b[1] * b[20] * b[38]);
	c[1] = (b[29] * b[7] * b[24] - b[29] * b[20] * b[11] + b[2] * b[20] * b[38] - b[2] * b[25] * b[33] - b[28] * b[20] * b[12] + b[28] * b[7] * b[25] - b[29] * b[19] * b[12] - b[3] * b[24] * b[33] + b[15] * b[33] * b[12] + b[3] * b[19] * b[38] - b[16] * b[6] * b[38] + b[3] * b[20] * b[37] + b[16] * b[32] * b[12] + b[29] * b[6] * b[25] - b[16] * b[7] * b[37] - b[3] * b[25] * b[32] - b[15] * b[7] * b[38] + b[16] * b[33] * b[11]);
	c[0] = -b[29] * b[20] * b[12] + b[29] * b[7] * b[25] + b[16] * b[33] * b[12] - b[16] * b[7] * b[38] + b[3] * b[20] * b[38] - b[3] * b[25] * b[33];

	std::vector<std::complex<double> > roots;
	solvePoly(coeffs, roots);

	std::vector<double> xs, ys, zs;
	int count = 0;
	double * e = ematrix->data.db;
	for (int i = 0; i < roots.size(); i++)
	{
		if (fabs(roots[i].imag()) > 1e-10) continue;
		double z1 = roots[i].real();
		double z2 = z1 * z1;
		double z3 = z2 * z1;
		double z4 = z3 * z1;

		double bz[3][3];
		for (int j = 0; j < 3; j++)
		{
			const double * br = b + j * 13;
			bz[j][0] = br[0] * z3 + br[1] * z2 + br[2] * z1 + br[3];
			bz[j][1] = br[4] * z3 + br[5] * z2 + br[6] * z1 + br[7];
			bz[j][2] = br[8] * z4 + br[9] * z3 + br[10] * z2 + br[11] * z1 + br[12];
		}

		Mat Bz(3, 3, CV_64F, bz);
		cv::Mat xy1;
		SVD::solveZ(Bz, xy1);

		if (fabs(xy1.at<double>(2)) < 1e-10) continue;
		xs.push_back(xy1.at<double>(0) / xy1.at<double>(2));
		ys.push_back(xy1.at<double>(1) / xy1.at<double>(2));
		zs.push_back(z1);

		cv::Mat Evec = EE.col(0) * xs.back() + EE.col(1) * ys.back() + EE.col(2) * zs.back() + EE.col(3);
		Evec /= norm(Evec);

		memcpy(e + count * 9, Evec.data, 9 * sizeof(double));
		count++;
	}

	return count;

}
// Same as the runKernel (run5Point), m1 and m2 should be 1 row x n col x 2 channels. And also, error has to be of CV_32FC1. 
void CvEMEstimator::computeReprojError(const CvMat* m1, const CvMat* m2, const CvMat* model, CvMat* error)
{
	Mat X1(m1), X2(m2);
	int n = X1.cols;
	X1 = X1.reshape(1, n);
	X2 = X2.reshape(1, n);

	X1.convertTo(X1, CV_64F);
	X2.convertTo(X2, CV_64F);

	Mat E(model);
	for (int i = 0; i < n; i++)
	{
		Mat x1 = (Mat_<double>(3, 1) << X1.at<double>(i, 0), X1.at<double>(i, 1), 1.0);
		Mat x2 = (Mat_<double>(3, 1) << X2.at<double>(i, 0), X2.at<double>(i, 1), 1.0);
		double x2tEx1 = x2.dot(E * x1);
		Mat Ex1 = E * x1;
		Mat Etx2 = E * x2;
		double a = Ex1.at<double>(0) * Ex1.at<double>(0);
		double b = Ex1.at<double>(1) * Ex1.at<double>(1);
		double c = Etx2.at<double>(0) * Etx2.at<double>(0);
		double d = Etx2.at<double>(0) * Etx2.at<double>(0);

		error->data.fl[i] = x2tEx1 * x2tEx1 / (a + b + c + d);
	}

	/*	Eigen::MatrixXd X1t, X2t;
	cv2eigen(Mat(m1).reshape(1, m1->cols), X1t);
	cv2eigen(Mat(m2).reshape(1, m2->cols), X2t);
	Eigen::MatrixXd X1(3, X1t.rows());
	Eigen::MatrixXd X2(3, X2t.rows());
	X1.topRows(2) = X1t.transpose();
	X2.topRows(2) = X2t.transpose();
	X1.row(2).setOnes();
	X2.row(2).setOnes();

	Eigen::MatrixXd E;
	cv2eigen(Mat(model), E);

	// Compute Simpson's error
	Eigen::MatrixXd Ex1, x2tEx1, Etx2, SimpsonError;
	Ex1 = E * X1;
	x2tEx1 = (X2.array() * Ex1.array()).matrix().colwise().sum();
	Etx2 = E.transpose() * X2;
	SimpsonError = x2tEx1.array().square() / (Ex1.row(0).array().square() + Ex1.row(1).array().square() + Etx2.row(0).array().square() + Etx2.row(1).array().square());

	assert( CV_IS_MAT_CONT(error->type) );
	Mat isInliers, R, t;
	for (int i = 0; i < SimpsonError.cols(); i++)
	{
	error->data.fl[i] = SimpsonError(0, i);
	}
	*/
}
void CvEMEstimator::getCoeffMat(double *e, double *A)
{
	double ep2[36], ep3[36];
	for (int i = 0; i < 36; i++)
	{
		ep2[i] = e[i] * e[i];
		ep3[i] = ep2[i] * e[i];
	}

	A[0] = e[33] * e[28] * e[32] - e[33] * e[31] * e[29] + e[30] * e[34] * e[29] - e[30] * e[28] * e[35] - e[27] * e[32] * e[34] + e[27] * e[31] * e[35];
	A[146] = .5000000000*e[6] * ep2[8] - .5000000000*e[6] * ep2[5] + .5000000000*ep3[6] + .5000000000*e[6] * ep2[7] - .5000000000*e[6] * ep2[4] + e[0] * e[2] * e[8] + e[3] * e[4] * e[7] + e[3] * e[5] * e[8] + e[0] * e[1] * e[7] - .5000000000*e[6] * ep2[1] - .5000000000*e[6] * ep2[2] + .5000000000*ep2[0] * e[6] + .5000000000*ep2[3] * e[6];
	A[1] = e[30] * e[34] * e[2] + e[33] * e[1] * e[32] - e[3] * e[28] * e[35] + e[0] * e[31] * e[35] + e[3] * e[34] * e[29] - e[30] * e[1] * e[35] + e[27] * e[31] * e[8] - e[27] * e[32] * e[7] - e[30] * e[28] * e[8] - e[33] * e[31] * e[2] - e[0] * e[32] * e[34] + e[6] * e[28] * e[32] - e[33] * e[4] * e[29] + e[33] * e[28] * e[5] + e[30] * e[7] * e[29] + e[27] * e[4] * e[35] - e[27] * e[5] * e[34] - e[6] * e[31] * e[29];
	A[147] = e[9] * e[27] * e[15] + e[9] * e[29] * e[17] + e[9] * e[11] * e[35] + e[9] * e[28] * e[16] + e[9] * e[10] * e[34] + e[27] * e[11] * e[17] + e[27] * e[10] * e[16] + e[12] * e[30] * e[15] + e[12] * e[32] * e[17] + e[12] * e[14] * e[35] + e[12] * e[31] * e[16] + e[12] * e[13] * e[34] + e[30] * e[14] * e[17] + e[30] * e[13] * e[16] + e[15] * e[35] * e[17] + e[15] * e[34] * e[16] - 1.*e[15] * e[28] * e[10] - 1.*e[15] * e[31] * e[13] - 1.*e[15] * e[32] * e[14] - 1.*e[15] * e[29] * e[11] + .5000000000*ep2[9] * e[33] + .5000000000*e[33] * ep2[16] - .5000000000*e[33] * ep2[11] + .5000000000*e[33] * ep2[12] + 1.500000000*e[33] * ep2[15] + .5000000000*e[33] * ep2[17] - .5000000000*e[33] * ep2[10] - .5000000000*e[33] * ep2[14] - .5000000000*e[33] * ep2[13];
	A[2] = -e[33] * e[22] * e[29] - e[33] * e[31] * e[20] - e[27] * e[32] * e[25] + e[27] * e[22] * e[35] - e[27] * e[23] * e[34] + e[27] * e[31] * e[26] + e[33] * e[28] * e[23] - e[21] * e[28] * e[35] + e[30] * e[25] * e[29] + e[24] * e[28] * e[32] - e[24] * e[31] * e[29] + e[18] * e[31] * e[35] - e[30] * e[28] * e[26] - e[30] * e[19] * e[35] + e[21] * e[34] * e[29] + e[33] * e[19] * e[32] - e[18] * e[32] * e[34] + e[30] * e[34] * e[20];
	A[144] = e[18] * e[2] * e[17] + e[3] * e[21] * e[15] + e[3] * e[12] * e[24] + e[3] * e[23] * e[17] + e[3] * e[14] * e[26] + e[3] * e[22] * e[16] + e[3] * e[13] * e[25] + 3.*e[6] * e[24] * e[15] + e[6] * e[26] * e[17] + e[6] * e[25] * e[16] + e[0] * e[20] * e[17] + e[0] * e[11] * e[26] + e[0] * e[19] * e[16] + e[0] * e[10] * e[25] + e[15] * e[26] * e[8] - 1.*e[15] * e[20] * e[2] - 1.*e[15] * e[19] * e[1] - 1.*e[15] * e[22] * e[4] + e[15] * e[25] * e[7] - 1.*e[15] * e[23] * e[5] + e[12] * e[21] * e[6] + e[12] * e[22] * e[7] + e[12] * e[4] * e[25] + e[12] * e[23] * e[8] + e[12] * e[5] * e[26] - 1.*e[24] * e[11] * e[2] - 1.*e[24] * e[10] * e[1] - 1.*e[24] * e[13] * e[4] + e[24] * e[16] * e[7] - 1.*e[24] * e[14] * e[5] + e[24] * e[17] * e[8] + e[21] * e[13] * e[7] + e[21] * e[4] * e[16] + e[21] * e[14] * e[8] + e[21] * e[5] * e[17] - 1.*e[6] * e[23] * e[14] - 1.*e[6] * e[20] * e[11] - 1.*e[6] * e[19] * e[10] - 1.*e[6] * e[22] * e[13] + e[9] * e[18] * e[6] + e[9] * e[0] * e[24] + e[9] * e[19] * e[7] + e[9] * e[1] * e[25] + e[9] * e[20] * e[8] + e[9] * e[2] * e[26] + e[18] * e[0] * e[15] + e[18] * e[10] * e[7] + e[18] * e[1] * e[16] + e[18] * e[11] * e[8];
	A[3] = e[33] * e[10] * e[32] + e[33] * e[28] * e[14] - e[33] * e[13] * e[29] - e[33] * e[31] * e[11] + e[9] * e[31] * e[35] - e[9] * e[32] * e[34] + e[27] * e[13] * e[35] - e[27] * e[32] * e[16] + e[27] * e[31] * e[17] - e[27] * e[14] * e[34] + e[12] * e[34] * e[29] - e[12] * e[28] * e[35] + e[30] * e[34] * e[11] + e[30] * e[16] * e[29] - e[30] * e[10] * e[35] - e[30] * e[28] * e[17] + e[15] * e[28] * e[32] - e[15] * e[31] * e[29];
	A[145] = e[0] * e[27] * e[6] + e[0] * e[28] * e[7] + e[0] * e[1] * e[34] + e[0] * e[29] * e[8] + e[0] * e[2] * e[35] + e[6] * e[34] * e[7] - 1.*e[6] * e[32] * e[5] + e[6] * e[30] * e[3] + e[6] * e[35] * e[8] - 1.*e[6] * e[29] * e[2] - 1.*e[6] * e[28] * e[1] - 1.*e[6] * e[31] * e[4] + e[27] * e[1] * e[7] + e[27] * e[2] * e[8] + e[3] * e[31] * e[7] + e[3] * e[4] * e[34] + e[3] * e[32] * e[8] + e[3] * e[5] * e[35] + e[30] * e[4] * e[7] + e[30] * e[5] * e[8] + .5000000000*ep2[0] * e[33] + 1.500000000*e[33] * ep2[6] - .5000000000*e[33] * ep2[4] - .5000000000*e[33] * ep2[5] - .5000000000*e[33] * ep2[1] + .5000000000*e[33] * ep2[7] + .5000000000*e[33] * ep2[3] - .5000000000*e[33] * ep2[2] + .5000000000*e[33] * ep2[8];
	A[4] = -e[0] * e[23] * e[16] + e[9] * e[4] * e[26] + e[9] * e[22] * e[8] - e[9] * e[5] * e[25] - e[9] * e[23] * e[7] + e[18] * e[4] * e[17] + e[18] * e[13] * e[8] - e[18] * e[5] * e[16] - e[18] * e[14] * e[7] + e[3] * e[16] * e[20] + e[3] * e[25] * e[11] - e[3] * e[10] * e[26] - e[3] * e[19] * e[17] + e[12] * e[7] * e[20] + e[12] * e[25] * e[2] - e[12] * e[1] * e[26] - e[12] * e[19] * e[8] + e[21] * e[7] * e[11] + e[21] * e[16] * e[2] - e[21] * e[1] * e[17] - e[21] * e[10] * e[8] + e[6] * e[10] * e[23] + e[6] * e[19] * e[14] - e[6] * e[13] * e[20] - e[6] * e[22] * e[11] + e[15] * e[1] * e[23] + e[15] * e[19] * e[5] - e[15] * e[4] * e[20] - e[15] * e[22] * e[2] + e[24] * e[1] * e[14] + e[24] * e[10] * e[5] - e[24] * e[4] * e[11] - e[24] * e[13] * e[2] + e[0] * e[13] * e[26] + e[0] * e[22] * e[17] - e[0] * e[14] * e[25];
	A[150] = e[18] * e[19] * e[25] + .5000000000*ep3[24] - .5000000000*e[24] * ep2[23] + e[18] * e[20] * e[26] + e[21] * e[22] * e[25] + e[21] * e[23] * e[26] - .5000000000*e[24] * ep2[19] + .5000000000*ep2[21] * e[24] + .5000000000*e[24] * ep2[26] - .5000000000*e[24] * ep2[20] + .5000000000*ep2[18] * e[24] - .5000000000*e[24] * ep2[22] + .5000000000*e[24] * ep2[25];
	A[5] = -e[3] * e[1] * e[35] - e[0] * e[32] * e[7] + e[27] * e[4] * e[8] + e[33] * e[1] * e[5] - e[33] * e[4] * e[2] + e[0] * e[4] * e[35] + e[3] * e[34] * e[2] - e[30] * e[1] * e[8] + e[30] * e[7] * e[2] - e[6] * e[4] * e[29] + e[3] * e[7] * e[29] + e[6] * e[1] * e[32] - e[0] * e[5] * e[34] - e[3] * e[28] * e[8] + e[0] * e[31] * e[8] + e[6] * e[28] * e[5] - e[6] * e[31] * e[2] - e[27] * e[5] * e[7];
	A[151] = e[33] * e[16] * e[7] - 1.*e[33] * e[14] * e[5] + e[33] * e[17] * e[8] + e[30] * e[13] * e[7] + e[30] * e[4] * e[16] + e[30] * e[14] * e[8] + e[30] * e[5] * e[17] + e[6] * e[27] * e[9] - 1.*e[6] * e[28] * e[10] - 1.*e[6] * e[31] * e[13] - 1.*e[6] * e[32] * e[14] - 1.*e[6] * e[29] * e[11] + e[9] * e[28] * e[7] + e[9] * e[1] * e[34] + e[9] * e[29] * e[8] + e[9] * e[2] * e[35] + e[27] * e[10] * e[7] + e[27] * e[1] * e[16] + e[27] * e[11] * e[8] + e[27] * e[2] * e[17] + e[3] * e[30] * e[15] + e[3] * e[12] * e[33] + e[3] * e[32] * e[17] + e[3] * e[14] * e[35] + e[3] * e[31] * e[16] + e[3] * e[13] * e[34] + 3.*e[6] * e[33] * e[15] + e[6] * e[35] * e[17] + e[6] * e[34] * e[16] + e[0] * e[27] * e[15] + e[0] * e[9] * e[33] + e[0] * e[29] * e[17] + e[0] * e[11] * e[35] + e[0] * e[28] * e[16] + e[0] * e[10] * e[34] + e[15] * e[34] * e[7] - 1.*e[15] * e[32] * e[5] + e[15] * e[35] * e[8] - 1.*e[15] * e[29] * e[2] - 1.*e[15] * e[28] * e[1] - 1.*e[15] * e[31] * e[4] + e[12] * e[30] * e[6] + e[12] * e[31] * e[7] + e[12] * e[4] * e[34] + e[12] * e[32] * e[8] + e[12] * e[5] * e[35] - 1.*e[33] * e[11] * e[2] - 1.*e[33] * e[10] * e[1] - 1.*e[33] * e[13] * e[4];
	A[6] = e[6] * e[1] * e[5] - e[6] * e[4] * e[2] + e[3] * e[7] * e[2] + e[0] * e[4] * e[8] - e[0] * e[5] * e[7] - e[3] * e[1] * e[8];
	A[148] = .5000000000*ep3[15] + e[9] * e[10] * e[16] - .5000000000*e[15] * ep2[11] + e[9] * e[11] * e[17] + .5000000000*ep2[12] * e[15] + .5000000000*e[15] * ep2[16] + .5000000000*e[15] * ep2[17] - .5000000000*e[15] * ep2[13] + .5000000000*ep2[9] * e[15] + e[12] * e[14] * e[17] - .5000000000*e[15] * ep2[10] - .5000000000*e[15] * ep2[14] + e[12] * e[13] * e[16];
	A[7] = e[15] * e[28] * e[14] - e[15] * e[13] * e[29] - e[15] * e[31] * e[11] + e[33] * e[10] * e[14] - e[33] * e[13] * e[11] + e[9] * e[13] * e[35] - e[9] * e[32] * e[16] + e[9] * e[31] * e[17] - e[9] * e[14] * e[34] + e[27] * e[13] * e[17] - e[27] * e[14] * e[16] + e[12] * e[34] * e[11] + e[12] * e[16] * e[29] - e[12] * e[10] * e[35] - e[12] * e[28] * e[17] + e[30] * e[16] * e[11] - e[30] * e[10] * e[17] + e[15] * e[10] * e[32];
	A[149] = e[18] * e[27] * e[24] + e[18] * e[28] * e[25] + e[18] * e[19] * e[34] + e[18] * e[29] * e[26] + e[18] * e[20] * e[35] + e[27] * e[19] * e[25] + e[27] * e[20] * e[26] + e[21] * e[30] * e[24] + e[21] * e[31] * e[25] + e[21] * e[22] * e[34] + e[21] * e[32] * e[26] + e[21] * e[23] * e[35] + e[30] * e[22] * e[25] + e[30] * e[23] * e[26] + e[24] * e[34] * e[25] + e[24] * e[35] * e[26] - 1.*e[24] * e[29] * e[20] - 1.*e[24] * e[31] * e[22] - 1.*e[24] * e[32] * e[23] - 1.*e[24] * e[28] * e[19] + 1.500000000*e[33] * ep2[24] + .5000000000*e[33] * ep2[25] + .5000000000*e[33] * ep2[26] - .5000000000*e[33] * ep2[23] - .5000000000*e[33] * ep2[19] - .5000000000*e[33] * ep2[20] - .5000000000*e[33] * ep2[22] + .5000000000*ep2[18] * e[33] + .5000000000*ep2[21] * e[33];
	A[9] = e[21] * e[25] * e[29] - e[27] * e[23] * e[25] + e[24] * e[19] * e[32] - e[21] * e[28] * e[26] - e[21] * e[19] * e[35] + e[18] * e[31] * e[26] - e[30] * e[19] * e[26] - e[24] * e[31] * e[20] + e[24] * e[28] * e[23] + e[27] * e[22] * e[26] + e[30] * e[25] * e[20] - e[33] * e[22] * e[20] + e[33] * e[19] * e[23] + e[21] * e[34] * e[20] - e[18] * e[23] * e[34] - e[24] * e[22] * e[29] - e[18] * e[32] * e[25] + e[18] * e[22] * e[35];
	A[155] = e[12] * e[14] * e[8] + e[12] * e[5] * e[17] + e[15] * e[16] * e[7] + e[15] * e[17] * e[8] + e[0] * e[11] * e[17] + e[0] * e[9] * e[15] + e[0] * e[10] * e[16] + e[3] * e[14] * e[17] + e[3] * e[13] * e[16] + e[9] * e[10] * e[7] + e[9] * e[1] * e[16] + e[9] * e[11] * e[8] + e[9] * e[2] * e[17] - 1.*e[15] * e[11] * e[2] - 1.*e[15] * e[10] * e[1] - 1.*e[15] * e[13] * e[4] - 1.*e[15] * e[14] * e[5] + e[12] * e[3] * e[15] + e[12] * e[13] * e[7] + e[12] * e[4] * e[16] + .5000000000*ep2[12] * e[6] + 1.500000000*ep2[15] * e[6] + .5000000000*e[6] * ep2[17] + .5000000000*e[6] * ep2[16] + .5000000000*e[6] * ep2[9] - .5000000000*e[6] * ep2[11] - .5000000000*e[6] * ep2[10] - .5000000000*e[6] * ep2[14] - .5000000000*e[6] * ep2[13];
	A[8] = -e[9] * e[14] * e[16] - e[12] * e[10] * e[17] + e[9] * e[13] * e[17] - e[15] * e[13] * e[11] + e[15] * e[10] * e[14] + e[12] * e[16] * e[11];
	A[154] = e[21] * e[14] * e[17] + e[21] * e[13] * e[16] + e[15] * e[26] * e[17] + e[15] * e[25] * e[16] - 1.*e[15] * e[23] * e[14] - 1.*e[15] * e[20] * e[11] - 1.*e[15] * e[19] * e[10] - 1.*e[15] * e[22] * e[13] + e[9] * e[20] * e[17] + e[9] * e[11] * e[26] + e[9] * e[19] * e[16] + e[9] * e[10] * e[25] + .5000000000*ep2[12] * e[24] + 1.500000000*e[24] * ep2[15] + .5000000000*e[24] * ep2[17] + .5000000000*e[24] * ep2[16] + .5000000000*ep2[9] * e[24] - .5000000000*e[24] * ep2[11] - .5000000000*e[24] * ep2[10] - .5000000000*e[24] * ep2[14] - .5000000000*e[24] * ep2[13] + e[18] * e[11] * e[17] + e[18] * e[9] * e[15] + e[18] * e[10] * e[16] + e[12] * e[21] * e[15] + e[12] * e[23] * e[17] + e[12] * e[14] * e[26] + e[12] * e[22] * e[16] + e[12] * e[13] * e[25];
	A[11] = -e[9] * e[5] * e[34] + e[9] * e[31] * e[8] - e[9] * e[32] * e[7] + e[27] * e[4] * e[17] + e[27] * e[13] * e[8] - e[27] * e[5] * e[16] - e[27] * e[14] * e[7] + e[0] * e[13] * e[35] - e[0] * e[32] * e[16] + e[0] * e[31] * e[17] - e[0] * e[14] * e[34] + e[9] * e[4] * e[35] + e[6] * e[10] * e[32] + e[6] * e[28] * e[14] - e[6] * e[13] * e[29] - e[6] * e[31] * e[11] + e[15] * e[1] * e[32] + e[3] * e[34] * e[11] + e[3] * e[16] * e[29] - e[3] * e[10] * e[35] - e[3] * e[28] * e[17] - e[12] * e[1] * e[35] + e[12] * e[7] * e[29] + e[12] * e[34] * e[2] - e[12] * e[28] * e[8] + e[15] * e[28] * e[5] - e[15] * e[4] * e[29] - e[15] * e[31] * e[2] + e[33] * e[1] * e[14] + e[33] * e[10] * e[5] - e[33] * e[4] * e[11] - e[33] * e[13] * e[2] + e[30] * e[7] * e[11] + e[30] * e[16] * e[2] - e[30] * e[1] * e[17] - e[30] * e[10] * e[8];
	A[153] = e[21] * e[31] * e[7] + e[21] * e[4] * e[34] + e[21] * e[32] * e[8] + e[21] * e[5] * e[35] + e[30] * e[22] * e[7] + e[30] * e[4] * e[25] + e[30] * e[23] * e[8] + e[30] * e[5] * e[26] + 3.*e[24] * e[33] * e[6] + e[24] * e[34] * e[7] + e[24] * e[35] * e[8] + e[33] * e[25] * e[7] + e[33] * e[26] * e[8] + e[0] * e[27] * e[24] + e[0] * e[18] * e[33] + e[0] * e[28] * e[25] + e[0] * e[19] * e[34] + e[0] * e[29] * e[26] + e[0] * e[20] * e[35] + e[18] * e[27] * e[6] + e[18] * e[28] * e[7] + e[18] * e[1] * e[34] + e[18] * e[29] * e[8] + e[18] * e[2] * e[35] + e[27] * e[19] * e[7] + e[27] * e[1] * e[25] + e[27] * e[20] * e[8] + e[27] * e[2] * e[26] + e[3] * e[30] * e[24] + e[3] * e[21] * e[33] + e[3] * e[31] * e[25] + e[3] * e[22] * e[34] + e[3] * e[32] * e[26] + e[3] * e[23] * e[35] + e[6] * e[30] * e[21] - 1.*e[6] * e[29] * e[20] + e[6] * e[35] * e[26] - 1.*e[6] * e[31] * e[22] - 1.*e[6] * e[32] * e[23] - 1.*e[6] * e[28] * e[19] + e[6] * e[34] * e[25] - 1.*e[24] * e[32] * e[5] - 1.*e[24] * e[29] * e[2] - 1.*e[24] * e[28] * e[1] - 1.*e[24] * e[31] * e[4] - 1.*e[33] * e[20] * e[2] - 1.*e[33] * e[19] * e[1] - 1.*e[33] * e[22] * e[4] - 1.*e[33] * e[23] * e[5];
	A[10] = e[21] * e[25] * e[20] - e[21] * e[19] * e[26] + e[18] * e[22] * e[26] - e[18] * e[23] * e[25] - e[24] * e[22] * e[20] + e[24] * e[19] * e[23];
	A[152] = e[3] * e[4] * e[25] + e[3] * e[23] * e[8] + e[3] * e[5] * e[26] + e[21] * e[4] * e[7] + e[21] * e[5] * e[8] + e[6] * e[25] * e[7] + e[6] * e[26] * e[8] + e[0] * e[19] * e[7] + e[0] * e[1] * e[25] + e[0] * e[20] * e[8] + e[0] * e[2] * e[26] - 1.*e[6] * e[20] * e[2] - 1.*e[6] * e[19] * e[1] - 1.*e[6] * e[22] * e[4] - 1.*e[6] * e[23] * e[5] + e[18] * e[1] * e[7] + e[18] * e[0] * e[6] + e[18] * e[2] * e[8] + e[3] * e[21] * e[6] + e[3] * e[22] * e[7] - .5000000000*e[24] * ep2[4] + .5000000000*e[24] * ep2[0] + 1.500000000*e[24] * ep2[6] - .5000000000*e[24] * ep2[5] - .5000000000*e[24] * ep2[1] + .5000000000*e[24] * ep2[7] + .5000000000*e[24] * ep2[3] - .5000000000*e[24] * ep2[2] + .5000000000*e[24] * ep2[8];
	A[13] = e[6] * e[28] * e[23] - e[6] * e[22] * e[29] - e[6] * e[31] * e[20] - e[3] * e[19] * e[35] + e[3] * e[34] * e[20] + e[3] * e[25] * e[29] - e[21] * e[1] * e[35] + e[21] * e[7] * e[29] + e[21] * e[34] * e[2] + e[24] * e[1] * e[32] + e[24] * e[28] * e[5] - e[24] * e[4] * e[29] - e[24] * e[31] * e[2] + e[33] * e[1] * e[23] + e[33] * e[19] * e[5] - e[33] * e[4] * e[20] - e[33] * e[22] * e[2] - e[21] * e[28] * e[8] + e[30] * e[7] * e[20] + e[30] * e[25] * e[2] - e[30] * e[1] * e[26] + e[18] * e[4] * e[35] - e[18] * e[5] * e[34] + e[18] * e[31] * e[8] - e[18] * e[32] * e[7] + e[27] * e[4] * e[26] + e[27] * e[22] * e[8] - e[27] * e[5] * e[25] - e[27] * e[23] * e[7] - e[3] * e[28] * e[26] - e[0] * e[32] * e[25] + e[0] * e[22] * e[35] - e[0] * e[23] * e[34] + e[0] * e[31] * e[26] - e[30] * e[19] * e[8] + e[6] * e[19] * e[32];
	A[159] = .5000000000*ep2[18] * e[6] + .5000000000*ep2[21] * e[6] + 1.500000000*ep2[24] * e[6] + .5000000000*e[6] * ep2[26] - .5000000000*e[6] * ep2[23] - .5000000000*e[6] * ep2[19] - .5000000000*e[6] * ep2[20] - .5000000000*e[6] * ep2[22] + .5000000000*e[6] * ep2[25] + e[21] * e[3] * e[24] + e[18] * e[20] * e[8] + e[21] * e[4] * e[25] + e[18] * e[19] * e[7] + e[18] * e[1] * e[25] + e[21] * e[22] * e[7] + e[21] * e[23] * e[8] + e[18] * e[0] * e[24] + e[18] * e[2] * e[26] + e[21] * e[5] * e[26] + e[24] * e[26] * e[8] - 1.*e[24] * e[20] * e[2] - 1.*e[24] * e[19] * e[1] - 1.*e[24] * e[22] * e[4] + e[24] * e[25] * e[7] - 1.*e[24] * e[23] * e[5] + e[0] * e[19] * e[25] + e[0] * e[20] * e[26] + e[3] * e[22] * e[25] + e[3] * e[23] * e[26];
	A[12] = e[18] * e[4] * e[8] + e[3] * e[7] * e[20] + e[3] * e[25] * e[2] - e[3] * e[1] * e[26] - e[18] * e[5] * e[7] + e[6] * e[1] * e[23] + e[6] * e[19] * e[5] - e[6] * e[4] * e[20] - e[6] * e[22] * e[2] + e[21] * e[7] * e[2] - e[21] * e[1] * e[8] + e[24] * e[1] * e[5] - e[24] * e[4] * e[2] - e[3] * e[19] * e[8] + e[0] * e[4] * e[26] + e[0] * e[22] * e[8] - e[0] * e[5] * e[25] - e[0] * e[23] * e[7];
	A[158] = e[9] * e[1] * e[7] + e[9] * e[0] * e[6] + e[9] * e[2] * e[8] + e[3] * e[12] * e[6] + e[3] * e[13] * e[7] + e[3] * e[4] * e[16] + e[3] * e[14] * e[8] + e[3] * e[5] * e[17] + e[12] * e[4] * e[7] + e[12] * e[5] * e[8] + e[6] * e[16] * e[7] + e[6] * e[17] * e[8] - 1.*e[6] * e[11] * e[2] - 1.*e[6] * e[10] * e[1] - 1.*e[6] * e[13] * e[4] - 1.*e[6] * e[14] * e[5] + e[0] * e[10] * e[7] + e[0] * e[1] * e[16] + e[0] * e[11] * e[8] + e[0] * e[2] * e[17] + .5000000000*ep2[3] * e[15] + 1.500000000*e[15] * ep2[6] + .5000000000*e[15] * ep2[7] + .5000000000*e[15] * ep2[8] + .5000000000*ep2[0] * e[15] - .5000000000*e[15] * ep2[4] - .5000000000*e[15] * ep2[5] - .5000000000*e[15] * ep2[1] - .5000000000*e[15] * ep2[2];
	A[15] = -e[15] * e[13] * e[2] - e[6] * e[13] * e[11] - e[15] * e[4] * e[11] + e[12] * e[16] * e[2] - e[3] * e[10] * e[17] + e[3] * e[16] * e[11] + e[0] * e[13] * e[17] - e[0] * e[14] * e[16] + e[15] * e[1] * e[14] - e[12] * e[10] * e[8] + e[9] * e[4] * e[17] + e[9] * e[13] * e[8] - e[9] * e[5] * e[16] - e[9] * e[14] * e[7] + e[15] * e[10] * e[5] + e[12] * e[7] * e[11] + e[6] * e[10] * e[14] - e[12] * e[1] * e[17];
	A[157] = e[12] * e[30] * e[24] + e[12] * e[21] * e[33] + e[12] * e[31] * e[25] + e[12] * e[22] * e[34] + e[12] * e[32] * e[26] + e[12] * e[23] * e[35] + e[9] * e[27] * e[24] + e[9] * e[18] * e[33] + e[9] * e[28] * e[25] + e[9] * e[19] * e[34] + e[9] * e[29] * e[26] + e[9] * e[20] * e[35] + e[21] * e[30] * e[15] + e[21] * e[32] * e[17] + e[21] * e[14] * e[35] + e[21] * e[31] * e[16] + e[21] * e[13] * e[34] + e[30] * e[23] * e[17] + e[30] * e[14] * e[26] + e[30] * e[22] * e[16] + e[30] * e[13] * e[25] + e[15] * e[27] * e[18] + 3.*e[15] * e[33] * e[24] - 1.*e[15] * e[29] * e[20] + e[15] * e[35] * e[26] - 1.*e[15] * e[31] * e[22] - 1.*e[15] * e[32] * e[23] - 1.*e[15] * e[28] * e[19] + e[15] * e[34] * e[25] + e[18] * e[29] * e[17] + e[18] * e[11] * e[35] + e[18] * e[28] * e[16] + e[18] * e[10] * e[34] + e[27] * e[20] * e[17] + e[27] * e[11] * e[26] + e[27] * e[19] * e[16] + e[27] * e[10] * e[25] - 1.*e[24] * e[28] * e[10] - 1.*e[24] * e[31] * e[13] - 1.*e[24] * e[32] * e[14] + e[24] * e[34] * e[16] + e[24] * e[35] * e[17] - 1.*e[24] * e[29] * e[11] - 1.*e[33] * e[23] * e[14] + e[33] * e[25] * e[16] + e[33] * e[26] * e[17] - 1.*e[33] * e[20] * e[11] - 1.*e[33] * e[19] * e[10] - 1.*e[33] * e[22] * e[13];
	A[14] = e[18] * e[13] * e[17] + e[9] * e[13] * e[26] + e[9] * e[22] * e[17] - e[9] * e[14] * e[25] - e[18] * e[14] * e[16] - e[15] * e[13] * e[20] - e[15] * e[22] * e[11] + e[12] * e[16] * e[20] + e[12] * e[25] * e[11] - e[12] * e[10] * e[26] - e[12] * e[19] * e[17] + e[21] * e[16] * e[11] - e[21] * e[10] * e[17] - e[9] * e[23] * e[16] + e[24] * e[10] * e[14] - e[24] * e[13] * e[11] + e[15] * e[10] * e[23] + e[15] * e[19] * e[14];
	A[156] = e[21] * e[12] * e[24] + e[21] * e[23] * e[17] + e[21] * e[14] * e[26] + e[21] * e[22] * e[16] + e[21] * e[13] * e[25] + e[24] * e[26] * e[17] + e[24] * e[25] * e[16] + e[9] * e[19] * e[25] + e[9] * e[18] * e[24] + e[9] * e[20] * e[26] + e[12] * e[22] * e[25] + e[12] * e[23] * e[26] + e[18] * e[20] * e[17] + e[18] * e[11] * e[26] + e[18] * e[19] * e[16] + e[18] * e[10] * e[25] - 1.*e[24] * e[23] * e[14] - 1.*e[24] * e[20] * e[11] - 1.*e[24] * e[19] * e[10] - 1.*e[24] * e[22] * e[13] + .5000000000*ep2[21] * e[15] + 1.500000000*ep2[24] * e[15] + .5000000000*e[15] * ep2[25] + .5000000000*e[15] * ep2[26] + .5000000000*e[15] * ep2[18] - .5000000000*e[15] * ep2[23] - .5000000000*e[15] * ep2[19] - .5000000000*e[15] * ep2[20] - .5000000000*e[15] * ep2[22];
	A[18] = e[6] * e[1] * e[14] + e[15] * e[1] * e[5] - e[0] * e[5] * e[16] - e[0] * e[14] * e[7] + e[0] * e[13] * e[8] - e[15] * e[4] * e[2] + e[12] * e[7] * e[2] + e[6] * e[10] * e[5] + e[3] * e[7] * e[11] - e[6] * e[4] * e[11] + e[3] * e[16] * e[2] - e[6] * e[13] * e[2] - e[3] * e[1] * e[17] - e[9] * e[5] * e[7] - e[3] * e[10] * e[8] - e[12] * e[1] * e[8] + e[0] * e[4] * e[17] + e[9] * e[4] * e[8];
	A[128] = -.5000000000*e[14] * ep2[16] - .5000000000*e[14] * ep2[10] - .5000000000*e[14] * ep2[9] + e[11] * e[9] * e[12] + .5000000000*ep3[14] + e[17] * e[13] * e[16] + .5000000000*e[14] * ep2[12] + e[11] * e[10] * e[13] - .5000000000*e[14] * ep2[15] + .5000000000*e[14] * ep2[17] + e[17] * e[12] * e[15] + .5000000000*ep2[11] * e[14] + .5000000000*e[14] * ep2[13];
	A[19] = -e[21] * e[19] * e[8] + e[18] * e[4] * e[26] - e[18] * e[5] * e[25] - e[18] * e[23] * e[7] + e[21] * e[25] * e[2] - e[21] * e[1] * e[26] + e[6] * e[19] * e[23] + e[18] * e[22] * e[8] - e[0] * e[23] * e[25] - e[6] * e[22] * e[20] + e[24] * e[1] * e[23] + e[24] * e[19] * e[5] - e[24] * e[4] * e[20] - e[24] * e[22] * e[2] + e[3] * e[25] * e[20] - e[3] * e[19] * e[26] + e[0] * e[22] * e[26] + e[21] * e[7] * e[20];
	A[129] = .5000000000*ep2[20] * e[32] + 1.500000000*e[32] * ep2[23] + .5000000000*e[32] * ep2[22] + .5000000000*e[32] * ep2[21] + .5000000000*e[32] * ep2[26] - .5000000000*e[32] * ep2[18] - .5000000000*e[32] * ep2[19] - .5000000000*e[32] * ep2[24] - .5000000000*e[32] * ep2[25] + e[20] * e[27] * e[21] + e[20] * e[18] * e[30] + e[20] * e[28] * e[22] + e[20] * e[19] * e[31] + e[20] * e[29] * e[23] + e[29] * e[19] * e[22] + e[29] * e[18] * e[21] + e[23] * e[30] * e[21] + e[23] * e[31] * e[22] + e[26] * e[30] * e[24] + e[26] * e[21] * e[33] + e[26] * e[31] * e[25] + e[26] * e[22] * e[34] + e[26] * e[23] * e[35] + e[35] * e[22] * e[25] + e[35] * e[21] * e[24] - 1.*e[23] * e[27] * e[18] - 1.*e[23] * e[33] * e[24] - 1.*e[23] * e[28] * e[19] - 1.*e[23] * e[34] * e[25];
	A[16] = -e[9] * e[23] * e[25] - e[21] * e[10] * e[26] - e[21] * e[19] * e[17] - e[18] * e[23] * e[16] + e[18] * e[13] * e[26] + e[12] * e[25] * e[20] - e[12] * e[19] * e[26] - e[15] * e[22] * e[20] + e[21] * e[16] * e[20] + e[21] * e[25] * e[11] + e[24] * e[10] * e[23] + e[24] * e[19] * e[14] - e[24] * e[13] * e[20] - e[24] * e[22] * e[11] + e[18] * e[22] * e[17] - e[18] * e[14] * e[25] + e[9] * e[22] * e[26] + e[15] * e[19] * e[23];
	A[130] = .5000000000*e[23] * ep2[21] + e[20] * e[19] * e[22] + e[20] * e[18] * e[21] + .5000000000*ep3[23] + e[26] * e[22] * e[25] + .5000000000*e[23] * ep2[26] - .5000000000*e[23] * ep2[18] + .5000000000*e[23] * ep2[22] - .5000000000*e[23] * ep2[19] + e[26] * e[21] * e[24] + .5000000000*ep2[20] * e[23] - .5000000000*e[23] * ep2[24] - .5000000000*e[23] * ep2[25];
	A[17] = e[18] * e[13] * e[35] - e[18] * e[32] * e[16] + e[18] * e[31] * e[17] - e[18] * e[14] * e[34] + e[27] * e[13] * e[26] + e[27] * e[22] * e[17] - e[27] * e[14] * e[25] - e[27] * e[23] * e[16] - e[9] * e[32] * e[25] + e[9] * e[22] * e[35] - e[9] * e[23] * e[34] + e[9] * e[31] * e[26] + e[15] * e[19] * e[32] + e[15] * e[28] * e[23] - e[15] * e[22] * e[29] - e[15] * e[31] * e[20] + e[24] * e[10] * e[32] + e[24] * e[28] * e[14] - e[24] * e[13] * e[29] - e[24] * e[31] * e[11] + e[33] * e[10] * e[23] + e[33] * e[19] * e[14] - e[33] * e[13] * e[20] - e[33] * e[22] * e[11] + e[21] * e[16] * e[29] - e[21] * e[10] * e[35] - e[21] * e[28] * e[17] + e[30] * e[16] * e[20] + e[30] * e[25] * e[11] - e[30] * e[10] * e[26] - e[30] * e[19] * e[17] - e[12] * e[28] * e[26] - e[12] * e[19] * e[35] + e[12] * e[34] * e[20] + e[12] * e[25] * e[29] + e[21] * e[34] * e[11];
	A[131] = -1.*e[32] * e[10] * e[1] + e[32] * e[13] * e[4] - 1.*e[32] * e[16] * e[7] - 1.*e[32] * e[15] * e[6] - 1.*e[32] * e[9] * e[0] + e[32] * e[12] * e[3] + e[17] * e[30] * e[6] + e[17] * e[3] * e[33] + e[17] * e[31] * e[7] + e[17] * e[4] * e[34] + e[17] * e[5] * e[35] - 1.*e[5] * e[27] * e[9] - 1.*e[5] * e[28] * e[10] - 1.*e[5] * e[33] * e[15] - 1.*e[5] * e[34] * e[16] + e[5] * e[29] * e[11] + e[35] * e[12] * e[6] + e[35] * e[3] * e[15] + e[35] * e[13] * e[7] + e[35] * e[4] * e[16] + e[11] * e[27] * e[3] + e[11] * e[0] * e[30] + e[11] * e[28] * e[4] + e[11] * e[1] * e[31] + e[29] * e[9] * e[3] + e[29] * e[0] * e[12] + e[29] * e[10] * e[4] + e[29] * e[1] * e[13] + e[5] * e[30] * e[12] + 3.*e[5] * e[32] * e[14] + e[5] * e[31] * e[13] + e[8] * e[30] * e[15] + e[8] * e[12] * e[33] + e[8] * e[32] * e[17] + e[8] * e[14] * e[35] + e[8] * e[31] * e[16] + e[8] * e[13] * e[34] + e[2] * e[27] * e[12] + e[2] * e[9] * e[30] + e[2] * e[29] * e[14] + e[2] * e[11] * e[32] + e[2] * e[28] * e[13] + e[2] * e[10] * e[31] - 1.*e[14] * e[27] * e[0] - 1.*e[14] * e[34] * e[7] - 1.*e[14] * e[33] * e[6] + e[14] * e[30] * e[3] - 1.*e[14] * e[28] * e[1] + e[14] * e[31] * e[4];
	A[22] = .5000000000*e[18] * ep2[29] + .5000000000*e[18] * ep2[28] + .5000000000*e[18] * ep2[30] + .5000000000*e[18] * ep2[33] - .5000000000*e[18] * ep2[32] - .5000000000*e[18] * ep2[31] - .5000000000*e[18] * ep2[34] - .5000000000*e[18] * ep2[35] + 1.500000000*e[18] * ep2[27] + e[27] * e[28] * e[19] + e[27] * e[29] * e[20] + e[21] * e[27] * e[30] + e[21] * e[29] * e[32] + e[21] * e[28] * e[31] + e[30] * e[28] * e[22] + e[30] * e[19] * e[31] + e[30] * e[29] * e[23] + e[30] * e[20] * e[32] + e[24] * e[27] * e[33] + e[24] * e[29] * e[35] + e[24] * e[28] * e[34] + e[33] * e[28] * e[25] + e[33] * e[19] * e[34] + e[33] * e[29] * e[26] + e[33] * e[20] * e[35] - 1.*e[27] * e[35] * e[26] - 1.*e[27] * e[31] * e[22] - 1.*e[27] * e[32] * e[23] - 1.*e[27] * e[34] * e[25];
	A[132] = e[20] * e[1] * e[4] + e[20] * e[0] * e[3] + e[20] * e[2] * e[5] + e[5] * e[21] * e[3] + e[5] * e[22] * e[4] + e[8] * e[21] * e[6] + e[8] * e[3] * e[24] + e[8] * e[22] * e[7] + e[8] * e[4] * e[25] + e[8] * e[5] * e[26] + e[26] * e[4] * e[7] + e[26] * e[3] * e[6] + e[2] * e[18] * e[3] + e[2] * e[0] * e[21] + e[2] * e[19] * e[4] + e[2] * e[1] * e[22] - 1.*e[5] * e[19] * e[1] - 1.*e[5] * e[18] * e[0] - 1.*e[5] * e[25] * e[7] - 1.*e[5] * e[24] * e[6] + .5000000000*e[23] * ep2[4] - .5000000000*e[23] * ep2[0] - .5000000000*e[23] * ep2[6] + 1.500000000*e[23] * ep2[5] - .5000000000*e[23] * ep2[1] - .5000000000*e[23] * ep2[7] + .5000000000*e[23] * ep2[3] + .5000000000*e[23] * ep2[2] + .5000000000*e[23] * ep2[8];
	A[23] = 1.500000000*e[9] * ep2[27] + .5000000000*e[9] * ep2[29] + .5000000000*e[9] * ep2[28] - .5000000000*e[9] * ep2[32] - .5000000000*e[9] * ep2[31] + .5000000000*e[9] * ep2[33] + .5000000000*e[9] * ep2[30] - .5000000000*e[9] * ep2[34] - .5000000000*e[9] * ep2[35] + e[33] * e[27] * e[15] + e[33] * e[29] * e[17] + e[33] * e[11] * e[35] + e[33] * e[28] * e[16] + e[33] * e[10] * e[34] + e[27] * e[29] * e[11] + e[27] * e[28] * e[10] + e[27] * e[30] * e[12] - 1.*e[27] * e[31] * e[13] - 1.*e[27] * e[32] * e[14] - 1.*e[27] * e[34] * e[16] - 1.*e[27] * e[35] * e[17] + e[30] * e[29] * e[14] + e[30] * e[11] * e[32] + e[30] * e[28] * e[13] + e[30] * e[10] * e[31] + e[12] * e[29] * e[32] + e[12] * e[28] * e[31] + e[15] * e[29] * e[35] + e[15] * e[28] * e[34];
	A[133] = -1.*e[32] * e[24] * e[6] + e[8] * e[30] * e[24] + e[8] * e[21] * e[33] + e[8] * e[31] * e[25] + e[8] * e[22] * e[34] + e[26] * e[30] * e[6] + e[26] * e[3] * e[33] + e[26] * e[31] * e[7] + e[26] * e[4] * e[34] + e[26] * e[32] * e[8] + e[26] * e[5] * e[35] + e[35] * e[21] * e[6] + e[35] * e[3] * e[24] + e[35] * e[22] * e[7] + e[35] * e[4] * e[25] + e[35] * e[23] * e[8] + e[2] * e[27] * e[21] + e[2] * e[18] * e[30] + e[2] * e[28] * e[22] + e[2] * e[19] * e[31] + e[2] * e[29] * e[23] + e[2] * e[20] * e[32] + e[20] * e[27] * e[3] + e[20] * e[0] * e[30] + e[20] * e[28] * e[4] + e[20] * e[1] * e[31] + e[20] * e[29] * e[5] + e[29] * e[18] * e[3] + e[29] * e[0] * e[21] + e[29] * e[19] * e[4] + e[29] * e[1] * e[22] + e[5] * e[30] * e[21] + e[5] * e[31] * e[22] + 3.*e[5] * e[32] * e[23] - 1.*e[5] * e[27] * e[18] - 1.*e[5] * e[33] * e[24] - 1.*e[5] * e[28] * e[19] - 1.*e[5] * e[34] * e[25] - 1.*e[23] * e[27] * e[0] - 1.*e[23] * e[34] * e[7] - 1.*e[23] * e[33] * e[6] + e[23] * e[30] * e[3] - 1.*e[23] * e[28] * e[1] + e[23] * e[31] * e[4] + e[32] * e[21] * e[3] - 1.*e[32] * e[19] * e[1] + e[32] * e[22] * e[4] - 1.*e[32] * e[18] * e[0] - 1.*e[32] * e[25] * e[7];
	A[20] = .5000000000*e[27] * ep2[33] - .5000000000*e[27] * ep2[32] - .5000000000*e[27] * ep2[31] - .5000000000*e[27] * ep2[34] - .5000000000*e[27] * ep2[35] + e[33] * e[29] * e[35] + .5000000000*e[27] * ep2[29] + e[30] * e[29] * e[32] + e[30] * e[28] * e[31] + e[33] * e[28] * e[34] + .5000000000*e[27] * ep2[28] + .5000000000*e[27] * ep2[30] + .5000000000*ep3[27];
	A[134] = e[14] * e[21] * e[12] + e[14] * e[22] * e[13] + e[17] * e[21] * e[15] + e[17] * e[12] * e[24] + e[17] * e[14] * e[26] + e[17] * e[22] * e[16] + e[17] * e[13] * e[25] + e[26] * e[12] * e[15] + e[26] * e[13] * e[16] - 1.*e[14] * e[24] * e[15] - 1.*e[14] * e[25] * e[16] - 1.*e[14] * e[18] * e[9] - 1.*e[14] * e[19] * e[10] + e[11] * e[18] * e[12] + e[11] * e[9] * e[21] + e[11] * e[19] * e[13] + e[11] * e[10] * e[22] + e[20] * e[11] * e[14] + e[20] * e[9] * e[12] + e[20] * e[10] * e[13] + 1.500000000*e[23] * ep2[14] + .5000000000*e[23] * ep2[12] + .5000000000*e[23] * ep2[13] + .5000000000*e[23] * ep2[17] + .5000000000*ep2[11] * e[23] - .5000000000*e[23] * ep2[16] - .5000000000*e[23] * ep2[9] - .5000000000*e[23] * ep2[15] - .5000000000*e[23] * ep2[10];
	A[21] = 1.500000000*e[0] * ep2[27] + .5000000000*e[0] * ep2[29] + .5000000000*e[0] * ep2[28] + .5000000000*e[0] * ep2[30] - .5000000000*e[0] * ep2[32] - .5000000000*e[0] * ep2[31] + .5000000000*e[0] * ep2[33] - .5000000000*e[0] * ep2[34] - .5000000000*e[0] * ep2[35] - 1.*e[27] * e[31] * e[4] + e[3] * e[27] * e[30] + e[3] * e[29] * e[32] + e[3] * e[28] * e[31] + e[30] * e[28] * e[4] + e[30] * e[1] * e[31] + e[30] * e[29] * e[5] + e[30] * e[2] * e[32] + e[6] * e[27] * e[33] + e[6] * e[29] * e[35] + e[6] * e[28] * e[34] + e[27] * e[28] * e[1] + e[27] * e[29] * e[2] + e[33] * e[28] * e[7] + e[33] * e[1] * e[34] + e[33] * e[29] * e[8] + e[33] * e[2] * e[35] - 1.*e[27] * e[34] * e[7] - 1.*e[27] * e[32] * e[5] - 1.*e[27] * e[35] * e[8];
	A[135] = e[14] * e[12] * e[3] + e[14] * e[13] * e[4] + e[17] * e[12] * e[6] + e[17] * e[3] * e[15] + e[17] * e[13] * e[7] + e[17] * e[4] * e[16] + e[17] * e[14] * e[8] + e[8] * e[12] * e[15] + e[8] * e[13] * e[16] + e[2] * e[11] * e[14] + e[2] * e[9] * e[12] + e[2] * e[10] * e[13] + e[11] * e[9] * e[3] + e[11] * e[0] * e[12] + e[11] * e[10] * e[4] + e[11] * e[1] * e[13] - 1.*e[14] * e[10] * e[1] - 1.*e[14] * e[16] * e[7] - 1.*e[14] * e[15] * e[6] - 1.*e[14] * e[9] * e[0] - .5000000000*e[5] * ep2[16] - .5000000000*e[5] * ep2[9] + .5000000000*e[5] * ep2[11] + .5000000000*e[5] * ep2[12] - .5000000000*e[5] * ep2[15] - .5000000000*e[5] * ep2[10] + .5000000000*e[5] * ep2[13] + 1.500000000*ep2[14] * e[5] + .5000000000*e[5] * ep2[17];
	A[27] = 1.500000000*e[27] * ep2[9] - .5000000000*e[27] * ep2[16] + .5000000000*e[27] * ep2[11] + .5000000000*e[27] * ep2[12] + .5000000000*e[27] * ep2[15] - .5000000000*e[27] * ep2[17] + .5000000000*e[27] * ep2[10] - .5000000000*e[27] * ep2[14] - .5000000000*e[27] * ep2[13] + e[12] * e[10] * e[31] + e[30] * e[11] * e[14] + e[30] * e[10] * e[13] + e[15] * e[9] * e[33] + e[15] * e[29] * e[17] + e[15] * e[11] * e[35] + e[15] * e[28] * e[16] + e[15] * e[10] * e[34] + e[33] * e[11] * e[17] + e[33] * e[10] * e[16] - 1.*e[9] * e[31] * e[13] - 1.*e[9] * e[32] * e[14] - 1.*e[9] * e[34] * e[16] - 1.*e[9] * e[35] * e[17] + e[9] * e[29] * e[11] + e[9] * e[28] * e[10] + e[12] * e[9] * e[30] + e[12] * e[29] * e[14] + e[12] * e[11] * e[32] + e[12] * e[28] * e[13];
	A[137] = e[29] * e[18] * e[12] + e[29] * e[9] * e[21] + e[29] * e[19] * e[13] + e[29] * e[10] * e[22] + e[17] * e[30] * e[24] + e[17] * e[21] * e[33] + e[17] * e[31] * e[25] + e[17] * e[22] * e[34] + e[17] * e[32] * e[26] + e[17] * e[23] * e[35] - 1.*e[23] * e[27] * e[9] - 1.*e[23] * e[28] * e[10] - 1.*e[23] * e[33] * e[15] - 1.*e[23] * e[34] * e[16] - 1.*e[32] * e[24] * e[15] - 1.*e[32] * e[25] * e[16] - 1.*e[32] * e[18] * e[9] - 1.*e[32] * e[19] * e[10] + e[26] * e[30] * e[15] + e[26] * e[12] * e[33] + e[26] * e[31] * e[16] + e[26] * e[13] * e[34] + e[35] * e[21] * e[15] + e[35] * e[12] * e[24] + e[35] * e[22] * e[16] + e[35] * e[13] * e[25] + e[14] * e[30] * e[21] + e[14] * e[31] * e[22] + 3.*e[14] * e[32] * e[23] + e[11] * e[27] * e[21] + e[11] * e[18] * e[30] + e[11] * e[28] * e[22] + e[11] * e[19] * e[31] + e[11] * e[29] * e[23] + e[11] * e[20] * e[32] + e[23] * e[30] * e[12] + e[23] * e[31] * e[13] + e[32] * e[21] * e[12] + e[32] * e[22] * e[13] - 1.*e[14] * e[27] * e[18] - 1.*e[14] * e[33] * e[24] + e[14] * e[29] * e[20] + e[14] * e[35] * e[26] - 1.*e[14] * e[28] * e[19] - 1.*e[14] * e[34] * e[25] + e[20] * e[27] * e[12] + e[20] * e[9] * e[30] + e[20] * e[28] * e[13] + e[20] * e[10] * e[31];
	A[26] = .5000000000*e[0] * ep2[1] + .5000000000*e[0] * ep2[2] + e[6] * e[2] * e[8] + e[6] * e[1] * e[7] + .5000000000*e[0] * ep2[3] + e[3] * e[1] * e[4] + .5000000000*e[0] * ep2[6] + e[3] * e[2] * e[5] - .5000000000*e[0] * ep2[5] - .5000000000*e[0] * ep2[8] + .5000000000*ep3[0] - .5000000000*e[0] * ep2[7] - .5000000000*e[0] * ep2[4];
	A[136] = 1.500000000*ep2[23] * e[14] + .5000000000*e[14] * ep2[26] - .5000000000*e[14] * ep2[18] - .5000000000*e[14] * ep2[19] + .5000000000*e[14] * ep2[20] + .5000000000*e[14] * ep2[22] - .5000000000*e[14] * ep2[24] + .5000000000*e[14] * ep2[21] - .5000000000*e[14] * ep2[25] + e[23] * e[21] * e[12] + e[23] * e[22] * e[13] + e[26] * e[21] * e[15] + e[26] * e[12] * e[24] + e[26] * e[23] * e[17] + e[26] * e[22] * e[16] + e[26] * e[13] * e[25] + e[17] * e[22] * e[25] + e[17] * e[21] * e[24] + e[11] * e[19] * e[22] + e[11] * e[18] * e[21] + e[11] * e[20] * e[23] + e[20] * e[18] * e[12] + e[20] * e[9] * e[21] + e[20] * e[19] * e[13] + e[20] * e[10] * e[22] - 1.*e[23] * e[24] * e[15] - 1.*e[23] * e[25] * e[16] - 1.*e[23] * e[18] * e[9] - 1.*e[23] * e[19] * e[10];
	A[25] = 1.500000000*e[27] * ep2[0] - .5000000000*e[27] * ep2[4] + .5000000000*e[27] * ep2[6] - .5000000000*e[27] * ep2[5] + .5000000000*e[27] * ep2[1] - .5000000000*e[27] * ep2[7] + .5000000000*e[27] * ep2[3] + .5000000000*e[27] * ep2[2] - .5000000000*e[27] * ep2[8] + e[0] * e[33] * e[6] + e[0] * e[30] * e[3] - 1.*e[0] * e[35] * e[8] - 1.*e[0] * e[31] * e[4] + e[3] * e[28] * e[4] + e[3] * e[1] * e[31] + e[3] * e[29] * e[5] + e[3] * e[2] * e[32] + e[30] * e[1] * e[4] + e[30] * e[2] * e[5] + e[6] * e[28] * e[7] + e[6] * e[1] * e[34] + e[6] * e[29] * e[8] + e[6] * e[2] * e[35] + e[33] * e[1] * e[7] + e[33] * e[2] * e[8] + e[0] * e[28] * e[1] + e[0] * e[29] * e[2] - 1.*e[0] * e[34] * e[7] - 1.*e[0] * e[32] * e[5];
	A[139] = e[8] * e[22] * e[25] + e[8] * e[21] * e[24] + e[20] * e[18] * e[3] + e[20] * e[0] * e[21] + e[20] * e[19] * e[4] + e[20] * e[1] * e[22] + e[20] * e[2] * e[23] + e[23] * e[21] * e[3] + e[23] * e[22] * e[4] + e[23] * e[26] * e[8] - 1.*e[23] * e[19] * e[1] - 1.*e[23] * e[18] * e[0] - 1.*e[23] * e[25] * e[7] - 1.*e[23] * e[24] * e[6] + e[2] * e[19] * e[22] + e[2] * e[18] * e[21] + e[26] * e[21] * e[6] + e[26] * e[3] * e[24] + e[26] * e[22] * e[7] + e[26] * e[4] * e[25] + .5000000000*ep2[20] * e[5] + 1.500000000*ep2[23] * e[5] + .5000000000*e[5] * ep2[22] + .5000000000*e[5] * ep2[21] + .5000000000*e[5] * ep2[26] - .5000000000*e[5] * ep2[18] - .5000000000*e[5] * ep2[19] - .5000000000*e[5] * ep2[24] - .5000000000*e[5] * ep2[25];
	A[24] = e[24] * e[11] * e[8] + e[24] * e[2] * e[17] + 3.*e[9] * e[18] * e[0] + e[9] * e[19] * e[1] + e[9] * e[20] * e[2] + e[18] * e[10] * e[1] + e[18] * e[11] * e[2] + e[3] * e[18] * e[12] + e[3] * e[9] * e[21] + e[3] * e[20] * e[14] + e[3] * e[11] * e[23] + e[3] * e[19] * e[13] + e[3] * e[10] * e[22] + e[6] * e[18] * e[15] + e[6] * e[9] * e[24] + e[6] * e[20] * e[17] + e[6] * e[11] * e[26] + e[6] * e[19] * e[16] + e[6] * e[10] * e[25] + e[0] * e[20] * e[11] + e[0] * e[19] * e[10] - 1.*e[9] * e[26] * e[8] - 1.*e[9] * e[22] * e[4] - 1.*e[9] * e[25] * e[7] - 1.*e[9] * e[23] * e[5] + e[12] * e[0] * e[21] + e[12] * e[19] * e[4] + e[12] * e[1] * e[22] + e[12] * e[20] * e[5] + e[12] * e[2] * e[23] - 1.*e[18] * e[13] * e[4] - 1.*e[18] * e[16] * e[7] - 1.*e[18] * e[14] * e[5] - 1.*e[18] * e[17] * e[8] + e[21] * e[10] * e[4] + e[21] * e[1] * e[13] + e[21] * e[11] * e[5] + e[21] * e[2] * e[14] + e[15] * e[0] * e[24] + e[15] * e[19] * e[7] + e[15] * e[1] * e[25] + e[15] * e[20] * e[8] + e[15] * e[2] * e[26] - 1.*e[0] * e[23] * e[14] - 1.*e[0] * e[25] * e[16] - 1.*e[0] * e[26] * e[17] - 1.*e[0] * e[22] * e[13] + e[24] * e[10] * e[7] + e[24] * e[1] * e[16];
	A[138] = e[11] * e[1] * e[4] + e[11] * e[0] * e[3] + e[11] * e[2] * e[5] + e[5] * e[12] * e[3] + e[5] * e[13] * e[4] + e[8] * e[12] * e[6] + e[8] * e[3] * e[15] + e[8] * e[13] * e[7] + e[8] * e[4] * e[16] + e[8] * e[5] * e[17] + e[17] * e[4] * e[7] + e[17] * e[3] * e[6] - 1.*e[5] * e[10] * e[1] - 1.*e[5] * e[16] * e[7] - 1.*e[5] * e[15] * e[6] - 1.*e[5] * e[9] * e[0] + e[2] * e[9] * e[3] + e[2] * e[0] * e[12] + e[2] * e[10] * e[4] + e[2] * e[1] * e[13] + .5000000000*ep2[2] * e[14] - .5000000000*e[14] * ep2[0] - .5000000000*e[14] * ep2[6] - .5000000000*e[14] * ep2[1] - .5000000000*e[14] * ep2[7] + 1.500000000*e[14] * ep2[5] + .5000000000*e[14] * ep2[4] + .5000000000*e[14] * ep2[3] + .5000000000*e[14] * ep2[8];
	A[31] = e[3] * e[27] * e[12] + e[3] * e[9] * e[30] + e[3] * e[29] * e[14] + e[3] * e[11] * e[32] + e[3] * e[28] * e[13] + e[3] * e[10] * e[31] + e[6] * e[27] * e[15] + e[6] * e[9] * e[33] + e[6] * e[29] * e[17] + e[6] * e[11] * e[35] + e[6] * e[28] * e[16] + e[6] * e[10] * e[34] + 3.*e[0] * e[27] * e[9] + e[0] * e[29] * e[11] + e[0] * e[28] * e[10] - 1.*e[9] * e[34] * e[7] - 1.*e[9] * e[32] * e[5] - 1.*e[9] * e[35] * e[8] + e[9] * e[29] * e[2] + e[9] * e[28] * e[1] - 1.*e[9] * e[31] * e[4] + e[12] * e[0] * e[30] + e[12] * e[28] * e[4] + e[12] * e[1] * e[31] + e[12] * e[29] * e[5] + e[12] * e[2] * e[32] + e[27] * e[11] * e[2] + e[27] * e[10] * e[1] - 1.*e[27] * e[13] * e[4] - 1.*e[27] * e[16] * e[7] - 1.*e[27] * e[14] * e[5] - 1.*e[27] * e[17] * e[8] + e[30] * e[10] * e[4] + e[30] * e[1] * e[13] + e[30] * e[11] * e[5] + e[30] * e[2] * e[14] + e[15] * e[0] * e[33] + e[15] * e[28] * e[7] + e[15] * e[1] * e[34] + e[15] * e[29] * e[8] + e[15] * e[2] * e[35] - 1.*e[0] * e[31] * e[13] - 1.*e[0] * e[32] * e[14] - 1.*e[0] * e[34] * e[16] - 1.*e[0] * e[35] * e[17] + e[33] * e[10] * e[7] + e[33] * e[1] * e[16] + e[33] * e[11] * e[8] + e[33] * e[2] * e[17];
	A[141] = .5000000000*ep2[30] * e[6] + .5000000000*e[6] * ep2[27] - .5000000000*e[6] * ep2[32] - .5000000000*e[6] * ep2[28] - .5000000000*e[6] * ep2[29] - .5000000000*e[6] * ep2[31] + 1.500000000*e[6] * ep2[33] + .5000000000*e[6] * ep2[34] + .5000000000*e[6] * ep2[35] + e[0] * e[27] * e[33] + e[0] * e[29] * e[35] + e[0] * e[28] * e[34] + e[3] * e[30] * e[33] + e[3] * e[32] * e[35] + e[3] * e[31] * e[34] + e[30] * e[31] * e[7] + e[30] * e[4] * e[34] + e[30] * e[32] * e[8] + e[30] * e[5] * e[35] + e[27] * e[28] * e[7] + e[27] * e[1] * e[34] + e[27] * e[29] * e[8] + e[27] * e[2] * e[35] + e[33] * e[34] * e[7] + e[33] * e[35] * e[8] - 1.*e[33] * e[32] * e[5] - 1.*e[33] * e[29] * e[2] - 1.*e[33] * e[28] * e[1] - 1.*e[33] * e[31] * e[4];
	A[30] = e[24] * e[20] * e[26] + e[21] * e[19] * e[22] - .5000000000*e[18] * ep2[22] - .5000000000*e[18] * ep2[25] + .5000000000*ep3[18] + .5000000000*e[18] * ep2[21] + e[21] * e[20] * e[23] + .5000000000*e[18] * ep2[20] + .5000000000*e[18] * ep2[19] + .5000000000*e[18] * ep2[24] + e[24] * e[19] * e[25] - .5000000000*e[18] * ep2[23] - .5000000000*e[18] * ep2[26];
	A[140] = .5000000000*e[33] * ep2[35] + .5000000000*ep3[33] + .5000000000*ep2[27] * e[33] + .5000000000*ep2[30] * e[33] - .5000000000*e[33] * ep2[29] + .5000000000*e[33] * ep2[34] - .5000000000*e[33] * ep2[32] - .5000000000*e[33] * ep2[28] + e[30] * e[32] * e[35] - .5000000000*e[33] * ep2[31] + e[27] * e[29] * e[35] + e[27] * e[28] * e[34] + e[30] * e[31] * e[34];
	A[29] = 1.500000000*e[27] * ep2[18] + .5000000000*e[27] * ep2[19] + .5000000000*e[27] * ep2[20] + .5000000000*e[27] * ep2[21] + .5000000000*e[27] * ep2[24] - .5000000000*e[27] * ep2[26] - .5000000000*e[27] * ep2[23] - .5000000000*e[27] * ep2[22] - .5000000000*e[27] * ep2[25] + e[33] * e[20] * e[26] - 1.*e[18] * e[35] * e[26] - 1.*e[18] * e[31] * e[22] - 1.*e[18] * e[32] * e[23] - 1.*e[18] * e[34] * e[25] + e[18] * e[28] * e[19] + e[18] * e[29] * e[20] + e[21] * e[18] * e[30] + e[21] * e[28] * e[22] + e[21] * e[19] * e[31] + e[21] * e[29] * e[23] + e[21] * e[20] * e[32] + e[30] * e[19] * e[22] + e[30] * e[20] * e[23] + e[24] * e[18] * e[33] + e[24] * e[28] * e[25] + e[24] * e[19] * e[34] + e[24] * e[29] * e[26] + e[24] * e[20] * e[35] + e[33] * e[19] * e[25];
	A[143] = e[9] * e[27] * e[33] + e[9] * e[29] * e[35] + e[9] * e[28] * e[34] + e[33] * e[35] * e[17] + e[33] * e[34] * e[16] + e[27] * e[29] * e[17] + e[27] * e[11] * e[35] + e[27] * e[28] * e[16] + e[27] * e[10] * e[34] + e[33] * e[30] * e[12] - 1.*e[33] * e[28] * e[10] - 1.*e[33] * e[31] * e[13] - 1.*e[33] * e[32] * e[14] - 1.*e[33] * e[29] * e[11] + e[30] * e[32] * e[17] + e[30] * e[14] * e[35] + e[30] * e[31] * e[16] + e[30] * e[13] * e[34] + e[12] * e[32] * e[35] + e[12] * e[31] * e[34] + .5000000000*e[15] * ep2[27] - .5000000000*e[15] * ep2[32] - .5000000000*e[15] * ep2[28] - .5000000000*e[15] * ep2[29] - .5000000000*e[15] * ep2[31] + 1.500000000*e[15] * ep2[33] + .5000000000*e[15] * ep2[30] + .5000000000*e[15] * ep2[34] + .5000000000*e[15] * ep2[35];
	A[28] = .5000000000*e[9] * ep2[12] - .5000000000*e[9] * ep2[16] + .5000000000*e[9] * ep2[10] - .5000000000*e[9] * ep2[17] - .5000000000*e[9] * ep2[13] + e[15] * e[10] * e[16] + e[12] * e[11] * e[14] + .5000000000*e[9] * ep2[11] + .5000000000*e[9] * ep2[15] - .5000000000*e[9] * ep2[14] + e[15] * e[11] * e[17] + .5000000000*ep3[9] + e[12] * e[10] * e[13];
	A[142] = e[18] * e[27] * e[33] + e[18] * e[29] * e[35] + e[18] * e[28] * e[34] + e[27] * e[28] * e[25] + e[27] * e[19] * e[34] + e[27] * e[29] * e[26] + e[27] * e[20] * e[35] + e[21] * e[30] * e[33] + e[21] * e[32] * e[35] + e[21] * e[31] * e[34] + e[30] * e[31] * e[25] + e[30] * e[22] * e[34] + e[30] * e[32] * e[26] + e[30] * e[23] * e[35] + e[33] * e[34] * e[25] + e[33] * e[35] * e[26] - 1.*e[33] * e[29] * e[20] - 1.*e[33] * e[31] * e[22] - 1.*e[33] * e[32] * e[23] - 1.*e[33] * e[28] * e[19] + .5000000000*ep2[27] * e[24] + .5000000000*ep2[30] * e[24] + 1.500000000*e[24] * ep2[33] + .5000000000*e[24] * ep2[35] + .5000000000*e[24] * ep2[34] - .5000000000*e[24] * ep2[32] - .5000000000*e[24] * ep2[28] - .5000000000*e[24] * ep2[29] - .5000000000*e[24] * ep2[31];
	A[36] = .5000000000*e[9] * ep2[21] + .5000000000*e[9] * ep2[24] + .5000000000*e[9] * ep2[19] + 1.500000000*e[9] * ep2[18] + .5000000000*e[9] * ep2[20] - .5000000000*e[9] * ep2[26] - .5000000000*e[9] * ep2[23] - .5000000000*e[9] * ep2[22] - .5000000000*e[9] * ep2[25] + e[21] * e[18] * e[12] + e[21] * e[20] * e[14] + e[21] * e[11] * e[23] + e[21] * e[19] * e[13] + e[21] * e[10] * e[22] + e[24] * e[18] * e[15] + e[24] * e[20] * e[17] + e[24] * e[11] * e[26] + e[24] * e[19] * e[16] + e[24] * e[10] * e[25] + e[15] * e[19] * e[25] + e[15] * e[20] * e[26] + e[12] * e[19] * e[22] + e[12] * e[20] * e[23] + e[18] * e[20] * e[11] + e[18] * e[19] * e[10] - 1.*e[18] * e[23] * e[14] - 1.*e[18] * e[25] * e[16] - 1.*e[18] * e[26] * e[17] - 1.*e[18] * e[22] * e[13];
	A[182] = .5000000000*ep2[29] * e[26] + .5000000000*ep2[32] * e[26] + .5000000000*e[26] * ep2[33] + 1.500000000*e[26] * ep2[35] + .5000000000*e[26] * ep2[34] - .5000000000*e[26] * ep2[27] - .5000000000*e[26] * ep2[28] - .5000000000*e[26] * ep2[31] - .5000000000*e[26] * ep2[30] + e[20] * e[27] * e[33] + e[20] * e[29] * e[35] + e[20] * e[28] * e[34] + e[29] * e[27] * e[24] + e[29] * e[18] * e[33] + e[29] * e[28] * e[25] + e[29] * e[19] * e[34] + e[23] * e[30] * e[33] + e[23] * e[32] * e[35] + e[23] * e[31] * e[34] + e[32] * e[30] * e[24] + e[32] * e[21] * e[33] + e[32] * e[31] * e[25] + e[32] * e[22] * e[34] + e[35] * e[33] * e[24] + e[35] * e[34] * e[25] - 1.*e[35] * e[27] * e[18] - 1.*e[35] * e[30] * e[21] - 1.*e[35] * e[31] * e[22] - 1.*e[35] * e[28] * e[19];
	A[37] = e[12] * e[19] * e[31] + e[12] * e[29] * e[23] + e[12] * e[20] * e[32] + 3.*e[9] * e[27] * e[18] + e[9] * e[28] * e[19] + e[9] * e[29] * e[20] + e[21] * e[9] * e[30] + e[21] * e[29] * e[14] + e[21] * e[11] * e[32] + e[21] * e[28] * e[13] + e[21] * e[10] * e[31] + e[30] * e[20] * e[14] + e[30] * e[11] * e[23] + e[30] * e[19] * e[13] + e[30] * e[10] * e[22] + e[9] * e[33] * e[24] - 1.*e[9] * e[35] * e[26] - 1.*e[9] * e[31] * e[22] - 1.*e[9] * e[32] * e[23] - 1.*e[9] * e[34] * e[25] + e[18] * e[29] * e[11] + e[18] * e[28] * e[10] + e[27] * e[20] * e[11] + e[27] * e[19] * e[10] + e[15] * e[27] * e[24] + e[15] * e[18] * e[33] + e[15] * e[28] * e[25] + e[15] * e[19] * e[34] + e[15] * e[29] * e[26] + e[15] * e[20] * e[35] - 1.*e[18] * e[31] * e[13] - 1.*e[18] * e[32] * e[14] - 1.*e[18] * e[34] * e[16] - 1.*e[18] * e[35] * e[17] - 1.*e[27] * e[23] * e[14] - 1.*e[27] * e[25] * e[16] - 1.*e[27] * e[26] * e[17] - 1.*e[27] * e[22] * e[13] + e[24] * e[29] * e[17] + e[24] * e[11] * e[35] + e[24] * e[28] * e[16] + e[24] * e[10] * e[34] + e[33] * e[20] * e[17] + e[33] * e[11] * e[26] + e[33] * e[19] * e[16] + e[33] * e[10] * e[25] + e[12] * e[27] * e[21] + e[12] * e[18] * e[30] + e[12] * e[28] * e[22];
	A[183] = -.5000000000*e[17] * ep2[27] + .5000000000*e[17] * ep2[32] - .5000000000*e[17] * ep2[28] + .5000000000*e[17] * ep2[29] - .5000000000*e[17] * ep2[31] + .5000000000*e[17] * ep2[33] - .5000000000*e[17] * ep2[30] + .5000000000*e[17] * ep2[34] + 1.500000000*e[17] * ep2[35] + e[32] * e[30] * e[15] + e[32] * e[12] * e[33] + e[32] * e[31] * e[16] + e[32] * e[13] * e[34] + e[14] * e[30] * e[33] + e[14] * e[31] * e[34] + e[11] * e[27] * e[33] + e[11] * e[29] * e[35] + e[11] * e[28] * e[34] + e[35] * e[33] * e[15] + e[35] * e[34] * e[16] + e[29] * e[27] * e[15] + e[29] * e[9] * e[33] + e[29] * e[28] * e[16] + e[29] * e[10] * e[34] - 1.*e[35] * e[27] * e[9] - 1.*e[35] * e[30] * e[12] - 1.*e[35] * e[28] * e[10] - 1.*e[35] * e[31] * e[13] + e[35] * e[32] * e[14];
	A[38] = .5000000000*e[9] * ep2[1] + 1.500000000*e[9] * ep2[0] + .5000000000*e[9] * ep2[2] + .5000000000*e[9] * ep2[3] + .5000000000*e[9] * ep2[6] - .5000000000*e[9] * ep2[4] - .5000000000*e[9] * ep2[5] - .5000000000*e[9] * ep2[7] - .5000000000*e[9] * ep2[8] + e[6] * e[0] * e[15] + e[6] * e[10] * e[7] + e[6] * e[1] * e[16] + e[6] * e[11] * e[8] + e[6] * e[2] * e[17] + e[15] * e[1] * e[7] + e[15] * e[2] * e[8] + e[0] * e[11] * e[2] + e[0] * e[10] * e[1] - 1.*e[0] * e[13] * e[4] - 1.*e[0] * e[16] * e[7] - 1.*e[0] * e[14] * e[5] - 1.*e[0] * e[17] * e[8] + e[3] * e[0] * e[12] + e[3] * e[10] * e[4] + e[3] * e[1] * e[13] + e[3] * e[11] * e[5] + e[3] * e[2] * e[14] + e[12] * e[1] * e[4] + e[12] * e[2] * e[5];
	A[180] = .5000000000*e[35] * ep2[33] + .5000000000*e[35] * ep2[34] - .5000000000*e[35] * ep2[27] - .5000000000*e[35] * ep2[28] - .5000000000*e[35] * ep2[31] - .5000000000*e[35] * ep2[30] + e[32] * e[31] * e[34] + .5000000000*ep2[29] * e[35] + .5000000000*ep2[32] * e[35] + e[29] * e[28] * e[34] + e[32] * e[30] * e[33] + .5000000000*ep3[35] + e[29] * e[27] * e[33];
	A[39] = .5000000000*e[0] * ep2[19] + .5000000000*e[0] * ep2[20] + .5000000000*e[0] * ep2[24] - .5000000000*e[0] * ep2[26] - .5000000000*e[0] * ep2[23] - .5000000000*e[0] * ep2[22] - .5000000000*e[0] * ep2[25] + 1.500000000*ep2[18] * e[0] + .5000000000*e[0] * ep2[21] + e[18] * e[19] * e[1] + e[18] * e[20] * e[2] + e[21] * e[18] * e[3] + e[21] * e[19] * e[4] + e[21] * e[1] * e[22] + e[21] * e[20] * e[5] + e[21] * e[2] * e[23] - 1.*e[18] * e[26] * e[8] - 1.*e[18] * e[22] * e[4] - 1.*e[18] * e[25] * e[7] - 1.*e[18] * e[23] * e[5] + e[18] * e[24] * e[6] + e[3] * e[19] * e[22] + e[3] * e[20] * e[23] + e[24] * e[19] * e[7] + e[24] * e[1] * e[25] + e[24] * e[20] * e[8] + e[24] * e[2] * e[26] + e[6] * e[19] * e[25] + e[6] * e[20] * e[26];
	A[181] = .5000000000*ep2[32] * e[8] - .5000000000*e[8] * ep2[27] - .5000000000*e[8] * ep2[28] + .5000000000*e[8] * ep2[29] - .5000000000*e[8] * ep2[31] + .5000000000*e[8] * ep2[33] - .5000000000*e[8] * ep2[30] + .5000000000*e[8] * ep2[34] + 1.500000000*e[8] * ep2[35] + e[2] * e[27] * e[33] + e[2] * e[29] * e[35] + e[2] * e[28] * e[34] + e[5] * e[30] * e[33] + e[5] * e[32] * e[35] + e[5] * e[31] * e[34] + e[32] * e[30] * e[6] + e[32] * e[3] * e[33] + e[32] * e[31] * e[7] + e[32] * e[4] * e[34] + e[29] * e[27] * e[6] + e[29] * e[0] * e[33] + e[29] * e[28] * e[7] + e[29] * e[1] * e[34] + e[35] * e[33] * e[6] + e[35] * e[34] * e[7] - 1.*e[35] * e[27] * e[0] - 1.*e[35] * e[30] * e[3] - 1.*e[35] * e[28] * e[1] - 1.*e[35] * e[31] * e[4];
	A[32] = -.5000000000*e[18] * ep2[4] + 1.500000000*e[18] * ep2[0] + .5000000000*e[18] * ep2[6] - .5000000000*e[18] * ep2[5] + .5000000000*e[18] * ep2[1] - .5000000000*e[18] * ep2[7] + .5000000000*e[18] * ep2[3] + .5000000000*e[18] * ep2[2] - .5000000000*e[18] * ep2[8] + e[3] * e[0] * e[21] + e[3] * e[19] * e[4] + e[3] * e[1] * e[22] + e[3] * e[20] * e[5] + e[3] * e[2] * e[23] + e[21] * e[1] * e[4] + e[21] * e[2] * e[5] + e[6] * e[0] * e[24] + e[6] * e[19] * e[7] + e[6] * e[1] * e[25] + e[6] * e[20] * e[8] + e[6] * e[2] * e[26] + e[24] * e[1] * e[7] + e[24] * e[2] * e[8] + e[0] * e[19] * e[1] + e[0] * e[20] * e[2] - 1.*e[0] * e[26] * e[8] - 1.*e[0] * e[22] * e[4] - 1.*e[0] * e[25] * e[7] - 1.*e[0] * e[23] * e[5];
	A[178] = e[10] * e[1] * e[7] + e[10] * e[0] * e[6] + e[10] * e[2] * e[8] + e[4] * e[12] * e[6] + e[4] * e[3] * e[15] + e[4] * e[13] * e[7] + e[4] * e[14] * e[8] + e[4] * e[5] * e[17] + e[13] * e[3] * e[6] + e[13] * e[5] * e[8] + e[7] * e[15] * e[6] + e[7] * e[17] * e[8] - 1.*e[7] * e[11] * e[2] - 1.*e[7] * e[9] * e[0] - 1.*e[7] * e[14] * e[5] - 1.*e[7] * e[12] * e[3] + e[1] * e[9] * e[6] + e[1] * e[0] * e[15] + e[1] * e[11] * e[8] + e[1] * e[2] * e[17] + 1.500000000*e[16] * ep2[7] + .5000000000*e[16] * ep2[6] + .5000000000*e[16] * ep2[8] + .5000000000*ep2[1] * e[16] - .5000000000*e[16] * ep2[0] - .5000000000*e[16] * ep2[5] - .5000000000*e[16] * ep2[3] - .5000000000*e[16] * ep2[2] + .5000000000*ep2[4] * e[16];
	A[33] = e[0] * e[30] * e[21] - 1.*e[0] * e[35] * e[26] - 1.*e[0] * e[31] * e[22] - 1.*e[0] * e[32] * e[23] - 1.*e[0] * e[34] * e[25] - 1.*e[18] * e[34] * e[7] - 1.*e[18] * e[32] * e[5] - 1.*e[18] * e[35] * e[8] - 1.*e[18] * e[31] * e[4] - 1.*e[27] * e[26] * e[8] - 1.*e[27] * e[22] * e[4] - 1.*e[27] * e[25] * e[7] - 1.*e[27] * e[23] * e[5] + e[6] * e[28] * e[25] + e[6] * e[19] * e[34] + e[6] * e[29] * e[26] + e[6] * e[20] * e[35] + e[21] * e[28] * e[4] + e[21] * e[1] * e[31] + e[21] * e[29] * e[5] + e[21] * e[2] * e[32] + e[30] * e[19] * e[4] + e[30] * e[1] * e[22] + e[30] * e[20] * e[5] + e[30] * e[2] * e[23] + e[24] * e[27] * e[6] + e[24] * e[0] * e[33] + e[24] * e[28] * e[7] + e[24] * e[1] * e[34] + e[24] * e[29] * e[8] + e[24] * e[2] * e[35] + e[33] * e[18] * e[6] + e[33] * e[19] * e[7] + e[33] * e[1] * e[25] + e[33] * e[20] * e[8] + e[33] * e[2] * e[26] + 3.*e[0] * e[27] * e[18] + e[0] * e[28] * e[19] + e[0] * e[29] * e[20] + e[18] * e[28] * e[1] + e[18] * e[29] * e[2] + e[27] * e[19] * e[1] + e[27] * e[20] * e[2] + e[3] * e[27] * e[21] + e[3] * e[18] * e[30] + e[3] * e[28] * e[22] + e[3] * e[19] * e[31] + e[3] * e[29] * e[23] + e[3] * e[20] * e[32];
	A[179] = e[19] * e[18] * e[6] + e[19] * e[0] * e[24] + e[19] * e[1] * e[25] + e[19] * e[20] * e[8] + e[19] * e[2] * e[26] + e[22] * e[21] * e[6] + e[22] * e[3] * e[24] + e[22] * e[4] * e[25] + e[22] * e[23] * e[8] + e[22] * e[5] * e[26] - 1.*e[25] * e[21] * e[3] + e[25] * e[26] * e[8] - 1.*e[25] * e[20] * e[2] - 1.*e[25] * e[18] * e[0] - 1.*e[25] * e[23] * e[5] + e[25] * e[24] * e[6] + e[1] * e[18] * e[24] + e[1] * e[20] * e[26] + e[4] * e[21] * e[24] + e[4] * e[23] * e[26] + .5000000000*ep2[19] * e[7] + .5000000000*ep2[22] * e[7] + 1.500000000*ep2[25] * e[7] + .5000000000*e[7] * ep2[26] - .5000000000*e[7] * ep2[18] - .5000000000*e[7] * ep2[23] - .5000000000*e[7] * ep2[20] + .5000000000*e[7] * ep2[24] - .5000000000*e[7] * ep2[21];
	A[34] = .5000000000*e[18] * ep2[11] + 1.500000000*e[18] * ep2[9] + .5000000000*e[18] * ep2[10] + .5000000000*e[18] * ep2[12] + .5000000000*e[18] * ep2[15] - .5000000000*e[18] * ep2[16] - .5000000000*e[18] * ep2[17] - .5000000000*e[18] * ep2[14] - .5000000000*e[18] * ep2[13] + e[12] * e[9] * e[21] + e[12] * e[20] * e[14] + e[12] * e[11] * e[23] + e[12] * e[19] * e[13] + e[12] * e[10] * e[22] + e[21] * e[11] * e[14] + e[21] * e[10] * e[13] + e[15] * e[9] * e[24] + e[15] * e[20] * e[17] + e[15] * e[11] * e[26] + e[15] * e[19] * e[16] + e[15] * e[10] * e[25] + e[24] * e[11] * e[17] + e[24] * e[10] * e[16] - 1.*e[9] * e[23] * e[14] - 1.*e[9] * e[25] * e[16] - 1.*e[9] * e[26] * e[17] + e[9] * e[20] * e[11] + e[9] * e[19] * e[10] - 1.*e[9] * e[22] * e[13];
	A[176] = e[13] * e[21] * e[24] + e[13] * e[23] * e[26] + e[19] * e[18] * e[15] + e[19] * e[9] * e[24] + e[19] * e[20] * e[17] + e[19] * e[11] * e[26] - 1.*e[25] * e[23] * e[14] - 1.*e[25] * e[20] * e[11] - 1.*e[25] * e[18] * e[9] - 1.*e[25] * e[21] * e[12] + e[22] * e[21] * e[15] + e[22] * e[12] * e[24] + e[22] * e[23] * e[17] + e[22] * e[14] * e[26] + e[22] * e[13] * e[25] + e[25] * e[24] * e[15] + e[25] * e[26] * e[17] + e[10] * e[19] * e[25] + e[10] * e[18] * e[24] + e[10] * e[20] * e[26] - .5000000000*e[16] * ep2[18] - .5000000000*e[16] * ep2[23] + .5000000000*e[16] * ep2[19] - .5000000000*e[16] * ep2[20] - .5000000000*e[16] * ep2[21] + .5000000000*ep2[22] * e[16] + 1.500000000*ep2[25] * e[16] + .5000000000*e[16] * ep2[24] + .5000000000*e[16] * ep2[26];
	A[35] = .5000000000*e[0] * ep2[12] + .5000000000*e[0] * ep2[15] + .5000000000*e[0] * ep2[11] + 1.500000000*e[0] * ep2[9] + .5000000000*e[0] * ep2[10] - .5000000000*e[0] * ep2[16] - .5000000000*e[0] * ep2[17] - .5000000000*e[0] * ep2[14] - .5000000000*e[0] * ep2[13] + e[12] * e[9] * e[3] + e[12] * e[10] * e[4] + e[12] * e[1] * e[13] + e[12] * e[11] * e[5] + e[12] * e[2] * e[14] + e[15] * e[9] * e[6] + e[15] * e[10] * e[7] + e[15] * e[1] * e[16] + e[15] * e[11] * e[8] + e[15] * e[2] * e[17] + e[6] * e[11] * e[17] + e[6] * e[10] * e[16] + e[3] * e[11] * e[14] + e[3] * e[10] * e[13] + e[9] * e[10] * e[1] + e[9] * e[11] * e[2] - 1.*e[9] * e[13] * e[4] - 1.*e[9] * e[16] * e[7] - 1.*e[9] * e[14] * e[5] - 1.*e[9] * e[17] * e[8];
	A[177] = e[19] * e[11] * e[35] + e[28] * e[18] * e[15] + e[28] * e[9] * e[24] + e[28] * e[20] * e[17] + e[28] * e[11] * e[26] - 1.*e[25] * e[27] * e[9] - 1.*e[25] * e[30] * e[12] - 1.*e[25] * e[32] * e[14] + e[25] * e[33] * e[15] + e[25] * e[35] * e[17] - 1.*e[25] * e[29] * e[11] - 1.*e[34] * e[23] * e[14] + e[34] * e[24] * e[15] + e[34] * e[26] * e[17] - 1.*e[34] * e[20] * e[11] - 1.*e[34] * e[18] * e[9] - 1.*e[34] * e[21] * e[12] + e[13] * e[30] * e[24] + e[13] * e[21] * e[33] + e[13] * e[31] * e[25] + e[13] * e[22] * e[34] + e[13] * e[32] * e[26] + e[13] * e[23] * e[35] + e[10] * e[27] * e[24] + e[10] * e[18] * e[33] + e[10] * e[28] * e[25] + e[10] * e[19] * e[34] + e[10] * e[29] * e[26] + e[10] * e[20] * e[35] + e[22] * e[30] * e[15] + e[22] * e[12] * e[33] + e[22] * e[32] * e[17] + e[22] * e[14] * e[35] + e[22] * e[31] * e[16] + e[31] * e[21] * e[15] + e[31] * e[12] * e[24] + e[31] * e[23] * e[17] + e[31] * e[14] * e[26] - 1.*e[16] * e[27] * e[18] + e[16] * e[33] * e[24] - 1.*e[16] * e[30] * e[21] - 1.*e[16] * e[29] * e[20] + e[16] * e[35] * e[26] - 1.*e[16] * e[32] * e[23] + e[16] * e[28] * e[19] + 3.*e[16] * e[34] * e[25] + e[19] * e[27] * e[15] + e[19] * e[9] * e[33] + e[19] * e[29] * e[17];
	A[45] = e[4] * e[27] * e[3] + e[4] * e[0] * e[30] + e[4] * e[29] * e[5] + e[4] * e[2] * e[32] + e[31] * e[0] * e[3] + e[31] * e[2] * e[5] + e[7] * e[27] * e[6] + e[7] * e[0] * e[33] + e[7] * e[29] * e[8] + e[7] * e[2] * e[35] + e[34] * e[0] * e[6] + e[34] * e[2] * e[8] + e[1] * e[27] * e[0] + e[1] * e[29] * e[2] + e[1] * e[34] * e[7] - 1.*e[1] * e[32] * e[5] - 1.*e[1] * e[33] * e[6] - 1.*e[1] * e[30] * e[3] - 1.*e[1] * e[35] * e[8] + e[1] * e[31] * e[4] + 1.500000000*e[28] * ep2[1] + .5000000000*e[28] * ep2[4] + .5000000000*e[28] * ep2[0] - .5000000000*e[28] * ep2[6] - .5000000000*e[28] * ep2[5] + .5000000000*e[28] * ep2[7] - .5000000000*e[28] * ep2[3] + .5000000000*e[28] * ep2[2] - .5000000000*e[28] * ep2[8];
	A[191] = -1.*e[35] * e[10] * e[1] - 1.*e[35] * e[13] * e[4] + e[35] * e[16] * e[7] + e[35] * e[15] * e[6] - 1.*e[35] * e[9] * e[0] - 1.*e[35] * e[12] * e[3] + e[32] * e[12] * e[6] + e[32] * e[3] * e[15] + e[32] * e[13] * e[7] + e[32] * e[4] * e[16] - 1.*e[8] * e[27] * e[9] - 1.*e[8] * e[30] * e[12] - 1.*e[8] * e[28] * e[10] - 1.*e[8] * e[31] * e[13] + e[8] * e[29] * e[11] + e[11] * e[27] * e[6] + e[11] * e[0] * e[33] + e[11] * e[28] * e[7] + e[11] * e[1] * e[34] + e[29] * e[9] * e[6] + e[29] * e[0] * e[15] + e[29] * e[10] * e[7] + e[29] * e[1] * e[16] + e[5] * e[30] * e[15] + e[5] * e[12] * e[33] + e[5] * e[32] * e[17] + e[5] * e[14] * e[35] + e[5] * e[31] * e[16] + e[5] * e[13] * e[34] + e[8] * e[33] * e[15] + 3.*e[8] * e[35] * e[17] + e[8] * e[34] * e[16] + e[2] * e[27] * e[15] + e[2] * e[9] * e[33] + e[2] * e[29] * e[17] + e[2] * e[11] * e[35] + e[2] * e[28] * e[16] + e[2] * e[10] * e[34] - 1.*e[17] * e[27] * e[0] + e[17] * e[34] * e[7] + e[17] * e[33] * e[6] - 1.*e[17] * e[30] * e[3] - 1.*e[17] * e[28] * e[1] - 1.*e[17] * e[31] * e[4] + e[14] * e[30] * e[6] + e[14] * e[3] * e[33] + e[14] * e[31] * e[7] + e[14] * e[4] * e[34] + e[14] * e[32] * e[8];
	A[44] = e[19] * e[11] * e[2] + e[4] * e[18] * e[12] + e[4] * e[9] * e[21] + e[4] * e[20] * e[14] + e[4] * e[11] * e[23] + e[4] * e[19] * e[13] + e[4] * e[10] * e[22] + e[7] * e[18] * e[15] + e[7] * e[9] * e[24] + e[7] * e[20] * e[17] + e[7] * e[11] * e[26] + e[7] * e[19] * e[16] + e[7] * e[10] * e[25] + e[1] * e[18] * e[9] + e[1] * e[20] * e[11] - 1.*e[10] * e[21] * e[3] - 1.*e[10] * e[26] * e[8] - 1.*e[10] * e[23] * e[5] - 1.*e[10] * e[24] * e[6] + e[13] * e[18] * e[3] + e[13] * e[0] * e[21] + e[13] * e[1] * e[22] + e[13] * e[20] * e[5] + e[13] * e[2] * e[23] - 1.*e[19] * e[15] * e[6] - 1.*e[19] * e[14] * e[5] - 1.*e[19] * e[12] * e[3] - 1.*e[19] * e[17] * e[8] + e[22] * e[9] * e[3] + e[22] * e[0] * e[12] + e[22] * e[11] * e[5] + e[22] * e[2] * e[14] + e[16] * e[18] * e[6] + e[16] * e[0] * e[24] + e[16] * e[1] * e[25] + e[16] * e[20] * e[8] + e[16] * e[2] * e[26] - 1.*e[1] * e[23] * e[14] - 1.*e[1] * e[24] * e[15] - 1.*e[1] * e[26] * e[17] - 1.*e[1] * e[21] * e[12] + e[25] * e[9] * e[6] + e[25] * e[0] * e[15] + e[25] * e[11] * e[8] + e[25] * e[2] * e[17] + e[10] * e[18] * e[0] + 3.*e[10] * e[19] * e[1] + e[10] * e[20] * e[2] + e[19] * e[9] * e[0];
	A[190] = .5000000000*ep2[23] * e[26] + .5000000000*e[26] * ep2[25] + .5000000000*ep2[20] * e[26] - .5000000000*e[26] * ep2[18] + .5000000000*ep3[26] + .5000000000*e[26] * ep2[24] + e[20] * e[19] * e[25] - .5000000000*e[26] * ep2[19] - .5000000000*e[26] * ep2[21] + e[20] * e[18] * e[24] - .5000000000*e[26] * ep2[22] + e[23] * e[21] * e[24] + e[23] * e[22] * e[25];
	A[47] = e[16] * e[9] * e[33] + e[16] * e[29] * e[17] + e[16] * e[11] * e[35] + e[16] * e[10] * e[34] + e[34] * e[11] * e[17] + e[34] * e[9] * e[15] - 1.*e[10] * e[30] * e[12] - 1.*e[10] * e[32] * e[14] - 1.*e[10] * e[33] * e[15] - 1.*e[10] * e[35] * e[17] + e[10] * e[27] * e[9] + e[10] * e[29] * e[11] + e[13] * e[27] * e[12] + e[13] * e[9] * e[30] + e[13] * e[29] * e[14] + e[13] * e[11] * e[32] + e[13] * e[10] * e[31] + e[31] * e[11] * e[14] + e[31] * e[9] * e[12] + e[16] * e[27] * e[15] + 1.500000000*e[28] * ep2[10] + .5000000000*e[28] * ep2[16] + .5000000000*e[28] * ep2[9] + .5000000000*e[28] * ep2[11] - .5000000000*e[28] * ep2[12] - .5000000000*e[28] * ep2[15] - .5000000000*e[28] * ep2[17] - .5000000000*e[28] * ep2[14] + .5000000000*e[28] * ep2[13];
	A[189] = .5000000000*ep2[20] * e[35] + .5000000000*ep2[23] * e[35] + 1.500000000*e[35] * ep2[26] + .5000000000*e[35] * ep2[25] + .5000000000*e[35] * ep2[24] - .5000000000*e[35] * ep2[18] - .5000000000*e[35] * ep2[19] - .5000000000*e[35] * ep2[22] - .5000000000*e[35] * ep2[21] + e[20] * e[27] * e[24] + e[20] * e[18] * e[33] + e[20] * e[28] * e[25] + e[20] * e[19] * e[34] + e[20] * e[29] * e[26] + e[29] * e[19] * e[25] + e[29] * e[18] * e[24] + e[23] * e[30] * e[24] + e[23] * e[21] * e[33] + e[23] * e[31] * e[25] + e[23] * e[22] * e[34] + e[23] * e[32] * e[26] + e[32] * e[22] * e[25] + e[32] * e[21] * e[24] + e[26] * e[33] * e[24] + e[26] * e[34] * e[25] - 1.*e[26] * e[27] * e[18] - 1.*e[26] * e[30] * e[21] - 1.*e[26] * e[31] * e[22] - 1.*e[26] * e[28] * e[19];
	A[46] = e[4] * e[2] * e[5] + .5000000000*e[1] * ep2[0] - .5000000000*e[1] * ep2[6] + e[7] * e[0] * e[6] + .5000000000*e[1] * ep2[7] + .5000000000*e[1] * ep2[4] - .5000000000*e[1] * ep2[8] + .5000000000*e[1] * ep2[2] - .5000000000*e[1] * ep2[3] + .5000000000*ep3[1] + e[7] * e[2] * e[8] - .5000000000*e[1] * ep2[5] + e[4] * e[0] * e[3];
	A[188] = -.5000000000*e[17] * ep2[13] - .5000000000*e[17] * ep2[9] + .5000000000*e[17] * ep2[16] + .5000000000*e[17] * ep2[15] + .5000000000*ep3[17] - .5000000000*e[17] * ep2[10] + e[14] * e[13] * e[16] + e[14] * e[12] * e[15] + .5000000000*ep2[14] * e[17] + e[11] * e[10] * e[16] - .5000000000*e[17] * ep2[12] + .5000000000*ep2[11] * e[17] + e[11] * e[9] * e[15];
	A[41] = e[4] * e[27] * e[30] + e[4] * e[29] * e[32] + e[4] * e[28] * e[31] + e[31] * e[27] * e[3] + e[31] * e[0] * e[30] + e[31] * e[29] * e[5] + e[31] * e[2] * e[32] + e[7] * e[27] * e[33] + e[7] * e[29] * e[35] + e[7] * e[28] * e[34] + e[28] * e[27] * e[0] + e[28] * e[29] * e[2] + e[34] * e[27] * e[6] + e[34] * e[0] * e[33] + e[34] * e[29] * e[8] + e[34] * e[2] * e[35] - 1.*e[28] * e[32] * e[5] - 1.*e[28] * e[33] * e[6] - 1.*e[28] * e[30] * e[3] - 1.*e[28] * e[35] * e[8] + .5000000000*e[1] * ep2[27] + .5000000000*e[1] * ep2[29] + 1.500000000*e[1] * ep2[28] + .5000000000*e[1] * ep2[31] - .5000000000*e[1] * ep2[32] - .5000000000*e[1] * ep2[33] - .5000000000*e[1] * ep2[30] + .5000000000*e[1] * ep2[34] - .5000000000*e[1] * ep2[35];
	A[187] = .5000000000*ep2[11] * e[35] + .5000000000*e[35] * ep2[16] - .5000000000*e[35] * ep2[9] - .5000000000*e[35] * ep2[12] + .5000000000*e[35] * ep2[15] + 1.500000000*e[35] * ep2[17] - .5000000000*e[35] * ep2[10] + .5000000000*e[35] * ep2[14] - .5000000000*e[35] * ep2[13] + e[11] * e[27] * e[15] + e[11] * e[9] * e[33] + e[11] * e[29] * e[17] + e[11] * e[28] * e[16] + e[11] * e[10] * e[34] + e[29] * e[9] * e[15] + e[29] * e[10] * e[16] + e[14] * e[30] * e[15] + e[14] * e[12] * e[33] + e[14] * e[32] * e[17] + e[14] * e[31] * e[16] + e[14] * e[13] * e[34] + e[32] * e[12] * e[15] + e[32] * e[13] * e[16] + e[17] * e[33] * e[15] + e[17] * e[34] * e[16] - 1.*e[17] * e[27] * e[9] - 1.*e[17] * e[30] * e[12] - 1.*e[17] * e[28] * e[10] - 1.*e[17] * e[31] * e[13];
	A[40] = e[34] * e[27] * e[33] + e[34] * e[29] * e[35] - .5000000000*e[28] * ep2[30] - .5000000000*e[28] * ep2[35] + .5000000000*ep3[28] + .5000000000*e[28] * ep2[27] + .5000000000*e[28] * ep2[29] + e[31] * e[27] * e[30] + e[31] * e[29] * e[32] - .5000000000*e[28] * ep2[32] - .5000000000*e[28] * ep2[33] + .5000000000*e[28] * ep2[31] + .5000000000*e[28] * ep2[34];
	A[186] = .5000000000*ep2[5] * e[8] + e[2] * e[0] * e[6] + .5000000000*ep2[2] * e[8] + .5000000000*ep3[8] - .5000000000*e[8] * ep2[0] + e[5] * e[4] * e[7] + e[5] * e[3] * e[6] + .5000000000*e[8] * ep2[7] + e[2] * e[1] * e[7] - .5000000000*e[8] * ep2[1] - .5000000000*e[8] * ep2[4] - .5000000000*e[8] * ep2[3] + .5000000000*e[8] * ep2[6];
	A[43] = e[28] * e[27] * e[9] + e[28] * e[29] * e[11] - 1.*e[28] * e[30] * e[12] + e[28] * e[31] * e[13] - 1.*e[28] * e[32] * e[14] - 1.*e[28] * e[33] * e[15] - 1.*e[28] * e[35] * e[17] + e[31] * e[27] * e[12] + e[31] * e[9] * e[30] + e[31] * e[29] * e[14] + e[31] * e[11] * e[32] + e[13] * e[27] * e[30] + e[13] * e[29] * e[32] + e[16] * e[27] * e[33] + e[16] * e[29] * e[35] + e[34] * e[27] * e[15] + e[34] * e[9] * e[33] + e[34] * e[29] * e[17] + e[34] * e[11] * e[35] + e[34] * e[28] * e[16] + .5000000000*e[10] * ep2[27] + .5000000000*e[10] * ep2[29] + 1.500000000*e[10] * ep2[28] - .5000000000*e[10] * ep2[32] + .5000000000*e[10] * ep2[31] - .5000000000*e[10] * ep2[33] - .5000000000*e[10] * ep2[30] + .5000000000*e[10] * ep2[34] - .5000000000*e[10] * ep2[35];
	A[185] = -.5000000000*e[35] * ep2[1] + .5000000000*e[35] * ep2[7] - .5000000000*e[35] * ep2[3] + .5000000000*ep2[2] * e[35] + 1.500000000*e[35] * ep2[8] - .5000000000*e[35] * ep2[4] - .5000000000*e[35] * ep2[0] + .5000000000*e[35] * ep2[6] + .5000000000*e[35] * ep2[5] + e[2] * e[27] * e[6] + e[2] * e[0] * e[33] + e[2] * e[28] * e[7] + e[2] * e[1] * e[34] + e[2] * e[29] * e[8] - 1.*e[8] * e[27] * e[0] + e[8] * e[34] * e[7] + e[8] * e[32] * e[5] + e[8] * e[33] * e[6] - 1.*e[8] * e[30] * e[3] - 1.*e[8] * e[28] * e[1] - 1.*e[8] * e[31] * e[4] + e[29] * e[1] * e[7] + e[29] * e[0] * e[6] + e[5] * e[30] * e[6] + e[5] * e[3] * e[33] + e[5] * e[31] * e[7] + e[5] * e[4] * e[34] + e[32] * e[4] * e[7] + e[32] * e[3] * e[6];
	A[42] = e[28] * e[27] * e[18] + e[28] * e[29] * e[20] + e[22] * e[27] * e[30] + e[22] * e[29] * e[32] + e[22] * e[28] * e[31] + e[31] * e[27] * e[21] + e[31] * e[18] * e[30] + e[31] * e[29] * e[23] + e[31] * e[20] * e[32] + e[25] * e[27] * e[33] + e[25] * e[29] * e[35] + e[25] * e[28] * e[34] + e[34] * e[27] * e[24] + e[34] * e[18] * e[33] + e[34] * e[29] * e[26] + e[34] * e[20] * e[35] - 1.*e[28] * e[33] * e[24] - 1.*e[28] * e[30] * e[21] - 1.*e[28] * e[35] * e[26] - 1.*e[28] * e[32] * e[23] - .5000000000*e[19] * ep2[33] - .5000000000*e[19] * ep2[30] - .5000000000*e[19] * ep2[35] + .5000000000*e[19] * ep2[27] + .5000000000*e[19] * ep2[29] + 1.500000000*e[19] * ep2[28] + .5000000000*e[19] * ep2[31] + .5000000000*e[19] * ep2[34] - .5000000000*e[19] * ep2[32];
	A[184] = e[23] * e[3] * e[15] - 1.*e[17] * e[19] * e[1] - 1.*e[17] * e[22] * e[4] - 1.*e[17] * e[18] * e[0] + e[17] * e[25] * e[7] + e[17] * e[24] * e[6] + e[14] * e[21] * e[6] + e[14] * e[3] * e[24] + e[14] * e[22] * e[7] + e[14] * e[4] * e[25] + e[14] * e[23] * e[8] - 1.*e[26] * e[10] * e[1] - 1.*e[26] * e[13] * e[4] + e[26] * e[16] * e[7] + e[26] * e[15] * e[6] - 1.*e[26] * e[9] * e[0] - 1.*e[26] * e[12] * e[3] + e[23] * e[12] * e[6] + e[11] * e[18] * e[6] + e[11] * e[0] * e[24] + e[11] * e[19] * e[7] + e[11] * e[1] * e[25] + e[11] * e[20] * e[8] + e[11] * e[2] * e[26] + e[20] * e[9] * e[6] + e[20] * e[0] * e[15] + e[20] * e[10] * e[7] + e[20] * e[1] * e[16] + e[20] * e[2] * e[17] + e[5] * e[21] * e[15] + e[5] * e[12] * e[24] + e[5] * e[23] * e[17] + e[5] * e[14] * e[26] + e[5] * e[22] * e[16] + e[5] * e[13] * e[25] + e[8] * e[24] * e[15] + 3.*e[8] * e[26] * e[17] + e[8] * e[25] * e[16] + e[2] * e[18] * e[15] + e[2] * e[9] * e[24] + e[2] * e[19] * e[16] + e[2] * e[10] * e[25] - 1.*e[17] * e[21] * e[3] + e[23] * e[4] * e[16] + e[23] * e[13] * e[7] - 1.*e[8] * e[18] * e[9] - 1.*e[8] * e[21] * e[12] - 1.*e[8] * e[19] * e[10] - 1.*e[8] * e[22] * e[13];
	A[54] = e[13] * e[18] * e[12] + e[13] * e[9] * e[21] + e[13] * e[20] * e[14] + e[13] * e[11] * e[23] + e[13] * e[10] * e[22] + e[22] * e[11] * e[14] + e[22] * e[9] * e[12] + e[16] * e[18] * e[15] + e[16] * e[9] * e[24] + e[16] * e[20] * e[17] + e[16] * e[11] * e[26] + e[16] * e[10] * e[25] + e[25] * e[11] * e[17] + e[25] * e[9] * e[15] - 1.*e[10] * e[23] * e[14] - 1.*e[10] * e[24] * e[15] - 1.*e[10] * e[26] * e[17] + e[10] * e[20] * e[11] + e[10] * e[18] * e[9] - 1.*e[10] * e[21] * e[12] + .5000000000*e[19] * ep2[11] + .5000000000*e[19] * ep2[9] + 1.500000000*e[19] * ep2[10] + .5000000000*e[19] * ep2[13] + .5000000000*e[19] * ep2[16] - .5000000000*e[19] * ep2[12] - .5000000000*e[19] * ep2[15] - .5000000000*e[19] * ep2[17] - .5000000000*e[19] * ep2[14];
	A[164] = e[10] * e[18] * e[6] + e[10] * e[0] * e[24] + e[10] * e[19] * e[7] + e[10] * e[1] * e[25] + e[10] * e[20] * e[8] + e[10] * e[2] * e[26] + e[19] * e[9] * e[6] + e[19] * e[0] * e[15] + e[19] * e[1] * e[16] + e[19] * e[11] * e[8] + e[19] * e[2] * e[17] + e[4] * e[21] * e[15] + e[4] * e[12] * e[24] + e[4] * e[23] * e[17] + e[4] * e[14] * e[26] + e[4] * e[22] * e[16] + e[4] * e[13] * e[25] + e[7] * e[24] * e[15] + e[7] * e[26] * e[17] + 3.*e[7] * e[25] * e[16] + e[1] * e[18] * e[15] + e[1] * e[9] * e[24] + e[1] * e[20] * e[17] + e[1] * e[11] * e[26] - 1.*e[16] * e[21] * e[3] + e[16] * e[26] * e[8] - 1.*e[16] * e[20] * e[2] - 1.*e[16] * e[18] * e[0] - 1.*e[16] * e[23] * e[5] + e[16] * e[24] * e[6] + e[13] * e[21] * e[6] + e[13] * e[3] * e[24] + e[13] * e[22] * e[7] + e[13] * e[23] * e[8] + e[13] * e[5] * e[26] - 1.*e[25] * e[11] * e[2] + e[25] * e[15] * e[6] - 1.*e[25] * e[9] * e[0] - 1.*e[25] * e[14] * e[5] - 1.*e[25] * e[12] * e[3] + e[25] * e[17] * e[8] + e[22] * e[12] * e[6] + e[22] * e[3] * e[15] + e[22] * e[14] * e[8] + e[22] * e[5] * e[17] - 1.*e[7] * e[23] * e[14] - 1.*e[7] * e[20] * e[11] - 1.*e[7] * e[18] * e[9] - 1.*e[7] * e[21] * e[12];
	A[55] = e[13] * e[9] * e[3] + e[13] * e[0] * e[12] + e[13] * e[10] * e[4] + e[13] * e[11] * e[5] + e[13] * e[2] * e[14] + e[16] * e[9] * e[6] + e[16] * e[0] * e[15] + e[16] * e[10] * e[7] + e[16] * e[11] * e[8] + e[16] * e[2] * e[17] + e[7] * e[11] * e[17] + e[7] * e[9] * e[15] + e[4] * e[11] * e[14] + e[4] * e[9] * e[12] + e[10] * e[9] * e[0] + e[10] * e[11] * e[2] - 1.*e[10] * e[15] * e[6] - 1.*e[10] * e[14] * e[5] - 1.*e[10] * e[12] * e[3] - 1.*e[10] * e[17] * e[8] + .5000000000*e[1] * ep2[11] + .5000000000*e[1] * ep2[9] + 1.500000000*e[1] * ep2[10] - .5000000000*e[1] * ep2[12] - .5000000000*e[1] * ep2[15] - .5000000000*e[1] * ep2[17] - .5000000000*e[1] * ep2[14] + .5000000000*e[1] * ep2[13] + .5000000000*e[1] * ep2[16];
	A[165] = e[1] * e[27] * e[6] + e[1] * e[0] * e[33] + e[1] * e[28] * e[7] + e[1] * e[29] * e[8] + e[1] * e[2] * e[35] - 1.*e[7] * e[27] * e[0] - 1.*e[7] * e[32] * e[5] + e[7] * e[33] * e[6] - 1.*e[7] * e[30] * e[3] + e[7] * e[35] * e[8] - 1.*e[7] * e[29] * e[2] + e[7] * e[31] * e[4] + e[28] * e[0] * e[6] + e[28] * e[2] * e[8] + e[4] * e[30] * e[6] + e[4] * e[3] * e[33] + e[4] * e[32] * e[8] + e[4] * e[5] * e[35] + e[31] * e[3] * e[6] + e[31] * e[5] * e[8] + .5000000000*ep2[1] * e[34] + 1.500000000*e[34] * ep2[7] + .5000000000*e[34] * ep2[4] - .5000000000*e[34] * ep2[0] + .5000000000*e[34] * ep2[6] - .5000000000*e[34] * ep2[5] - .5000000000*e[34] * ep2[3] - .5000000000*e[34] * ep2[2] + .5000000000*e[34] * ep2[8];
	A[52] = e[4] * e[18] * e[3] + e[4] * e[0] * e[21] + e[4] * e[1] * e[22] + e[4] * e[20] * e[5] + e[4] * e[2] * e[23] + e[22] * e[0] * e[3] + e[22] * e[2] * e[5] + e[7] * e[18] * e[6] + e[7] * e[0] * e[24] + e[7] * e[1] * e[25] + e[7] * e[20] * e[8] + e[7] * e[2] * e[26] + e[25] * e[0] * e[6] + e[25] * e[2] * e[8] + e[1] * e[18] * e[0] + e[1] * e[20] * e[2] - 1.*e[1] * e[21] * e[3] - 1.*e[1] * e[26] * e[8] - 1.*e[1] * e[23] * e[5] - 1.*e[1] * e[24] * e[6] + .5000000000*e[19] * ep2[4] + .5000000000*e[19] * ep2[0] - .5000000000*e[19] * ep2[6] - .5000000000*e[19] * ep2[5] + 1.500000000*e[19] * ep2[1] + .5000000000*e[19] * ep2[7] - .5000000000*e[19] * ep2[3] + .5000000000*e[19] * ep2[2] - .5000000000*e[19] * ep2[8];
	A[166] = -.5000000000*e[7] * ep2[0] + e[4] * e[5] * e[8] + .5000000000*ep2[4] * e[7] - .5000000000*e[7] * ep2[2] + .5000000000*e[7] * ep2[8] - .5000000000*e[7] * ep2[5] + .5000000000*e[7] * ep2[6] + e[1] * e[0] * e[6] + .5000000000*ep3[7] + e[4] * e[3] * e[6] + e[1] * e[2] * e[8] - .5000000000*e[7] * ep2[3] + .5000000000*ep2[1] * e[7];
	A[53] = -1.*e[1] * e[32] * e[23] - 1.*e[19] * e[32] * e[5] - 1.*e[19] * e[33] * e[6] - 1.*e[19] * e[30] * e[3] - 1.*e[19] * e[35] * e[8] - 1.*e[28] * e[21] * e[3] - 1.*e[28] * e[26] * e[8] - 1.*e[28] * e[23] * e[5] - 1.*e[28] * e[24] * e[6] + e[7] * e[27] * e[24] + e[7] * e[18] * e[33] + e[7] * e[29] * e[26] + e[7] * e[20] * e[35] + e[22] * e[27] * e[3] + e[22] * e[0] * e[30] + e[22] * e[29] * e[5] + e[22] * e[2] * e[32] + e[31] * e[18] * e[3] + e[31] * e[0] * e[21] + e[31] * e[20] * e[5] + e[31] * e[2] * e[23] + e[25] * e[27] * e[6] + e[25] * e[0] * e[33] + e[25] * e[28] * e[7] + e[25] * e[1] * e[34] + e[25] * e[29] * e[8] + e[25] * e[2] * e[35] + e[34] * e[18] * e[6] + e[34] * e[0] * e[24] + e[34] * e[19] * e[7] + e[34] * e[20] * e[8] + e[34] * e[2] * e[26] + e[1] * e[27] * e[18] + 3.*e[1] * e[28] * e[19] + e[1] * e[29] * e[20] + e[19] * e[27] * e[0] + e[19] * e[29] * e[2] + e[28] * e[18] * e[0] + e[28] * e[20] * e[2] + e[4] * e[27] * e[21] + e[4] * e[18] * e[30] + e[4] * e[28] * e[22] + e[4] * e[19] * e[31] + e[4] * e[29] * e[23] + e[4] * e[20] * e[32] - 1.*e[1] * e[33] * e[24] - 1.*e[1] * e[30] * e[21] - 1.*e[1] * e[35] * e[26] + e[1] * e[31] * e[22];
	A[167] = e[10] * e[27] * e[15] + e[10] * e[9] * e[33] + e[10] * e[29] * e[17] + e[10] * e[11] * e[35] + e[10] * e[28] * e[16] + e[28] * e[11] * e[17] + e[28] * e[9] * e[15] + e[13] * e[30] * e[15] + e[13] * e[12] * e[33] + e[13] * e[32] * e[17] + e[13] * e[14] * e[35] + e[13] * e[31] * e[16] + e[31] * e[14] * e[17] + e[31] * e[12] * e[15] + e[16] * e[33] * e[15] + e[16] * e[35] * e[17] - 1.*e[16] * e[27] * e[9] - 1.*e[16] * e[30] * e[12] - 1.*e[16] * e[32] * e[14] - 1.*e[16] * e[29] * e[11] + .5000000000*ep2[10] * e[34] + 1.500000000*e[34] * ep2[16] - .5000000000*e[34] * ep2[9] - .5000000000*e[34] * ep2[11] - .5000000000*e[34] * ep2[12] + .5000000000*e[34] * ep2[15] + .5000000000*e[34] * ep2[17] - .5000000000*e[34] * ep2[14] + .5000000000*e[34] * ep2[13];
	A[50] = .5000000000*e[19] * ep2[18] + .5000000000*e[19] * ep2[25] + .5000000000*e[19] * ep2[22] + e[25] * e[20] * e[26] - .5000000000*e[19] * ep2[21] + .5000000000*e[19] * ep2[20] - .5000000000*e[19] * ep2[26] - .5000000000*e[19] * ep2[23] - .5000000000*e[19] * ep2[24] + .5000000000*ep3[19] + e[22] * e[20] * e[23] + e[25] * e[18] * e[24] + e[22] * e[18] * e[21];
	A[160] = .5000000000*e[34] * ep2[33] + .5000000000*e[34] * ep2[35] - .5000000000*e[34] * ep2[27] - .5000000000*e[34] * ep2[32] - .5000000000*e[34] * ep2[29] - .5000000000*e[34] * ep2[30] + .5000000000*ep2[28] * e[34] + e[31] * e[30] * e[33] + e[31] * e[32] * e[35] + e[28] * e[27] * e[33] + .5000000000*ep3[34] + e[28] * e[29] * e[35] + .5000000000*ep2[31] * e[34];
	A[51] = e[4] * e[28] * e[13] + e[4] * e[10] * e[31] + e[7] * e[27] * e[15] + e[7] * e[9] * e[33] + e[7] * e[29] * e[17] + e[7] * e[11] * e[35] + e[7] * e[28] * e[16] + e[7] * e[10] * e[34] + e[1] * e[27] * e[9] + e[1] * e[29] * e[11] + 3.*e[1] * e[28] * e[10] + e[10] * e[27] * e[0] - 1.*e[10] * e[32] * e[5] - 1.*e[10] * e[33] * e[6] - 1.*e[10] * e[30] * e[3] - 1.*e[10] * e[35] * e[8] + e[10] * e[29] * e[2] + e[13] * e[27] * e[3] + e[13] * e[0] * e[30] + e[13] * e[1] * e[31] + e[13] * e[29] * e[5] + e[13] * e[2] * e[32] + e[28] * e[11] * e[2] - 1.*e[28] * e[15] * e[6] + e[28] * e[9] * e[0] - 1.*e[28] * e[14] * e[5] - 1.*e[28] * e[12] * e[3] - 1.*e[28] * e[17] * e[8] + e[31] * e[9] * e[3] + e[31] * e[0] * e[12] + e[31] * e[11] * e[5] + e[31] * e[2] * e[14] + e[16] * e[27] * e[6] + e[16] * e[0] * e[33] + e[16] * e[1] * e[34] + e[16] * e[29] * e[8] + e[16] * e[2] * e[35] - 1.*e[1] * e[30] * e[12] - 1.*e[1] * e[32] * e[14] - 1.*e[1] * e[33] * e[15] - 1.*e[1] * e[35] * e[17] + e[34] * e[9] * e[6] + e[34] * e[0] * e[15] + e[34] * e[11] * e[8] + e[34] * e[2] * e[17] + e[4] * e[27] * e[12] + e[4] * e[9] * e[30] + e[4] * e[29] * e[14] + e[4] * e[11] * e[32];
	A[161] = e[4] * e[30] * e[33] + e[4] * e[32] * e[35] + e[4] * e[31] * e[34] + e[31] * e[30] * e[6] + e[31] * e[3] * e[33] + e[31] * e[32] * e[8] + e[31] * e[5] * e[35] + e[28] * e[27] * e[6] + e[28] * e[0] * e[33] + e[28] * e[29] * e[8] + e[28] * e[2] * e[35] + e[34] * e[33] * e[6] + e[34] * e[35] * e[8] - 1.*e[34] * e[27] * e[0] - 1.*e[34] * e[32] * e[5] - 1.*e[34] * e[30] * e[3] - 1.*e[34] * e[29] * e[2] + e[1] * e[27] * e[33] + e[1] * e[29] * e[35] + e[1] * e[28] * e[34] + .5000000000*ep2[31] * e[7] - .5000000000*e[7] * ep2[27] - .5000000000*e[7] * ep2[32] + .5000000000*e[7] * ep2[28] - .5000000000*e[7] * ep2[29] + .5000000000*e[7] * ep2[33] - .5000000000*e[7] * ep2[30] + 1.500000000*e[7] * ep2[34] + .5000000000*e[7] * ep2[35];
	A[48] = -.5000000000*e[10] * ep2[14] - .5000000000*e[10] * ep2[17] - .5000000000*e[10] * ep2[15] + e[13] * e[11] * e[14] + e[16] * e[11] * e[17] + .5000000000*e[10] * ep2[13] + e[13] * e[9] * e[12] - .5000000000*e[10] * ep2[12] + .5000000000*ep3[10] + e[16] * e[9] * e[15] + .5000000000*e[10] * ep2[16] + .5000000000*e[10] * ep2[11] + .5000000000*e[10] * ep2[9];
	A[162] = e[22] * e[32] * e[35] + e[22] * e[31] * e[34] + e[31] * e[30] * e[24] + e[31] * e[21] * e[33] + e[31] * e[32] * e[26] + e[31] * e[23] * e[35] + e[34] * e[33] * e[24] + e[34] * e[35] * e[26] - 1.*e[34] * e[27] * e[18] - 1.*e[34] * e[30] * e[21] - 1.*e[34] * e[29] * e[20] - 1.*e[34] * e[32] * e[23] + e[19] * e[27] * e[33] + e[19] * e[29] * e[35] + e[19] * e[28] * e[34] + e[28] * e[27] * e[24] + e[28] * e[18] * e[33] + e[28] * e[29] * e[26] + e[28] * e[20] * e[35] + e[22] * e[30] * e[33] + .5000000000*ep2[28] * e[25] + .5000000000*ep2[31] * e[25] + .5000000000*e[25] * ep2[33] + .5000000000*e[25] * ep2[35] + 1.500000000*e[25] * ep2[34] - .5000000000*e[25] * ep2[27] - .5000000000*e[25] * ep2[32] - .5000000000*e[25] * ep2[29] - .5000000000*e[25] * ep2[30];
	A[49] = -1.*e[19] * e[35] * e[26] - 1.*e[19] * e[32] * e[23] + e[19] * e[27] * e[18] + e[19] * e[29] * e[20] + e[22] * e[27] * e[21] + e[22] * e[18] * e[30] + e[22] * e[19] * e[31] + e[22] * e[29] * e[23] + e[22] * e[20] * e[32] + e[31] * e[18] * e[21] + e[31] * e[20] * e[23] + e[25] * e[27] * e[24] + e[25] * e[18] * e[33] + e[25] * e[19] * e[34] + e[25] * e[29] * e[26] + e[25] * e[20] * e[35] + e[34] * e[18] * e[24] + e[34] * e[20] * e[26] - 1.*e[19] * e[33] * e[24] - 1.*e[19] * e[30] * e[21] + 1.500000000*e[28] * ep2[19] + .5000000000*e[28] * ep2[18] + .5000000000*e[28] * ep2[20] + .5000000000*e[28] * ep2[22] + .5000000000*e[28] * ep2[25] - .5000000000*e[28] * ep2[26] - .5000000000*e[28] * ep2[23] - .5000000000*e[28] * ep2[24] - .5000000000*e[28] * ep2[21];
	A[163] = e[10] * e[27] * e[33] + e[10] * e[29] * e[35] + e[10] * e[28] * e[34] + e[34] * e[33] * e[15] + e[34] * e[35] * e[17] + e[28] * e[27] * e[15] + e[28] * e[9] * e[33] + e[28] * e[29] * e[17] + e[28] * e[11] * e[35] - 1.*e[34] * e[27] * e[9] - 1.*e[34] * e[30] * e[12] + e[34] * e[31] * e[13] - 1.*e[34] * e[32] * e[14] - 1.*e[34] * e[29] * e[11] + e[31] * e[30] * e[15] + e[31] * e[12] * e[33] + e[31] * e[32] * e[17] + e[31] * e[14] * e[35] + e[13] * e[30] * e[33] + e[13] * e[32] * e[35] - .5000000000*e[16] * ep2[27] - .5000000000*e[16] * ep2[32] + .5000000000*e[16] * ep2[28] - .5000000000*e[16] * ep2[29] + .5000000000*e[16] * ep2[31] + .5000000000*e[16] * ep2[33] - .5000000000*e[16] * ep2[30] + 1.500000000*e[16] * ep2[34] + .5000000000*e[16] * ep2[35];
	A[63] = e[29] * e[32] * e[14] - 1.*e[29] * e[33] * e[15] - 1.*e[29] * e[34] * e[16] + e[32] * e[27] * e[12] + e[32] * e[9] * e[30] + e[32] * e[28] * e[13] + e[32] * e[10] * e[31] + e[14] * e[27] * e[30] + e[14] * e[28] * e[31] + e[17] * e[27] * e[33] + e[17] * e[28] * e[34] + e[35] * e[27] * e[15] + e[35] * e[9] * e[33] + e[35] * e[29] * e[17] + e[35] * e[28] * e[16] + e[35] * e[10] * e[34] + e[29] * e[27] * e[9] + e[29] * e[28] * e[10] - 1.*e[29] * e[30] * e[12] - 1.*e[29] * e[31] * e[13] + .5000000000*e[11] * ep2[27] + 1.500000000*e[11] * ep2[29] + .5000000000*e[11] * ep2[28] + .5000000000*e[11] * ep2[32] - .5000000000*e[11] * ep2[31] - .5000000000*e[11] * ep2[33] - .5000000000*e[11] * ep2[30] - .5000000000*e[11] * ep2[34] + .5000000000*e[11] * ep2[35];
	A[173] = e[1] * e[20] * e[35] + e[19] * e[27] * e[6] + e[19] * e[0] * e[33] + e[19] * e[28] * e[7] + e[19] * e[29] * e[8] + e[19] * e[2] * e[35] + e[28] * e[18] * e[6] + e[28] * e[0] * e[24] + e[28] * e[20] * e[8] + e[28] * e[2] * e[26] + e[4] * e[30] * e[24] + e[4] * e[21] * e[33] + e[4] * e[31] * e[25] + e[4] * e[22] * e[34] + e[4] * e[32] * e[26] + e[4] * e[23] * e[35] - 1.*e[7] * e[27] * e[18] + e[7] * e[33] * e[24] - 1.*e[7] * e[30] * e[21] - 1.*e[7] * e[29] * e[20] + e[7] * e[35] * e[26] + e[7] * e[31] * e[22] - 1.*e[7] * e[32] * e[23] - 1.*e[25] * e[27] * e[0] - 1.*e[25] * e[32] * e[5] - 1.*e[25] * e[30] * e[3] - 1.*e[25] * e[29] * e[2] - 1.*e[34] * e[21] * e[3] - 1.*e[34] * e[20] * e[2] - 1.*e[34] * e[18] * e[0] - 1.*e[34] * e[23] * e[5] + e[22] * e[30] * e[6] + e[22] * e[3] * e[33] + e[22] * e[32] * e[8] + e[22] * e[5] * e[35] + e[31] * e[21] * e[6] + e[31] * e[3] * e[24] + e[31] * e[23] * e[8] + e[31] * e[5] * e[26] + e[34] * e[26] * e[8] + e[1] * e[27] * e[24] + e[1] * e[18] * e[33] + e[1] * e[28] * e[25] + e[1] * e[19] * e[34] + e[1] * e[29] * e[26] + e[34] * e[24] * e[6] + e[25] * e[33] * e[6] + 3.*e[25] * e[34] * e[7] + e[25] * e[35] * e[8];
	A[62] = .5000000000*e[20] * ep2[27] + 1.500000000*e[20] * ep2[29] + .5000000000*e[20] * ep2[28] + .5000000000*e[20] * ep2[32] + .5000000000*e[20] * ep2[35] - .5000000000*e[20] * ep2[31] - .5000000000*e[20] * ep2[33] - .5000000000*e[20] * ep2[30] - .5000000000*e[20] * ep2[34] + e[29] * e[27] * e[18] + e[29] * e[28] * e[19] + e[23] * e[27] * e[30] + e[23] * e[29] * e[32] + e[23] * e[28] * e[31] + e[32] * e[27] * e[21] + e[32] * e[18] * e[30] + e[32] * e[28] * e[22] + e[32] * e[19] * e[31] + e[26] * e[27] * e[33] + e[26] * e[29] * e[35] + e[26] * e[28] * e[34] + e[35] * e[27] * e[24] + e[35] * e[18] * e[33] + e[35] * e[28] * e[25] + e[35] * e[19] * e[34] - 1.*e[29] * e[33] * e[24] - 1.*e[29] * e[30] * e[21] - 1.*e[29] * e[31] * e[22] - 1.*e[29] * e[34] * e[25];
	A[172] = e[19] * e[1] * e[7] + e[19] * e[0] * e[6] + e[19] * e[2] * e[8] + e[4] * e[21] * e[6] + e[4] * e[3] * e[24] + e[4] * e[22] * e[7] + e[4] * e[23] * e[8] + e[4] * e[5] * e[26] + e[22] * e[3] * e[6] + e[22] * e[5] * e[8] + e[7] * e[24] * e[6] + e[7] * e[26] * e[8] + e[1] * e[18] * e[6] + e[1] * e[0] * e[24] + e[1] * e[20] * e[8] + e[1] * e[2] * e[26] - 1.*e[7] * e[21] * e[3] - 1.*e[7] * e[20] * e[2] - 1.*e[7] * e[18] * e[0] - 1.*e[7] * e[23] * e[5] + .5000000000*e[25] * ep2[4] - .5000000000*e[25] * ep2[0] + .5000000000*e[25] * ep2[6] - .5000000000*e[25] * ep2[5] + .5000000000*e[25] * ep2[1] + 1.500000000*e[25] * ep2[7] - .5000000000*e[25] * ep2[3] - .5000000000*e[25] * ep2[2] + .5000000000*e[25] * ep2[8];
	A[61] = e[5] * e[27] * e[30] + e[5] * e[29] * e[32] + e[5] * e[28] * e[31] + e[32] * e[27] * e[3] + e[32] * e[0] * e[30] + e[32] * e[28] * e[4] + e[32] * e[1] * e[31] + e[8] * e[27] * e[33] + e[8] * e[29] * e[35] + e[8] * e[28] * e[34] + e[29] * e[27] * e[0] + e[29] * e[28] * e[1] + e[35] * e[27] * e[6] + e[35] * e[0] * e[33] + e[35] * e[28] * e[7] + e[35] * e[1] * e[34] - 1.*e[29] * e[34] * e[7] - 1.*e[29] * e[33] * e[6] - 1.*e[29] * e[30] * e[3] - 1.*e[29] * e[31] * e[4] + .5000000000*e[2] * ep2[27] + 1.500000000*e[2] * ep2[29] + .5000000000*e[2] * ep2[28] + .5000000000*e[2] * ep2[32] - .5000000000*e[2] * ep2[31] - .5000000000*e[2] * ep2[33] - .5000000000*e[2] * ep2[30] - .5000000000*e[2] * ep2[34] + .5000000000*e[2] * ep2[35];
	A[175] = e[13] * e[12] * e[6] + e[13] * e[3] * e[15] + e[13] * e[4] * e[16] + e[13] * e[14] * e[8] + e[13] * e[5] * e[17] + e[16] * e[15] * e[6] + e[16] * e[17] * e[8] + e[1] * e[11] * e[17] + e[1] * e[9] * e[15] + e[1] * e[10] * e[16] + e[4] * e[14] * e[17] + e[4] * e[12] * e[15] + e[10] * e[9] * e[6] + e[10] * e[0] * e[15] + e[10] * e[11] * e[8] + e[10] * e[2] * e[17] - 1.*e[16] * e[11] * e[2] - 1.*e[16] * e[9] * e[0] - 1.*e[16] * e[14] * e[5] - 1.*e[16] * e[12] * e[3] + .5000000000*ep2[13] * e[7] + 1.500000000*ep2[16] * e[7] + .5000000000*e[7] * ep2[17] + .5000000000*e[7] * ep2[15] - .5000000000*e[7] * ep2[9] - .5000000000*e[7] * ep2[11] - .5000000000*e[7] * ep2[12] + .5000000000*e[7] * ep2[10] - .5000000000*e[7] * ep2[14];
	A[60] = .5000000000*e[29] * ep2[32] + .5000000000*e[29] * ep2[35] - .5000000000*e[29] * ep2[31] - .5000000000*e[29] * ep2[33] - .5000000000*e[29] * ep2[30] - .5000000000*e[29] * ep2[34] + e[32] * e[27] * e[30] + .5000000000*ep3[29] + .5000000000*e[29] * ep2[28] + e[35] * e[28] * e[34] + .5000000000*e[29] * ep2[27] + e[35] * e[27] * e[33] + e[32] * e[28] * e[31];
	A[174] = -1.*e[16] * e[21] * e[12] + e[10] * e[18] * e[15] + e[10] * e[9] * e[24] + e[10] * e[20] * e[17] + e[10] * e[11] * e[26] + e[19] * e[11] * e[17] + e[19] * e[9] * e[15] + e[19] * e[10] * e[16] + e[13] * e[21] * e[15] + e[13] * e[12] * e[24] + e[13] * e[23] * e[17] + e[13] * e[14] * e[26] + e[13] * e[22] * e[16] + e[22] * e[14] * e[17] + e[22] * e[12] * e[15] + e[16] * e[24] * e[15] + e[16] * e[26] * e[17] - 1.*e[16] * e[23] * e[14] - 1.*e[16] * e[20] * e[11] - 1.*e[16] * e[18] * e[9] + .5000000000*ep2[13] * e[25] + 1.500000000*e[25] * ep2[16] + .5000000000*e[25] * ep2[17] + .5000000000*e[25] * ep2[15] + .5000000000*ep2[10] * e[25] - .5000000000*e[25] * ep2[9] - .5000000000*e[25] * ep2[11] - .5000000000*e[25] * ep2[12] - .5000000000*e[25] * ep2[14];
	A[59] = e[19] * e[20] * e[2] + e[22] * e[18] * e[3] + e[22] * e[0] * e[21] + e[22] * e[19] * e[4] + e[22] * e[20] * e[5] + e[22] * e[2] * e[23] - 1.*e[19] * e[21] * e[3] - 1.*e[19] * e[26] * e[8] + e[19] * e[25] * e[7] - 1.*e[19] * e[23] * e[5] - 1.*e[19] * e[24] * e[6] + e[4] * e[18] * e[21] + e[4] * e[20] * e[23] + e[25] * e[18] * e[6] + e[25] * e[0] * e[24] + e[25] * e[20] * e[8] + e[25] * e[2] * e[26] + e[7] * e[18] * e[24] + e[7] * e[20] * e[26] + e[19] * e[18] * e[0] + 1.500000000*ep2[19] * e[1] + .5000000000*e[1] * ep2[22] + .5000000000*e[1] * ep2[18] + .5000000000*e[1] * ep2[20] + .5000000000*e[1] * ep2[25] - .5000000000*e[1] * ep2[26] - .5000000000*e[1] * ep2[23] - .5000000000*e[1] * ep2[24] - .5000000000*e[1] * ep2[21];
	A[169] = e[19] * e[27] * e[24] + e[19] * e[18] * e[33] + e[19] * e[28] * e[25] + e[19] * e[29] * e[26] + e[19] * e[20] * e[35] + e[28] * e[18] * e[24] + e[28] * e[20] * e[26] + e[22] * e[30] * e[24] + e[22] * e[21] * e[33] + e[22] * e[31] * e[25] + e[22] * e[32] * e[26] + e[22] * e[23] * e[35] + e[31] * e[21] * e[24] + e[31] * e[23] * e[26] + e[25] * e[33] * e[24] + e[25] * e[35] * e[26] - 1.*e[25] * e[27] * e[18] - 1.*e[25] * e[30] * e[21] - 1.*e[25] * e[29] * e[20] - 1.*e[25] * e[32] * e[23] - .5000000000*e[34] * ep2[18] - .5000000000*e[34] * ep2[23] - .5000000000*e[34] * ep2[20] - .5000000000*e[34] * ep2[21] + .5000000000*ep2[19] * e[34] + .5000000000*ep2[22] * e[34] + 1.500000000*e[34] * ep2[25] + .5000000000*e[34] * ep2[24] + .5000000000*e[34] * ep2[26];
	A[58] = e[16] * e[0] * e[6] + e[16] * e[2] * e[8] + e[1] * e[11] * e[2] - 1.*e[1] * e[15] * e[6] + e[1] * e[9] * e[0] - 1.*e[1] * e[14] * e[5] - 1.*e[1] * e[12] * e[3] - 1.*e[1] * e[17] * e[8] + e[4] * e[9] * e[3] + e[4] * e[0] * e[12] + e[4] * e[1] * e[13] + e[4] * e[11] * e[5] + e[4] * e[2] * e[14] + e[13] * e[0] * e[3] + e[13] * e[2] * e[5] + e[7] * e[9] * e[6] + e[7] * e[0] * e[15] + e[7] * e[1] * e[16] + e[7] * e[11] * e[8] + e[7] * e[2] * e[17] - .5000000000*e[10] * ep2[6] - .5000000000*e[10] * ep2[5] - .5000000000*e[10] * ep2[3] - .5000000000*e[10] * ep2[8] + 1.500000000*e[10] * ep2[1] + .5000000000*e[10] * ep2[0] + .5000000000*e[10] * ep2[2] + .5000000000*e[10] * ep2[4] + .5000000000*e[10] * ep2[7];
	A[168] = e[13] * e[14] * e[17] + e[13] * e[12] * e[15] + e[10] * e[9] * e[15] + .5000000000*e[16] * ep2[15] - .5000000000*e[16] * ep2[11] - .5000000000*e[16] * ep2[12] - .5000000000*e[16] * ep2[14] + e[10] * e[11] * e[17] + .5000000000*ep2[10] * e[16] + .5000000000*ep3[16] - .5000000000*e[16] * ep2[9] + .5000000000*e[16] * ep2[17] + .5000000000*ep2[13] * e[16];
	A[57] = e[10] * e[29] * e[20] + e[22] * e[27] * e[12] + e[22] * e[9] * e[30] + e[22] * e[29] * e[14] + e[22] * e[11] * e[32] + e[22] * e[10] * e[31] + e[31] * e[18] * e[12] + e[31] * e[9] * e[21] + e[31] * e[20] * e[14] + e[31] * e[11] * e[23] - 1.*e[10] * e[33] * e[24] - 1.*e[10] * e[30] * e[21] - 1.*e[10] * e[35] * e[26] - 1.*e[10] * e[32] * e[23] + e[10] * e[34] * e[25] + e[19] * e[27] * e[9] + e[19] * e[29] * e[11] + e[28] * e[18] * e[9] + e[28] * e[20] * e[11] + e[16] * e[27] * e[24] + e[16] * e[18] * e[33] + e[16] * e[28] * e[25] + e[16] * e[19] * e[34] + e[16] * e[29] * e[26] + e[16] * e[20] * e[35] - 1.*e[19] * e[30] * e[12] - 1.*e[19] * e[32] * e[14] - 1.*e[19] * e[33] * e[15] - 1.*e[19] * e[35] * e[17] - 1.*e[28] * e[23] * e[14] - 1.*e[28] * e[24] * e[15] - 1.*e[28] * e[26] * e[17] - 1.*e[28] * e[21] * e[12] + e[25] * e[27] * e[15] + e[25] * e[9] * e[33] + e[25] * e[29] * e[17] + e[25] * e[11] * e[35] + e[34] * e[18] * e[15] + e[34] * e[9] * e[24] + e[34] * e[20] * e[17] + e[34] * e[11] * e[26] + e[13] * e[27] * e[21] + e[13] * e[18] * e[30] + e[13] * e[28] * e[22] + e[13] * e[19] * e[31] + e[13] * e[29] * e[23] + e[13] * e[20] * e[32] + e[10] * e[27] * e[18] + 3.*e[10] * e[28] * e[19];
	A[171] = e[4] * e[30] * e[15] + e[4] * e[12] * e[33] + e[4] * e[32] * e[17] + e[4] * e[14] * e[35] + e[4] * e[31] * e[16] + e[4] * e[13] * e[34] + e[7] * e[33] * e[15] + e[7] * e[35] * e[17] + 3.*e[7] * e[34] * e[16] + e[1] * e[27] * e[15] + e[1] * e[9] * e[33] + e[1] * e[29] * e[17] + e[1] * e[11] * e[35] + e[1] * e[28] * e[16] + e[1] * e[10] * e[34] - 1.*e[16] * e[27] * e[0] - 1.*e[16] * e[32] * e[5] + e[16] * e[33] * e[6] - 1.*e[16] * e[30] * e[3] + e[16] * e[35] * e[8] - 1.*e[16] * e[29] * e[2] + e[13] * e[30] * e[6] + e[13] * e[3] * e[33] + e[13] * e[31] * e[7] + e[13] * e[32] * e[8] + e[13] * e[5] * e[35] - 1.*e[34] * e[11] * e[2] + e[34] * e[15] * e[6] - 1.*e[34] * e[9] * e[0] - 1.*e[34] * e[14] * e[5] - 1.*e[34] * e[12] * e[3] + e[34] * e[17] * e[8] + e[31] * e[12] * e[6] + e[31] * e[3] * e[15] + e[31] * e[14] * e[8] + e[31] * e[5] * e[17] - 1.*e[7] * e[27] * e[9] - 1.*e[7] * e[30] * e[12] + e[7] * e[28] * e[10] - 1.*e[7] * e[32] * e[14] + e[10] * e[27] * e[6] + e[10] * e[0] * e[33] + e[10] * e[29] * e[8] + e[10] * e[2] * e[35] + e[28] * e[9] * e[6] + e[28] * e[0] * e[15] + e[28] * e[11] * e[8] + e[28] * e[2] * e[17] - 1.*e[7] * e[29] * e[11];
	A[56] = e[22] * e[18] * e[12] + e[22] * e[9] * e[21] + e[22] * e[20] * e[14] + e[22] * e[11] * e[23] + e[22] * e[19] * e[13] + e[25] * e[18] * e[15] + e[25] * e[9] * e[24] + e[25] * e[20] * e[17] + e[25] * e[11] * e[26] + e[25] * e[19] * e[16] + e[16] * e[18] * e[24] + e[16] * e[20] * e[26] + e[13] * e[18] * e[21] + e[13] * e[20] * e[23] + e[19] * e[18] * e[9] + e[19] * e[20] * e[11] - 1.*e[19] * e[23] * e[14] - 1.*e[19] * e[24] * e[15] - 1.*e[19] * e[26] * e[17] - 1.*e[19] * e[21] * e[12] + .5000000000*e[10] * ep2[22] + .5000000000*e[10] * ep2[25] + 1.500000000*e[10] * ep2[19] + .5000000000*e[10] * ep2[18] + .5000000000*e[10] * ep2[20] - .5000000000*e[10] * ep2[26] - .5000000000*e[10] * ep2[23] - .5000000000*e[10] * ep2[24] - .5000000000*e[10] * ep2[21];
	A[170] = e[19] * e[20] * e[26] - .5000000000*e[25] * ep2[20] + e[22] * e[21] * e[24] + e[19] * e[18] * e[24] + .5000000000*ep2[22] * e[25] - .5000000000*e[25] * ep2[21] - .5000000000*e[25] * ep2[23] + .5000000000*ep2[19] * e[25] - .5000000000*e[25] * ep2[18] + .5000000000*e[25] * ep2[24] + .5000000000*e[25] * ep2[26] + .5000000000*ep3[25] + e[22] * e[23] * e[26];
	A[73] = -1.*e[20] * e[33] * e[6] - 1.*e[20] * e[30] * e[3] - 1.*e[20] * e[31] * e[4] - 1.*e[29] * e[21] * e[3] - 1.*e[29] * e[22] * e[4] - 1.*e[29] * e[25] * e[7] - 1.*e[29] * e[24] * e[6] + e[8] * e[27] * e[24] + e[8] * e[18] * e[33] + e[8] * e[28] * e[25] + e[8] * e[19] * e[34] + e[23] * e[27] * e[3] + e[23] * e[0] * e[30] + e[23] * e[28] * e[4] + e[23] * e[1] * e[31] + e[32] * e[18] * e[3] + e[32] * e[0] * e[21] + e[32] * e[19] * e[4] + e[32] * e[1] * e[22] + e[26] * e[27] * e[6] + e[26] * e[0] * e[33] + e[26] * e[28] * e[7] + e[26] * e[1] * e[34] + e[26] * e[29] * e[8] + e[26] * e[2] * e[35] + e[35] * e[18] * e[6] + e[35] * e[0] * e[24] + e[35] * e[19] * e[7] + e[35] * e[1] * e[25] + e[35] * e[20] * e[8] + e[2] * e[27] * e[18] + e[2] * e[28] * e[19] + 3.*e[2] * e[29] * e[20] + e[20] * e[27] * e[0] + e[20] * e[28] * e[1] + e[29] * e[18] * e[0] + e[29] * e[19] * e[1] + e[5] * e[27] * e[21] + e[5] * e[18] * e[30] + e[5] * e[28] * e[22] + e[5] * e[19] * e[31] + e[5] * e[29] * e[23] + e[5] * e[20] * e[32] - 1.*e[2] * e[33] * e[24] - 1.*e[2] * e[30] * e[21] - 1.*e[2] * e[31] * e[22] + e[2] * e[32] * e[23] - 1.*e[2] * e[34] * e[25] - 1.*e[20] * e[34] * e[7];
	A[72] = e[5] * e[18] * e[3] + e[5] * e[0] * e[21] + e[5] * e[19] * e[4] + e[5] * e[1] * e[22] + e[5] * e[2] * e[23] + e[23] * e[1] * e[4] + e[23] * e[0] * e[3] + e[8] * e[18] * e[6] + e[8] * e[0] * e[24] + e[8] * e[19] * e[7] + e[8] * e[1] * e[25] + e[8] * e[2] * e[26] + e[26] * e[1] * e[7] + e[26] * e[0] * e[6] + e[2] * e[18] * e[0] + e[2] * e[19] * e[1] - 1.*e[2] * e[21] * e[3] - 1.*e[2] * e[22] * e[4] - 1.*e[2] * e[25] * e[7] - 1.*e[2] * e[24] * e[6] - .5000000000*e[20] * ep2[4] + .5000000000*e[20] * ep2[0] - .5000000000*e[20] * ep2[6] + .5000000000*e[20] * ep2[5] + .5000000000*e[20] * ep2[1] - .5000000000*e[20] * ep2[7] - .5000000000*e[20] * ep2[3] + 1.500000000*e[20] * ep2[2] + .5000000000*e[20] * ep2[8];
	A[75] = e[14] * e[9] * e[3] + e[14] * e[0] * e[12] + e[14] * e[10] * e[4] + e[14] * e[1] * e[13] + e[14] * e[11] * e[5] + e[17] * e[9] * e[6] + e[17] * e[0] * e[15] + e[17] * e[10] * e[7] + e[17] * e[1] * e[16] + e[17] * e[11] * e[8] + e[8] * e[9] * e[15] + e[8] * e[10] * e[16] + e[5] * e[9] * e[12] + e[5] * e[10] * e[13] + e[11] * e[9] * e[0] + e[11] * e[10] * e[1] - 1.*e[11] * e[13] * e[4] - 1.*e[11] * e[16] * e[7] - 1.*e[11] * e[15] * e[6] - 1.*e[11] * e[12] * e[3] + .5000000000*e[2] * ep2[14] + .5000000000*e[2] * ep2[17] + 1.500000000*e[2] * ep2[11] + .5000000000*e[2] * ep2[9] + .5000000000*e[2] * ep2[10] - .5000000000*e[2] * ep2[16] - .5000000000*e[2] * ep2[12] - .5000000000*e[2] * ep2[15] - .5000000000*e[2] * ep2[13];
	A[74] = e[14] * e[18] * e[12] + e[14] * e[9] * e[21] + e[14] * e[11] * e[23] + e[14] * e[19] * e[13] + e[14] * e[10] * e[22] + e[23] * e[9] * e[12] + e[23] * e[10] * e[13] + e[17] * e[18] * e[15] + e[17] * e[9] * e[24] + e[17] * e[11] * e[26] + e[17] * e[19] * e[16] + e[17] * e[10] * e[25] + e[26] * e[9] * e[15] + e[26] * e[10] * e[16] - 1.*e[11] * e[24] * e[15] - 1.*e[11] * e[25] * e[16] + e[11] * e[18] * e[9] - 1.*e[11] * e[21] * e[12] + e[11] * e[19] * e[10] - 1.*e[11] * e[22] * e[13] + 1.500000000*e[20] * ep2[11] + .5000000000*e[20] * ep2[9] + .5000000000*e[20] * ep2[10] + .5000000000*e[20] * ep2[14] + .5000000000*e[20] * ep2[17] - .5000000000*e[20] * ep2[16] - .5000000000*e[20] * ep2[12] - .5000000000*e[20] * ep2[15] - .5000000000*e[20] * ep2[13];
	A[77] = e[23] * e[10] * e[31] + e[32] * e[18] * e[12] + e[32] * e[9] * e[21] + e[32] * e[19] * e[13] + e[32] * e[10] * e[22] - 1.*e[11] * e[33] * e[24] - 1.*e[11] * e[30] * e[21] + e[11] * e[35] * e[26] - 1.*e[11] * e[31] * e[22] - 1.*e[11] * e[34] * e[25] + e[20] * e[27] * e[9] + e[20] * e[28] * e[10] + e[29] * e[18] * e[9] + e[29] * e[19] * e[10] + e[17] * e[27] * e[24] + e[17] * e[18] * e[33] + e[17] * e[28] * e[25] + e[17] * e[19] * e[34] + e[17] * e[29] * e[26] + e[17] * e[20] * e[35] - 1.*e[20] * e[30] * e[12] - 1.*e[20] * e[31] * e[13] - 1.*e[20] * e[33] * e[15] - 1.*e[20] * e[34] * e[16] - 1.*e[29] * e[24] * e[15] - 1.*e[29] * e[25] * e[16] - 1.*e[29] * e[21] * e[12] - 1.*e[29] * e[22] * e[13] + e[26] * e[27] * e[15] + e[26] * e[9] * e[33] + e[26] * e[28] * e[16] + e[26] * e[10] * e[34] + e[35] * e[18] * e[15] + e[35] * e[9] * e[24] + e[35] * e[19] * e[16] + e[35] * e[10] * e[25] + e[14] * e[27] * e[21] + e[14] * e[18] * e[30] + e[14] * e[28] * e[22] + e[14] * e[19] * e[31] + e[14] * e[29] * e[23] + e[14] * e[20] * e[32] + e[11] * e[27] * e[18] + e[11] * e[28] * e[19] + 3.*e[11] * e[29] * e[20] + e[23] * e[27] * e[12] + e[23] * e[9] * e[30] + e[23] * e[11] * e[32] + e[23] * e[28] * e[13];
	A[76] = e[23] * e[18] * e[12] + e[23] * e[9] * e[21] + e[23] * e[20] * e[14] + e[23] * e[19] * e[13] + e[23] * e[10] * e[22] + e[26] * e[18] * e[15] + e[26] * e[9] * e[24] + e[26] * e[20] * e[17] + e[26] * e[19] * e[16] + e[26] * e[10] * e[25] + e[17] * e[19] * e[25] + e[17] * e[18] * e[24] + e[14] * e[19] * e[22] + e[14] * e[18] * e[21] + e[20] * e[18] * e[9] + e[20] * e[19] * e[10] - 1.*e[20] * e[24] * e[15] - 1.*e[20] * e[25] * e[16] - 1.*e[20] * e[21] * e[12] - 1.*e[20] * e[22] * e[13] + .5000000000*e[11] * ep2[23] + .5000000000*e[11] * ep2[26] + .5000000000*e[11] * ep2[19] + .5000000000*e[11] * ep2[18] + 1.500000000*e[11] * ep2[20] - .5000000000*e[11] * ep2[22] - .5000000000*e[11] * ep2[24] - .5000000000*e[11] * ep2[21] - .5000000000*e[11] * ep2[25];
	A[79] = -1.*e[20] * e[21] * e[3] + e[20] * e[26] * e[8] - 1.*e[20] * e[22] * e[4] - 1.*e[20] * e[25] * e[7] - 1.*e[20] * e[24] * e[6] + e[5] * e[19] * e[22] + e[5] * e[18] * e[21] + e[26] * e[18] * e[6] + e[26] * e[0] * e[24] + e[26] * e[19] * e[7] + e[26] * e[1] * e[25] + e[8] * e[19] * e[25] + e[8] * e[18] * e[24] + e[20] * e[18] * e[0] + e[20] * e[19] * e[1] + e[23] * e[18] * e[3] + e[23] * e[0] * e[21] + e[23] * e[19] * e[4] + e[23] * e[1] * e[22] + e[23] * e[20] * e[5] + 1.500000000*ep2[20] * e[2] + .5000000000*e[2] * ep2[23] + .5000000000*e[2] * ep2[19] + .5000000000*e[2] * ep2[18] + .5000000000*e[2] * ep2[26] - .5000000000*e[2] * ep2[22] - .5000000000*e[2] * ep2[24] - .5000000000*e[2] * ep2[21] - .5000000000*e[2] * ep2[25];
	A[78] = -1.*e[2] * e[15] * e[6] + e[2] * e[9] * e[0] - 1.*e[2] * e[12] * e[3] + e[5] * e[9] * e[3] + e[5] * e[0] * e[12] + e[5] * e[10] * e[4] + e[5] * e[1] * e[13] + e[5] * e[2] * e[14] + e[14] * e[1] * e[4] + e[14] * e[0] * e[3] + e[8] * e[9] * e[6] + e[8] * e[0] * e[15] + e[8] * e[10] * e[7] + e[8] * e[1] * e[16] + e[8] * e[2] * e[17] + e[17] * e[1] * e[7] + e[17] * e[0] * e[6] + e[2] * e[10] * e[1] - 1.*e[2] * e[13] * e[4] - 1.*e[2] * e[16] * e[7] + .5000000000*e[11] * ep2[1] + .5000000000*e[11] * ep2[0] + 1.500000000*e[11] * ep2[2] + .5000000000*e[11] * ep2[5] + .5000000000*e[11] * ep2[8] - .5000000000*e[11] * ep2[4] - .5000000000*e[11] * ep2[6] - .5000000000*e[11] * ep2[7] - .5000000000*e[11] * ep2[3];
	A[64] = e[5] * e[19] * e[13] + e[5] * e[10] * e[22] + e[8] * e[18] * e[15] + e[8] * e[9] * e[24] + e[8] * e[20] * e[17] + e[8] * e[11] * e[26] + e[8] * e[19] * e[16] + e[8] * e[10] * e[25] + e[2] * e[18] * e[9] + e[2] * e[19] * e[10] - 1.*e[11] * e[21] * e[3] - 1.*e[11] * e[22] * e[4] - 1.*e[11] * e[25] * e[7] - 1.*e[11] * e[24] * e[6] + e[14] * e[18] * e[3] + e[14] * e[0] * e[21] + e[14] * e[19] * e[4] + e[14] * e[1] * e[22] + e[14] * e[2] * e[23] - 1.*e[20] * e[13] * e[4] - 1.*e[20] * e[16] * e[7] - 1.*e[20] * e[15] * e[6] - 1.*e[20] * e[12] * e[3] + e[23] * e[9] * e[3] + e[23] * e[0] * e[12] + e[23] * e[10] * e[4] + e[23] * e[1] * e[13] + e[17] * e[18] * e[6] + e[17] * e[0] * e[24] + e[17] * e[19] * e[7] + e[17] * e[1] * e[25] + e[17] * e[2] * e[26] - 1.*e[2] * e[24] * e[15] - 1.*e[2] * e[25] * e[16] - 1.*e[2] * e[21] * e[12] - 1.*e[2] * e[22] * e[13] + e[26] * e[9] * e[6] + e[26] * e[0] * e[15] + e[26] * e[10] * e[7] + e[26] * e[1] * e[16] + e[11] * e[18] * e[0] + e[11] * e[19] * e[1] + 3.*e[11] * e[20] * e[2] + e[20] * e[9] * e[0] + e[20] * e[10] * e[1] + e[5] * e[18] * e[12] + e[5] * e[9] * e[21] + e[5] * e[20] * e[14] + e[5] * e[11] * e[23];
	A[65] = e[32] * e[1] * e[4] + e[32] * e[0] * e[3] + e[8] * e[27] * e[6] + e[8] * e[0] * e[33] + e[8] * e[28] * e[7] + e[8] * e[1] * e[34] + e[35] * e[1] * e[7] + e[35] * e[0] * e[6] + e[2] * e[27] * e[0] + e[2] * e[28] * e[1] - 1.*e[2] * e[34] * e[7] + e[2] * e[32] * e[5] - 1.*e[2] * e[33] * e[6] - 1.*e[2] * e[30] * e[3] + e[2] * e[35] * e[8] - 1.*e[2] * e[31] * e[4] + e[5] * e[27] * e[3] + e[5] * e[0] * e[30] + e[5] * e[28] * e[4] + e[5] * e[1] * e[31] + 1.500000000*e[29] * ep2[2] - .5000000000*e[29] * ep2[4] + .5000000000*e[29] * ep2[0] - .5000000000*e[29] * ep2[6] + .5000000000*e[29] * ep2[5] + .5000000000*e[29] * ep2[1] - .5000000000*e[29] * ep2[7] - .5000000000*e[29] * ep2[3] + .5000000000*e[29] * ep2[8];
	A[66] = e[5] * e[0] * e[3] + e[8] * e[1] * e[7] + e[8] * e[0] * e[6] + e[5] * e[1] * e[4] - .5000000000*e[2] * ep2[4] + .5000000000*ep3[2] + .5000000000*e[2] * ep2[1] - .5000000000*e[2] * ep2[3] + .5000000000*e[2] * ep2[0] + .5000000000*e[2] * ep2[8] + .5000000000*e[2] * ep2[5] - .5000000000*e[2] * ep2[6] - .5000000000*e[2] * ep2[7];
	A[67] = e[35] * e[9] * e[15] + e[35] * e[10] * e[16] - 1.*e[11] * e[30] * e[12] - 1.*e[11] * e[31] * e[13] - 1.*e[11] * e[33] * e[15] - 1.*e[11] * e[34] * e[16] + e[11] * e[27] * e[9] + e[11] * e[28] * e[10] + e[14] * e[27] * e[12] + e[14] * e[9] * e[30] + e[14] * e[11] * e[32] + e[14] * e[28] * e[13] + e[14] * e[10] * e[31] + e[32] * e[9] * e[12] + e[32] * e[10] * e[13] + e[17] * e[27] * e[15] + e[17] * e[9] * e[33] + e[17] * e[11] * e[35] + e[17] * e[28] * e[16] + e[17] * e[10] * e[34] + 1.500000000*e[29] * ep2[11] - .5000000000*e[29] * ep2[16] + .5000000000*e[29] * ep2[9] - .5000000000*e[29] * ep2[12] - .5000000000*e[29] * ep2[15] + .5000000000*e[29] * ep2[17] + .5000000000*e[29] * ep2[10] + .5000000000*e[29] * ep2[14] - .5000000000*e[29] * ep2[13];
	A[68] = e[14] * e[9] * e[12] + e[17] * e[10] * e[16] + e[17] * e[9] * e[15] + .5000000000*ep3[11] + e[14] * e[10] * e[13] + .5000000000*e[11] * ep2[10] - .5000000000*e[11] * ep2[15] + .5000000000*e[11] * ep2[14] - .5000000000*e[11] * ep2[13] - .5000000000*e[11] * ep2[12] + .5000000000*e[11] * ep2[9] - .5000000000*e[11] * ep2[16] + .5000000000*e[11] * ep2[17];
	A[69] = e[20] * e[27] * e[18] + e[20] * e[28] * e[19] + e[23] * e[27] * e[21] + e[23] * e[18] * e[30] + e[23] * e[28] * e[22] + e[23] * e[19] * e[31] + e[23] * e[20] * e[32] + e[32] * e[19] * e[22] + e[32] * e[18] * e[21] + e[26] * e[27] * e[24] + e[26] * e[18] * e[33] + e[26] * e[28] * e[25] + e[26] * e[19] * e[34] + e[26] * e[20] * e[35] + e[35] * e[19] * e[25] + e[35] * e[18] * e[24] - 1.*e[20] * e[33] * e[24] - 1.*e[20] * e[30] * e[21] - 1.*e[20] * e[31] * e[22] - 1.*e[20] * e[34] * e[25] + .5000000000*e[29] * ep2[23] + .5000000000*e[29] * ep2[26] - .5000000000*e[29] * ep2[22] - .5000000000*e[29] * ep2[24] - .5000000000*e[29] * ep2[21] - .5000000000*e[29] * ep2[25] + 1.500000000*e[29] * ep2[20] + .5000000000*e[29] * ep2[19] + .5000000000*e[29] * ep2[18];
	A[70] = .5000000000*e[20] * ep2[26] + .5000000000*e[20] * ep2[18] + .5000000000*ep3[20] + .5000000000*e[20] * ep2[19] + e[26] * e[18] * e[24] + .5000000000*e[20] * ep2[23] - .5000000000*e[20] * ep2[25] + e[23] * e[19] * e[22] - .5000000000*e[20] * ep2[24] - .5000000000*e[20] * ep2[21] - .5000000000*e[20] * ep2[22] + e[23] * e[18] * e[21] + e[26] * e[19] * e[25];
	A[71] = e[8] * e[28] * e[16] + e[8] * e[10] * e[34] + e[2] * e[27] * e[9] + 3.*e[2] * e[29] * e[11] + e[2] * e[28] * e[10] + e[11] * e[27] * e[0] - 1.*e[11] * e[34] * e[7] - 1.*e[11] * e[33] * e[6] - 1.*e[11] * e[30] * e[3] + e[11] * e[28] * e[1] - 1.*e[11] * e[31] * e[4] + e[14] * e[27] * e[3] + e[14] * e[0] * e[30] + e[14] * e[28] * e[4] + e[14] * e[1] * e[31] + e[14] * e[2] * e[32] + e[29] * e[10] * e[1] - 1.*e[29] * e[13] * e[4] - 1.*e[29] * e[16] * e[7] - 1.*e[29] * e[15] * e[6] + e[29] * e[9] * e[0] - 1.*e[29] * e[12] * e[3] + e[32] * e[9] * e[3] + e[32] * e[0] * e[12] + e[32] * e[10] * e[4] + e[32] * e[1] * e[13] + e[17] * e[27] * e[6] + e[17] * e[0] * e[33] + e[17] * e[28] * e[7] + e[17] * e[1] * e[34] + e[17] * e[2] * e[35] - 1.*e[2] * e[30] * e[12] - 1.*e[2] * e[31] * e[13] - 1.*e[2] * e[33] * e[15] - 1.*e[2] * e[34] * e[16] + e[35] * e[9] * e[6] + e[35] * e[0] * e[15] + e[35] * e[10] * e[7] + e[35] * e[1] * e[16] + e[5] * e[27] * e[12] + e[5] * e[9] * e[30] + e[5] * e[29] * e[14] + e[5] * e[11] * e[32] + e[5] * e[28] * e[13] + e[5] * e[10] * e[31] + e[8] * e[27] * e[15] + e[8] * e[9] * e[33] + e[8] * e[29] * e[17] + e[8] * e[11] * e[35];
	A[91] = -1.*e[12] * e[34] * e[7] + e[12] * e[32] * e[5] - 1.*e[12] * e[35] * e[8] - 1.*e[12] * e[29] * e[2] - 1.*e[12] * e[28] * e[1] + e[12] * e[31] * e[4] - 1.*e[30] * e[11] * e[2] - 1.*e[30] * e[10] * e[1] + e[30] * e[13] * e[4] - 1.*e[30] * e[16] * e[7] + e[30] * e[14] * e[5] - 1.*e[30] * e[17] * e[8] + e[15] * e[3] * e[33] + e[15] * e[31] * e[7] + e[15] * e[4] * e[34] + e[15] * e[32] * e[8] + e[15] * e[5] * e[35] + e[3] * e[27] * e[9] - 1.*e[3] * e[28] * e[10] - 1.*e[3] * e[34] * e[16] - 1.*e[3] * e[35] * e[17] - 1.*e[3] * e[29] * e[11] + e[33] * e[13] * e[7] + e[33] * e[4] * e[16] + e[33] * e[14] * e[8] + e[33] * e[5] * e[17] + e[9] * e[28] * e[4] + e[9] * e[1] * e[31] + e[9] * e[29] * e[5] + e[9] * e[2] * e[32] + e[27] * e[10] * e[4] + e[27] * e[1] * e[13] + e[27] * e[11] * e[5] + e[27] * e[2] * e[14] + 3.*e[3] * e[30] * e[12] + e[3] * e[32] * e[14] + e[3] * e[31] * e[13] + e[6] * e[30] * e[15] + e[6] * e[12] * e[33] + e[6] * e[32] * e[17] + e[6] * e[14] * e[35] + e[6] * e[31] * e[16] + e[6] * e[13] * e[34] + e[0] * e[27] * e[12] + e[0] * e[9] * e[30] + e[0] * e[29] * e[14] + e[0] * e[11] * e[32] + e[0] * e[28] * e[13] + e[0] * e[10] * e[31];
	A[90] = .5000000000*e[21] * ep2[24] - .5000000000*e[21] * ep2[25] + .5000000000*e[21] * ep2[23] - .5000000000*e[21] * ep2[26] + .5000000000*ep2[18] * e[21] + .5000000000*e[21] * ep2[22] - .5000000000*e[21] * ep2[20] + e[24] * e[22] * e[25] + e[24] * e[23] * e[26] - .5000000000*e[21] * ep2[19] + e[18] * e[19] * e[22] + e[18] * e[20] * e[23] + .5000000000*ep3[21];
	A[89] = -.5000000000*e[30] * ep2[26] - .5000000000*e[30] * ep2[19] - .5000000000*e[30] * ep2[20] - .5000000000*e[30] * ep2[25] + .5000000000*ep2[18] * e[30] + 1.500000000*e[30] * ep2[21] + .5000000000*e[30] * ep2[22] + .5000000000*e[30] * ep2[23] + .5000000000*e[30] * ep2[24] + e[18] * e[27] * e[21] + e[18] * e[28] * e[22] + e[18] * e[19] * e[31] + e[18] * e[29] * e[23] + e[18] * e[20] * e[32] + e[27] * e[19] * e[22] + e[27] * e[20] * e[23] + e[21] * e[31] * e[22] + e[21] * e[32] * e[23] + e[24] * e[21] * e[33] + e[24] * e[31] * e[25] + e[24] * e[22] * e[34] + e[24] * e[32] * e[26] + e[24] * e[23] * e[35] + e[33] * e[22] * e[25] + e[33] * e[23] * e[26] - 1.*e[21] * e[29] * e[20] - 1.*e[21] * e[35] * e[26] - 1.*e[21] * e[28] * e[19] - 1.*e[21] * e[34] * e[25];
	A[88] = .5000000000*e[12] * ep2[15] - .5000000000*e[12] * ep2[17] + e[15] * e[13] * e[16] - .5000000000*e[12] * ep2[10] + e[15] * e[14] * e[17] - .5000000000*e[12] * ep2[16] - .5000000000*e[12] * ep2[11] + e[9] * e[10] * e[13] + .5000000000*e[12] * ep2[13] + .5000000000*ep2[9] * e[12] + .5000000000*ep3[12] + e[9] * e[11] * e[14] + .5000000000*e[12] * ep2[14];
	A[95] = e[12] * e[13] * e[4] + e[12] * e[14] * e[5] + e[15] * e[12] * e[6] + e[15] * e[13] * e[7] + e[15] * e[4] * e[16] + e[15] * e[14] * e[8] + e[15] * e[5] * e[17] + e[6] * e[14] * e[17] + e[6] * e[13] * e[16] + e[0] * e[11] * e[14] + e[0] * e[9] * e[12] + e[0] * e[10] * e[13] + e[9] * e[10] * e[4] + e[9] * e[1] * e[13] + e[9] * e[11] * e[5] + e[9] * e[2] * e[14] - 1.*e[12] * e[11] * e[2] - 1.*e[12] * e[10] * e[1] - 1.*e[12] * e[16] * e[7] - 1.*e[12] * e[17] * e[8] + 1.500000000*ep2[12] * e[3] + .5000000000*e[3] * ep2[15] - .5000000000*e[3] * ep2[16] + .5000000000*e[3] * ep2[9] - .5000000000*e[3] * ep2[11] - .5000000000*e[3] * ep2[17] - .5000000000*e[3] * ep2[10] + .5000000000*e[3] * ep2[14] + .5000000000*e[3] * ep2[13];
	A[94] = e[18] * e[11] * e[14] + e[18] * e[9] * e[12] + e[18] * e[10] * e[13] + e[12] * e[23] * e[14] + e[12] * e[22] * e[13] + e[15] * e[12] * e[24] + e[15] * e[23] * e[17] + e[15] * e[14] * e[26] + e[15] * e[22] * e[16] + e[15] * e[13] * e[25] + e[24] * e[14] * e[17] + e[24] * e[13] * e[16] - 1.*e[12] * e[25] * e[16] - 1.*e[12] * e[26] * e[17] - 1.*e[12] * e[20] * e[11] - 1.*e[12] * e[19] * e[10] + e[9] * e[20] * e[14] + e[9] * e[11] * e[23] + e[9] * e[19] * e[13] + e[9] * e[10] * e[22] + .5000000000*ep2[9] * e[21] - .5000000000*e[21] * ep2[16] - .5000000000*e[21] * ep2[11] - .5000000000*e[21] * ep2[17] - .5000000000*e[21] * ep2[10] + 1.500000000*e[21] * ep2[12] + .5000000000*e[21] * ep2[14] + .5000000000*e[21] * ep2[13] + .5000000000*e[21] * ep2[15];
	A[93] = -1.*e[21] * e[35] * e[8] - 1.*e[21] * e[29] * e[2] - 1.*e[21] * e[28] * e[1] + e[21] * e[31] * e[4] - 1.*e[30] * e[26] * e[8] - 1.*e[30] * e[20] * e[2] - 1.*e[30] * e[19] * e[1] + e[30] * e[22] * e[4] - 1.*e[30] * e[25] * e[7] + e[30] * e[23] * e[5] + e[6] * e[31] * e[25] + e[6] * e[22] * e[34] + e[6] * e[32] * e[26] + e[6] * e[23] * e[35] + e[24] * e[30] * e[6] + e[24] * e[3] * e[33] + e[24] * e[31] * e[7] + e[24] * e[4] * e[34] + e[24] * e[32] * e[8] + e[24] * e[5] * e[35] + e[33] * e[21] * e[6] + e[33] * e[22] * e[7] + e[33] * e[4] * e[25] + e[33] * e[23] * e[8] + e[33] * e[5] * e[26] + e[0] * e[27] * e[21] + e[0] * e[18] * e[30] + e[0] * e[28] * e[22] + e[0] * e[19] * e[31] + e[0] * e[29] * e[23] + e[0] * e[20] * e[32] + e[18] * e[27] * e[3] + e[18] * e[28] * e[4] + e[18] * e[1] * e[31] + e[18] * e[29] * e[5] + e[18] * e[2] * e[32] + e[27] * e[19] * e[4] + e[27] * e[1] * e[22] + e[27] * e[20] * e[5] + e[27] * e[2] * e[23] + 3.*e[3] * e[30] * e[21] + e[3] * e[31] * e[22] + e[3] * e[32] * e[23] - 1.*e[3] * e[29] * e[20] - 1.*e[3] * e[35] * e[26] - 1.*e[3] * e[28] * e[19] - 1.*e[3] * e[34] * e[25] - 1.*e[21] * e[34] * e[7] + e[21] * e[32] * e[5];
	A[92] = e[18] * e[1] * e[4] + e[18] * e[0] * e[3] + e[18] * e[2] * e[5] + e[3] * e[22] * e[4] + e[3] * e[23] * e[5] + e[6] * e[3] * e[24] + e[6] * e[22] * e[7] + e[6] * e[4] * e[25] + e[6] * e[23] * e[8] + e[6] * e[5] * e[26] + e[24] * e[4] * e[7] + e[24] * e[5] * e[8] + e[0] * e[19] * e[4] + e[0] * e[1] * e[22] + e[0] * e[20] * e[5] + e[0] * e[2] * e[23] - 1.*e[3] * e[26] * e[8] - 1.*e[3] * e[20] * e[2] - 1.*e[3] * e[19] * e[1] - 1.*e[3] * e[25] * e[7] + .5000000000*e[21] * ep2[4] + .5000000000*e[21] * ep2[0] + .5000000000*e[21] * ep2[6] + .5000000000*e[21] * ep2[5] - .5000000000*e[21] * ep2[1] - .5000000000*e[21] * ep2[7] + 1.500000000*e[21] * ep2[3] - .5000000000*e[21] * ep2[2] - .5000000000*e[21] * ep2[8];
	A[82] = .5000000000*ep2[27] * e[21] + 1.500000000*e[21] * ep2[30] + .5000000000*e[21] * ep2[32] + .5000000000*e[21] * ep2[31] + .5000000000*e[21] * ep2[33] - .5000000000*e[21] * ep2[28] - .5000000000*e[21] * ep2[29] - .5000000000*e[21] * ep2[34] - .5000000000*e[21] * ep2[35] + e[18] * e[27] * e[30] + e[18] * e[29] * e[32] + e[18] * e[28] * e[31] + e[27] * e[28] * e[22] + e[27] * e[19] * e[31] + e[27] * e[29] * e[23] + e[27] * e[20] * e[32] + e[30] * e[31] * e[22] + e[30] * e[32] * e[23] + e[24] * e[30] * e[33] + e[24] * e[32] * e[35] + e[24] * e[31] * e[34] + e[33] * e[31] * e[25] + e[33] * e[22] * e[34] + e[33] * e[32] * e[26] + e[33] * e[23] * e[35] - 1.*e[30] * e[29] * e[20] - 1.*e[30] * e[35] * e[26] - 1.*e[30] * e[28] * e[19] - 1.*e[30] * e[34] * e[25];
	A[192] = -.5000000000*e[26] * ep2[4] - .5000000000*e[26] * ep2[0] + .5000000000*e[26] * ep2[6] + .5000000000*e[26] * ep2[5] - .5000000000*e[26] * ep2[1] + .5000000000*e[26] * ep2[7] - .5000000000*e[26] * ep2[3] + .5000000000*e[26] * ep2[2] + 1.500000000*e[26] * ep2[8] + e[20] * e[0] * e[6] + e[20] * e[2] * e[8] + e[5] * e[21] * e[6] + e[5] * e[3] * e[24] + e[5] * e[22] * e[7] + e[5] * e[4] * e[25] + e[5] * e[23] * e[8] + e[23] * e[4] * e[7] + e[23] * e[3] * e[6] + e[8] * e[24] * e[6] + e[8] * e[25] * e[7] + e[2] * e[18] * e[6] + e[2] * e[0] * e[24] + e[2] * e[19] * e[7] + e[2] * e[1] * e[25] - 1.*e[8] * e[21] * e[3] - 1.*e[8] * e[19] * e[1] - 1.*e[8] * e[22] * e[4] - 1.*e[8] * e[18] * e[0] + e[20] * e[1] * e[7];
	A[83] = e[9] * e[27] * e[30] + e[9] * e[29] * e[32] + e[9] * e[28] * e[31] + e[33] * e[30] * e[15] + e[33] * e[32] * e[17] + e[33] * e[14] * e[35] + e[33] * e[31] * e[16] + e[33] * e[13] * e[34] + e[27] * e[29] * e[14] + e[27] * e[11] * e[32] + e[27] * e[28] * e[13] + e[27] * e[10] * e[31] - 1.*e[30] * e[28] * e[10] + e[30] * e[31] * e[13] + e[30] * e[32] * e[14] - 1.*e[30] * e[34] * e[16] - 1.*e[30] * e[35] * e[17] - 1.*e[30] * e[29] * e[11] + e[15] * e[32] * e[35] + e[15] * e[31] * e[34] - .5000000000*e[12] * ep2[34] - .5000000000*e[12] * ep2[35] + .5000000000*e[12] * ep2[27] + .5000000000*e[12] * ep2[32] - .5000000000*e[12] * ep2[28] - .5000000000*e[12] * ep2[29] + .5000000000*e[12] * ep2[31] + .5000000000*e[12] * ep2[33] + 1.500000000*e[12] * ep2[30];
	A[193] = e[23] * e[30] * e[6] + e[23] * e[3] * e[33] + e[23] * e[31] * e[7] + e[23] * e[4] * e[34] + e[32] * e[21] * e[6] + e[32] * e[3] * e[24] + e[32] * e[22] * e[7] + e[32] * e[4] * e[25] + e[26] * e[33] * e[6] + e[26] * e[34] * e[7] + 3.*e[26] * e[35] * e[8] + e[35] * e[24] * e[6] + e[35] * e[25] * e[7] + e[2] * e[27] * e[24] + e[2] * e[18] * e[33] + e[2] * e[28] * e[25] + e[2] * e[19] * e[34] + e[2] * e[29] * e[26] + e[2] * e[20] * e[35] + e[20] * e[27] * e[6] + e[20] * e[0] * e[33] + e[20] * e[28] * e[7] + e[20] * e[1] * e[34] + e[20] * e[29] * e[8] + e[29] * e[18] * e[6] + e[29] * e[0] * e[24] + e[29] * e[19] * e[7] + e[29] * e[1] * e[25] + e[5] * e[30] * e[24] + e[5] * e[21] * e[33] + e[5] * e[31] * e[25] + e[5] * e[22] * e[34] + e[5] * e[32] * e[26] + e[5] * e[23] * e[35] - 1.*e[8] * e[27] * e[18] + e[8] * e[33] * e[24] - 1.*e[8] * e[30] * e[21] - 1.*e[8] * e[31] * e[22] + e[8] * e[32] * e[23] - 1.*e[8] * e[28] * e[19] + e[8] * e[34] * e[25] - 1.*e[26] * e[27] * e[0] - 1.*e[26] * e[30] * e[3] - 1.*e[26] * e[28] * e[1] - 1.*e[26] * e[31] * e[4] - 1.*e[35] * e[21] * e[3] - 1.*e[35] * e[19] * e[1] - 1.*e[35] * e[22] * e[4] - 1.*e[35] * e[18] * e[0];
	A[80] = e[27] * e[29] * e[32] + e[27] * e[28] * e[31] + e[33] * e[32] * e[35] + e[33] * e[31] * e[34] + .5000000000*ep3[30] - .5000000000*e[30] * ep2[28] - .5000000000*e[30] * ep2[29] - .5000000000*e[30] * ep2[34] + .5000000000*e[30] * ep2[33] + .5000000000*ep2[27] * e[30] + .5000000000*e[30] * ep2[32] + .5000000000*e[30] * ep2[31] - .5000000000*e[30] * ep2[35];
	A[194] = .5000000000*ep2[14] * e[26] + 1.500000000*e[26] * ep2[17] + .5000000000*e[26] * ep2[15] + .5000000000*e[26] * ep2[16] + .5000000000*ep2[11] * e[26] - .5000000000*e[26] * ep2[9] - .5000000000*e[26] * ep2[12] - .5000000000*e[26] * ep2[10] - .5000000000*e[26] * ep2[13] + e[20] * e[11] * e[17] + e[20] * e[9] * e[15] + e[20] * e[10] * e[16] + e[14] * e[21] * e[15] + e[14] * e[12] * e[24] + e[14] * e[23] * e[17] + e[14] * e[22] * e[16] + e[14] * e[13] * e[25] + e[23] * e[12] * e[15] + e[23] * e[13] * e[16] + e[17] * e[24] * e[15] + e[17] * e[25] * e[16] - 1.*e[17] * e[18] * e[9] - 1.*e[17] * e[21] * e[12] - 1.*e[17] * e[19] * e[10] - 1.*e[17] * e[22] * e[13] + e[11] * e[18] * e[15] + e[11] * e[9] * e[24] + e[11] * e[19] * e[16] + e[11] * e[10] * e[25];
	A[81] = e[0] * e[27] * e[30] + e[0] * e[29] * e[32] + e[0] * e[28] * e[31] + e[30] * e[31] * e[4] + e[30] * e[32] * e[5] + e[6] * e[30] * e[33] + e[6] * e[32] * e[35] + e[6] * e[31] * e[34] + e[27] * e[28] * e[4] + e[27] * e[1] * e[31] + e[27] * e[29] * e[5] + e[27] * e[2] * e[32] + e[33] * e[31] * e[7] + e[33] * e[4] * e[34] + e[33] * e[32] * e[8] + e[33] * e[5] * e[35] - 1.*e[30] * e[34] * e[7] - 1.*e[30] * e[35] * e[8] - 1.*e[30] * e[29] * e[2] - 1.*e[30] * e[28] * e[1] + 1.500000000*e[3] * ep2[30] + .5000000000*e[3] * ep2[32] + .5000000000*e[3] * ep2[31] + .5000000000*e[3] * ep2[27] - .5000000000*e[3] * ep2[28] - .5000000000*e[3] * ep2[29] + .5000000000*e[3] * ep2[33] - .5000000000*e[3] * ep2[34] - .5000000000*e[3] * ep2[35];
	A[195] = .5000000000*ep2[14] * e[8] + 1.500000000*ep2[17] * e[8] + .5000000000*e[8] * ep2[15] + .5000000000*e[8] * ep2[16] - .5000000000*e[8] * ep2[9] + .5000000000*e[8] * ep2[11] - .5000000000*e[8] * ep2[12] - .5000000000*e[8] * ep2[10] - .5000000000*e[8] * ep2[13] + e[14] * e[12] * e[6] + e[14] * e[3] * e[15] + e[14] * e[13] * e[7] + e[14] * e[4] * e[16] + e[14] * e[5] * e[17] + e[17] * e[15] * e[6] + e[17] * e[16] * e[7] + e[2] * e[11] * e[17] + e[2] * e[9] * e[15] + e[2] * e[10] * e[16] + e[5] * e[12] * e[15] + e[5] * e[13] * e[16] + e[11] * e[9] * e[6] + e[11] * e[0] * e[15] + e[11] * e[10] * e[7] + e[11] * e[1] * e[16] - 1.*e[17] * e[10] * e[1] - 1.*e[17] * e[13] * e[4] - 1.*e[17] * e[9] * e[0] - 1.*e[17] * e[12] * e[3];
	A[86] = -.5000000000*e[3] * ep2[1] - .5000000000*e[3] * ep2[7] + .5000000000*ep3[3] - .5000000000*e[3] * ep2[8] + e[0] * e[2] * e[5] + .5000000000*e[3] * ep2[6] + .5000000000*e[3] * ep2[4] - .5000000000*e[3] * ep2[2] + e[0] * e[1] * e[4] + e[6] * e[4] * e[7] + .5000000000*ep2[0] * e[3] + .5000000000*e[3] * ep2[5] + e[6] * e[5] * e[8];
	A[196] = .5000000000*ep2[23] * e[17] + 1.500000000*ep2[26] * e[17] + .5000000000*e[17] * ep2[25] + .5000000000*e[17] * ep2[24] - .5000000000*e[17] * ep2[18] - .5000000000*e[17] * ep2[19] + .5000000000*e[17] * ep2[20] - .5000000000*e[17] * ep2[22] - .5000000000*e[17] * ep2[21] + e[23] * e[21] * e[15] + e[23] * e[12] * e[24] + e[23] * e[14] * e[26] + e[23] * e[22] * e[16] + e[23] * e[13] * e[25] + e[26] * e[24] * e[15] + e[26] * e[25] * e[16] + e[11] * e[19] * e[25] + e[11] * e[18] * e[24] + e[11] * e[20] * e[26] + e[14] * e[22] * e[25] + e[14] * e[21] * e[24] + e[20] * e[18] * e[15] + e[20] * e[9] * e[24] + e[20] * e[19] * e[16] + e[20] * e[10] * e[25] - 1.*e[26] * e[18] * e[9] - 1.*e[26] * e[21] * e[12] - 1.*e[26] * e[19] * e[10] - 1.*e[26] * e[22] * e[13];
	A[87] = -1.*e[12] * e[34] * e[16] - 1.*e[12] * e[35] * e[17] - 1.*e[12] * e[29] * e[11] + e[9] * e[27] * e[12] + e[9] * e[29] * e[14] + e[9] * e[11] * e[32] + e[9] * e[28] * e[13] + e[9] * e[10] * e[31] + e[27] * e[11] * e[14] + e[27] * e[10] * e[13] + e[12] * e[32] * e[14] + e[12] * e[31] * e[13] + e[15] * e[12] * e[33] + e[15] * e[32] * e[17] + e[15] * e[14] * e[35] + e[15] * e[31] * e[16] + e[15] * e[13] * e[34] + e[33] * e[14] * e[17] + e[33] * e[13] * e[16] - 1.*e[12] * e[28] * e[10] + .5000000000*ep2[9] * e[30] - .5000000000*e[30] * ep2[16] - .5000000000*e[30] * ep2[11] + 1.500000000*e[30] * ep2[12] + .5000000000*e[30] * ep2[15] - .5000000000*e[30] * ep2[17] - .5000000000*e[30] * ep2[10] + .5000000000*e[30] * ep2[14] + .5000000000*e[30] * ep2[13];
	A[197] = e[32] * e[22] * e[16] + e[32] * e[13] * e[25] - 1.*e[17] * e[27] * e[18] + e[17] * e[33] * e[24] - 1.*e[17] * e[30] * e[21] + e[17] * e[29] * e[20] + 3.*e[17] * e[35] * e[26] - 1.*e[17] * e[31] * e[22] - 1.*e[17] * e[28] * e[19] + e[17] * e[34] * e[25] + e[20] * e[27] * e[15] + e[20] * e[9] * e[33] + e[20] * e[28] * e[16] + e[20] * e[10] * e[34] + e[29] * e[18] * e[15] + e[29] * e[9] * e[24] + e[29] * e[19] * e[16] + e[29] * e[10] * e[25] - 1.*e[26] * e[27] * e[9] - 1.*e[26] * e[30] * e[12] - 1.*e[26] * e[28] * e[10] - 1.*e[26] * e[31] * e[13] + e[26] * e[33] * e[15] + e[26] * e[34] * e[16] + e[35] * e[24] * e[15] + e[35] * e[25] * e[16] - 1.*e[35] * e[18] * e[9] - 1.*e[35] * e[21] * e[12] - 1.*e[35] * e[19] * e[10] - 1.*e[35] * e[22] * e[13] + e[14] * e[30] * e[24] + e[14] * e[21] * e[33] + e[14] * e[31] * e[25] + e[14] * e[22] * e[34] + e[14] * e[32] * e[26] + e[14] * e[23] * e[35] + e[11] * e[27] * e[24] + e[11] * e[18] * e[33] + e[11] * e[28] * e[25] + e[11] * e[19] * e[34] + e[11] * e[29] * e[26] + e[11] * e[20] * e[35] + e[23] * e[30] * e[15] + e[23] * e[12] * e[33] + e[23] * e[32] * e[17] + e[23] * e[31] * e[16] + e[23] * e[13] * e[34] + e[32] * e[21] * e[15] + e[32] * e[12] * e[24];
	A[84] = e[6] * e[23] * e[17] + e[6] * e[14] * e[26] + e[6] * e[22] * e[16] + e[6] * e[13] * e[25] + e[0] * e[20] * e[14] + e[0] * e[11] * e[23] + e[0] * e[19] * e[13] + e[0] * e[10] * e[22] - 1.*e[12] * e[26] * e[8] - 1.*e[12] * e[20] * e[2] - 1.*e[12] * e[19] * e[1] + e[12] * e[22] * e[4] - 1.*e[12] * e[25] * e[7] + e[12] * e[23] * e[5] - 1.*e[21] * e[11] * e[2] - 1.*e[21] * e[10] * e[1] + e[21] * e[13] * e[4] - 1.*e[21] * e[16] * e[7] + e[21] * e[14] * e[5] - 1.*e[21] * e[17] * e[8] + e[15] * e[3] * e[24] + e[15] * e[22] * e[7] + e[15] * e[4] * e[25] + e[15] * e[23] * e[8] + e[15] * e[5] * e[26] - 1.*e[3] * e[25] * e[16] - 1.*e[3] * e[26] * e[17] - 1.*e[3] * e[20] * e[11] - 1.*e[3] * e[19] * e[10] + e[24] * e[13] * e[7] + e[24] * e[4] * e[16] + e[24] * e[14] * e[8] + e[24] * e[5] * e[17] + e[9] * e[18] * e[3] + e[9] * e[0] * e[21] + e[9] * e[19] * e[4] + e[9] * e[1] * e[22] + e[9] * e[20] * e[5] + e[9] * e[2] * e[23] + e[18] * e[0] * e[12] + e[18] * e[10] * e[4] + e[18] * e[1] * e[13] + e[18] * e[11] * e[5] + e[18] * e[2] * e[14] + 3.*e[3] * e[21] * e[12] + e[3] * e[23] * e[14] + e[3] * e[22] * e[13] + e[6] * e[21] * e[15] + e[6] * e[12] * e[24];
	A[198] = .5000000000*ep2[5] * e[17] + 1.500000000*e[17] * ep2[8] + .5000000000*e[17] * ep2[7] + .5000000000*e[17] * ep2[6] + .5000000000*ep2[2] * e[17] - .5000000000*e[17] * ep2[4] - .5000000000*e[17] * ep2[0] - .5000000000*e[17] * ep2[1] - .5000000000*e[17] * ep2[3] + e[11] * e[1] * e[7] + e[11] * e[0] * e[6] + e[11] * e[2] * e[8] + e[5] * e[12] * e[6] + e[5] * e[3] * e[15] + e[5] * e[13] * e[7] + e[5] * e[4] * e[16] + e[5] * e[14] * e[8] + e[14] * e[4] * e[7] + e[14] * e[3] * e[6] + e[8] * e[15] * e[6] + e[8] * e[16] * e[7] - 1.*e[8] * e[10] * e[1] - 1.*e[8] * e[13] * e[4] - 1.*e[8] * e[9] * e[0] - 1.*e[8] * e[12] * e[3] + e[2] * e[9] * e[6] + e[2] * e[0] * e[15] + e[2] * e[10] * e[7] + e[2] * e[1] * e[16];
	A[85] = e[6] * e[4] * e[34] + e[6] * e[32] * e[8] + e[6] * e[5] * e[35] + e[33] * e[4] * e[7] + e[33] * e[5] * e[8] + e[0] * e[27] * e[3] + e[0] * e[28] * e[4] + e[0] * e[1] * e[31] + e[0] * e[29] * e[5] + e[0] * e[2] * e[32] - 1.*e[3] * e[34] * e[7] + e[3] * e[32] * e[5] + e[3] * e[33] * e[6] - 1.*e[3] * e[35] * e[8] - 1.*e[3] * e[29] * e[2] - 1.*e[3] * e[28] * e[1] + e[3] * e[31] * e[4] + e[27] * e[1] * e[4] + e[27] * e[2] * e[5] + e[6] * e[31] * e[7] + .5000000000*e[30] * ep2[4] + .5000000000*e[30] * ep2[6] + .5000000000*e[30] * ep2[5] - .5000000000*e[30] * ep2[1] - .5000000000*e[30] * ep2[7] - .5000000000*e[30] * ep2[2] - .5000000000*e[30] * ep2[8] + .5000000000*ep2[0] * e[30] + 1.500000000*e[30] * ep2[3];
	A[199] = .5000000000*ep2[23] * e[8] + 1.500000000*ep2[26] * e[8] - .5000000000*e[8] * ep2[18] - .5000000000*e[8] * ep2[19] - .5000000000*e[8] * ep2[22] + .5000000000*e[8] * ep2[24] - .5000000000*e[8] * ep2[21] + .5000000000*e[8] * ep2[25] + .5000000000*ep2[20] * e[8] + e[20] * e[18] * e[6] + e[20] * e[0] * e[24] + e[20] * e[19] * e[7] + e[20] * e[1] * e[25] + e[20] * e[2] * e[26] + e[23] * e[21] * e[6] + e[23] * e[3] * e[24] + e[23] * e[22] * e[7] + e[23] * e[4] * e[25] + e[23] * e[5] * e[26] - 1.*e[26] * e[21] * e[3] - 1.*e[26] * e[19] * e[1] - 1.*e[26] * e[22] * e[4] - 1.*e[26] * e[18] * e[0] + e[26] * e[25] * e[7] + e[26] * e[24] * e[6] + e[2] * e[19] * e[25] + e[2] * e[18] * e[24] + e[5] * e[22] * e[25] + e[5] * e[21] * e[24];
	A[109] = e[19] * e[27] * e[21] + e[19] * e[18] * e[30] + e[19] * e[28] * e[22] + e[19] * e[29] * e[23] + e[19] * e[20] * e[32] + e[28] * e[18] * e[21] + e[28] * e[20] * e[23] + e[22] * e[30] * e[21] + e[22] * e[32] * e[23] + e[25] * e[30] * e[24] + e[25] * e[21] * e[33] + e[25] * e[22] * e[34] + e[25] * e[32] * e[26] + e[25] * e[23] * e[35] + e[34] * e[21] * e[24] + e[34] * e[23] * e[26] - 1.*e[22] * e[27] * e[18] - 1.*e[22] * e[33] * e[24] - 1.*e[22] * e[29] * e[20] - 1.*e[22] * e[35] * e[26] + .5000000000*ep2[19] * e[31] + 1.500000000*e[31] * ep2[22] + .5000000000*e[31] * ep2[21] + .5000000000*e[31] * ep2[23] + .5000000000*e[31] * ep2[25] - .5000000000*e[31] * ep2[26] - .5000000000*e[31] * ep2[18] - .5000000000*e[31] * ep2[20] - .5000000000*e[31] * ep2[24];
	A[108] = -.5000000000*e[13] * ep2[15] + .5000000000*e[13] * ep2[16] + .5000000000*e[13] * ep2[12] + e[16] * e[12] * e[15] + .5000000000*ep3[13] + e[10] * e[11] * e[14] + .5000000000*e[13] * ep2[14] - .5000000000*e[13] * ep2[17] - .5000000000*e[13] * ep2[11] - .5000000000*e[13] * ep2[9] + .5000000000*ep2[10] * e[13] + e[10] * e[9] * e[12] + e[16] * e[14] * e[17];
	A[111] = -1.*e[13] * e[29] * e[2] - 1.*e[31] * e[11] * e[2] - 1.*e[31] * e[15] * e[6] - 1.*e[31] * e[9] * e[0] + e[31] * e[14] * e[5] + e[31] * e[12] * e[3] - 1.*e[31] * e[17] * e[8] + e[16] * e[30] * e[6] + e[16] * e[3] * e[33] + e[16] * e[4] * e[34] + e[16] * e[32] * e[8] + e[16] * e[5] * e[35] - 1.*e[4] * e[27] * e[9] + e[4] * e[28] * e[10] - 1.*e[4] * e[33] * e[15] - 1.*e[4] * e[35] * e[17] - 1.*e[4] * e[29] * e[11] + e[34] * e[12] * e[6] + e[34] * e[3] * e[15] + e[34] * e[14] * e[8] + e[34] * e[5] * e[17] + e[10] * e[27] * e[3] + e[10] * e[0] * e[30] + e[10] * e[29] * e[5] + e[10] * e[2] * e[32] + e[28] * e[9] * e[3] + e[28] * e[0] * e[12] + e[28] * e[11] * e[5] + e[28] * e[2] * e[14] + e[4] * e[30] * e[12] + e[4] * e[32] * e[14] + 3.*e[4] * e[31] * e[13] + e[7] * e[30] * e[15] + e[7] * e[12] * e[33] + e[7] * e[32] * e[17] + e[7] * e[14] * e[35] + e[7] * e[31] * e[16] + e[7] * e[13] * e[34] + e[1] * e[27] * e[12] + e[1] * e[9] * e[30] + e[1] * e[29] * e[14] + e[1] * e[11] * e[32] + e[1] * e[28] * e[13] + e[1] * e[10] * e[31] - 1.*e[13] * e[27] * e[0] + e[13] * e[32] * e[5] - 1.*e[13] * e[33] * e[6] + e[13] * e[30] * e[3] - 1.*e[13] * e[35] * e[8];
	A[110] = e[25] * e[23] * e[26] + e[19] * e[20] * e[23] + e[19] * e[18] * e[21] + e[25] * e[21] * e[24] + .5000000000*ep3[22] + .5000000000*e[22] * ep2[23] + .5000000000*ep2[19] * e[22] - .5000000000*e[22] * ep2[18] - .5000000000*e[22] * ep2[24] + .5000000000*e[22] * ep2[21] + .5000000000*e[22] * ep2[25] - .5000000000*e[22] * ep2[20] - .5000000000*e[22] * ep2[26];
	A[105] = e[34] * e[5] * e[8] + e[1] * e[27] * e[3] + e[1] * e[0] * e[30] + e[1] * e[28] * e[4] + e[1] * e[29] * e[5] + e[1] * e[2] * e[32] - 1.*e[4] * e[27] * e[0] + e[4] * e[34] * e[7] + e[4] * e[32] * e[5] - 1.*e[4] * e[33] * e[6] + e[4] * e[30] * e[3] - 1.*e[4] * e[35] * e[8] - 1.*e[4] * e[29] * e[2] + e[28] * e[0] * e[3] + e[28] * e[2] * e[5] + e[7] * e[30] * e[6] + e[7] * e[3] * e[33] + e[7] * e[32] * e[8] + e[7] * e[5] * e[35] + e[34] * e[3] * e[6] + .5000000000*ep2[1] * e[31] + 1.500000000*e[31] * ep2[4] - .5000000000*e[31] * ep2[0] - .5000000000*e[31] * ep2[6] + .5000000000*e[31] * ep2[5] + .5000000000*e[31] * ep2[7] + .5000000000*e[31] * ep2[3] - .5000000000*e[31] * ep2[2] - .5000000000*e[31] * ep2[8];
	A[104] = e[1] * e[20] * e[14] + e[1] * e[11] * e[23] + e[13] * e[21] * e[3] - 1.*e[13] * e[26] * e[8] - 1.*e[13] * e[20] * e[2] - 1.*e[13] * e[18] * e[0] + e[13] * e[23] * e[5] - 1.*e[13] * e[24] * e[6] - 1.*e[22] * e[11] * e[2] - 1.*e[22] * e[15] * e[6] - 1.*e[22] * e[9] * e[0] + e[22] * e[14] * e[5] + e[22] * e[12] * e[3] - 1.*e[22] * e[17] * e[8] + e[16] * e[21] * e[6] + e[16] * e[3] * e[24] + e[16] * e[4] * e[25] + e[16] * e[23] * e[8] + e[16] * e[5] * e[26] - 1.*e[4] * e[24] * e[15] - 1.*e[4] * e[26] * e[17] - 1.*e[4] * e[20] * e[11] - 1.*e[4] * e[18] * e[9] + e[25] * e[12] * e[6] + e[25] * e[3] * e[15] + e[25] * e[14] * e[8] + e[25] * e[5] * e[17] + e[10] * e[18] * e[3] + e[10] * e[0] * e[21] + e[10] * e[19] * e[4] + e[10] * e[1] * e[22] + e[10] * e[20] * e[5] + e[10] * e[2] * e[23] + e[19] * e[9] * e[3] + e[19] * e[0] * e[12] + e[19] * e[1] * e[13] + e[19] * e[11] * e[5] + e[19] * e[2] * e[14] + e[4] * e[21] * e[12] + e[4] * e[23] * e[14] + 3.*e[4] * e[22] * e[13] + e[7] * e[21] * e[15] + e[7] * e[12] * e[24] + e[7] * e[23] * e[17] + e[7] * e[14] * e[26] + e[7] * e[22] * e[16] + e[7] * e[13] * e[25] + e[1] * e[18] * e[12] + e[1] * e[9] * e[21];
	A[107] = e[10] * e[27] * e[12] + e[10] * e[9] * e[30] + e[10] * e[29] * e[14] + e[10] * e[11] * e[32] + e[10] * e[28] * e[13] + e[28] * e[11] * e[14] + e[28] * e[9] * e[12] + e[13] * e[30] * e[12] + e[13] * e[32] * e[14] + e[16] * e[30] * e[15] + e[16] * e[12] * e[33] + e[16] * e[32] * e[17] + e[16] * e[14] * e[35] + e[16] * e[13] * e[34] + e[34] * e[14] * e[17] + e[34] * e[12] * e[15] - 1.*e[13] * e[27] * e[9] - 1.*e[13] * e[33] * e[15] - 1.*e[13] * e[35] * e[17] - 1.*e[13] * e[29] * e[11] + .5000000000*ep2[10] * e[31] + .5000000000*e[31] * ep2[16] - .5000000000*e[31] * ep2[9] - .5000000000*e[31] * ep2[11] + .5000000000*e[31] * ep2[12] - .5000000000*e[31] * ep2[15] - .5000000000*e[31] * ep2[17] + .5000000000*e[31] * ep2[14] + 1.500000000*e[31] * ep2[13];
	A[106] = -.5000000000*e[4] * ep2[6] - .5000000000*e[4] * ep2[0] + e[1] * e[2] * e[5] + .5000000000*e[4] * ep2[7] + e[1] * e[0] * e[3] + e[7] * e[5] * e[8] - .5000000000*e[4] * ep2[8] + .5000000000*e[4] * ep2[3] + .5000000000*e[4] * ep2[5] + e[7] * e[3] * e[6] - .5000000000*e[4] * ep2[2] + .5000000000*ep3[4] + .5000000000*ep2[1] * e[4];
	A[100] = e[34] * e[32] * e[35] - .5000000000*e[31] * ep2[35] + .5000000000*e[31] * ep2[34] + .5000000000*ep2[28] * e[31] + .5000000000*ep3[31] + .5000000000*e[31] * ep2[32] + e[34] * e[30] * e[33] - .5000000000*e[31] * ep2[27] + .5000000000*e[31] * ep2[30] - .5000000000*e[31] * ep2[33] - .5000000000*e[31] * ep2[29] + e[28] * e[29] * e[32] + e[28] * e[27] * e[30];
	A[101] = e[1] * e[27] * e[30] + e[1] * e[29] * e[32] + e[1] * e[28] * e[31] + e[31] * e[30] * e[3] + e[31] * e[32] * e[5] + e[7] * e[30] * e[33] + e[7] * e[32] * e[35] + e[7] * e[31] * e[34] + e[28] * e[27] * e[3] + e[28] * e[0] * e[30] + e[28] * e[29] * e[5] + e[28] * e[2] * e[32] + e[34] * e[30] * e[6] + e[34] * e[3] * e[33] + e[34] * e[32] * e[8] + e[34] * e[5] * e[35] - 1.*e[31] * e[27] * e[0] - 1.*e[31] * e[33] * e[6] - 1.*e[31] * e[35] * e[8] - 1.*e[31] * e[29] * e[2] + .5000000000*e[4] * ep2[30] + .5000000000*e[4] * ep2[32] + 1.500000000*e[4] * ep2[31] - .5000000000*e[4] * ep2[27] + .5000000000*e[4] * ep2[28] - .5000000000*e[4] * ep2[29] - .5000000000*e[4] * ep2[33] + .5000000000*e[4] * ep2[34] - .5000000000*e[4] * ep2[35];
	A[102] = .5000000000*e[22] * ep2[30] + .5000000000*e[22] * ep2[32] + 1.500000000*e[22] * ep2[31] + .5000000000*e[22] * ep2[34] - .5000000000*e[22] * ep2[27] - .5000000000*e[22] * ep2[29] - .5000000000*e[22] * ep2[33] - .5000000000*e[22] * ep2[35] + e[28] * e[18] * e[30] + e[28] * e[29] * e[23] + e[28] * e[20] * e[32] + e[31] * e[30] * e[21] + e[31] * e[32] * e[23] + e[25] * e[30] * e[33] + e[25] * e[32] * e[35] + e[25] * e[31] * e[34] + e[34] * e[30] * e[24] + e[34] * e[21] * e[33] + e[34] * e[32] * e[26] + e[34] * e[23] * e[35] - 1.*e[31] * e[27] * e[18] - 1.*e[31] * e[33] * e[24] - 1.*e[31] * e[29] * e[20] - 1.*e[31] * e[35] * e[26] + e[19] * e[27] * e[30] + e[19] * e[29] * e[32] + e[19] * e[28] * e[31] + e[28] * e[27] * e[21] + .5000000000*ep2[28] * e[22];
	A[103] = e[16] * e[30] * e[33] + e[16] * e[32] * e[35] + e[10] * e[27] * e[30] + e[10] * e[29] * e[32] + e[10] * e[28] * e[31] + e[34] * e[30] * e[15] + e[34] * e[12] * e[33] + e[34] * e[32] * e[17] + e[34] * e[14] * e[35] + e[34] * e[31] * e[16] + e[28] * e[27] * e[12] + e[28] * e[9] * e[30] + e[28] * e[29] * e[14] + e[28] * e[11] * e[32] - 1.*e[31] * e[27] * e[9] + e[31] * e[30] * e[12] + e[31] * e[32] * e[14] - 1.*e[31] * e[33] * e[15] - 1.*e[31] * e[35] * e[17] - 1.*e[31] * e[29] * e[11] - .5000000000*e[13] * ep2[27] + .5000000000*e[13] * ep2[32] + .5000000000*e[13] * ep2[28] - .5000000000*e[13] * ep2[29] + 1.500000000*e[13] * ep2[31] - .5000000000*e[13] * ep2[33] + .5000000000*e[13] * ep2[30] + .5000000000*e[13] * ep2[34] - .5000000000*e[13] * ep2[35];
	A[96] = e[21] * e[23] * e[14] + e[21] * e[22] * e[13] + e[24] * e[21] * e[15] + e[24] * e[23] * e[17] + e[24] * e[14] * e[26] + e[24] * e[22] * e[16] + e[24] * e[13] * e[25] + e[15] * e[22] * e[25] + e[15] * e[23] * e[26] + e[9] * e[19] * e[22] + e[9] * e[18] * e[21] + e[9] * e[20] * e[23] + e[18] * e[20] * e[14] + e[18] * e[11] * e[23] + e[18] * e[19] * e[13] + e[18] * e[10] * e[22] - 1.*e[21] * e[25] * e[16] - 1.*e[21] * e[26] * e[17] - 1.*e[21] * e[20] * e[11] - 1.*e[21] * e[19] * e[10] + 1.500000000*ep2[21] * e[12] + .5000000000*e[12] * ep2[24] - .5000000000*e[12] * ep2[26] + .5000000000*e[12] * ep2[18] + .5000000000*e[12] * ep2[23] - .5000000000*e[12] * ep2[19] - .5000000000*e[12] * ep2[20] + .5000000000*e[12] * ep2[22] - .5000000000*e[12] * ep2[25];
	A[97] = -1.*e[12] * e[29] * e[20] - 1.*e[12] * e[35] * e[26] - 1.*e[12] * e[28] * e[19] - 1.*e[12] * e[34] * e[25] + e[18] * e[29] * e[14] + e[18] * e[11] * e[32] + e[18] * e[28] * e[13] + e[18] * e[10] * e[31] + e[27] * e[20] * e[14] + e[27] * e[11] * e[23] + e[27] * e[19] * e[13] + e[27] * e[10] * e[22] + e[15] * e[30] * e[24] + e[15] * e[21] * e[33] + e[15] * e[31] * e[25] + e[15] * e[22] * e[34] + e[15] * e[32] * e[26] + e[15] * e[23] * e[35] - 1.*e[21] * e[28] * e[10] - 1.*e[21] * e[34] * e[16] - 1.*e[21] * e[35] * e[17] - 1.*e[21] * e[29] * e[11] - 1.*e[30] * e[25] * e[16] - 1.*e[30] * e[26] * e[17] - 1.*e[30] * e[20] * e[11] - 1.*e[30] * e[19] * e[10] + e[24] * e[32] * e[17] + e[24] * e[14] * e[35] + e[24] * e[31] * e[16] + e[24] * e[13] * e[34] + e[33] * e[23] * e[17] + e[33] * e[14] * e[26] + e[33] * e[22] * e[16] + e[33] * e[13] * e[25] + 3.*e[12] * e[30] * e[21] + e[12] * e[31] * e[22] + e[12] * e[32] * e[23] + e[9] * e[27] * e[21] + e[9] * e[18] * e[30] + e[9] * e[28] * e[22] + e[9] * e[19] * e[31] + e[9] * e[29] * e[23] + e[9] * e[20] * e[32] + e[21] * e[32] * e[14] + e[21] * e[31] * e[13] + e[30] * e[23] * e[14] + e[30] * e[22] * e[13] + e[12] * e[27] * e[18] + e[12] * e[33] * e[24];
	A[98] = e[0] * e[11] * e[5] + e[0] * e[2] * e[14] + e[9] * e[1] * e[4] + e[9] * e[0] * e[3] + e[9] * e[2] * e[5] + e[3] * e[13] * e[4] + e[3] * e[14] * e[5] + e[6] * e[3] * e[15] + e[6] * e[13] * e[7] + e[6] * e[4] * e[16] + e[6] * e[14] * e[8] + e[6] * e[5] * e[17] + e[15] * e[4] * e[7] + e[15] * e[5] * e[8] - 1.*e[3] * e[11] * e[2] - 1.*e[3] * e[10] * e[1] - 1.*e[3] * e[16] * e[7] - 1.*e[3] * e[17] * e[8] + e[0] * e[10] * e[4] + e[0] * e[1] * e[13] + 1.500000000*e[12] * ep2[3] + .5000000000*e[12] * ep2[4] + .5000000000*e[12] * ep2[5] + .5000000000*e[12] * ep2[6] + .5000000000*ep2[0] * e[12] - .5000000000*e[12] * ep2[1] - .5000000000*e[12] * ep2[7] - .5000000000*e[12] * ep2[2] - .5000000000*e[12] * ep2[8];
	A[99] = e[21] * e[24] * e[6] + e[0] * e[19] * e[22] + e[0] * e[20] * e[23] + e[24] * e[22] * e[7] + e[24] * e[4] * e[25] + e[24] * e[23] * e[8] + e[24] * e[5] * e[26] + e[6] * e[22] * e[25] + e[6] * e[23] * e[26] + e[18] * e[0] * e[21] + e[18] * e[19] * e[4] + e[18] * e[1] * e[22] + e[18] * e[20] * e[5] + e[18] * e[2] * e[23] + e[21] * e[22] * e[4] + e[21] * e[23] * e[5] - 1.*e[21] * e[26] * e[8] - 1.*e[21] * e[20] * e[2] - 1.*e[21] * e[19] * e[1] - 1.*e[21] * e[25] * e[7] + 1.500000000*ep2[21] * e[3] + .5000000000*e[3] * ep2[22] + .5000000000*e[3] * ep2[23] + .5000000000*e[3] * ep2[24] - .5000000000*e[3] * ep2[26] - .5000000000*e[3] * ep2[19] - .5000000000*e[3] * ep2[20] - .5000000000*e[3] * ep2[25] + .5000000000*ep2[18] * e[3];
	A[127] = e[11] * e[27] * e[12] + e[11] * e[9] * e[30] + e[11] * e[29] * e[14] + e[11] * e[28] * e[13] + e[11] * e[10] * e[31] + e[29] * e[9] * e[12] + e[29] * e[10] * e[13] + e[14] * e[30] * e[12] + e[14] * e[31] * e[13] + e[17] * e[30] * e[15] + e[17] * e[12] * e[33] + e[17] * e[14] * e[35] + e[17] * e[31] * e[16] + e[17] * e[13] * e[34] + e[35] * e[12] * e[15] + e[35] * e[13] * e[16] - 1.*e[14] * e[27] * e[9] - 1.*e[14] * e[28] * e[10] - 1.*e[14] * e[33] * e[15] - 1.*e[14] * e[34] * e[16] + .5000000000*ep2[11] * e[32] - .5000000000*e[32] * ep2[16] - .5000000000*e[32] * ep2[9] + .5000000000*e[32] * ep2[12] - .5000000000*e[32] * ep2[15] + .5000000000*e[32] * ep2[17] - .5000000000*e[32] * ep2[10] + 1.500000000*e[32] * ep2[14] + .5000000000*e[32] * ep2[13];
	A[126] = e[8] * e[3] * e[6] + .5000000000*ep2[2] * e[5] - .5000000000*e[5] * ep2[0] + .5000000000*e[5] * ep2[4] - .5000000000*e[5] * ep2[6] + .5000000000*e[5] * ep2[8] + e[8] * e[4] * e[7] + .5000000000*ep3[5] + e[2] * e[0] * e[3] + .5000000000*e[5] * ep2[3] - .5000000000*e[5] * ep2[7] + e[2] * e[1] * e[4] - .5000000000*e[5] * ep2[1];
	A[125] = e[2] * e[27] * e[3] + e[2] * e[0] * e[30] + e[2] * e[28] * e[4] + e[2] * e[1] * e[31] + e[2] * e[29] * e[5] - 1.*e[5] * e[27] * e[0] - 1.*e[5] * e[34] * e[7] - 1.*e[5] * e[33] * e[6] + e[5] * e[30] * e[3] + e[5] * e[35] * e[8] - 1.*e[5] * e[28] * e[1] + e[5] * e[31] * e[4] + e[29] * e[1] * e[4] + e[29] * e[0] * e[3] + e[8] * e[30] * e[6] + e[8] * e[3] * e[33] + e[8] * e[31] * e[7] + e[8] * e[4] * e[34] + e[35] * e[4] * e[7] + e[35] * e[3] * e[6] + .5000000000*ep2[2] * e[32] + 1.500000000*e[32] * ep2[5] + .5000000000*e[32] * ep2[4] - .5000000000*e[32] * ep2[0] - .5000000000*e[32] * ep2[6] - .5000000000*e[32] * ep2[1] - .5000000000*e[32] * ep2[7] + .5000000000*e[32] * ep2[3] + .5000000000*e[32] * ep2[8];
	A[124] = -1.*e[14] * e[19] * e[1] + e[14] * e[22] * e[4] - 1.*e[14] * e[18] * e[0] - 1.*e[14] * e[25] * e[7] - 1.*e[14] * e[24] * e[6] - 1.*e[23] * e[10] * e[1] + e[23] * e[13] * e[4] - 1.*e[23] * e[16] * e[7] - 1.*e[23] * e[15] * e[6] - 1.*e[23] * e[9] * e[0] + e[23] * e[12] * e[3] + e[17] * e[21] * e[6] + e[17] * e[3] * e[24] + e[17] * e[22] * e[7] + e[17] * e[4] * e[25] + e[17] * e[5] * e[26] - 1.*e[5] * e[24] * e[15] - 1.*e[5] * e[25] * e[16] - 1.*e[5] * e[18] * e[9] - 1.*e[5] * e[19] * e[10] + e[26] * e[12] * e[6] + e[26] * e[3] * e[15] + e[26] * e[13] * e[7] + e[26] * e[4] * e[16] + e[11] * e[18] * e[3] + e[11] * e[0] * e[21] + e[11] * e[19] * e[4] + e[11] * e[1] * e[22] + e[11] * e[20] * e[5] + e[11] * e[2] * e[23] + e[20] * e[9] * e[3] + e[20] * e[0] * e[12] + e[20] * e[10] * e[4] + e[20] * e[1] * e[13] + e[20] * e[2] * e[14] + e[5] * e[21] * e[12] + 3.*e[5] * e[23] * e[14] + e[5] * e[22] * e[13] + e[8] * e[21] * e[15] + e[8] * e[12] * e[24] + e[8] * e[23] * e[17] + e[8] * e[14] * e[26] + e[8] * e[22] * e[16] + e[8] * e[13] * e[25] + e[2] * e[18] * e[12] + e[2] * e[9] * e[21] + e[2] * e[19] * e[13] + e[2] * e[10] * e[22] + e[14] * e[21] * e[3];
	A[123] = -.5000000000*e[14] * ep2[27] + 1.500000000*e[14] * ep2[32] - .5000000000*e[14] * ep2[28] + .5000000000*e[14] * ep2[29] + .5000000000*e[14] * ep2[31] - .5000000000*e[14] * ep2[33] + .5000000000*e[14] * ep2[30] - .5000000000*e[14] * ep2[34] + .5000000000*e[14] * ep2[35] + e[11] * e[27] * e[30] + e[11] * e[29] * e[32] + e[11] * e[28] * e[31] + e[35] * e[30] * e[15] + e[35] * e[12] * e[33] + e[35] * e[32] * e[17] + e[35] * e[31] * e[16] + e[35] * e[13] * e[34] + e[29] * e[27] * e[12] + e[29] * e[9] * e[30] + e[29] * e[28] * e[13] + e[29] * e[10] * e[31] - 1.*e[32] * e[27] * e[9] + e[32] * e[30] * e[12] - 1.*e[32] * e[28] * e[10] + e[32] * e[31] * e[13] - 1.*e[32] * e[33] * e[15] - 1.*e[32] * e[34] * e[16] + e[17] * e[30] * e[33] + e[17] * e[31] * e[34];
	A[122] = -.5000000000*e[23] * ep2[33] - .5000000000*e[23] * ep2[34] + .5000000000*ep2[29] * e[23] + .5000000000*e[23] * ep2[30] + 1.500000000*e[23] * ep2[32] + .5000000000*e[23] * ep2[31] + .5000000000*e[23] * ep2[35] - .5000000000*e[23] * ep2[27] - .5000000000*e[23] * ep2[28] + e[32] * e[30] * e[21] + e[32] * e[31] * e[22] + e[26] * e[30] * e[33] + e[26] * e[32] * e[35] + e[26] * e[31] * e[34] + e[35] * e[30] * e[24] + e[35] * e[21] * e[33] + e[35] * e[31] * e[25] + e[35] * e[22] * e[34] - 1.*e[32] * e[27] * e[18] - 1.*e[32] * e[33] * e[24] - 1.*e[32] * e[28] * e[19] - 1.*e[32] * e[34] * e[25] + e[20] * e[27] * e[30] + e[20] * e[29] * e[32] + e[20] * e[28] * e[31] + e[29] * e[27] * e[21] + e[29] * e[18] * e[30] + e[29] * e[28] * e[22] + e[29] * e[19] * e[31];
	A[121] = e[2] * e[27] * e[30] + e[2] * e[29] * e[32] + e[2] * e[28] * e[31] + e[32] * e[30] * e[3] + e[32] * e[31] * e[4] + e[8] * e[30] * e[33] + e[8] * e[32] * e[35] + e[8] * e[31] * e[34] + e[29] * e[27] * e[3] + e[29] * e[0] * e[30] + e[29] * e[28] * e[4] + e[29] * e[1] * e[31] + e[35] * e[30] * e[6] + e[35] * e[3] * e[33] + e[35] * e[31] * e[7] + e[35] * e[4] * e[34] - 1.*e[32] * e[27] * e[0] - 1.*e[32] * e[34] * e[7] - 1.*e[32] * e[33] * e[6] - 1.*e[32] * e[28] * e[1] + .5000000000*e[5] * ep2[30] + 1.500000000*e[5] * ep2[32] + .5000000000*e[5] * ep2[31] - .5000000000*e[5] * ep2[27] - .5000000000*e[5] * ep2[28] + .5000000000*e[5] * ep2[29] - .5000000000*e[5] * ep2[33] - .5000000000*e[5] * ep2[34] + .5000000000*e[5] * ep2[35];
	A[120] = .5000000000*e[32] * ep2[31] + .5000000000*e[32] * ep2[35] - .5000000000*e[32] * ep2[27] + e[29] * e[27] * e[30] + e[29] * e[28] * e[31] + e[35] * e[30] * e[33] + e[35] * e[31] * e[34] + .5000000000*ep2[29] * e[32] + .5000000000*ep3[32] - .5000000000*e[32] * ep2[33] - .5000000000*e[32] * ep2[34] + .5000000000*e[32] * ep2[30] - .5000000000*e[32] * ep2[28];
	A[118] = e[10] * e[1] * e[4] + e[10] * e[0] * e[3] + e[10] * e[2] * e[5] + e[4] * e[12] * e[3] + e[4] * e[14] * e[5] + e[7] * e[12] * e[6] + e[7] * e[3] * e[15] + e[7] * e[4] * e[16] + e[7] * e[14] * e[8] + e[7] * e[5] * e[17] + e[16] * e[3] * e[6] + e[16] * e[5] * e[8] - 1.*e[4] * e[11] * e[2] - 1.*e[4] * e[15] * e[6] - 1.*e[4] * e[9] * e[0] - 1.*e[4] * e[17] * e[8] + e[1] * e[9] * e[3] + e[1] * e[0] * e[12] + e[1] * e[11] * e[5] + e[1] * e[2] * e[14] + 1.500000000*e[13] * ep2[4] + .5000000000*e[13] * ep2[3] + .5000000000*e[13] * ep2[5] + .5000000000*e[13] * ep2[7] + .5000000000*ep2[1] * e[13] - .5000000000*e[13] * ep2[0] - .5000000000*e[13] * ep2[6] - .5000000000*e[13] * ep2[2] - .5000000000*e[13] * ep2[8];
	A[119] = e[25] * e[21] * e[6] + e[25] * e[3] * e[24] + e[25] * e[23] * e[8] + e[25] * e[5] * e[26] + e[7] * e[21] * e[24] + e[7] * e[23] * e[26] + e[19] * e[18] * e[3] + e[19] * e[0] * e[21] + e[19] * e[1] * e[22] + e[19] * e[20] * e[5] + e[19] * e[2] * e[23] + e[22] * e[21] * e[3] + e[22] * e[23] * e[5] - 1.*e[22] * e[26] * e[8] - 1.*e[22] * e[20] * e[2] - 1.*e[22] * e[18] * e[0] + e[22] * e[25] * e[7] - 1.*e[22] * e[24] * e[6] + e[1] * e[18] * e[21] + e[1] * e[20] * e[23] + .5000000000*e[4] * ep2[25] - .5000000000*e[4] * ep2[26] - .5000000000*e[4] * ep2[18] - .5000000000*e[4] * ep2[20] - .5000000000*e[4] * ep2[24] + .5000000000*ep2[19] * e[4] + 1.500000000*ep2[22] * e[4] + .5000000000*e[4] * ep2[21] + .5000000000*e[4] * ep2[23];
	A[116] = e[22] * e[21] * e[12] + e[22] * e[23] * e[14] + e[25] * e[21] * e[15] + e[25] * e[12] * e[24] + e[25] * e[23] * e[17] + e[25] * e[14] * e[26] + e[25] * e[22] * e[16] + e[16] * e[21] * e[24] + e[16] * e[23] * e[26] + e[10] * e[19] * e[22] + e[10] * e[18] * e[21] + e[10] * e[20] * e[23] + e[19] * e[18] * e[12] + e[19] * e[9] * e[21] + e[19] * e[20] * e[14] + e[19] * e[11] * e[23] - 1.*e[22] * e[24] * e[15] - 1.*e[22] * e[26] * e[17] - 1.*e[22] * e[20] * e[11] - 1.*e[22] * e[18] * e[9] - .5000000000*e[13] * ep2[26] - .5000000000*e[13] * ep2[18] + .5000000000*e[13] * ep2[23] + .5000000000*e[13] * ep2[19] - .5000000000*e[13] * ep2[20] - .5000000000*e[13] * ep2[24] + .5000000000*e[13] * ep2[21] + 1.500000000*ep2[22] * e[13] + .5000000000*e[13] * ep2[25];
	A[117] = e[13] * e[30] * e[21] + 3.*e[13] * e[31] * e[22] + e[13] * e[32] * e[23] + e[10] * e[27] * e[21] + e[10] * e[18] * e[30] + e[10] * e[28] * e[22] + e[10] * e[19] * e[31] + e[10] * e[29] * e[23] + e[10] * e[20] * e[32] + e[22] * e[30] * e[12] + e[22] * e[32] * e[14] + e[31] * e[21] * e[12] + e[31] * e[23] * e[14] - 1.*e[13] * e[27] * e[18] - 1.*e[13] * e[33] * e[24] - 1.*e[13] * e[29] * e[20] - 1.*e[13] * e[35] * e[26] + e[13] * e[28] * e[19] + e[13] * e[34] * e[25] + e[19] * e[27] * e[12] + e[19] * e[9] * e[30] + e[19] * e[29] * e[14] + e[19] * e[11] * e[32] + e[28] * e[18] * e[12] + e[28] * e[9] * e[21] + e[28] * e[20] * e[14] + e[28] * e[11] * e[23] + e[16] * e[30] * e[24] + e[16] * e[21] * e[33] + e[16] * e[31] * e[25] + e[16] * e[22] * e[34] + e[16] * e[32] * e[26] + e[16] * e[23] * e[35] - 1.*e[22] * e[27] * e[9] - 1.*e[22] * e[33] * e[15] - 1.*e[22] * e[35] * e[17] - 1.*e[22] * e[29] * e[11] - 1.*e[31] * e[24] * e[15] - 1.*e[31] * e[26] * e[17] - 1.*e[31] * e[20] * e[11] - 1.*e[31] * e[18] * e[9] + e[25] * e[30] * e[15] + e[25] * e[12] * e[33] + e[25] * e[32] * e[17] + e[25] * e[14] * e[35] + e[34] * e[21] * e[15] + e[34] * e[12] * e[24] + e[34] * e[23] * e[17] + e[34] * e[14] * e[26];
	A[114] = e[19] * e[11] * e[14] + e[19] * e[9] * e[12] + e[19] * e[10] * e[13] + e[13] * e[21] * e[12] + e[13] * e[23] * e[14] + e[16] * e[21] * e[15] + e[16] * e[12] * e[24] + e[16] * e[23] * e[17] + e[16] * e[14] * e[26] + e[16] * e[13] * e[25] + e[25] * e[14] * e[17] + e[25] * e[12] * e[15] - 1.*e[13] * e[24] * e[15] - 1.*e[13] * e[26] * e[17] - 1.*e[13] * e[20] * e[11] - 1.*e[13] * e[18] * e[9] + e[10] * e[18] * e[12] + e[10] * e[9] * e[21] + e[10] * e[20] * e[14] + e[10] * e[11] * e[23] + 1.500000000*e[22] * ep2[13] + .5000000000*e[22] * ep2[14] + .5000000000*e[22] * ep2[12] + .5000000000*e[22] * ep2[16] + .5000000000*ep2[10] * e[22] - .5000000000*e[22] * ep2[9] - .5000000000*e[22] * ep2[11] - .5000000000*e[22] * ep2[15] - .5000000000*e[22] * ep2[17];
	A[115] = e[13] * e[12] * e[3] + e[13] * e[14] * e[5] + e[16] * e[12] * e[6] + e[16] * e[3] * e[15] + e[16] * e[13] * e[7] + e[16] * e[14] * e[8] + e[16] * e[5] * e[17] + e[7] * e[14] * e[17] + e[7] * e[12] * e[15] + e[1] * e[11] * e[14] + e[1] * e[9] * e[12] + e[1] * e[10] * e[13] + e[10] * e[9] * e[3] + e[10] * e[0] * e[12] + e[10] * e[11] * e[5] + e[10] * e[2] * e[14] - 1.*e[13] * e[11] * e[2] - 1.*e[13] * e[15] * e[6] - 1.*e[13] * e[9] * e[0] - 1.*e[13] * e[17] * e[8] + 1.500000000*ep2[13] * e[4] + .5000000000*e[4] * ep2[16] - .5000000000*e[4] * ep2[9] - .5000000000*e[4] * ep2[11] + .5000000000*e[4] * ep2[12] - .5000000000*e[4] * ep2[15] - .5000000000*e[4] * ep2[17] + .5000000000*e[4] * ep2[10] + .5000000000*e[4] * ep2[14];
	A[112] = e[19] * e[1] * e[4] + e[19] * e[0] * e[3] + e[19] * e[2] * e[5] + e[4] * e[21] * e[3] + e[4] * e[23] * e[5] + e[7] * e[21] * e[6] + e[7] * e[3] * e[24] + e[7] * e[4] * e[25] + e[7] * e[23] * e[8] + e[7] * e[5] * e[26] + e[25] * e[3] * e[6] + e[25] * e[5] * e[8] + e[1] * e[18] * e[3] + e[1] * e[0] * e[21] + e[1] * e[20] * e[5] + e[1] * e[2] * e[23] - 1.*e[4] * e[26] * e[8] - 1.*e[4] * e[20] * e[2] - 1.*e[4] * e[18] * e[0] - 1.*e[4] * e[24] * e[6] + 1.500000000*e[22] * ep2[4] - .5000000000*e[22] * ep2[0] - .5000000000*e[22] * ep2[6] + .5000000000*e[22] * ep2[5] + .5000000000*e[22] * ep2[1] + .5000000000*e[22] * ep2[7] + .5000000000*e[22] * ep2[3] - .5000000000*e[22] * ep2[2] - .5000000000*e[22] * ep2[8];
	A[113] = -1.*e[31] * e[20] * e[2] - 1.*e[31] * e[18] * e[0] + e[31] * e[23] * e[5] - 1.*e[31] * e[24] * e[6] + e[7] * e[30] * e[24] + e[7] * e[21] * e[33] + e[7] * e[32] * e[26] + e[7] * e[23] * e[35] + e[25] * e[30] * e[6] + e[25] * e[3] * e[33] + e[25] * e[31] * e[7] + e[25] * e[4] * e[34] + e[25] * e[32] * e[8] + e[25] * e[5] * e[35] + e[34] * e[21] * e[6] + e[34] * e[3] * e[24] + e[34] * e[22] * e[7] + e[34] * e[23] * e[8] + e[34] * e[5] * e[26] + e[1] * e[27] * e[21] + e[1] * e[18] * e[30] + e[1] * e[28] * e[22] + e[1] * e[19] * e[31] + e[1] * e[29] * e[23] + e[1] * e[20] * e[32] + e[19] * e[27] * e[3] + e[19] * e[0] * e[30] + e[19] * e[28] * e[4] + e[19] * e[29] * e[5] + e[19] * e[2] * e[32] + e[28] * e[18] * e[3] + e[28] * e[0] * e[21] + e[28] * e[20] * e[5] + e[28] * e[2] * e[23] + e[4] * e[30] * e[21] + 3.*e[4] * e[31] * e[22] + e[4] * e[32] * e[23] - 1.*e[4] * e[27] * e[18] - 1.*e[4] * e[33] * e[24] - 1.*e[4] * e[29] * e[20] - 1.*e[4] * e[35] * e[26] - 1.*e[22] * e[27] * e[0] + e[22] * e[32] * e[5] - 1.*e[22] * e[33] * e[6] + e[22] * e[30] * e[3] - 1.*e[22] * e[35] * e[8] - 1.*e[22] * e[29] * e[2] + e[31] * e[21] * e[3] - 1.*e[31] * e[26] * e[8];

	int perm[20] = { 6, 8, 18, 15, 12, 5, 14, 7, 4, 11, 19, 13, 1, 16, 17, 3, 10, 9, 2, 0 };
	double AA[200];
	for (int i = 0; i < 20; i++)
	{
		for (int j = 0; j < 10; j++) AA[i + j * 20] = A[perm[i] + j * 20];
	}

	for (int i = 0; i < 200; i++)
	{
		A[i] = AA[i];
	}
}

// Input should be a vector of n 2D points or a Nx2 matrix
Mat findEssentialMat(InputArray _points1, InputArray _points2, Mat K1, Mat K2, int method, double prob, double threshold, int maxIters, OutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);

	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 5 && points2.checkVector(2) == npoints &&
		points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	double f1 = K1.at<double>(0), f2 = K2.at<double>(0), u1 = K1.at<double>(2), v1 = K1.at<double>(4);
	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	// Reshape data to fit opencv ransac function
	points1 = points1.reshape(2, 1);
	points2 = points2.reshape(2, 1);

	Mat E(3, 3, CV_64F);
	CvEMEstimator estimator;

	CvMat p1 = points1;
	CvMat p2 = points2;
	CvMat _E = E;
	CvMat* tempMask = cvCreateMat(1, npoints, CV_8U);

	assert(npoints >= 5);
	threshold /= 0.25*(K1.at<double>(0) + K1.at<double>(4) + K2.at<double>(0) + K2.at<double>(4));
	int count = 1;
	if (npoints == 5)
	{
		E.create(3 * 10, 3, CV_64F);
		_E = E;
		count = estimator.runKernel(&p1, &p2, &_E);
		E = E.rowRange(0, 3 * count) * 1.0;
		Mat(tempMask).setTo(true);
	}
	else if (method == CV_RANSAC)
	{
		estimator.runRANSAC(&p1, &p2, &_E, tempMask, threshold, prob, maxIters);
	}
	else
	{
		estimator.runLMeDS(&p1, &p2, &_E, tempMask, prob);
	}

	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		Mat(tempMask).copyTo(mask);
	}


	return E;

}
void decomposeEssentialMat(const Mat & E, Mat & R1, Mat & R2, Mat & t)
{
	assert(E.cols == 3 && E.rows == 3);
	Mat D, U, Vt;
	SVD::compute(E, D, U, Vt);
	if (determinant(U) < 0) U = -U;
	if (determinant(Vt) < 0) Vt = -Vt;
	Mat W = (Mat_<double>(3, 3) << 0, 1, 0, -1, 0, 0, 0, 0, 1);
	W.convertTo(W, E.type());
	R1 = U * W * Vt;
	R2 = U * W.t() * Vt;
	t = U.col(2) * 1.0;
}
int recoverPose(const Mat & E, InputArray _points1, InputArray _points2, Mat & _R, Mat & _t, Mat K1, Mat K2, InputOutputArray _mask)
{
	Mat points1, points2;
	_points1.getMat().copyTo(points1);
	_points2.getMat().copyTo(points2);
	int npoints = points1.checkVector(2);
	CV_Assert(npoints >= 0 && points2.checkVector(2) == npoints &&
		points1.type() == points2.type());

	if (points1.channels() > 1)
	{
		points1 = points1.reshape(1, npoints);
		points2 = points2.reshape(1, npoints);
	}
	points1.convertTo(points1, CV_64F);
	points2.convertTo(points2, CV_64F);

	points1.col(0) = (points1.col(0) - K1.at<double>(2)) / K1.at<double>(0);
	points1.col(1) = (points1.col(1) - K1.at<double>(5)) / K1.at<double>(4);
	points2.col(0) = (points2.col(0) - K2.at<double>(2)) / K2.at<double>(0);
	points2.col(1) = (points2.col(1) - K2.at<double>(5)) / K2.at<double>(4);

	points1 = points1.t();
	points2 = points2.t();

	Mat R1, R2, t;
	decomposeEssentialMat(E, R1, R2, t);
	Mat P0 = Mat::eye(3, 4, R1.type());
	Mat P1(3, 4, R1.type()), P2(3, 4, R1.type()), P3(3, 4, R1.type()), P4(3, 4, R1.type());
	P1(Range::all(), Range(0, 3)) = R1 * 1.0; P1.col(3) = t * 1.0;
	P2(Range::all(), Range(0, 3)) = R2 * 1.0; P2.col(3) = t * 1.0;
	P3(Range::all(), Range(0, 3)) = R1 * 1.0; P3.col(3) = -t * 1.0;
	P4(Range::all(), Range(0, 3)) = R2 * 1.0; P4.col(3) = -t * 1.0;

	// Do the cheirality check. 
	// Notice here a threshold dist is used to filter
	// out far away points (i.e. infinite points) since 
	// there depth may vary between postive and negtive. 
	double dist = 50.0;
	Mat Q;
	triangulatePoints(P0, P1, points1, points2, Q);
	Mat mask1 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask1 = (Q.row(2) < dist) & mask1;
	Q = P1 * Q;
	mask1 = (Q.row(2) > 0) & mask1;
	mask1 = (Q.row(2) < dist) & mask1;

	triangulatePoints(P0, P2, points1, points2, Q);
	Mat mask2 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask2 = (Q.row(2) < dist) & mask2;
	Q = P2 * Q;
	mask2 = (Q.row(2) > 0) & mask2;
	mask2 = (Q.row(2) < dist) & mask2;

	triangulatePoints(P0, P3, points1, points2, Q);
	Mat mask3 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask3 = (Q.row(2) < dist) & mask3;
	Q = P3 * Q;
	mask3 = (Q.row(2) > 0) & mask3;
	mask3 = (Q.row(2) < dist) & mask3;

	triangulatePoints(P0, P4, points1, points2, Q);
	Mat mask4 = Q.row(2).mul(Q.row(3)) > 0;
	Q.row(0) /= Q.row(3);
	Q.row(1) /= Q.row(3);
	Q.row(2) /= Q.row(3);
	Q.row(3) /= Q.row(3);
	mask4 = (Q.row(2) < dist) & mask4;
	Q = P4 * Q;
	mask4 = (Q.row(2) > 0) & mask4;
	mask4 = (Q.row(2) < dist) & mask4;

	// If _mask is given, then use it to filter outliers. 
	if (_mask.needed())
	{
		_mask.create(1, npoints, CV_8U, -1, true);
		Mat mask = _mask.getMat();
		bitwise_and(mask, mask1, mask1);
		bitwise_and(mask, mask2, mask2);
		bitwise_and(mask, mask3, mask3);
		bitwise_and(mask, mask4, mask4);
	}

	int good1 = countNonZero(mask1);
	int good2 = countNonZero(mask2);
	int good3 = countNonZero(mask3);
	int good4 = countNonZero(mask4);
	if (good1 >= good2 && good1 >= good3 && good1 >= good4)
	{
		_R = R1; _t = t;
		if (_mask.needed()) mask1.copyTo(_mask.getMat());
		return good1;
	}
	else if (good2 >= good1 && good2 >= good3 && good2 >= good4)
	{
		_R = R2; _t = t;
		if (_mask.needed()) mask2.copyTo(_mask.getMat());
		return good2;
	}
	else if (good3 >= good1 && good3 >= good2 && good3 >= good4)
	{
		_R = R1; _t = -t;
		if (_mask.needed()) mask3.copyTo(_mask.getMat());
		return good3;
	}
	else
	{
		_R = R2; _t = -t;
		if (_mask.needed()) mask4.copyTo(_mask.getMat());
		return good4;
	}

}
int EMatTest()
{
	int N = 500;
	double bound_2d = 5;

	double focal1 = 300, focal2 = 350, u1 = 0, v1 = 0, u2 = 1, v2 = 2;
	Point2d pp(0, 0);

	Mat rvec = (cv::Mat_<double>(3, 1) << 0.1, 0.2, 0.3);
	Mat tvec = (cv::Mat_<double>(3, 1) << 0.4, 0.5, 0.6);
	normalize(tvec, tvec);
	std::cout << "Expected rvec: " << rvec << std::endl;
	std::cout << "Expected tvec: " << tvec << std::endl;

	Mat rmat;
	Rodrigues(rvec, rmat);

	Mat K1 = (Mat_<double>(3, 3) << focal1, 0, u1, 0, focal1, v1, 0, 0, 1);
	Mat K2 = (Mat_<double>(3, 3) << focal2, 0, u2, 0, focal2, v2, 0, 0, 1);

	RNG rng;
	Mat Xs(N, 3, CV_32F);
	rng.fill(Xs, RNG::UNIFORM, -bound_2d, bound_2d);

	Mat x1s = K1 * Xs.t();
	Mat x2s = rmat * Xs.t();
	for (int j = 0; j < x2s.cols; j++) x2s.col(j) += tvec;
	x2s = K2 * x2s;

	x1s.row(0) /= x1s.row(2);
	x1s.row(1) /= x1s.row(2);
	x1s.row(2) /= x1s.row(2);

	x2s.row(0) /= x2s.row(2);
	x2s.row(1) /= x2s.row(2);
	x2s.row(2) /= x2s.row(2);

	x1s = x1s.t();
	x2s = x2s.t();

	x1s = x1s.colRange(0, 2) * 1.0;
	x2s = x2s.colRange(0, 2) * 1.0;

	double start = omp_get_wtime();
	Mat E = findEssentialMat(x1s, x2s, K1, K2, CV_RANSAC, 0.99, 1, 200, noArray());
	printf("Time: %.6fs\n", omp_get_wtime() - start);

	std::cout << "============================= ========================" << std::endl;
	Mat R1_5pt, R2_5pt, tvec_5pt, rvec1_5pt, rvec2_5pt;
	decomposeEssentialMat(E, R1_5pt, R2_5pt, tvec_5pt);
	Rodrigues(R1_5pt, rvec1_5pt);
	Rodrigues(R2_5pt, rvec2_5pt);
	std::cout << "5-pt-nister rvec: " << std::endl;
	std::cout << rvec1_5pt << std::endl;
	std::cout << rvec2_5pt << std::endl;
	std::cout << "5-pt-nister tvec: " << std::endl;
	std::cout << tvec_5pt << std::endl;
	std::cout << -tvec_5pt << std::endl;


	start = omp_get_wtime();
	Mat R_5pt, rvec_5pt;
	recoverPose(E, x1s, x2s, R_5pt, tvec_5pt, K1, K2, noArray());
	printf("Time: %.6fs\n", omp_get_wtime() - start);

	Rodrigues(R_5pt, rvec_5pt);
	std::cout << "5-pt-nister rvec: " << std::endl;
	std::cout << rvec_5pt << std::endl;
	std::cout << "5-pt-nister tvec: " << std::endl;
	std::cout << tvec_5pt << std::endl;

	return 0;
}

int USAC_FindFundamentalMatrix(ConfigParamsFund cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Fmat, vector<int>&InlierIndicator, int &ninlers)
{
	FundMatrixEstimator* fund = new FundMatrixEstimator;
	fund->initParamsUSAC(cfg);

	// set up the fundamental matrix estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	fund->initDataUSAC(cfg);
	fund->initProblem(cfg, &point_data[0]);
	if (!fund->solve())
		return 1;

	// write out results
	ninlers = fund->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Fmat[3 * i + j] = fund->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(fund->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	fund->cleanupProblem();
	delete fund;

	return 0;
}
int USAC_FindFundamentalDriver(char *Path, int id1, int id2, int timeID)
{
	ConfigParamsFund cfg;
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	/// store common parameters
	cfg.common.confThreshold = 0.99;
	cfg.common.minSampleSize = 7;
	cfg.common.inlierThreshold = 1.5;
	cfg.common.maxHypotheses = 850000;
	cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true;
	cfg.common.prevalidateModel = true;
	cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM;
	cfg.common.verifMethod = USACConfig::VERIF_SPRT;
	cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	// read in PROSAC parameters if required
	if (USEPROSAC)
	{
		cfg.prosac.maxSamples;
		cfg.prosac.beta;
		cfg.prosac.nonRandConf;
		cfg.prosac.minStopLen;
	}

	// read in SPRT parameters if required
	if (USESPRT)
	{
		cfg.sprt.tM = 200.0;
		cfg.sprt.mS = 2.38;
		cfg.sprt.delta = 0.05;
		cfg.sprt.epsilon = 0.15;
	}

	// read in LO parameters if required
	if (USELOSAC)
	{
		cfg.losac.innerSampleSize = 15;
		cfg.losac.innerRansacRepetitions = 5;
		cfg.losac.thresholdMultiplier = 2.0;
		cfg.losac.numStepsIterative = 4;
	}
	cfg.fund.inputFilePath = Path;// "C:/temp/test1/orig_pts.txt";

	// read data from from file
	char Fname[200];

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys2))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int npts, pid1, pid2;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot open %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	cfg.common.numDataPoints = npts;

	vector<Point2d>pts1, pts2;
	pts1.reserve(npts); pts2.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
	{
		pts1.push_back(Point2d(Keys1[pid1].pt.x, Keys1[pid1].pt.y));
		pts2.push_back(Point2d(Keys2[pid2].pt.x, Keys2[pid2].pt.y));
	}
	fclose(fp);

	std::vector<unsigned int> prosac_data;
	if (USEPROSAC)
	{
		prosac_data.resize(cfg.common.numDataPoints);
		if (!readPROSACDataFromFile(cfg.prosac.sortedPointsFile, cfg.common.numDataPoints, prosac_data))
			return 1;
		cfg.prosac.sortedPointIndices = &prosac_data[0];
	}
	else
		cfg.prosac.sortedPointIndices = NULL;

	int ninliers = 0;
	double Fmat[9];
	vector<int> InlierIndicator;
	USAC_FindFundamentalMatrix(cfg, pts1, pts2, Fmat, InlierIndicator, ninliers);

	/*sprintf(Fname, "%s/orig_pts.txt", Path); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	fprintf(fp, "%.2f %.2f %.2f %.2f\n", pts1[ii].x, pts1[ii].y, pts2[ii].x, pts2[ii].y);
	fclose(fp);*/

	// write out results
	sprintf(Fname, "%s/F.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Fmat[ii]);
	fclose(fp);

	sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", InlierIndicator[ii]);
	fclose(fp);

	return 0;
}
int USAC_FindHomography(ConfigParamsHomog cfg, vector<Point2d> pts1, vector<Point2d>pts2, double *Hmat, vector<int>&InlierIndicator, int &ninlers)
{
	HomogEstimator* homog = new HomogEstimator;
	homog->initParamsUSAC(cfg);

	// set up the homography estimation problem
	std::vector<double> point_data; point_data.reserve(6 * cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	{
		point_data.push_back(pts1[ii].x), point_data.push_back(pts1[ii].y), point_data.push_back(1.0);
		point_data.push_back(pts2[ii].x), point_data.push_back(pts2[ii].y), point_data.push_back(1.0);
	}

	homog->initDataUSAC(cfg);
	homog->initProblem(cfg, &point_data[0]);
	if (!homog->solve())
		return 1;

	// write out results
	ninlers = homog->usac_results_.best_inlier_count_;
	for (unsigned int i = 0; i < 3; ++i)
		for (unsigned int j = 0; j < 3; ++j)
			Hmat[3 * i + j] = homog->final_model_params_[3 * i + j];

	InlierIndicator.reserve(cfg.common.numDataPoints);
	for (unsigned int i = 0; i < cfg.common.numDataPoints; ++i)
		InlierIndicator.push_back(homog->usac_results_.inlier_flags_[i]);

	// clean up
	point_data.clear();
	//prosac_data.clear();
	homog->cleanupProblem();
	delete homog;

	return 0;
}
int USAC_FindHomographyDriver(char *Path, int id1, int id2, int timeID)
{
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;

	ConfigParamsHomog cfg;
	/// store common parameters
	cfg.common.confThreshold = 0.99;
	cfg.common.minSampleSize = 4;
	cfg.common.inlierThreshold = 2.0;
	cfg.common.maxHypotheses = 850000;
	cfg.common.maxSolutionsPerSample = 1;
	cfg.common.prevalidateSample = true;
	cfg.common.prevalidateModel = true;
	cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM;
	cfg.common.verifMethod = USACConfig::VERIF_SPRT;
	cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	// read in PROSAC parameters if required
	if (USEPROSAC)
	{
		cfg.prosac.maxSamples;
		cfg.prosac.beta;
		cfg.prosac.nonRandConf;
		cfg.prosac.minStopLen;
	}

	// read in SPRT parameters if required
	if (USESPRT)
	{
		cfg.sprt.tM = 100.0;
		cfg.sprt.mS = 1.0;
		cfg.sprt.delta = 0.01;
		cfg.sprt.epsilon = 0.2;
	}

	// read in LO parameters if required
	if (USELOSAC)
	{
		cfg.losac.innerSampleSize = 12;
		cfg.losac.innerRansacRepetitions = 3;
		cfg.losac.thresholdMultiplier = 2.0;
		cfg.losac.numStepsIterative = 4;
	}
	cfg.homog.inputFilePath = Path;// "C:/temp/test1/orig_pts.txt";

	// read data from from file
	char Fname[200];

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys2))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int npts, pid1, pid2;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot open %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	cfg.common.numDataPoints = npts;

	vector<Point2d>pts1, pts2;
	pts1.reserve(npts); pts2.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
	{
		pts1.push_back(Point2d(Keys1[pid1].pt.x, Keys1[pid1].pt.y));
		pts2.push_back(Point2d(Keys2[pid2].pt.x, Keys2[pid2].pt.y));
	}
	fclose(fp);

	std::vector<unsigned int> prosac_data;
	if (USEPROSAC)
	{
		prosac_data.resize(cfg.common.numDataPoints);
		if (!readPROSACDataFromFile(cfg.prosac.sortedPointsFile, cfg.common.numDataPoints, prosac_data))
			return 1;
		cfg.prosac.sortedPointIndices = &prosac_data[0];
	}
	else
		cfg.prosac.sortedPointIndices = NULL;

	int ninliers = 0;
	double Hmat[9];
	vector<int> InlierIndicator;
	USAC_FindHomography(cfg, pts1, pts2, Hmat, InlierIndicator, ninliers);

	/*sprintf(Fname, "%s/orig_pts.txt", Path); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", cfg.common.numDataPoints);
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
	fprintf(fp, "%.2f %.2f %.2f %.2f\n", pts1[ii].x, pts1[ii].y, pts2[ii].x, pts2[ii].y);
	fclose(fp);*/

	// write out results
	sprintf(Fname, "%s/H.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Hmat[ii]);
	fclose(fp);

	sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", InlierIndicator[ii]);
	fclose(fp);

	return 0;
}

double SearchLK(Point2d From, Point2d &Target, float *Img1Para, float *Img2Para, int nchannels, int width1, int height1, int width2, int height2, LKParameters LKArg, double *Timg = 0, double *T = 0, double *iWp = 0, double *direction = 0, double* iCovariance = 0)
{
	int i, j, k, kk, iii, jjj, ij, i2, j2;
	int hsubset = LKArg.hsubset, DIC_Algo = LKArg.DIC_Algo, Interpolation_Algorithm = LKArg.InterpAlgo;
	int Iter_Max = LKArg.IterMax, Convergence_Criteria = LKArg.Convergence_Criteria, Speed = LKArg.Analysis_Speed;
	double znccThresh = LKArg.ZNCCThreshold, pssdabThresh = LKArg.PSSDab_thresh;

	double ii, jj, II, JJ, a, b, gx, gy, DIC_Coeff, DIC_Coeff_min, t_1, t_2, t_3, t_4, t_5, t_6, m_F, m_G, S[9], p_best[14];
	double conv_crit_1 = 1.0 / pow(10.0, Convergence_Criteria + 2);
	double conv_crit_2 = conv_crit_1*0.01;
	int NN[] = { 3, 7, 4, 8, 9, 13, 10, 14 };
	int jumpStep[2] = { 1, 2 };
	int DIC_Algo2 = DIC_Algo, nn, nExtraParas = 2, _iter = 0;
	int p_jump, p_jump_0 = jumpStep[Speed], p_jump_incr = 1;

	if (DIC_Algo == 4)
	{
		nn = 7, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 1;
	}
	else if (DIC_Algo == 5)
	{
		nn = 7, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 1;
	}
	else if (DIC_Algo == 6)
	{
		nn = 8, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 3;
	}
	else if (DIC_Algo == 7)
	{
		nn = 8, DIC_Algo2 = DIC_Algo;
		DIC_Algo = 3;
	}
	else
		nn = NN[DIC_Algo];

	double AA[196], BB[14], CC[14], p[14];
	for (i = 0; i < nn; i++)
		p[i] = (i == nn - 2 ? 1.0 : 0.0);

	int length1 = width1*height1, length2 = width2*height2, TimgS = 2 * hsubset + 1, Tlength = TimgS*TimgS;

	bool createMem = false;
	if (Timg == NULL)
	{
		Timg = new double[Tlength*nchannels];
		T = new double[2 * Tlength*nchannels];
	}

	for (jjj = -hsubset; jjj <= hsubset; jjj++)
	{
		for (iii = -hsubset; iii <= hsubset; iii++)
		{
			ii = From.x + iii, jj = From.y + jjj;
			for (kk = 0; kk < nchannels; kk++)
			{
				Get_Value_Spline(Img1Para + kk*length1, width1, height1, ii, jj, S, -1, Interpolation_Algorithm);
				Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength] = S[0];
			}
		}
	}

	bool printout = false;
	FILE *fp;
	if (printout)
	{
		fp = fopen("C:/temp/src.txt", "w+");
		for (jjj = -hsubset; jjj <= hsubset; jjj++)
		{
			for (iii = -hsubset; iii <= hsubset; iii++)
				for (kk = 0; kk < nchannels; kk++)
					fprintf(fp, "%.2f ", Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength]);
			fprintf(fp, "\n");
		}
		fclose(fp);
	}

	bool useInitPara = false;
	if (iWp != NULL)
	{
		useInitPara = true;
		p[2] = iWp[0], p[3] = iWp[1], p[4] = iWp[2], p[5] = iWp[3];
	}

	/// Let's start with only translation and only match the at the highest level of the pyramid
	bool Break_Flag = false;
	DIC_Coeff_min = 1e10;
	for (p_jump = p_jump_0; p_jump > 0; p_jump -= 2)
	{
		DIC_Coeff_min = 1e10;
		bool Break_Flag = false;
		for (k = 0; k < Iter_Max; k++)
		{
			t_1 = 0.0;
			t_2 = 0.0;
			for (i = 0; i < 4; i++)
				AA[i] = 0.0;
			for (i = 0; i < 2; i++)
				BB[i] = 0.0;

			if (printout)
				fp = fopen("C:/temp/tar.txt", "w+");

			for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
			{
				for (iii = -hsubset; iii <= hsubset; iii += p_jump)
				{
					if (DIC_Algo == 1 || DIC_Algo == 3)
						II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
					else
						II = Target.x + iii + p[0], JJ = Target.y + jjj + p[1];

					if (II<0.0 || II>(double)(width1 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height1 - 1) - (1e-10))
						continue;

					for (kk = 0; kk < nchannels; kk++)
					{
						Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

						m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
						m_G = S[3 * kk];
						if (printout)
							fprintf(fp, "%.2f ", m_G);
						t_3 = m_G - m_F;
						CC[0] = S[3 * kk + 1], CC[1] = S[3 * kk + 2];

						for (i = 0; i < 2; i++)
							BB[i] += t_3*CC[i];

						for (j = 0; j < 2; j++)
							for (i = j; i < 2; i++)
								AA[j * 2 + i] += CC[i] * CC[j];

						t_1 += t_3*t_3, t_2 += m_F*m_F;
					}
				}
				if (printout)
					fprintf(fp, "\n");
			}
			if (printout)
				fclose(fp);

			DIC_Coeff = t_1 / t_2;
			mat_completeSym(AA, 2);
			QR_Solution_Double(AA, BB, 2, 2);
			for (i = 0; i < 2; i++)
				p[i] -= BB[i];


			if (DIC_Coeff != DIC_Coeff || DIC_Coeff > 50 || abs(p[0]) > hsubset || abs(p[1]) > hsubset)
			{
				if (createMem)
				{
					delete[]T;
					delete[]Timg;
				}
				return 0.0;
			}

			if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
			{
				DIC_Coeff_min = DIC_Coeff;
				p_best[0] = p[0], p_best[1] = p[1];
				if (p[0] != p[0] || p[1] != p[1])
				{
					if (createMem)
					{
						delete[]T;
						delete[]Timg;
					}
					return 0.0;
				}
			}

			if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
				break;
		}
	}
	p[0] = p_best[0], p[1] = p_best[1];

	if (DIC_Algo <= 1)
	{
		p[0] = 0.5*(p[0] / direction[0] + p[1] / direction[1]);
		if (DIC_Algo == 0)
			p[1] = 1.0, p[2] = 0.0;
		else
			p[1] = 0.0, p[2] = 0.0, p[3] = 0.0, p[4] = 0.0;
	}

	if (useInitPara)
	{
		if (DIC_Algo == 1)
			p[1] = iWp[0], p[2] = iWp[1], p[3] = iWp[2], p[4] = iWp[3], p[5] = 1.0, p[6] = 0.0;
		else if (DIC_Algo == 3)
			p[2] = iWp[0], p[3] = iWp[1], p[4] = iWp[2], p[5] = iWp[3], p[6] = 1.0, p[7] = 0.0;
	}

	//Now, do the full DIC
	for (p_jump = p_jump_0; p_jump > 0; p_jump -= p_jump_incr)
	{
		DIC_Coeff_min = 1e10;
		bool Break_Flag = false;

		for (k = 0; k < Iter_Max; k++)
		{
			t_1 = 0.0, t_2 = 0.0;
			for (i = 0; i < nn*nn; i++)
				AA[i] = 0.0;
			for (i = 0; i < nn; i++)
				BB[i] = 0.0;

			if (printout)
				fp = fopen("C:/temp/tar.txt", "w+");

			a = p[nn - 2], b = p[nn - 1];
			for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
			{
				for (iii = -hsubset; iii <= hsubset; iii += p_jump)
				{
					if (DIC_Algo == 0)
					{
						II = Target.x + iii + p[0] * direction[0];
						JJ = Target.y + jjj + p[0] * direction[1];
					}
					else if (DIC_Algo == 1) //afine
					{
						II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj;
						JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj;
					}
					else if (DIC_Algo == 2)
					{
						II = Target.x + iii + p[0];
						JJ = Target.y + jjj + p[1];
					}
					else if (DIC_Algo == 3)
					{
						II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj;
						JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
					}

					if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
						continue;

					for (kk = 0; kk < nchannels; kk++)
					{
						Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

						m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
						m_G = S[3 * kk];

						if (printout)
							fprintf(fp, "%.2f ", m_G);

						gx = S[3 * kk + 1], gy = S[3 * kk + 2];
						t_3 = a*m_G + b - m_F;

						t_4 = a, t_5 = t_4*gx, t_6 = t_4*gy;
						if (DIC_Algo == 0)
						{
							CC[0] = t_5*direction[0] + t_6*direction[1];
							CC[1] = m_G, CC[2] = 1.0;
						}
						else if (DIC_Algo == 1)
						{
							CC[0] = t_5*direction[0] + t_6*direction[1];
							CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
							CC[5] = m_G, CC[6] = 1.0;
						}
						else if (DIC_Algo == 2)
						{
							CC[0] = t_5, CC[1] = t_6;
							CC[2] = m_G, CC[3] = 1.0;
						}
						else if (DIC_Algo == 3)
						{
							CC[0] = t_5, CC[1] = t_6;
							CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
							CC[6] = m_G, CC[7] = 1.0;
						}

						for (j = 0; j < nn; j++)
						{
							BB[j] += t_3*CC[j];
							for (i = j; i < nn; i++)
								AA[j*nn + i] += CC[i] * CC[j];
						}

						t_1 += t_3*t_3;
						t_2 += m_F*m_F;
					}
				}
				if (printout)
					fprintf(fp, "\n");
			}
			if (printout)
				fclose(fp);

			DIC_Coeff = t_1 / t_2;

			mat_completeSym(AA, nn);
			QR_Solution_Double(AA, BB, nn, nn);
			for (i = 0; i < nn; i++)
				p[i] -= BB[i];

			if (DIC_Coeff != DIC_Coeff || DIC_Coeff > 50)
			{
				if (createMem)
					delete[]T, delete[]Timg;
				return 0.0;
			}
			if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
			{
				DIC_Coeff_min = DIC_Coeff;
				for (i = 0; i < nn; i++)
					p_best[i] = p[i];
				if (p[0] != p[0])
				{
					if (createMem)
						delete[]T, delete[]Timg;
					return 0.0;
				}
			}

			if (DIC_Algo <= 1)
			{
				if (abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
				{
					if (createMem)
						delete[]T, delete[]Timg;
					return 0.0;
				}
				if (fabs(BB[0]) < conv_crit_1)
				{
					for (i = 1; i < nn - nExtraParas; i++)
						if (fabs(BB[i]) > conv_crit_2)
							break;
					if (i == nn - nExtraParas)
						Break_Flag = true;
				}
			}
			else
			{
				if (abs(p[0]) > hsubset || abs(p[1]) > hsubset)
				{
					if (createMem)
					{
						delete[]T;
						delete[]Timg;
					}
					return 0.0;
				}
				if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
				{
					for (i = 2; i < nn - nExtraParas; i++)
					{
						if (fabs(BB[i]) > conv_crit_2)
							break;
					}
					if (i == nn - nExtraParas)
						Break_Flag = true;
				}
			}

			if (Break_Flag)
				break;
		}
		_iter += k;
		// In case the iteration converges to "wrong" points, always use the data that lead to the least-square value.
		for (i = 0; i < nn; i++)
			p[i] = p_best[i];
	}

	//Quadratic if needed:
	if (DIC_Algo2 > 3)
	{
		DIC_Algo = DIC_Algo2, nn = NN[DIC_Algo];
		if (DIC_Algo == 4)
		{
			p[7] = p[5], p[8] = p[6];
			for (i = 5; i < 7; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 5)
		{
			p[11] = p[5], p[12] = p[6];
			for (i = 5; i < 11; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 6)
		{
			p[8] = p[6], p[9] = p[7];
			for (i = 6; i < 8; i++)
				p[i] = 0.0;
		}
		else if (DIC_Algo == 7)
		{
			p[12] = p[6], p[13] = p[7];
			for (i = 6; i < 12; i++)
				p[i] = 0.0;
		}

		//p_jump_0 = 1;
		for (p_jump = p_jump_0; p_jump > 0; p_jump -= p_jump_incr)
		{
			DIC_Coeff_min = 1e10;
			bool Break_Flag = false;

			for (k = 0; k < Iter_Max; k++)
			{
				t_1 = 0.0, t_2 = 0.0;
				for (i = 0; i < nn*nn; i++)
					AA[i] = 0.0;
				for (i = 0; i < nn; i++)
					BB[i] = 0.0;

				a = p[nn - 2], b = p[nn - 1];

				if (printout)
					fp = fopen("C:/temp/tar.txt", "w+");

				for (jjj = -hsubset; jjj <= hsubset; jjj += p_jump)
				{
					for (iii = -hsubset; iii <= hsubset; iii += p_jump)
					{
						if (DIC_Algo == 4) //irregular
						{
							ij = iii*jjj;
							II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij;
							JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij;
						}
						else if (DIC_Algo == 5) //Quadratic
						{
							ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
							II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij + p[7] * i2 + p[8] * j2;
							JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij + p[9] * i2 + p[10] * j2;
						}
						else if (DIC_Algo == 6)
						{
							ij = iii*jjj;
							II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij;
							JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij;
						}
						else if (DIC_Algo == 7)
						{
							ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
							II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij + p[8] * i2 + p[9] * j2;
							JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij + p[10] * i2 + p[11] * j2;
						}

						if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
							continue;

						for (kk = 0; kk < nchannels; kk++)
						{
							Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, 0, Interpolation_Algorithm);

							m_F = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
							m_G = S[3 * kk];

							if (printout)
								fprintf(fp, "%.2f ", m_G);

							gx = S[3 * kk + 1], gy = S[3 * kk + 2];
							t_3 = a*m_G + b - m_F;

							t_4 = a, t_5 = t_4*gx, t_6 = t_4*gy;
							if (DIC_Algo == 4) //irregular
							{
								CC[0] = t_5*direction[0] + t_6*direction[1];
								CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
								CC[5] = t_5*ij, CC[6] = t_6*ij;
								CC[7] = m_G, CC[8] = 1.0;
							}
							else if (DIC_Algo == 5) //Quadratic
							{
								CC[0] = t_5*direction[0] + t_6*direction[1];
								CC[1] = t_5*iii, CC[2] = t_5*jjj, CC[3] = t_6*iii, CC[4] = t_6*jjj;
								CC[5] = t_5*ij, CC[6] = t_6*ij, CC[7] = t_5*i2, CC[8] = t_5*j2, CC[9] = t_6*i2, CC[10] = t_6*j2;
								CC[11] = m_G, CC[12] = 1.0;
							}
							else if (DIC_Algo == 6)  //irregular
							{
								CC[0] = t_5, CC[1] = t_6;
								CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
								CC[6] = t_5*ij, CC[7] = t_6*ij;
								CC[8] = m_G, CC[9] = 1.0;
							}
							else if (DIC_Algo == 7)
							{
								CC[0] = t_5, CC[1] = t_6;
								CC[2] = t_5*iii, CC[3] = t_5*jjj, CC[4] = t_6*iii, CC[5] = t_6*jjj;
								CC[6] = t_5*ij, CC[7] = t_6*ij, CC[8] = t_5*i2, CC[9] = t_5*j2, CC[10] = t_6*i2, CC[11] = t_6*j2;
								CC[12] = m_G, CC[13] = 1.0;
							}

							for (j = 0; j < nn; j++)
							{
								BB[j] += t_3*CC[j];
								for (i = j; i < nn; i++)
									AA[j*nn + i] += CC[i] * CC[j];
							}

							t_1 += t_3*t_3, t_2 += m_F*m_F;
						}
					}
					if (printout)
						fprintf(fp, "\n");
				}
				if (printout)
					fclose(fp);

				DIC_Coeff = t_1 / t_2;
				mat_completeSym(AA, nn);
				QR_Solution_Double(AA, BB, nn, nn);
				for (i = 0; i < nn; i++)
					p[i] -= BB[i];

				if (DIC_Coeff < DIC_Coeff_min)	// If the iteration does not converge, this can be helpful
				{
					DIC_Coeff_min = DIC_Coeff;
					for (i = 0; i < nn; i++)
						p_best[i] = p[i];
					if (p[0] != p[0])
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
				}

				if (DIC_Algo <= 1)
				{
					if (abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
					if (fabs(BB[0]) < conv_crit_1)
					{
						for (i = 1; i < nn - nExtraParas; i++)
							if (fabs(BB[i]) > conv_crit_2)
								break;
						if (i == nn - nExtraParas)
							Break_Flag = true;
					}
				}
				else
				{
					if (abs(p[0]) > hsubset || abs(p[1]) > hsubset)
					{
						if (createMem)
							delete[]T, delete[]Timg;
						return 0.0;
					}
					if (fabs(BB[0]) < conv_crit_1 && fabs(BB[1]) < conv_crit_1)
					{
						for (i = 2; i < nn - nExtraParas; i++)
							if (fabs(BB[i]) > conv_crit_2)
								break;
						if (i == nn - nExtraParas)
							Break_Flag = true;
					}
				}
				if (Break_Flag)
					break;
			}
			_iter += k;
			// In case the iteration converges to "wrong" points, always use the data that lead to the least-square value.
			for (i = 0; i < nn; i++)
				p[i] = p_best[i];
		}
	}
	/// DIC Iteration: End

	//Now, dont really trust the pssad error too much, compute zncc score instead! They are usually close on convergence, but in case of trouble, zncc is more reliable.
	if (DIC_Coeff_min < pssdabThresh)
	{
		int m = 0;
		double t_1, t_2, t_3, t_4, t_5, t_f = 0.0, t_g = 0.0;
		if (printout)
			fp = fopen("C:/temp/tar.txt", "w+");
		for (jjj = -hsubset; jjj <= hsubset; jjj++)
		{
			for (iii = -hsubset; iii <= hsubset; iii++)
			{
				if (DIC_Algo == 0)
					II = Target.x + iii + p[0] * direction[0], JJ = Target.y + jjj + p[0] * direction[1];
				else if (DIC_Algo == 1)
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj, JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj;
				else if (DIC_Algo == 2)
					II = Target.x + iii + p[0], JJ = Target.y + jjj + p[1];
				else if (DIC_Algo == 3)
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj;
				else if (DIC_Algo == 4) //irregular
				{
					ij = iii*jjj;
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij;
					JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij;
				}
				else if (DIC_Algo == 5) //Quadratic
				{
					ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
					II = Target.x + iii + p[0] * direction[0] + p[1] * iii + p[2] * jjj + p[5] * ij + p[7] * i2 + p[8] * j2;
					JJ = Target.y + jjj + p[0] * direction[1] + p[3] * iii + p[4] * jjj + p[6] * ij + p[9] * i2 + p[10] * j2;
				}
				else if (DIC_Algo == 6)
				{
					ij = iii*jjj;
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij, JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij;
				}
				else if (DIC_Algo == 7)
				{
					ij = iii*jjj, i2 = iii*iii, j2 = jjj*jjj;
					II = Target.x + iii + p[0] + p[2] * iii + p[3] * jjj + p[6] * ij + p[8] * i2 + p[9] * j2;
					JJ = Target.y + jjj + p[1] + p[4] * iii + p[5] * jjj + p[7] * ij + p[10] * i2 + p[11] * j2;
				}

				if (II<0.0 || II>(double)(width2 - 1) - (1e-10) || JJ<0.0 || JJ>(double)(height2 - 1) - (1e-10))
					continue;

				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Img2Para + kk*length2, width2, height2, II, JJ, S + 3 * kk, -1, Interpolation_Algorithm);
					if (printout)
						fprintf(fp, "%.4f ", S[3 * kk]);

					T[2 * m] = Timg[(iii + hsubset) + (jjj + hsubset)*TimgS + kk*Tlength];
					T[2 * m + 1] = S[3 * kk];
					t_f += T[2 * m];
					t_g += T[2 * m + 1];
					m++;
				}
			}
			if (printout)
				fprintf(fp, "\n");
		}
		if (printout)
			fclose(fp);

		t_f = t_f / m, t_g = t_g / m;
		t_1 = 0.0, t_2 = 0.0, t_3 = 0.0;
		for (i = 0; i < m; i++)
		{
			t_4 = T[2 * i] - t_f, t_5 = T[2 * i + 1] - t_g;
			t_1 += 1.0*t_4*t_5, t_2 += 1.0*t_4*t_4, t_3 += 1.0*t_5*t_5;
		}

		t_2 = sqrt(t_2*t_3);
		if (t_2 < 1e-10)
			t_2 = 1e-10;

		DIC_Coeff_min = t_1 / t_2; //This is the zncc score
		if (abs(DIC_Coeff_min) > 1.0)
			DIC_Coeff_min = 0.0;
	}

	if (createMem)
	{
		delete[]Timg;
		delete[]T;
	}
	if (DIC_Coeff_min > 1.0)
		return 0.0;

	if (DIC_Algo <= 1)
	{
		if (DIC_Coeff_min< znccThresh || p[0] != p[0] || abs(p[0] * direction[0]) > hsubset || abs(p[1] * direction[0]) > hsubset)
			return DIC_Coeff_min;
	}
	else
	{
		if (DIC_Coeff_min< znccThresh || p[0] != p[0] || p[1] != p[1] || abs(p[0]) > 2.0*hsubset || abs(p[1]) > 2.0*hsubset)
			return DIC_Coeff_min;
	}

	if (useInitPara)
	{
		if (DIC_Algo == 1 || DIC_Algo == 4 || DIC_Algo == 5)
			iWp[0] = p[1], iWp[1] = p[2], iWp[2] = p[3], iWp[3] = p[4];
		else if (DIC_Algo == 3 || DIC_Algo == 6 || DIC_Algo == 7)
			iWp[0] = p[2], iWp[1] = p[3], iWp[2] = p[4], iWp[3] = p[5];
	}

	if (DIC_Algo < 2 || (DIC_Algo>3 && DIC_Algo < 6))
		Target.x += p[0] * direction[0], Target.y += p[0] * direction[1];
	else
		Target.x += p[0], Target.y += p[1];

	return DIC_Coeff_min;
}
int SparsePointTrackingDriver(char *Path, vector<Point2d> &Tracks, vector<float*> &ImgPara, int viewID, int startF, int stopF, LKParameters LKArg, int &width, int &height, int nchannels)
{
	char Fname[200];

	Mat view;
	char *Img = 0;
	float *sImg = 0;
	if (ImgPara.size() < 3)
	{
		for (int ii = startF; ii <= startF + 1; ii++)//Load the 1st 2 images
		{
			sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, ii, ii, viewID);
			Mat view = imread(Fname, nchannels == 1 ? 0 : 1);
			if (view.data == NULL)
			{
				cout << "Cannot load: " << Fname << endl;
				delete[]Img;
				return 1;
			}
			width = view.cols, height = view.rows;
			int length = width *height*nchannels;
			if (Img == NULL)
				Img = new char[length];
			if (sImg == NULL)
				sImg = new float[length];
			for (int ii = 0; ii < length; ii++)
				Img[ii] = view.data[ii];
			Gaussian_smooth(Img, sImg, height, width, 255.0, 1.0);

			float *Para = new float[width*height*nchannels];
			Generate_Para_Spline(sImg, Para, width, height, LKArg.InterpAlgo);
			ImgPara.push_back(Para);
		}
	}

	//Track:
	int hsubset = LKArg.hsubset + LKArg.nscales * LKArg.scaleStep, orghsubset = LKArg.hsubset;
	int TimgS = 2 * hsubset + 1, Tlength = TimgS*TimgS;
	double *Timg = new double[Tlength*nchannels];
	double *T = new double[2 * Tlength*nchannels];

	double bestDistance = 100;
	Point2d bestfPt;
	for (int st = 0; st < LKArg.nscales; st++)
	{
		LKArg.hsubset = orghsubset + st*LKArg.scaleStep;

		//Forward
		Point2d fPt = Tracks[0];
		double score1 = SearchLK(Tracks[0], fPt, ImgPara[0], ImgPara[1], nchannels, width, height, width, height, LKArg, Timg, T);

		//Backward
		Point2d bPt = fPt;
		double score2 = SearchLK(fPt, bPt, ImgPara[1], ImgPara[0], nchannels, width, height, width, height, LKArg, Timg, T);

		double distance = sqrt(pow(bPt.x - Tracks[0].x, 2) + pow(bPt.y - Tracks[0].y, 2));
		if (distance < bestDistance && score1>0.0 && score2 > 0.0)
		{
			bestfPt = fPt;
			bestDistance = distance;
		}
	}

	if (bestDistance > LKArg.DisplacementThresh)//drifted
	{
		delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
		return 0;
	}
	else
		Tracks.push_back(bestfPt);

	for (int ii = startF + 2; ii <= stopF; ii++)
	{
		printf("%d .. ", ii);
		if (ImgPara.size() < ii - startF + 1)
		{
			//sprintf(Fname, "%s/%d.png", Path, ii);
			sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, ii, ii, viewID);
			Mat view = imread(Fname, nchannels == 1 ? 0 : 1);
			if (view.data == NULL)
			{
				cout << "Cannot load: " << Fname << endl;
				delete[]Img, delete[]Timg, delete[]T;
				return 1;
			}
			width = view.cols, height = view.rows;
			int length = width *height*nchannels;
			if (Img == NULL)
				Img = new char[length];
			if (sImg == NULL)
				sImg = new float[length];
			for (int ii = 0; ii < length; ii++)
				Img[ii] = view.data[ii];
			Gaussian_smooth(Img, sImg, height, width, 255.0, 1.0);

			float *Para = new float[width*height*nchannels];
			Generate_Para_Spline(sImg, Para, width, height, LKArg.InterpAlgo);
			ImgPara.push_back(Para);
		}

		//Run tracking
		bestDistance = 999.0;
		int currentTimeId = ii - startF - 1;
		for (int st = 0; st < LKArg.nscales; st++)
		{
			LKArg.hsubset = orghsubset + st*LKArg.scaleStep;

			//Forward
			Point2d fPt = Tracks[currentTimeId];
			double score1 = SearchLK(Tracks[currentTimeId], fPt, ImgPara[currentTimeId], ImgPara[currentTimeId + 1], nchannels, width, height, width, height, LKArg, Timg, T);

			//Backward
			Point2d bPt = fPt;
			double score2 = SearchLK(fPt, bPt, ImgPara[currentTimeId + 1], ImgPara[currentTimeId], nchannels, width, height, width, height, LKArg, Timg, T);

			double distance = sqrt(pow(bPt.x - Tracks[currentTimeId].x, 2) + pow(bPt.y - Tracks[currentTimeId].y, 2));
			if (distance < bestDistance && score1>0.0 && score2 > 0.0)
			{
				bestfPt = fPt;
				bestDistance = distance;
			}
		}
		if (bestDistance > LKArg.DisplacementThresh)
		{
			delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
			return 0;
		}
		else
			Tracks.push_back(bestfPt);
	}

	delete[]Img, delete[]sImg, delete[]Timg, delete[]T;
	return 0;
}
//The fisheye camera is parameterized using 12 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, 2 for distortion center, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2f> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrectionPoint(vector<Point2d> &Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double omega, double DistCtrX, double DistCtrY, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeDistortionPoint(vector<Point2d>&Points, double omega, double DistCtrX, double DistCtrY)
{
	double x, y, ru, rd, x_u, y_u, t;
	int npts = Points.size();
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		x = Points[iPoint].x - DistCtrX, y = Points[iPoint].y - DistCtrY;
		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;
		Points[iPoint].x = x_u + DistCtrX, Points[iPoint].y = y_u + DistCtrY;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double omega, double DistCtrX, double DistCtrY, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int length = width*height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (int kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}



	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };

	omp_set_num_threads(omp_get_max_threads());
#pragma omp parallel for
	for (int jj = 0; jj < Mheight; jj++)
	{
		for (int ii = 0; ii < Mwidth; ii++)
		{
			double S[3];
			Point2d ImgPt(H[0] * ii + H[1] * jj + H[2], H[3] * ii + H[4] * jj + H[5]);

			FishEyeDistortionPoint(&ImgPt, omega, DistCtrX, DistCtrY, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (int kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (int kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The fisheye camera is parameterized using 10 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 1 for omage, and 6 for rotation translation.
void FishEyeCorrectionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x_n, y_n, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x_n = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y_n = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x_n*x_n + y_n*y_n), rd = tan(ru*omega) / 2 / tan(omega / 2);
		t = rd / ru;
		x_u = t*x_n, y_u = t*y_n;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeDistortionPoint(Point2d *Points, double *K, double* invK, double omega, int npts)
{
	double x, y, ru, rd, x_u, y_u, t;
	for (int iPoint = 0; iPoint < npts; iPoint++)
	{
		t = invK[6] * Points[iPoint].x + invK[7] * Points[iPoint].y + invK[8];
		x = (invK[0] * Points[iPoint].x + invK[1] * Points[iPoint].y + invK[2]) / t;
		y = (invK[3] * Points[iPoint].x + invK[4] * Points[iPoint].y + invK[5]) / t;

		ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
		t = rd / ru;
		x_u = t*x, y_u = t*y;

		t = K[6] * x_u + K[7] * y_u + K[8];
		Points[iPoint].x = (K[0] * x_u + K[1] * y_u + K[2]) / t;
		Points[iPoint].y = (K[3] * x_u + K[4] * y_u + K[5]) / t;
	}
}
void FishEyeCorrection(unsigned char *Img, int width, int height, int nchannels, double *K, double* invK, double omega, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width*height, Mwidth = width*ImgMag, Mheight = height*ImgMag, Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}


	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			FishEyeDistortionPoint(&ImgPt, K, invK, omega, 1);
			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

//The camera is parameterized using 16 parameters: 2 for  focal length, 1 for skew, 2 for principal point, 3 for radial distortion, 2 for tangential distortion, 2 for prism, and 6 for rotation translation.
void LensDistortionPoint(Point2d *img_point, double *K, double *distortion, int npts)
{
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void LensDistortionPoint2(Point2d *img_point, double *Intrinsic, double *distortion, int npts)
{
	double alpha = Intrinsic[0], beta = Intrinsic[1], gamma = Intrinsic[2], u0 = Intrinsic[3], v0 = Intrinsic[4];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void LensDistortionPoint(vector<Point2d> &img_point, double *K, double *distortion)
{
	int npts = img_point.size();
	double alpha = K[0], beta = K[4], gamma = K[1], u0 = K[2], v0 = K[5];

	for (int ii = 0; ii < npts; ii++)
	{
		double ycn = (img_point[ii].y - v0) / beta;
		double xcn = (img_point[ii].x - u0 - gamma*ycn) / alpha;

		double r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, X2 = xcn*xcn, Y2 = ycn*ycn, XY = xcn*ycn;

		double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
		double p0 = distortion[3], p1 = distortion[4];
		double s0 = distortion[5], s1 = distortion[6];

		double radial = 1 + a0*r2 + a1*r4 + a2*r6;
		double tangential_x = 2.0*p1*XY + p0*(r2 + 2.0*X2);
		double tangential_y = p1*(r2 + 2.0*Y2) + 2.0*p0*XY;
		double prism_x = s0*r2;
		double prism_y = s1*r2;

		double xcn_ = radial*xcn + tangential_x + prism_x;
		double ycn_ = radial*ycn + tangential_y + prism_y;

		img_point[ii].x = alpha*xcn_ + gamma*ycn_ + u0;
		img_point[ii].y = beta*ycn_ + v0;
	}

	return;
}
void CC_Calculate_xcn_ycn_from_i_j(double i, double j, double &xcn, double &ycn, double *A, double *distortion, int Method)
{
	int k;
	double Xcn, Ycn, r2, r4, r6, x2, y2, xy, x0, y0;
	double radial, tangential_x, tangential_y, prism_x, prism_y;
	double a0 = distortion[0], a1 = distortion[1], a2 = distortion[2];
	double p0 = distortion[3], p1 = distortion[4];
	double s0 = distortion[5], s1 = distortion[6];

	Ycn = (j - A[4]) / A[1];
	Xcn = (i - A[3] - A[2] * Ycn) / A[0];

	xcn = Xcn;
	ycn = Ycn;
	for (k = 0; k < 20; k++)
	{
		x0 = xcn;
		y0 = ycn;
		r2 = xcn*xcn + ycn*ycn, r4 = r2*r2, r6 = r2*r4, x2 = xcn*xcn, y2 = ycn*ycn, xy = xcn*ycn;

		radial = 1.0 + a0*r2 + a1*r4 + a2*r6;
		tangential_x = 2.0*p1*xy + p0*(r2 + 2.0*x2);
		tangential_y = p1*(r2 + 2.0*y2) + 2.0*p0*xy;

		prism_x = s0*r2;
		prism_y = s1*r2;

		xcn = (Xcn - tangential_x - prism_x) / radial;
		ycn = (Ycn - tangential_y - prism_y) / radial;

		if (abs((xcn - x0) / xcn) < 1.0e-9 && abs((ycn - y0) / ycn) < 1.0e-9)
			break;
	}
	return;
}
void LensCorrectionPoint(Point2d *uv, double *K, double *distortion, int npts)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2f> &uv, double *K, double *distortion)
{
	double u, v, xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		u = uv[ii].x, v = uv[ii].y;
		CC_Calculate_xcn_ycn_from_i_j(u, v, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensCorrectionPoint(vector<Point2d> &uv, double *K, double *distortion)
{
	double xcn, ycn, A[] = { K[0], K[4], K[1], K[2], K[5] };

	int npts = uv.size();
	for (int ii = 0; ii < npts; ii++)
	{
		CC_Calculate_xcn_ycn_from_i_j(uv[ii].x, uv[ii].y, xcn, ycn, A, distortion, 0);

		uv[ii].x = A[0] * xcn + A[2] * ycn + A[3];
		uv[ii].y = A[1] * ycn + A[4];
	}

	return;
}
void LensUndistortion(unsigned char *Img, int width, int height, int nchannels, double *K, double *distortion, int intepAlgo, double ImgMag, double Contscale, double *Para)
{
	Contscale = 1.0 / Contscale;
	int ii, jj, kk, length = width*height, Mwidth = (int)(width*ImgMag), Mheight = (int)(height*ImgMag), Mlength = Mwidth*Mheight;
	bool createMem = false;
	if (Para == NULL)
	{
		createMem = true;
		Para = new double[length*nchannels];

		for (kk = 0; kk < nchannels; kk++)
			Generate_Para_Spline(Img + kk*length, Para + kk*length, width, height, intepAlgo);
	}

	double S[3];
	Point2d ImgPt;
	double H[9] = { Contscale, 0, width / 2 - Mwidth / 2 * Contscale, 0, Contscale, height / 2 - Mheight / 2 * Contscale, 0, 0, 1 };
	for (jj = 0; jj < Mheight; jj++)
	{
		for (ii = 0; ii < Mwidth; ii++)
		{
			ImgPt.x = H[0] * ii + H[1] * jj + H[2], ImgPt.y = H[3] * ii + H[4] * jj + H[5];
			LensDistortionPoint(&ImgPt, K, distortion, 1);

			if (ImgPt.x < 0 || ImgPt.x > width - 1 || ImgPt.y<0.0 || ImgPt.y > height - 1)
			{
				for (kk = 0; kk < nchannels; kk++)
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)0;
			}
			else
			{
				for (kk = 0; kk < nchannels; kk++)
				{
					Get_Value_Spline(Para + kk*length, width, height, ImgPt.x, ImgPt.y, S, -1, intepAlgo);
					S[0] = min(max(S[0], 0.0), 255.0);
					Img[ii + jj*Mwidth + kk*Mlength] = (unsigned char)MyFtoI(S[0]);
				}
			}
		}
	}

	if (createMem)
		delete[]Para;

	return;
}

int EssentialMatOutliersRemove(char *Path, int timeID, int id1, int id2, int nCams, int cameraToScan, int ninlierThresh, int distortionCorrected, bool needDuplicateRemove)
{
	CameraData *camera = new CameraData[nCams];
	if (ReadIntrinsicResults(Path, camera) != 0)
		return 1;

	if (distortionCorrected == 1)
		for (int ii = 0; ii < nCams; ii++)
			for (int jj = 0; jj < 7; jj++)
				camera[ii].distortion[jj] = 0.0;

	for (int ii = 0; ii < nCams; ii++)
		camera[ii].threshold = 3.0, camera[ii].ninlierThresh = 50;

	char Fname[200];
	vector<Point2i> RawPairWiseMatchID;
	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < 40)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID);

	if (!ReadKPointsBinarySIFTGPU(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (unsigned int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
		else
			sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1[ii].x = Keys1.at(id1).pt.x, pts1[ii].y = Keys1.at(id1).pt.y;
		pts2[ii].x = Keys2.at(id2).pt.x, pts2[ii].y = Keys2.at(id2).pt.y;
	}

	if (cameraToScan != -1)
	{
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
			LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion, npts);
		}
		if (distortionCorrected == 0 && camera[cameraToScan].LensModel == FISHEYE)
		{
			FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
			FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2], npts);
		}
	}
	else
	{
		if (distortionCorrected == 0 && camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion, npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion, npts);
		if (distortionCorrected == 0 && camera[id1].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2], npts);
		if (distortionCorrected == 0 && camera[id2].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts1, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2], npts);
	}

	Mat x1s(npts, 2, CV_64F), x2s(npts, 2, CV_64F);
	for (int ii = 0; ii < npts; ii++)
	{
		x1s.at<double>(ii, 0) = pts1[ii].x, x1s.at<double>(ii, 1) = pts1[ii].y;
		x2s.at<double>(ii, 0) = pts2[ii].x, x2s.at<double>(ii, 1) = pts2[ii].y;
	}

	double start = omp_get_wtime();
	Mat Inliers, E;
	double ProThresh = 0.95, PercentInlier = 0.2;
	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 5)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	if (cameraToScan != -1)
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[cameraToScan].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold, iterMax, Inliers);
	}
	else
	{
		Mat cvK1 = Mat(3, 3, CV_64F, camera[id1].K);
		Mat cvK2 = Mat(3, 3, CV_64F, camera[id2].K);
		E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, ProThresh, camera[0].threshold, iterMax, Inliers);
	}

	int ninliers = 0;
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			ninliers++;

	if (ninliers < camera[0].ninlierThresh)
	{
#pragma omp critical
		printf("View (%d, %d) fails....%d inliers\n", id1, id2, ninliers);
		return 0;
	}

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, id1, id2);
	fp = fopen(Fname, "w+");	fprintf(fp, "%d\n", ninliers);
	for (int ii = 0; ii < Inliers.cols; ii++)
		if (Inliers.at<bool>(ii))
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
	fclose(fp);

#pragma omp critical
	printf("View (%d, %d) of frame %d...%d matches... %.2fs\n", id1, id2, timeID, ninliers, omp_get_wtime() - start);
	return 0;
}
int FundamentalMatOutliersRemove(char *Path, int timeID, int id1, int id2, int ninlierThresh, int LensType, int distortionCorrected, bool needDuplicateRemove, int nCams, int cameraToScan, int *FrameOffset)
{
	char Fname[200];
	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, id1, id2);
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot find %s\n", Fname);
		return 0;
	}
	fclose(fp);

	bool notCalibrated = false;
	CameraData *camera = new CameraData[nCams];
	if (!ReadIntrinsicResults(Path, camera) != 0)
		notCalibrated = true;

	if (notCalibrated &&distortionCorrected == 0 && LensType == FISHEYE)
		return 1;


	if (FrameOffset == NULL)
	{
		FrameOffset = new int[nCams];
		for (int ii = 0; ii < nCams; ii++)
			FrameOffset[ii] = 0;
	}

	vector<Point2i> RawPairWiseMatchID;
	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, id1, id2);

	int pid1, pid2, npts;
	fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d ", &npts);
	RawPairWiseMatchID.reserve(npts);
	while (fscanf(fp, "%d %d ", &pid1, &pid2) != EOF)
		RawPairWiseMatchID.push_back(Point2i(pid1, pid2));
	fclose(fp);

	if (npts < ninlierThresh)
		return 1;

	vector<KeyPoint> Keys1, Keys2;
	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id1);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id1, timeID + FrameOffset[id1]);

	if (!ReadKPointsBinarySIFTGPU(Fname, Keys1))
		return 1;

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, id2);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, id2, timeID + FrameOffset[id2]);
	if (!ReadKPointsBinarySIFTGPU(Fname, Keys2))
		return 1;

	if (needDuplicateRemove)
	{
		int SortingVec[20000], tId[20000]; //should be more than enough
		vector<Point2i> SRawPairWiseMatchID; SRawPairWiseMatchID.reserve(RawPairWiseMatchID.size());

		//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
		SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(0));
		for (int i = 1; i < min(npts, 20000); i++)
			if (RawPairWiseMatchID.at(i).x != RawPairWiseMatchID.at(i - 1).x)
				SRawPairWiseMatchID.push_back(RawPairWiseMatchID.at(i));

		if (SRawPairWiseMatchID.size() < ninlierThresh)
			return 1;

		//Start sorting
		int nsPairwiseMatchID = SRawPairWiseMatchID.size();
		for (int i = 0; i < min(nsPairwiseMatchID, 20000); i++)
		{
			SortingVec[i] = SRawPairWiseMatchID.at(i).x;
			tId[i] = i;
		}
		Quick_Sort_Int(SortingVec, tId, 0, min(nsPairwiseMatchID, 20000) - 1);

		//Store sorted vector
		RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[0]));
		for (unsigned int i = 1; i < min(nsPairwiseMatchID, 20000); i++)
			if (SortingVec[i] != SortingVec[i - 1])
				RawPairWiseMatchID.push_back(SRawPairWiseMatchID.at(tId[i]));

		npts = RawPairWiseMatchID.size();
		if (npts < ninlierThresh)
			return 1;

		if (timeID < 0)
			sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
		else
			sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, id1, id2);
		fp = fopen(Fname, "w+");
		fprintf(fp, "%d\n", npts);
		for (int ii = 0; ii < npts; ii++)
			fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

	vector<Point2d> pts1, pts2;
	pts1.reserve(npts), pts2.reserve(npts);
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = RawPairWiseMatchID[ii].x, id2 = RawPairWiseMatchID[ii].y;
		pts1.push_back(Point2d(Keys1.at(id1).pt.x, Keys1.at(id1).pt.y));
		pts2.push_back(Point2d(Keys2.at(id2).pt.x, Keys2.at(id2).pt.y));
	}


	if (distortionCorrected == 0 && cameraToScan != -1) //only one camera is used to scan the corpus
	{
		if (camera[cameraToScan].LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			LensCorrectionPoint(pts1, camera[cameraToScan].K, camera[cameraToScan].distortion);
			LensCorrectionPoint(pts2, camera[cameraToScan].K, camera[cameraToScan].distortion);
		}
		else if (camera[cameraToScan].LensModel == FISHEYE)
		{
			FishEyeCorrectionPoint(pts1, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
			FishEyeCorrectionPoint(pts2, camera[cameraToScan].distortion[0], camera[cameraToScan].distortion[1], camera[cameraToScan].distortion[2]);
		}
	}
	else if (distortionCorrected == 0 && !notCalibrated) //multiple cameras are used but they are all calibrated
	{
		if (camera[id1].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts1, camera[id1].K, camera[id1].distortion);
		else if (camera[id1].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts1, camera[id1].distortion[0], camera[id1].distortion[1], camera[id1].distortion[2]);
		if (camera[id2].LensModel == RADIAL_TANGENTIAL_PRISM)
			LensCorrectionPoint(pts2, camera[id2].K, camera[id2].distortion);
		else if (camera[id2].LensModel == FISHEYE)
			FishEyeCorrectionPoint(pts2, camera[id2].distortion[0], camera[id2].distortion[1], camera[id2].distortion[2]);
	}
	else
		;//not fish eye lens, not calibrated, not undistorted.
	delete[]camera;

	//USAC config
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	ConfigParamsFund cfg;
	cfg.common.confThreshold = 0.99, cfg.common.minSampleSize = 7, cfg.common.inlierThreshold = 3.0;
	cfg.common.maxHypotheses = 850000, cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true, cfg.common.prevalidateModel = true, cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM, cfg.common.verifMethod = USACConfig::VERIF_SPRT, cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	if (USEPROSAC)
		cfg.prosac.maxSamples, cfg.prosac.beta, cfg.prosac.nonRandConf, cfg.prosac.minStopLen;
	if (USESPRT)
		cfg.sprt.tM = 200.0, cfg.sprt.mS = 2.38, cfg.sprt.delta = 0.05, cfg.sprt.epsilon = 0.15;
	if (USELOSAC)
		cfg.losac.innerSampleSize = 15, cfg.losac.innerRansacRepetitions = 5, cfg.losac.thresholdMultiplier = 2.0, cfg.losac.numStepsIterative = 4;

	if (notCalibrated)
		cfg.common.inlierThreshold *= 3.0;//;

	int ninliers = 0;
	double Fmat[9];
	vector<int>Inliers; Inliers.reserve(pts1.size());
	cfg.common.numDataPoints = pts1.size();
	USAC_FindFundamentalMatrix(cfg, pts1, pts2, Fmat, Inliers, ninliers);
#pragma omp critical
	if (ninliers < ninlierThresh)
		printf("(%d, %d): failed Fundamental matrix test\n\n", id1, id2);

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, id1, id2);
	else
		sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, id1, id2);
#pragma omp critical
	fp = fopen(Fname, "w+");

	if (ninliers < ninlierThresh)
	{
		fprintf(fp, "%d\n", 0);
		fclose(fp);
	}
	else
	{
		fprintf(fp, "%d\n", ninliers);
		for (int ii = 0; ii < Inliers.size(); ii++)
			if (Inliers[ii] == 1)
				fprintf(fp, "%d %d\n", RawPairWiseMatchID[ii].x, RawPairWiseMatchID[ii].y);
		fclose(fp);
	}

#pragma omp critical
	if (timeID>0)
		printf("(%d, %d) to (%d, %d) ...%d matches...\n", id1, timeID + FrameOffset[id1], id2, timeID + FrameOffset[id2], ninliers);
	else
		printf("%d to  %d ...%d matches...\n", id1, id2, ninliers);

	return 0;
}
static void flannFindPairs(const CvSeq*objectKpts, const CvSeq* objectDescriptors, const CvSeq*imageKpts, const CvSeq* imageDescriptors, vector<int>& ptpairs)
{
	int length = (int)(objectDescriptors->elem_size / sizeof(float));

	cv::Mat m_object(objectDescriptors->total, length, CV_32F);
	cv::Mat m_image(imageDescriptors->total, length, CV_32F);


	// copy descriptors
	CvSeqReader obj_reader;
	float* obj_ptr = m_object.ptr<float>(0);
	cvStartReadSeq(objectDescriptors, &obj_reader);
	for (int i = 0; i < objectDescriptors->total; i++)
	{
		const float* descriptor = (const float*)obj_reader.ptr;
		CV_NEXT_SEQ_ELEM(obj_reader.seq->elem_size, obj_reader);
		memcpy(obj_ptr, descriptor, length*sizeof(float));
		obj_ptr += length;
	}
	CvSeqReader img_reader;
	float* img_ptr = m_image.ptr<float>(0);
	cvStartReadSeq(imageDescriptors, &img_reader);
	for (int i = 0; i < imageDescriptors->total; i++)
	{
		const float* descriptor = (const float*)img_reader.ptr;
		CV_NEXT_SEQ_ELEM(img_reader.seq->elem_size, img_reader);
		memcpy(img_ptr, descriptor, length*sizeof(float));
		img_ptr += length;
	}

	// find nearest neighbors using FLANN
	cv::Mat m_indices(objectDescriptors->total, 2, CV_32S);
	cv::Mat m_dists(objectDescriptors->total, 2, CV_32F);
	cv::flann::Index flann_index(m_image, cv::flann::KDTreeIndexParams(4));  // using 4 randomized kdtrees
	flann_index.knnSearch(m_object, m_indices, m_dists, 2, cv::flann::SearchParams(64)); // maximum number of leafs checked

	int* indices_ptr = m_indices.ptr<int>(0);
	float* dists_ptr = m_dists.ptr<float>(0);
	for (int i = 0; i < m_indices.rows; ++i) {
		if (dists_ptr[2 * i] < 0.6*dists_ptr[2 * i + 1]) {
			ptpairs.push_back(i);
			ptpairs.push_back(indices_ptr[2 * i]);
		}
	}
}
int GeneratePointsCorrespondenceMatrix(char *Path, int nviews, int timeID)
{
	char Fname[200];
	FILE *fp = 0;
	int ii, jj;

	bool BinaryDesc = false;

	int minHessian = 400, descriptorSize = 128;
	SiftFeatureDetector detector(MAXSIFTPTS);
	SiftDescriptorExtractor extractor;

	Mat img, imgGray, equalizedImg;
	vector<int> cumulativePts;

	omp_set_num_threads(omp_get_max_threads());

	int *PtsPerView = new int[nviews];
	double start = omp_get_wtime();
#pragma omp parallel for
	for (int ii = 0; ii < nviews; ii++)
	{
		char Fname[200];
		if (timeID < 0)
			sprintf(Fname, "%s/S/%d.png", Path, ii);
		else
			sprintf(Fname, "%s/%d/%d.png", Path, ii, timeID);
		Mat img = imread(Fname, CV_LOAD_IMAGE_COLOR);
		if (img.empty())
		{
			printf("Can't read %s\n", Fname);
			continue;
		}

		//cvtColor(img, imgGray, CV_BGR2GRAY);
		////equalizeHist(imgGray, equalizedImg);

		double start = omp_get_wtime();

		vector<KeyPoint> keypoints; keypoints.reserve(MAXSIFTPTS);
		Mat descriptors(MAXSIFTPTS, descriptorSize, CV_32F);
		detector.detect(img, keypoints);
		extractor.compute(img, keypoints, descriptors);

#pragma omp critical
		{
			if (timeID < 0)
			{
				sprintf(Fname, "%s/K%d.dat", Path, ii), WriteKPointsBinary(Fname, keypoints, false);
				sprintf(Fname, "%s/D%d.dat", Path, ii), WriteDescriptorBinary(Fname, descriptors, false);
			}
			else
			{
				sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID), WriteKPointsBinary(Fname, keypoints, false);
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID), WriteDescriptorBinary(Fname, descriptors, false);
			}
			printf("Obtain %d points for view %d frame %d  ... wrote to files. Take %.2fs\n", keypoints.size(), ii + 1, timeID, omp_get_wtime() - start);
		}

		PtsPerView[ii] = keypoints.size();
	}
	printf("Finished extracting feature points ... in %.2fs\n", omp_get_wtime() - start);

	int totalPts = 0;
	for (int ii = 0; ii < nviews; ii++)
	{
		cumulativePts.push_back(totalPts);
		totalPts += PtsPerView[ii];
	}
	cumulativePts.push_back(totalPts);

	if (timeID < 0)
		sprintf(Fname, "%s/CumlativePoints.txt", Path);
	else
		sprintf(Fname, "%s/CumlativePoints_%d.txt", Path, timeID);
	fp = fopen(Fname, "w+");
	for (ii = 0; ii < cumulativePts.size(); ii++)
		fprintf(fp, "%d\n", cumulativePts[ii]);
	fclose(fp);

	// NEAREST NEIGHBOR MATCHING USING FLANN LIBRARY :  match descriptor2 to descriptor1
	vector<int> *MatchingMatrix = new vector<int>[totalPts];

	bool useBFMatcher = false; // SET TO TRUE TO USE BRUTE FORCE MATCHER
	const int knn = 2, ntrees = 4, maxLeafCheck = 128;
	const float nndrRatio = 0.6f;

	start = omp_get_wtime();
	printf("Running feature matching...\n");
	Mat descriptors1;
	for (int jj = 0; jj < nviews - 1; jj++)
	{
		if (timeID < 0)
			sprintf(Fname, "%s/D%d.dat", Path, jj);
		else
			sprintf(Fname, "%s/%d/D%d.dat", Path, jj, timeID);
		descriptors1 = ReadDescriptorBinary(Fname, descriptorSize);
		if (descriptors1.empty())
			continue;

#pragma omp parallel for
		for (int ii = jj + 1; ii < nviews; ii++)
		{
			char Fname[200];
			if (timeID < 0)
				sprintf(Fname, "%s/D%d.dat", Path, ii);
			else
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID);
			Mat descriptors2 = ReadDescriptorBinary(Fname, descriptorSize);
			if (descriptors2.empty())
				continue;

			double start = omp_get_wtime();
			//Finding nearest neighbor
			Mat indices, dists;
			vector<vector<DMatch> > matches;
			if (BinaryDesc)
			{
				//printf("Binary descriptors detected...\n");// ORB, Brief, BRISK, FREAK
				if (useBFMatcher)
				{
					cv::BFMatcher matcher(cv::NORM_HAMMING); // use cv::NORM_HAMMING2 for ORB descriptor with WTA_K == 3 or 4 (see ORB constructor)
					matcher.knnMatch(descriptors2, descriptors1, matches, knn);
				}
				else
				{
					// Create Flann LSH index
					cv::flann::Index flannIndex(descriptors1, cv::flann::LshIndexParams(12, 20, 2), cvflann::FLANN_DIST_HAMMING);
					flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams());
				}
			}
			else
			{
				if (useBFMatcher)
				{
					cv::BFMatcher matcher(cv::NORM_L2);
					matcher.knnMatch(descriptors2, descriptors1, matches, knn);
				}
				else
				{
					// Create Flann KDTree index
					cv::flann::Index flannIndex(descriptors1, cv::flann::KDTreeIndexParams(ntrees));//, cvflann::FLANN_DIST_EUCLIDEAN);
					flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams(maxLeafCheck));
				}
			}

			// Find correspondences by NNDR (Nearest Neighbor Distance Ratio)
			int count = 0;
			if (!useBFMatcher)
			{
				for (int i = 0; i < descriptors2.rows; ++i)
				{
					//printf("q=%d dist1=%f dist2=%f\n", i, dists.at<float>(i,0), dists.at<float>(i,1));
					int ind1 = indices.at<int>(i, 0);
					if (indices.at<int>(i, 0) >= 0 && indices.at<int>(i, 1) >= 0 && dists.at<float>(i, 0) <= nndrRatio * dists.at<float>(i, 1))
					{
						MatchingMatrix[cumulativePts.at(jj) + ind1].push_back(cumulativePts[ii] + i);
						count++;
					}
				}
			}
			else
			{
				for (unsigned int i = 0; i < matches.size(); ++i)
				{
					//printf("q=%d dist1=%f dist2=%f\n", matches.at(i).at(0).queryIdx, matches.at(i).at(0).distance, matches.at(i).at(1).distance);
					if (matches.at(i).size() == 2 && matches.at(i).at(0).distance <= nndrRatio * matches.at(i).at(1).distance)
					{
						MatchingMatrix[cumulativePts.at(jj) + matches.at(i).at(0).trainIdx].push_back(cumulativePts[ii] + i);
						count++;
					}
				}
			}
#pragma omp critical
			printf("Matching view %d to view %d of frame %d has %d points in %.2fs.\n", jj + 1, ii + 1, timeID, count, omp_get_wtime() - start);
		}
	}
	printf("Finished matching feature points ... in %.2fs\n", omp_get_wtime() - start);

	if (timeID < 0)
		sprintf(Fname, "%s/PM.txt", Path);
	else
		sprintf(Fname, "%s/PM_%d.txt", Path, timeID);
	fp = fopen(Fname, "w+");
	if (fp != NULL)
	{
		for (jj = 0; jj < totalPts; jj++)
		{
			int nmatches = MatchingMatrix[jj].size();
			fprintf(fp, "%d ", nmatches);
			sort(MatchingMatrix[jj].begin(), MatchingMatrix[jj].end());
			for (ii = 0; ii < nmatches; ii++)
				fprintf(fp, "%d ", MatchingMatrix[jj][ii]);
			fprintf(fp, "\n");
		}
		fclose(fp);
	}
	printf("Finished generateing point correspondence matrix\n");

	delete[]MatchingMatrix;

	return 0;
}
int ExtractSiftGPUfromExtractedFrames(char *Path, vector<int> &nviews, int startF, int stopF, int increF, int HistogramEqual)
{
	// Allocation size to the largest width and largest height 1920x1080
	// Maximum working dimension. All the SIFT octaves that needs a larger texture size will be skipped. maxd = 2560 <-> 768MB of graphic memory. 
	char * argv[] = { "-fo", "-1", "-v", "0", "-p", "1920x1080", "-maxd", "4096" };
	//-fo -1    staring from -1 octave 
	//-v 1      only print out # feature and overall time
	//-loweo    add a (.5, .5) offset
	//-tc <num> set a soft limit to number of detected features
	//-m,       up to 2 orientations for each feature (change to single orientation by using -m 1)
	//-s        enable subpixel subscale (disable by using -s 0)
	//"-cuda", "[device_id]"  : cuda implementation (fastest for smaller images). CUDA-implementation allows you to create multiple instances for multiple threads. Checkout src\TestWin\MultiThreadSIFT
	// "-Display", "display_name" (for OPENGL) to select monitor/GPU (XLIB/GLUT) on windows the display name would be something like \\.\DISPLAY4
	//Only the following parameters can be changed after initialization (by calling ParseParam):-dw, -ofix, -ofix-not, -fo, -unn, -maxd, -b
	//to change other parameters at runtime, you need to first unload the dynamically loaded libaray reload the libarary, then create a new siftgpu instance

	//Init SiftGPU: START
#ifdef _WIN32
#ifdef _DEBUG
	HMODULE  hsiftgpu = LoadLibrary("siftgpu_d.dll");
#else
	HMODULE  hsiftgpu = LoadLibrary("siftgpu.dll");
#endif
#else
	void * hsiftgpu = dlopen("libsiftgpu.so", RTLD_LAZY);
#endif

	if (hsiftgpu == NULL)
		return 0;

	SiftGPU* (*pCreateNewSiftGPU)(int) = NULL;
	SiftMatchGPU* (*pCreateNewSiftMatchGPU)(int) = NULL;
	pCreateNewSiftGPU = (SiftGPU* (*) (int)) GET_MYPROC(hsiftgpu, "CreateNewSiftGPU");
	pCreateNewSiftMatchGPU = (SiftMatchGPU* (*)(int)) GET_MYPROC(hsiftgpu, "CreateNewSiftMatchGPU");
	SiftGPU* sift = pCreateNewSiftGPU(1);

	int argc = sizeof(argv) / sizeof(char*);
	sift->ParseParam(argc, argv);
	if (sift->CreateContextGL() != SiftGPU::SIFTGPU_FULL_SUPPORTED)
		return 0;
	//Init SiftGPU: END

	//SIFT DECTION: START
	int numKeys, descriptorSize = SIFTBINS;
	vector<float > descriptors; descriptors.reserve(MAXSIFTPTS * descriptorSize);
	vector<SiftGPU::SiftKeypoint> keys; keys.reserve(MAXSIFTPTS);
	vector<Point3i> Vrgb; Vrgb.reserve(MAXSIFTPTS);

	Mat cvImg, equalizedImg;
	char Fname[200];
	double start = omp_get_wtime();
	for (int frameID = startF; frameID <= stopF; frameID += increF)
	{
		for (int ii = 0; ii < nviews.size(); ii++)
		{
			int viewID = nviews[ii];
			keys.clear(), descriptors.clear();
			double start = omp_get_wtime();

			if (frameID < 0)
				sprintf(Fname, "%s/%d.png", Path, viewID);
			else
				sprintf(Fname, "%s/%d/%d.png", Path, viewID, frameID);
			if (HistogramEqual == 1)
			{
				cvImg = imread(Fname, 0);
				equalizeHist(cvImg, equalizedImg);

				if (frameID < 0)
					sprintf(Fname, "%s/H_%d.png", Path, viewID);
				else
					sprintf(Fname, "%s/%d/H_%d.png", Path, viewID, frameID);
				imwrite(Fname, equalizedImg);
			}

			if (sift->RunSIFT(Fname)) //You can have at most one OpenGL-based SiftGPU (per process)--> no omp can be used
			{
				numKeys = sift->GetFeatureNum();
				keys.resize(numKeys);    descriptors.resize(descriptorSize * numKeys);
				sift->GetFeatureVector(&keys[0], &descriptors[0]);

				//Getting color info
				Vrgb.clear();
				if (frameID < 0)
					sprintf(Fname, "%s/%d.png", Path, viewID);
				else
					sprintf(Fname, "%s/%d/%d.png", Path, viewID, frameID);
				cvImg = imread(Fname, IMREAD_COLOR);
				for (int kk = 0; kk < numKeys; kk++)
				{
					int x = (int)keys.at(kk).x, y = (int)keys.at(kk).y;
					int id = x + y*cvImg.cols;
					Point3i rgb;
					rgb.z = cvImg.data[3 * id + 0];//b
					rgb.y = cvImg.data[3 * id + 1];//g
					rgb.x = cvImg.data[3 * id + 2];//r
					Vrgb.push_back(rgb);
				}

				sprintf(Fname, "%s/%d/K%d.dat", Path, viewID, frameID); WriteKPointsBinarySIFTGPU(Fname, keys);
				sprintf(Fname, "%s/%d/RGB%d.dat", Path, viewID, frameID); WriteRGBBinarySIFTGPU(Fname, Vrgb);
				sprintf(Fname, "%s/%d/D%d.dat", Path, viewID, frameID); WriteDescriptorBinarySIFTGPU(Fname, descriptors);
				printf("View (%d, %d): %d points ... Wrote to files. Take %.2fs\n", viewID, frameID, numKeys, omp_get_wtime() - start);
			}
			else
				printf("Cannot load %s", Fname);
		}
	}
	printf("Total time: %.2fs\n", omp_get_wtime() - start);

	return 0;
}

//Use GPU for brute force Sift matching
int SiftGPUPair(char *Path, char *Fname1, char *Fname2, float nndrRatio, int timeID, double density, bool flipCoordinate)
{
	// Allocation size to the largest width and largest height 1920x1080
	// Maximum working dimension. All the SIFT octaves that needs a larger texture size will be skipped. maxd = 2560 <-> 768MB of graphic memory. 
	char * argv[] = { "-fo", "-1", "-v", "0", "-p", "1920x1080", "-maxd", "3200" };
	//-fo -1    staring from -1 octave 
	//-v 1      only print out # feature and overall time
	//-loweo    add a (.5, .5) offset
	//-tc <num> set a soft limit to number of detected features
	//-m,       up to 2 orientations for each feature (change to single orientation by using -m 1)
	//-s        enable subpixel subscale (disable by using -s 0)
	//"-cuda", "[device_id]"  : cuda implementation (fastest for smaller images). CUDA-implementation allows you to create multiple instances for multiple threads. Checkout src\TestWin\MultiThreadSIFT
	// "-Display", "display_name" (for OPENGL) to select monitor/GPU (XLIB/GLUT) on windows the display name would be something like \\.\DISPLAY4
	//Only the following parameters can be changed after initialization (by calling ParseParam):-dw, -ofix, -ofix-not, -fo, -unn, -maxd, -b
	//to change other parameters at runtime, you need to first unload the dynamically loaded libaray reload the libarary, then create a new siftgpu instance

	//Init SiftGPU: START
#ifdef _WIN32
#ifdef _DEBUG
	HMODULE  hsiftgpu = LoadLibrary("siftgpu_d.dll");
#else
	HMODULE  hsiftgpu = LoadLibrary("siftgpu.dll");
#endif
#else
	void * hsiftgpu = dlopen("libsiftgpu.so", RTLD_LAZY);
#endif

	if (hsiftgpu == NULL)
		return 0;

	SiftGPU* (*pCreateNewSiftGPU)(int) = NULL;
	SiftMatchGPU* (*pCreateNewSiftMatchGPU)(int) = NULL;
	pCreateNewSiftGPU = (SiftGPU* (*) (int)) GET_MYPROC(hsiftgpu, "CreateNewSiftGPU");
	pCreateNewSiftMatchGPU = (SiftMatchGPU* (*)(int)) GET_MYPROC(hsiftgpu, "CreateNewSiftMatchGPU");
	SiftGPU* sift = pCreateNewSiftGPU(1);

	int argc = sizeof(argv) / sizeof(char*);
	sift->ParseParam(argc, argv);
	if (sift->CreateContextGL() != SiftGPU::SIFTGPU_FULL_SUPPORTED)
		return 0;
	//Init SiftGPU: END

	//SIFT DECTION: START
	int descriptorSize = SIFTBINS;
	vector<float > descriptors1(1), descriptors2(1);
	vector<SiftGPU::SiftKeypoint> keys1(1), keys2(1);

	int pts1, pts2;
	char Fname[200];
	double start = omp_get_wtime();
	if (sift->RunSIFT(Fname1)) //You can have at most one OpenGL-based SiftGPU (per process)--> no omp can be used
	{
		pts1 = sift->GetFeatureNum();
		keys1.resize(pts1);    descriptors1.resize(descriptorSize * pts1);
		sift->GetFeatureVector(&keys1[0], &descriptors1[0]);
		WriteKPointsSIFTGPU("C:/temp/x.txt", keys1, true);

		printf("View 1:  %d points. Take %.2fs\n", pts1, omp_get_wtime() - start);
	}
	else
		printf("Cannot load %s", Fname1);

	start = omp_get_wtime();
	if (sift->RunSIFT(Fname2)) //You can have at most one OpenGL-based SiftGPU (per process)--> no omp can be used
	{
		pts2 = sift->GetFeatureNum();
		keys2.resize(pts2);    descriptors2.resize(descriptorSize * pts2);
		sift->GetFeatureVector(&keys2[0], &descriptors2[0]);

		printf("View 2: %d points. Take %.2fs\n", pts2, omp_get_wtime() - start);
	}
	else
		printf("Cannot load %s", Fname2);
	//SIFT DECTION: ENDS

	///SIFT MATCHING: START
	SiftMatchGPU* matcher = pCreateNewSiftMatchGPU(8192);
	matcher->VerifyContextGL(); //must call once
	int(*match_buf)[2] = new int[MAXSIFTPTS][2];
	vector<Point2i> RawPairWiseMatchID;	RawPairWiseMatchID.reserve(10000);

	start = omp_get_wtime();
	//Finding nearest neighbor. call matcher->SetMaxSift() to change the limit before calling setdescriptor if you want change maxMatch
	matcher->SetDescriptors(0, pts1, &descriptors1[0]); //image 1
	matcher->SetDescriptors(1, pts2, &descriptors2[0]); //image 2

	//enumerate all the feature matches
	int num_match = matcher->GetSiftMatch(pts1, match_buf, 0.7f, nndrRatio);
	sprintf(Fname, "%s/C1P1_%05d.txt", Path, timeID);	FILE *fp1 = fopen(Fname, "w+");
	sprintf(Fname, "%s/P1C1_%05d.txt", Path, timeID);	FILE *fp2 = fopen(Fname, "w+");
	for (int i = 0; i < num_match; ++i)
	{
		//How to get the feature matches: 
		SiftGPU::SiftKeypoint & key1 = keys1[match_buf[i][0]];
		SiftGPU::SiftKeypoint & key2 = keys2[match_buf[i][1]];
		if (flipCoordinate)
		{
			fprintf(fp1, "%.2f %.2f\n", key1.x, 500.0 - key1.y);
			fprintf(fp2, "%.2f %.2f\n", key2.x, 600.0 - key2.y);
		}
		else
		{
			fprintf(fp1, "%.2f %.2f\n", key1.x, key1.y);
			fprintf(fp2, "%.2f %.2f\n", key2.x, key2.y);
		}
		//key1 in the first image matches with key2 in the second image
	}
	fclose(fp1), fclose(fp2);
	///SIFT MATCHING: ENDS

	return 0;
	int nchannels = 3;
	IplImage *Img1 = cvLoadImage(Fname1, nchannels == 3 ? 1 : 0);
	if (Img1->imageData == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	IplImage *Img2 = cvLoadImage(Fname2, nchannels == 3 ? 1 : 0);
	if (Img2->imageData == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}

	IplImage* correspond = cvCreateImage(cvSize(Img1->width + Img2->width, Img1->height), 8, nchannels);
	cvSetImageROI(correspond, cvRect(0, 0, Img1->width, Img1->height));
	cvCopy(Img1, correspond);
	cvSetImageROI(correspond, cvRect(Img1->width, 0, correspond->width, correspond->height));
	cvCopy(Img2, correspond);
	cvResetImageROI(correspond);

	vector<int>CorresID;
	vector<Point2d> keypoints1, keypoints2;
	CorresID.reserve(2 * num_match);
	keypoints1.reserve(num_match);
	keypoints2.reserve(num_match);
	for (int i = 0; i < num_match; ++i)
	{
		CorresID.push_back(i), CorresID.push_back(i);
		SiftGPU::SiftKeypoint & key1 = keys1[match_buf[i][0]];
		SiftGPU::SiftKeypoint & key2 = keys2[match_buf[i][1]];
		keypoints1.push_back(Point2d(key1.x, key1.y));
		keypoints2.push_back(Point2d(key2.x, key2.y));
	}

	DisplayImageCorrespondence(correspond, Img1->width, 0, keypoints1, keypoints2, CorresID, density);
	cvReleaseImage(&correspond);
	cvReleaseImage(&Img1), cvReleaseImage(&Img2);
	delete[] match_buf;
	delete sift;
	delete matcher;
	FREE_MYLIB(hsiftgpu);

	return 0;
}
//Use GPU for brute force Sift matching
int GeneratePointsCorrespondenceMatrix_SiftGPU1(char *Path, int nviews, int timeID, float nndrRatio, int distortionCorrected, int OulierRemoveTestMethod, int cameraToScan)
{

	// Allocation size to the largest width and largest height 1920x1080
	// Maximum working dimension. All the SIFT octaves that needs a larger texture size will be skipped. maxd = 2560 <-> 768MB of graphic memory. 
	char * argv[] = { "-fo", "-1", "-v", "0", "-p", "1920x1080", "-maxd", "3200" };
	//-fo -1    staring from -1 octave 
	//-v 1      only print out # feature and overall time
	//-loweo    add a (.5, .5) offset
	//-tc <num> set a soft limit to number of detected features
	//-m,       up to 2 orientations for each feature (change to single orientation by using -m 1)
	//-s        enable subpixel subscale (disable by using -s 0)
	//"-cuda", "[device_id]"  : cuda implementation (fastest for smaller images). CUDA-implementation allows you to create multiple instances for multiple threads. Checkout src\TestWin\MultiThreadSIFT
	// "-Display", "display_name" (for OPENGL) to select monitor/GPU (XLIB/GLUT) on windows the display name would be something like \\.\DISPLAY4
	//Only the following parameters can be changed after initialization (by calling ParseParam):-dw, -ofix, -ofix-not, -fo, -unn, -maxd, -b
	//to change other parameters at runtime, you need to first unload the dynamically loaded libaray reload the libarary, then create a new siftgpu instance

	//Init SiftGPU: START
#ifdef _WIN32
#ifdef _DEBUG
	HMODULE  hsiftgpu = LoadLibrary("siftgpu_d.dll");
#else
	HMODULE  hsiftgpu = LoadLibrary("siftgpu.dll");
#endif
#else
	void * hsiftgpu = dlopen("libsiftgpu.so", RTLD_LAZY);
#endif

	if (hsiftgpu == NULL)
		return 0;

	SiftGPU* (*pCreateNewSiftGPU)(int) = NULL;
	SiftMatchGPU* (*pCreateNewSiftMatchGPU)(int) = NULL;
	pCreateNewSiftGPU = (SiftGPU* (*) (int)) GET_MYPROC(hsiftgpu, "CreateNewSiftGPU");
	pCreateNewSiftMatchGPU = (SiftMatchGPU* (*)(int)) GET_MYPROC(hsiftgpu, "CreateNewSiftMatchGPU");
	SiftGPU* sift = pCreateNewSiftGPU(1);

	int argc = sizeof(argv) / sizeof(char*);
	sift->ParseParam(argc, argv);
	if (sift->CreateContextGL() != SiftGPU::SIFTGPU_FULL_SUPPORTED)
		return 0;
	//Init SiftGPU: END

	//SIFT DECTION: START
	int numKeys, descriptorSize = SIFTBINS;
	vector<float > descriptors; descriptors.reserve(MAXSIFTPTS * descriptorSize);
	vector<SiftGPU::SiftKeypoint> keys; keys.reserve(MAXSIFTPTS);

	vector<int>cumulativePts;
	vector<int>PtsPerView;

	int totalPts = 0;
	char Fname[200];

	double start;
	for (int ii = 0; ii < nviews; ii++)
	{
		keys.clear(), descriptors.clear();
		start = omp_get_wtime();

		//Try to read all sift points if available
		if (timeID < 0)
			sprintf(Fname, "%s/K%d.dat", Path, ii);
		else
			sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID);
		if (ReadKPointsBinarySIFTGPU(Fname, keys))
		{
			cumulativePts.push_back(totalPts);
			totalPts += keys.size();
			PtsPerView.push_back(keys.size());
			continue; //Sift availble, move one
		}

		if (timeID < 0)
			sprintf(Fname, "%s/%d.png", Path, ii);
		else
			sprintf(Fname, "%s/%d/%d.png", Path, ii, timeID);
		if (sift->RunSIFT(Fname)) //You can have at most one OpenGL-based SiftGPU (per process)--> no omp can be used
		{
			numKeys = sift->GetFeatureNum();
			keys.resize(numKeys);    descriptors.resize(descriptorSize * numKeys);
			sift->GetFeatureVector(&keys[0], &descriptors[0]);

			if (timeID < 0)
			{
				sprintf(Fname, "%s/K%d.dat", Path, ii); WriteKPointsBinarySIFTGPU(Fname, keys);
				sprintf(Fname, "%s/D%d.dat", Path, ii); WriteDescriptorBinarySIFTGPU(Fname, descriptors);
			}
			else
			{
				sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID); WriteKPointsBinarySIFTGPU(Fname, keys);
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID); WriteDescriptorBinarySIFTGPU(Fname, descriptors);
			}

			printf("View %d: %d points ... Wrote to files. Take %.2fs\n", ii, numKeys, omp_get_wtime() - start);

			cumulativePts.push_back(totalPts);
			totalPts += numKeys;
			PtsPerView.push_back(numKeys);
		}
		else
			printf("Cannot load %s", Fname);
	}
	cumulativePts.push_back(totalPts);

	if (timeID < 0)
		sprintf(Fname, "%s/CumlativePoints.txt", Path);
	else
		sprintf(Fname, "%s/CumlativePoints_%d.txt", Path, timeID);
	FILE* fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cumulativePts.size(); ii++)
		fprintf(fp, "%d\n", cumulativePts[ii]);
	fclose(fp);
	//SIFT DECTION: ENDS

	///SIFT MATCHING: START
	SiftMatchGPU* matcher = pCreateNewSiftMatchGPU(8192);
	matcher->VerifyContextGL(); //must call once
	int(*match_buf)[2] = new int[MAXSIFTPTS][2];

	vector<float > descriptors1, descriptors2;
	descriptors1.reserve(MAXSIFTPTS * descriptorSize), descriptors2.reserve(MAXSIFTPTS * descriptorSize);

	vector<Point2i> RawPairWiseMatchID;	RawPairWiseMatchID.reserve(10000);

	start = omp_get_wtime();
	printf("Running feature matching...\n");
	for (int jj = 0; jj < nviews - 1; jj++)
	{
		if (timeID < 0)
			sprintf(Fname, "%s/D%d.dat", Path, jj);
		else
			sprintf(Fname, "%s/%d/D%d.dat", Path, jj, timeID);
		if (!ReadDescriptorBinarySIFTGPU(Fname, descriptors1))
			continue;

		int num1 = PtsPerView.at(jj);
		for (int ii = jj + 1; ii < nviews; ii++)
		{
			if (timeID < 0)
				sprintf(Fname, "%s/D%d.dat", Path, ii);
			else
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID);
			if (!ReadDescriptorBinarySIFTGPU(Fname, descriptors2))
				continue;

			double start = omp_get_wtime();
			printf("View (%d, %d) of frame %d ...", jj, ii, timeID);

			int num2 = PtsPerView[ii];
			//Finding nearest neighbor. call matcher->SetMaxSift() to change the limit before calling setdescriptor if you want change maxMatch
			matcher->SetDescriptors(0, num1, &descriptors1[0]); //image 1
			matcher->SetDescriptors(1, num2, &descriptors2[0]); //image 2

			int num_match = matcher->GetSiftMatch(num1, match_buf, 0.7f, nndrRatio);
			for (int i = 0; i < num_match; ++i)
			{
				int id1 = match_buf[i][0], id2 = match_buf[i][1];
				RawPairWiseMatchID.push_back(Point2i(id1, id2));
			}

			printf("%d matches .... %.2fs\n", num_match, omp_get_wtime() - start);
			if (timeID < 0)
				sprintf(Fname, "%s/M_%d_%d.dat", Path, jj, ii);
			else
				sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, jj, ii);
			FILE *fp = fopen(Fname, "w+");
			fprintf(fp, "%d\n", RawPairWiseMatchID.size());
			for (int i = 0; i < RawPairWiseMatchID.size(); i++)
				fprintf(fp, "%d %d\n", RawPairWiseMatchID.at(i).x, RawPairWiseMatchID.at(i).y);
			fclose(fp);
		}
	}
	printf("Finished matching feature points ... in %.2fs\n", omp_get_wtime() - start);
	///SIFT MATCHING: ENDS

	GenerateMatchingTable(Path, nviews, timeID);

	delete[] match_buf;
	delete sift;
	delete matcher;
	FREE_MYLIB(hsiftgpu);

	return 0;
}
//Use CPU for flann Sift matching: OulierRemoveTestMethod 0: no test, 1: Emat, 2: Fmat
int GeneratePointsCorrespondenceMatrix_SiftGPU2(char *Path, int nviews, int timeID, int HistogramEqual, float nndrRatio, int *FrameOffset)
{
	// Allocation size to the largest width and largest height 1920x1080
	// Maximum working dimension. All the SIFT octaves that needs a larger texture size will be skipped. maxd = 2560 <-> 768MB of graphic memory. 
	char * argv[] = { "-fo", "-1", "-v", "0", "-p", "1920x1080", "-maxd", "4096" };
	//-fo -1    staring from -1 octave
	//-v 1      only print out # feature and overall time
	//-loweo    add a (.5, .5) offset
	//-tc <num> set a soft limit to number of detected features
	//-m,       up to 2 orientations for each feature (change to single orientation by using -m 1)
	//-s        enable subpixel subscale (disable by using -s 0)
	//"-cuda", "[device_id]"  : cuda implementation (fastest for smaller images). CUDA-implementation allows you to create multiple instances for multiple threads. Checkout src\TestWin\MultiThreadSIFT
	// "-Display", "display_name" (for OPENGL) to select monitor/GPU (XLIB/GLUT) on windows the display name would be something like \\.\DISPLAY4
	//Only the following parameters can be changed after initialization (by calling ParseParam):-dw, -ofix, -ofix-not, -fo, -unn, -maxd, -b
	//to change other parameters at runtime, you need to first unload the dynamically loaded libaray reload the libarary, then create a new siftgpu instance

	//Init SiftGPU: START
#ifdef _WIN32
#ifdef _DEBUG
	HMODULE  hsiftgpu = LoadLibrary("siftgpu_d.dll");
#else
	HMODULE  hsiftgpu = LoadLibrary("siftgpu.dll");
#endif
#else
	void * hsiftgpu = dlopen("libsiftgpu.so", RTLD_LAZY);
#endif

	if (hsiftgpu == NULL)
		return 0;

	SiftGPU* (*pCreateNewSiftGPU)(int) = NULL;
	SiftMatchGPU* (*pCreateNewSiftMatchGPU)(int) = NULL;
	pCreateNewSiftGPU = (SiftGPU* (*) (int)) GET_MYPROC(hsiftgpu, "CreateNewSiftGPU");
	pCreateNewSiftMatchGPU = (SiftMatchGPU* (*)(int)) GET_MYPROC(hsiftgpu, "CreateNewSiftMatchGPU");
	SiftGPU* sift = pCreateNewSiftGPU(1);

	int argc = sizeof(argv) / sizeof(char*);
	sift->ParseParam(argc, argv);
	if (sift->CreateContextGL() != SiftGPU::SIFTGPU_FULL_SUPPORTED)
		return 0;
	//Init SiftGPU: END

	//SIFT DECTION: START
	int numKeys, descriptorSize = SIFTBINS;
	vector<float > descriptors; descriptors.reserve(MAXSIFTPTS * descriptorSize);
	vector<SiftGPU::SiftKeypoint> keys; keys.reserve(MAXSIFTPTS);

	vector<int>cumulativePts;
	vector<int>PtsPerView;

	int totalPts = 0;
	char Fname[200];
	Mat cvImg, equalizedImg;
	vector<Point3i> Vrgb; Vrgb.reserve(30000);

	if (FrameOffset == NULL)
	{
		FrameOffset = new int[nviews];
		for (int ii = 0; ii < nviews; ii++)
			FrameOffset[ii] = 0;
	}

	bool HanFormat = false;
	double start;
	for (int ii = 0; ii < nviews; ii++)
	{
		keys.clear(), descriptors.clear();
		start = omp_get_wtime();

		//Try to read all sift points if available
		if (timeID < 0)
			sprintf(Fname, "%s/K%d.dat", Path, ii);
		else
			sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID + FrameOffset[ii]);
		if (ReadKPointsBinarySIFTGPU(Fname, keys))
		{
			printf("Loaded %s with %d SIFTs\n", Fname, keys.size());
			cumulativePts.push_back(totalPts);
			totalPts += keys.size();
			PtsPerView.push_back(keys.size());
			continue; //Sift availble, move one
		}

		if (timeID < 0)
			sprintf(Fname, "%s/%d.png", Path, ii);
		else
			sprintf(Fname, "%s/%d/%d.png", Path, ii, timeID + FrameOffset[ii]);

		//Check if image is available
		ifstream testFin(Fname);
		if (testFin.is_open())
			testFin.close();
		else
		{
			HanFormat = true;
			sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, timeID, timeID, ii);//Han's format
		}

		if (HistogramEqual == 1)
		{
			cvImg = imread(Fname, 0);
			if (cvImg.empty())
			{
				printf("Cannot load %s\n", Fname);
				numKeys = 0;
				cumulativePts.push_back(totalPts);
				totalPts += numKeys;
				PtsPerView.push_back(numKeys);
				continue;
			}
			equalizeHist(cvImg, equalizedImg);

			if (timeID < 0)
				sprintf(Fname, "%s/_%d.png", Path, ii);
			else
				sprintf(Fname, "%s/%d/_%d.png", Path, ii, timeID + FrameOffset[ii]);
			imwrite(Fname, equalizedImg);
		}

		if (sift->RunSIFT(Fname)) //You can have at most one OpenGL-based SiftGPU (per process)--> no omp can be used
		{
			//sprintf(Fname, "%s/%d.sift", Path, ii);sift->SaveSIFT(Fname);
			numKeys = sift->GetFeatureNum();
			keys.resize(numKeys);    descriptors.resize(descriptorSize * numKeys);
			sift->GetFeatureVector(&keys[0], &descriptors[0]);

			//Getting color info
			Vrgb.clear();
			if (timeID < 0)
				sprintf(Fname, "%s/%d.png", Path, ii);
			else
			{
				if (!HanFormat)
					sprintf(Fname, "%s/%d/%d.png", Path, ii, timeID);
				else
					sprintf(Fname, "%s/In/%08d/%08d_00_%02d.png", Path, timeID, timeID, ii);//Han's format
			}
			cvImg = imread(Fname, IMREAD_COLOR);
			for (int kk = 0; kk < numKeys; kk++)
			{
				int x = (int)keys.at(kk).x, y = (int)keys.at(kk).y;
				int id = x + y*cvImg.cols;
				Point3i rgb;
				rgb.z = cvImg.data[3 * id + 0];//b
				rgb.y = cvImg.data[3 * id + 1];//g
				rgb.x = cvImg.data[3 * id + 2];//r
				Vrgb.push_back(rgb);
			}

			sprintf(Fname, "%s/%d", Path, ii), makeDir(Fname);
			if (timeID < 0)
			{
				sprintf(Fname, "%s/K%d.dat", Path, ii); WriteKPointsBinarySIFTGPU(Fname, keys);
				sprintf(Fname, "%s/RGB%d.dat", Path, ii); WriteRGBBinarySIFTGPU(Fname, Vrgb);
				sprintf(Fname, "%s/D%d.dat", Path, ii); WriteDescriptorBinarySIFTGPU(Fname, descriptors);
			}
			else
			{
				sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID + FrameOffset[ii]); WriteKPointsBinarySIFTGPU(Fname, keys);
				sprintf(Fname, "%s/%d/RGB%d.dat", Path, ii, timeID + FrameOffset[ii]); WriteRGBBinarySIFTGPU(Fname, Vrgb);
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID + FrameOffset[ii]); WriteDescriptorBinarySIFTGPU(Fname, descriptors);
			}

			printf("View %d: %d points ... Wrote to files. Take %.2fs\n", ii, numKeys, omp_get_wtime() - start);

			cumulativePts.push_back(totalPts);
			totalPts += numKeys;
			PtsPerView.push_back(numKeys);
		}
		else
		{
			printf("Cannot load %s\n", Fname);
			numKeys = 0;
			cumulativePts.push_back(totalPts);
			totalPts += numKeys;
			PtsPerView.push_back(numKeys);
		}
	}
	cumulativePts.push_back(totalPts);


	if (timeID < 0)
		sprintf(Fname, "%s/CumlativePoints.txt", Path);
	else
	{
		sprintf(Fname, "%s/Dynamic", Path), makeDir(Fname);
		sprintf(Fname, "%s/Dynamic/CumlativePoints_%d.txt", Path, timeID);
	}
	FILE* fp = fopen(Fname, "w+");
	for (int ii = 0; ii < cumulativePts.size(); ii++)
		fprintf(fp, "%d\n", cumulativePts[ii]);
	fclose(fp);
	//SIFT DECTION: ENDS

	///SIFT MATCHING: START
	int nthreads = omp_get_max_threads();
	omp_set_num_threads(nthreads);

	vector<KeyPoint> Keys1, Keys2;
	SiftMatchGPU* matcher = pCreateNewSiftMatchGPU(8192);
	matcher->VerifyContextGL(); //must call once
	int(*match_buf)[2] = new int[MAXSIFTPTS][2];

	vector<Point2i> *RawPairWiseMatchID = new vector<Point2i>[nthreads];
	for (int ii = 0; ii < nthreads; ii++)
		RawPairWiseMatchID[ii].reserve(10000);
	vector<Point2i> *SRawPairWiseMatchID = new vector<Point2i>[nthreads];
	for (int ii = 0; ii < nthreads; ii++)
		SRawPairWiseMatchID[ii].reserve(10000);

	const int ninlierThesh = 50;
	int *SortingVec = new int[50000 * nthreads]; //should be more than enough
	int *tId = new int[50000 * nthreads];

	bool BinaryDesc = false, useBFMatcher = false; // SET TO TRUE TO USE BRUTE FORCE MATCHER
	const int knn = 2, ntrees = 4, maxLeafCheck = 128;

	start = omp_get_wtime();
	printf("Running feature matching...\n");
	Mat descriptors1;
	for (int jj = 0; jj < nviews - 1; jj++)
	{
		if (timeID < 0)
			sprintf(Fname, "%s/D%d.dat", Path, jj);
		else
			sprintf(Fname, "%s/%d/D%d.dat", Path, jj, timeID + FrameOffset[jj]);
		Mat descriptors1 = ReadDescriptorBinarySIFTGPU(Fname);
		if (descriptors1.rows == 1)
			continue;

#ifdef _WINDOWS
		if (timeID>0)
			sprintf(Fname, "%s/Dynamic", Path); mkdir(Fname);
#endif

#pragma omp parallel for
		for (int ii = jj + 1; ii < nviews; ii++)
		{
			if (timeID < 0)
				sprintf(Fname, "%s/M_%d_%d.dat", Path, jj, ii);
			else
				sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, jj, ii);
			FILE *fp = fopen(Fname, "r");
			if (fp != NULL)
				continue;

			char Fname[200];
			if (timeID < 0)
				sprintf(Fname, "%s/D%d.dat", Path, ii);
			else
				sprintf(Fname, "%s/%d/D%d.dat", Path, ii, timeID + FrameOffset[ii]);
			Mat descriptors2 = ReadDescriptorBinarySIFTGPU(Fname);
			if (descriptors2.rows == 1)
				continue;

			double start = omp_get_wtime();
			int threadID = omp_get_thread_num();
			RawPairWiseMatchID[threadID].clear(), SRawPairWiseMatchID[threadID].clear();

			//Finding nearest neighbor
			Mat indices, dists;
			vector<vector<DMatch> > matches;
			if (BinaryDesc)
			{
				//printf("Binary descriptors detected...\n");// ORB, Brief, BRISK, FREAK
				if (useBFMatcher)
				{
					cv::BFMatcher matcher(cv::NORM_HAMMING); // use cv::NORM_HAMMING2 for ORB descriptor with WTA_K == 3 or 4 (see ORB constructor)
					matcher.knnMatch(descriptors2, descriptors1, matches, knn);
				}
				else
				{
					// Create Flann LSH index
					cv::flann::Index flannIndex(descriptors1, cv::flann::LshIndexParams(12, 20, 2), cvflann::FLANN_DIST_HAMMING);
					flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams());
				}
			}
			else
			{
				if (useBFMatcher)
				{
					cv::BFMatcher matcher(cv::NORM_L2);
					matcher.knnMatch(descriptors2, descriptors1, matches, knn);
				}
				else
				{
					// Create Flann KDTree index
					cv::flann::Index flannIndex(descriptors1, cv::flann::KDTreeIndexParams(ntrees));//, cvflann::FLANN_DIST_EUCLIDEAN);
					flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams(maxLeafCheck));
				}
			}

			// Find correspondences by NNDR (Nearest Neighbor Distance Ratio)
			int count = ii - jj - 1;
			for (int i = 0; i <= jj - 1; i++)
				count += nviews - i - 1;

			if (!useBFMatcher)
			{
				for (int i = 0; i < descriptors2.rows; ++i)
				{
					int ind1 = indices.at<int>(i, 0);
					if (indices.at<int>(i, 0) >= 0 && indices.at<int>(i, 1) >= 0 && dists.at<float>(i, 0) <= nndrRatio * dists.at<float>(i, 1))
						RawPairWiseMatchID[threadID].push_back(Point2i(ind1, i));
				}
			}
			else
			{
				for (unsigned int i = 0; i < matches.size(); ++i)
					if (matches.at(i).size() == 2 && matches.at(i).at(0).distance <= nndrRatio * matches.at(i).at(1).distance)
						RawPairWiseMatchID[threadID].push_back(Point2i(matches.at(i).at(0).trainIdx, i));
			}

			//To remove the nonsense case of every point matchces to 1 point-->IT HAPPENED
			SRawPairWiseMatchID[threadID].push_back(RawPairWiseMatchID[threadID].at(0));
			for (unsigned int i = 1; i < min((int)RawPairWiseMatchID[threadID].size(), 50000); i++)
				if (RawPairWiseMatchID[threadID].at(i).x != RawPairWiseMatchID[threadID].at(i - 1).x)
					SRawPairWiseMatchID[threadID].push_back(RawPairWiseMatchID[threadID].at(i));

			if (SRawPairWiseMatchID[threadID].size() < ninlierThesh)
				continue;

			//Start sorting
			for (unsigned int i = 0; i < min((int)SRawPairWiseMatchID[threadID].size(), 50000); i++)
			{
				SortingVec[i + 50000 * threadID] = SRawPairWiseMatchID[threadID].at(i).x;
				tId[i + 50000 * threadID] = i;
			}
			Quick_Sort_Int(SortingVec + 50000 * threadID, tId + 50000 * threadID, 0, min((int)SRawPairWiseMatchID[threadID].size(), 50000) - 1);

			//Store sorted vector
			RawPairWiseMatchID[threadID].push_back(SRawPairWiseMatchID[threadID].at(tId[0 + 50000 * threadID]));
			for (unsigned int i = 1; i < min((int)SRawPairWiseMatchID[threadID].size(), 50000); i++)
				if (SortingVec[i + 50000 * threadID] != SortingVec[i - 1 + 50000 * threadID])
					RawPairWiseMatchID[threadID].push_back(SRawPairWiseMatchID[threadID].at(tId[i + 50000 * threadID]));

#pragma omp critical
			{
				printf("(%d, %d) to (%d, %d)...%d matches... %.2fs\n", jj, timeID + FrameOffset[jj], ii, timeID + FrameOffset[ii], SRawPairWiseMatchID[threadID].size(), omp_get_wtime() - start);
				if (timeID < 0)
					sprintf(Fname, "%s/M_%d_%d.dat", Path, jj, ii);
				else
					sprintf(Fname, "%s/Dynamic/M%d_%d_%d.dat", Path, timeID, jj, ii);
				FILE *fp = fopen(Fname, "w+");
				fprintf(fp, "%d\n", SRawPairWiseMatchID[threadID].size());
				for (int i = 0; i < SRawPairWiseMatchID[threadID].size(); i++)
					fprintf(fp, "%d %d\n", SRawPairWiseMatchID[threadID].at(i).x, SRawPairWiseMatchID[threadID].at(i).y);
				fclose(fp);
			}
		}
	}
	printf("Finished matching feature points ... in %.2fs\n", omp_get_wtime() - start);

	delete[]SortingVec;
	delete[]tId;
	delete[]RawPairWiseMatchID, delete[]SRawPairWiseMatchID;
	delete[] match_buf;
	delete sift;
	delete matcher;
	FREE_MYLIB(hsiftgpu);
	///SIFT MATCHING: ENDS

	return 0;
}


void BestPairFinder(char *Path, int nviews, int timeID, int *viewPair)
{
	char Fname[200];
	int ii, jj;

	int *viewMatrix = new int[nviews*nviews];

	if (timeID < 0)
		sprintf(Fname, "%s/VM.txt", Path);
	else
		sprintf(Fname, "%s/VM_%d.txt", Path, timeID);
	FILE *fp = fopen(Fname, "r");
	for (jj = 0; jj < nviews; jj++)
		for (ii = 0; ii < nviews; ii++)
			fscanf(fp, "%d ", &viewMatrix[ii + jj*nviews]);
	fclose(fp);

	int bestCount = 0;
	for (jj = 0; jj < nviews; jj++)
	{
		for (ii = 0; ii < nviews; ii++)
		{
			if (viewMatrix[ii + jj*nviews] > bestCount)
			{
				bestCount = viewMatrix[ii + jj*nviews];
				viewPair[0] = ii, viewPair[1] = jj;
			}
		}
	}

	delete[]viewMatrix;

	return;
}
int NextViewFinder(char *Path, int nviews, int timeID, int currentView, int &maxPoints, vector<int> usedViews)
{
	char Fname[200];
	int ii, jj, kk;

	int *viewMatrix = new int[nviews*nviews];

	if (timeID < 0)
		sprintf(Fname, "%s/VM.txt", Path);
	else
		sprintf(Fname, "%s/VM_%d.txt", Path, timeID);
	FILE *fp = fopen(Fname, "r");
	for (jj = 0; jj < nviews; jj++){
		for (ii = 0; ii < nviews; ii++){
			fscanf(fp, "%d ", &viewMatrix[ii + jj*nviews]);
		}
	}
	fclose(fp);

	for (ii = 0; ii < usedViews.size(); ii++){
		for (jj = 0; jj < usedViews.size(); jj++){
			if (jj != ii){
				viewMatrix[usedViews[ii] + usedViews.at(jj)*nviews] = 0, viewMatrix[usedViews.at(jj) + usedViews[ii] * nviews] = 0;
			}
		}
	}

	jj = 0;
	for (ii = 0; ii < nviews; ii++)
	{
		if (viewMatrix[ii + currentView*nviews] > jj)
		{
			jj = viewMatrix[ii + currentView*nviews];
			kk = ii;
		}
	}

	maxPoints = jj;

	delete[]viewMatrix;

	return kk;
}

int GetPoint2DPairCorrespondence(char *Path, int timeID, vector<int>viewID, vector<KeyPoint>&keypoints1, vector<KeyPoint>&keypoints2, vector<int>&CorrespondencesID)
{
	//SelectedIndex: index of correspondenceID in the total points pool
	keypoints1.clear(), keypoints2.clear(), CorrespondencesID.clear();
	char Fname[200];

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, viewID.at(0));
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, viewID.at(0), timeID);
	if (useGPU)
		ReadKPointsBinarySIFTGPU(Fname, keypoints1);
	else
		ReadKPointsBinary(Fname, keypoints1);

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, viewID.at(1));
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, viewID.at(1), timeID);
	if (useGPU)
		ReadKPointsBinarySIFTGPU(Fname, keypoints2);
	else
		ReadKPointsBinary(Fname, keypoints2);

	vector<int>matches; matches.reserve(500);//Cannot be found in more than 500 views!

	if (timeID < 0)
		sprintf(Fname, "%s/M_%d_%d.dat", Path, viewID.at(0), viewID.at(1));
	else
		sprintf(Fname, "%s/M%d_%d_%d.dat", Path, timeID, viewID.at(0), viewID.at(1));

	int npts, id1, id2;
	FILE *fp = fopen(Fname, "r");
	fscanf(fp, "%d ", &npts);
	CorrespondencesID.reserve(npts * 2);
	while (fscanf(fp, "%d %d ", &id1, &id2) != EOF)
		CorrespondencesID.push_back(id1), CorrespondencesID.push_back(id2);
	fclose(fp);

	return 0;
}
int GetPoint3D2DPairCorrespondence(char *Path, int nviews, int timeID, vector<int> cumulativePts, vector<int> viewID, Point3d *ThreeD, vector<KeyPoint>&keypoints1, vector<KeyPoint>&keypoints2, vector<int>&TwoDCorrespondencesID, vector<int> &ThreeDCorrespondencesID, vector<int>&SelectedIndex, bool SwapView)
{
	//SelectedIndex: index of correspondenceID in the total points pool
	keypoints1.clear(), keypoints2.clear(), TwoDCorrespondencesID.clear(), ThreeDCorrespondencesID.clear();

	int ii, jj, kk, ll, id;
	char Fname[200];

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, viewID.at(0));
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, viewID.at(0), timeID);
	if (useGPU)
		ReadKPointsBinarySIFTGPU(Fname, keypoints1);
	else
		ReadKPointsBinary(Fname, keypoints1);

	if (timeID < 0)
		sprintf(Fname, "%s/K%d.dat", Path, viewID.at(1));
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, viewID.at(1), timeID);
	if (useGPU)
		ReadKPointsBinarySIFTGPU(Fname, keypoints2);
	else
		ReadKPointsBinary(Fname, keypoints2);

	int totalPts = cumulativePts.at(nviews);
	vector<int>matches; matches.reserve(500);//Cannot be found in more than 500 views!
	//vector<int>CorrespondencesID;CorrespondencesID.reserve((cumulativePts.at(viewID.at(1)+1)-cumulativePts.at(viewID.at(0)+1))*2);

	if (timeID < 0)
		sprintf(Fname, "%s/PM.txt", Path);
	else
		sprintf(Fname, "%s/PM_%d.txt", Path, timeID);
	FILE *fp = fopen(Fname, "r");
	for (jj = 0; jj < totalPts; jj++)
	{
		kk = 0; matches.clear();
		fscanf(fp, "%d ", &kk);
		for (ii = 0; ii < kk; ii++)
		{
			fscanf(fp, "%d ", &ll);
			matches.push_back(ll);
		}

		if (jj >= cumulativePts.at(viewID.at(0)) && jj < cumulativePts.at(viewID.at(0) + 1))
		{
			for (ii = 0; ii < matches.size(); ii++)
			{
				int match = matches[ii];
				if (match >= cumulativePts.at(viewID.at(1)) && match < cumulativePts.at(viewID.at(1) + 1))
				{
					TwoDCorrespondencesID.push_back(jj - cumulativePts.at(viewID.at(0)));
					TwoDCorrespondencesID.push_back(match - cumulativePts.at(viewID.at(1)));
					SelectedIndex.push_back(jj);

					if (abs(ThreeD[jj].z) > 0.0 && !SwapView)
					{
						id = match - cumulativePts.at(viewID.at(1));
						ThreeDCorrespondencesID.push_back(id);
						ThreeDCorrespondencesID.push_back(jj);
					}
					else if (abs(ThreeD[match].z) > 0.0 && SwapView)
					{
						id = jj - cumulativePts.at(viewID.at(0));
						ThreeDCorrespondencesID.push_back(id);
						ThreeDCorrespondencesID.push_back(match);
					}
				}
			}
		}
	}
	fclose(fp);

	return 0;
}
int GetPoint3D2DAllCorrespondence(char *Path, int nviews, int timeID, vector<int> cumulativePts, Point3d *ThreeD, vector<int> availViews, vector<int>&Selected3DIndex, vector<Point2d> *selected2D, vector<int>*nSelectedViews, int &nSelectedPts)
{
	//SelectedIndex: index of correspondenceID in the total points pool
	Selected3DIndex.clear();
	int ii, jj, kk, ll;
	char Fname[200];

	bool PointAdded, PointAdded2, once;
	int viewID1, viewID2, match, totalPts = cumulativePts.at(nviews);

	vector<int>matches; matches.reserve(500);//Cannot be found in more than 500 views!
	//vector<int>CorrespondencesID;CorrespondencesID.reserve((cumulativePts.at(viewsID[1]+1)-cumulativePts.at(viewsID[0]+1))*2);
	vector<int> *selected2Did = new vector<int>[totalPts];
	for (ii = 0; ii < totalPts; ii++)
		selected2Did[ii].reserve(20);

	//fill in selected3D, select3Dindex, index of 2d points in available views
	if (timeID < 0)
		sprintf(Fname, "%s/PM.txt", Path);
	else
		sprintf(Fname, "%s/PM_%d.txt", Path, timeID);
	FILE* fp = fopen(Fname, "r");
	nSelectedPts = 0;
	for (jj = 0; jj < totalPts; jj++)
	{
		kk = 0; matches.clear();
		fscanf(fp, "%d ", &kk);
		for (ii = 0; ii < kk; ii++)
		{
			fscanf(fp, "%d ", &match);
			matches.push_back(match);
		}

		if (abs(ThreeD[jj].z) > 0.0 && matches.size() > 0)
		{
			once = true, PointAdded = false, PointAdded2 = false;
			for (kk = 0; kk < availViews.size(); kk++)
			{
				viewID1 = availViews.at(kk);
				if (jj >= cumulativePts.at(viewID1) && jj < cumulativePts.at(viewID1 + 1))
				{
					for (ii = 0; ii < matches.size(); ii++)
					{
						PointAdded = false;
						match = matches[ii];
						for (ll = 0; ll < availViews.size(); ll++)
						{
							if (ll == kk)
								continue;

							viewID2 = availViews.at(ll);
							if (match >= cumulativePts.at(viewID2) && match < cumulativePts.at(viewID2 + 1))
							{
								if (once)
								{
									once = false, PointAdded = true, PointAdded2 = true;
									Selected3DIndex.push_back(jj);
									nSelectedViews[nSelectedPts].clear();  nSelectedViews[nSelectedPts].push_back(viewID1);
									selected2Did[nSelectedPts].push_back(jj - cumulativePts.at(viewID1));
								}
								nSelectedViews[nSelectedPts].push_back(viewID2);
								selected2Did[nSelectedPts].push_back(match - cumulativePts.at(viewID2));
							}
							if (PointAdded)
								break;
						}
					}
				}
				if (PointAdded2)
					break;
			}
			if (PointAdded2)
				nSelectedPts++;
		}
	}
	fclose(fp);
	//fill in select2D: points seen in available views
	vector<KeyPoint> keypoints; keypoints.reserve(10000);

	for (ii = 0; ii < nSelectedPts; ii++)
	{
		int nviews = nSelectedViews[ii].size();
		selected2D[ii].clear(); selected2D[ii].reserve(nviews);
		for (jj = 0; jj < nviews; jj++)
			selected2D[ii].push_back(Point2d(0, 0));
	}

	for (kk = 0; kk < availViews.size(); kk++)
	{
		int viewID = availViews.at(kk); keypoints.clear();
		if (timeID < 0)
			sprintf(Fname, "%s/K%d.dat", Path, viewID);
		else
			sprintf(Fname, "%s/%d/K%d.dat", Path, viewID, timeID);

		if (useGPU)
			ReadKPointsBinarySIFTGPU(Fname, keypoints);
		else
			ReadKPointsBinary(Fname, keypoints);
		for (ll = 0; ll < nSelectedPts; ll++)
		{
			for (jj = 0; jj < nSelectedViews[ll].size(); jj++)
			{
				if (nSelectedViews[ll].at(jj) == viewID)
				{
					int poindID = selected2Did[ll].at(jj);
					selected2D[ll].at(jj).x = keypoints.at(poindID).pt.x;
					selected2D[ll].at(jj).y = keypoints.at(poindID).pt.y;
					break;
				}
			}
		}
	}

	delete[]selected2Did;
	return 0;
}

void FisheyeProjectandDistort(Point3d WC, Point2d *pts, double *P, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (distortion != NULL)
			FishEyeDistortionPoint(&pts[ii], distortion[7 * ii], distortion[7 * ii + 1], distortion[7 * ii + 2]);
	}

	return;
}
void ProjectandDistort(Point3d WC, Point2d *pts, double *P, double *camera, double *distortion, int nviews)
{
	int ii;
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		num1 = P[ii * 12 + 0] * WC.x + P[ii * 12 + 1] * WC.y + P[ii * 12 + 2] * WC.z + P[ii * 12 + 3];
		num2 = P[ii * 12 + 4] * WC.x + P[ii * 12 + 5] * WC.y + P[ii * 12 + 6] * WC.z + P[ii * 12 + 7];
		denum = P[ii * 12 + 8] * WC.x + P[ii * 12 + 9] * WC.y + P[ii * 12 + 10] * WC.z + P[ii * 12 + 11];

		pts[ii].x = num1 / denum, pts[ii].y = num2 / denum;
		if (camera != NULL)
			LensDistortionPoint(&pts[ii], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void ProjectandDistort(vector<Point3d> WC, Point2d *pts, double *P, double *camera, double *distortion, int nviews)
{
	int ii, jj, npts = WC.size();
	double num1, num2, denum;

	for (ii = 0; ii < nviews; ii++)
	{
		for (jj = 0; jj < npts; jj++)
		{
			num1 = P[ii * 12 + 0] * WC[jj].x + P[ii * 12 + 1] * WC[jj].y + P[ii * 12 + 2] * WC[jj].z + P[ii * 12 + 3];
			num2 = P[ii * 12 + 4] * WC[jj].x + P[ii * 12 + 5] * WC[jj].y + P[ii * 12 + 6] * WC[jj].z + P[ii * 12 + 7];
			denum = P[ii * 12 + 8] * WC[jj].x + P[ii * 12 + 9] * WC[jj].y + P[ii * 12 + 10] * WC[jj].z + P[ii * 12 + 11];

			pts[ii*npts + jj].x = num1 / denum, pts[ii*npts + jj].y = num2 / denum;
		}
		if (camera != NULL)
			for (jj = 0; jj < npts; jj++)
				LensDistortionPoint(&pts[ii*npts + jj], camera + ii * 9, distortion + ii * 7);
	}

	return;
}
void Stereo_Triangulation(Point2d *pts1, Point2d *pts2, double *P1, double *P2, Point3d *WC, int npts)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < npts; ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1*p31;
		A[1] = p12 - u1*p32;
		A[2] = p13 - u1*p33;
		A[3] = p21 - v1*p31;
		A[4] = p22 - v1*p32;
		A[5] = p23 - v1*p33;

		A[6] = P11 - u2*P31;
		A[7] = P12 - u2*P32;
		A[8] = P13 - u2*P33;
		A[9] = P21 - v2*P31;
		A[10] = P22 - v2*P32;
		A[11] = P23 - v2*P33;

		B[0] = u1*p34 - p14;
		B[1] = v1*p34 - p24;
		B[2] = u2*P34 - P14;
		B[3] = v2*P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC[ii].x = B[0];
		WC[ii].y = B[1];
		WC[ii].z = B[2];
	}

	return;
}
void Stereo_Triangulation(vector<Point2d> pts1, vector<Point2d> pts2, double *P1, double *P2, vector<Point3d> &WC)
{
	int ii;
	double A[12], B[4], u1, v1, u2, v2;
	double p11 = P1[0], p12 = P1[1], p13 = P1[2], p14 = P1[3];
	double p21 = P1[4], p22 = P1[5], p23 = P1[6], p24 = P1[7];
	double p31 = P1[8], p32 = P1[9], p33 = P1[10], p34 = P1[11];

	double P11 = P2[0], P12 = P2[1], P13 = P2[2], P14 = P2[3];
	double P21 = P2[4], P22 = P2[5], P23 = P2[6], P24 = P2[7];
	double P31 = P2[8], P32 = P2[9], P33 = P2[10], P34 = P2[11];

	for (ii = 0; ii < (int)pts1.size(); ii++)
	{
		u1 = pts1[ii].x, v1 = pts1[ii].y;
		u2 = pts2[ii].x, v2 = pts2[ii].y;

		A[0] = p11 - u1*p31;
		A[1] = p12 - u1*p32;
		A[2] = p13 - u1*p33;
		A[3] = p21 - v1*p31;
		A[4] = p22 - v1*p32;
		A[5] = p23 - v1*p33;

		A[6] = P11 - u2*P31;
		A[7] = P12 - u2*P32;
		A[8] = P13 - u2*P33;
		A[9] = P21 - v2*P31;
		A[10] = P22 - v2*P32;
		A[11] = P23 - v2*P33;

		B[0] = u1*p34 - p14;
		B[1] = v1*p34 - p24;
		B[2] = u2*P34 - P14;
		B[3] = v2*P34 - P24;

		QR_Solution_Double(A, B, 4, 3);

		WC.push_back(Point3d(B[0], B[1], B[2]));
	}

	return;
}
void TwoViewTriangulationQualityCheck(Point2d *pts1, Point2d *pts2, Point3d *WC, double *P1, double *P2, bool *GoodPoints, double thresh, int npts, double *K1, double *K2, double *distortion1, double *distortion2)
{
	double u1, v1, u2, v2, denum, reprojectionError;
	for (int ii = 0; ii < npts; ii++)
	{
		Point2d p1(pts1[ii].x, pts1[ii].y), p2(pts2[ii].x, pts2[ii].y);
		if (distortion1 != NULL)
		{
			LensCorrectionPoint(&p1, K1, distortion1);
			LensCorrectionPoint(&p2, K2, distortion2);
		}

		//Project to 1st view
		denum = P1[8] * WC[ii].x + P1[9] * WC[ii].y + P1[10] * WC[ii].z + P1[11];
		u1 = (P1[0] * WC[ii].x + P1[1] * WC[ii].y + P1[2] * WC[ii].z + P1[3]) / denum;
		v1 = (P1[4] * WC[ii].x + P1[5] * WC[ii].y + P1[6] * WC[ii].z + P1[7]) / denum;

		//Project to 2nd view
		denum = P2[8] * WC[ii].x + P2[9] * WC[ii].y + P2[10] * WC[ii].z + P2[11];
		u2 = (P2[0] * WC[ii].x + P2[1] * WC[ii].y + P2[2] * WC[ii].z + P2[3]) / denum;
		v2 = (P2[4] * WC[ii].x + P2[5] * WC[ii].y + P2[6] * WC[ii].z + P2[7]) / denum;

		reprojectionError = (abs(u2 - p2.x) + abs(v2 - p2.y) + abs(u1 - p1.x) + abs(v1 - p1.y)) / 4.0;
		if (reprojectionError > thresh)
			GoodPoints[ii] = false;
		else
			GoodPoints[ii] = true;
	}
	return;
}
void NviewTriangulation(Point2d *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(vector<Point2d> *pts, double *P, Point3d *WC, int nview, int npts, double *Cov, double *A, double *B)
{
	int ii, jj, kk;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
	}
	double u, v;

	if (Cov == NULL)
	{
		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}
	}
	else
	{
		double mse = 0.0;
		double *At = new double[6 * nview];
		double *Bt = new double[2 * nview];
		double *t1 = new double[4 * nview*nview];
		double *t2 = new double[4 * nview*nview];
		double *Identity = new double[4 * nview*nview];
		double AtA[9], iAtA[9];
		for (ii = 0; ii < 4 * nview*nview; ii++)
			Identity[ii] = 0.0;
		for (ii = 0; ii < 2 * nview; ii++)
			Identity[ii + ii * 2 * nview] = 1.0;

		for (ii = 0; ii < npts; ii++)
		{
			for (jj = 0; jj < nview; jj++)
			{
				u = pts[ii][jj].x, v = pts[ii][jj].y;

				A[6 * jj + 0] = P[12 * jj] - u*P[12 * jj + 8];
				A[6 * jj + 1] = P[12 * jj + 1] - u*P[12 * jj + 9];
				A[6 * jj + 2] = P[12 * jj + 2] - u*P[12 * jj + 10];
				A[6 * jj + 3] = P[12 * jj + 4] - v*P[12 * jj + 8];
				A[6 * jj + 4] = P[12 * jj + 5] - v*P[12 * jj + 9];
				A[6 * jj + 5] = P[12 * jj + 6] - v*P[12 * jj + 10];
				B[2 * jj + 0] = u*P[12 * jj + 11] - P[12 * jj + 3];
				B[2 * jj + 1] = v*P[12 * jj + 11] - P[12 * jj + 7];
			}

			mat_transpose(A, At, nview * 2, 3);
			mat_transpose(B, Bt, nview * 2, 1);
			mat_mul(At, A, AtA, 3, 2 * nview, 3);
			mat_invert(AtA, iAtA);
			mat_mul(A, iAtA, t1, 2 * nview, 3, 3);
			mat_mul(t1, At, t2, 2 * nview, 3, 2 * nview);
			mat_subtract(Identity, t2, t1, 2 * nview, 2 * nview);
			mat_mul(Bt, t1, t2, 1, 2 * nview, 2 * nview);
			mat_mul(Bt, t2, t1, 1, 2 * nview, 1);
			mse = t1[0] / (2 * nview - 3);

			for (jj = 0; jj < 3; jj++)
				for (kk = 0; kk < 3; kk++)
					Cov[kk + jj * 3] = iAtA[kk + jj * 3] * mse;

			QR_Solution_Double(A, B, 2 * nview, 3);

			WC[ii].x = B[0];
			WC[ii].y = B[1];
			WC[ii].z = B[2];
		}

		delete[]At;
		delete[]Bt;
		delete[]t1;
		delete[]t2;
		delete[]Identity;
	}

	if (MenCreated)
		delete[]A, delete[]B;

	return;
}
void NviewTriangulation(CameraData *ViewInfo, int nviews, vector <vector<int> > &viewIdAll3D, vector<vector<Point2d> > &uvAll3D, vector<Point3d> &AllP3D, bool CayleyRS)
{
	int count;

	double *P = new double[12 * nviews], *A = new double[6 * nviews], *B = new double[2 * nviews], *points2d = new double[nviews * 2];

	double error, point3d[3];
	Point3d p3d;
	vector<Point2d> p2d;
	for (int ii = 0; ii < (int)viewIdAll3D.size(); ii++)
	{
		if (viewIdAll3D[ii].size() > 1)
		{
			p2d.clear();
			count = 0;
			for (int jj = 0; jj < viewIdAll3D[ii].size(); jj++)
			{
				if (ViewInfo[viewIdAll3D[ii][jj]].valid)
				{
					for (int kk = 0; kk < 12; kk++)
						P[count * 12 + kk] = ViewInfo[viewIdAll3D[ii][jj]].P[kk];
					p2d.push_back(uvAll3D[ii][jj]);

					int viewID = viewIdAll3D[ii][jj];
					LensCorrectionPoint(&p2d[count], ViewInfo[viewID].K, ViewInfo[viewID].distortion);
					count++;
				}
			}

			NviewTriangulation(&p2d, P, &p3d, count, 1, NULL, A, B);

			point3d[0] = p3d.x, point3d[1] = p3d.y, point3d[2] = p3d.z;
			for (int jj = 0; jj < count; jj++)
				points2d[2 * jj] = p2d[jj].x, points2d[2 * jj + 1] = p2d[jj].y;

			if (!CayleyRS)
				NviewTriangulationNonLinear(P, points2d, point3d, &error, count, 1);
			else
				NviewTriangulationNonLinearCayley(ViewInfo, points2d, point3d, &error, nviews, 1);

			AllP3D[ii] = Point3d(point3d[0], point3d[1], point3d[2]);
		}
	}
	delete[]P, delete[]A, delete[]B, delete[]points2d;

	return;
}
double NviewTriangulationRANSAC(Point2d *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
		tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		//Pick a random pair to triangulate
		Point pair;
		bestCount = 0;
		for (kk = 0; kk < MaxRanSacIter; kk++)
		{
			pair.x = int(UniformNoise(nview - 1, 0));
			while (true)
			{
				pair.y = int(UniformNoise(nview - 1, 0));
				if (pair.y != pair.x)
					break;
			}
			Stereo_Triangulation(&pts[ii + pair.x*npts], &pts[ii + pair.y*npts], &P[12 * pair.x], &P[12 * pair.y], &t3D);

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				_pt = pts[ii + jj*npts];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii + jj*npts].x) < threshold && abs(_pt.y - pts[ii + jj*npts].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll<nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount> nview*inlierPercent)
				break;
		}

		int t = nview*inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					//pts[ii + jj*npts].x = 0.0, pts[ii + jj*npts].y = 0.0;
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii + jj*npts].x, v = pts[ii + jj*npts].y;
				goodpts2d[count] = pts[jj], goodpts2dbk[count] = pts[jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u*tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u*tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u*tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v*tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v*tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v*tP[12 * jj + 10];
				B[2 * jj + 0] = u*tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v*tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac)
			{
				goodCount = 0; finalerror = 0.0;
				Inliers[ii].clear();
				for (jj = 0; jj < nview; jj++)
				{
					ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
					double difx = _pt.x - pts[ii + jj*npts].x, dify = _pt.y - pts[ii + jj*npts].y, error = pow(difx, 2) + pow(dify, 2);

					if (error < threshold*threshold)
					{
						finalerror += error;
						Inliers[ii].push_back(1);

						GoodViewID[jj] = true;
						tP[12 * goodCount + ll] = P[12 * jj + ll];
						goodpts2dbk[goodCount] = pts[ii + jj*npts];
						P2D[2 * goodCount] = pts[ii + jj*npts].x, P2D[2 * goodCount + 1] = pts[ii + jj*npts].y;
						goodCount++;
					}
					else
						GoodViewID[jj] = false, Inliers[ii].push_back(0);
				}
				finalerror = sqrt(finalerror / goodCount);

				if (goodCount > bestCount)
				{
					NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
					WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

					finalerror = 0.0;
					for (jj = 0; jj < goodCount; jj++)
					{
						ProjectandDistort(WC[ii], goodpts2d, tP + 12 * jj, NULL, NULL, 1);
						finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
					}
					finalerror = sqrt(finalerror / goodCount);
				}
				if (finalerror < threshold)
					PassedTri[ii] = true;
				else
					PassedTri[ii] = false;
			}
		}
	}

	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
double NviewTriangulationRANSAC(vector<Point2d> *pts, double *P, Point3d *WC, bool *PassedTri, vector<int> *Inliers, int nview, int npts, int MaxRanSacIter, double inlierPercent, double threshold, double *A, double *B, double *tP, bool nonlinear, bool refineRanSac)
{
	int ii, jj, kk, ll, goodCount, bestCount;
	double u, v;
	Point2d _pt;
	Point3d t3D, b3D;
	bool MenCreated = false;
	if (A == NULL)
	{
		MenCreated = true;
		A = new double[6 * nview];
		B = new double[2 * nview];
		tP = new double[12 * nview];
	}

	double P3D[3];
	int *GoodViewID = new int[nview], *BestViewID = new int[nview];
	Point2d *goodpts2d = new Point2d[nview], *goodpts2dbk = new Point2d[nview];
	double *reprojectErr = 0, *P2D = 0;
	if (nonlinear)
	{
		reprojectErr = new double[nview];
		P2D = new double[nview * 2];
	}

	double finalerror = 999;
	for (ii = 0; ii < npts; ii++)
	{
		//Pick a random pair to triangulate
		Point pair;
		bestCount = 0;
		for (kk = 0; kk < MaxRanSacIter; kk++)
		{
			pair.x = int(UniformNoise(nview - 1, 0));
			while (true)
			{
				pair.y = int(UniformNoise(nview - 1, 0));
				if (pair.y != pair.x)
					break;
			}
			//Stereo_Triangulation(&pts[ii + pair.x*npts], &pts[ii + pair.y*npts], &P[12 * pair.x], &P[12 * pair.y], &t3D);
			Stereo_Triangulation(&pts[ii].at(pair.x), &pts[ii].at(pair.y), &P[12 * pair.x], &P[12 * pair.y], &t3D);

			//Project to other views
			goodCount = 0;
			for (jj = 0; jj < nview; jj++)
			{
				//_pt = pts[ii + jj*npts];
				_pt = pts[ii][jj];
				ProjectandDistort(t3D, &_pt, &P[12 * jj], NULL, NULL, 1);
				if (abs(_pt.x - pts[ii][jj].x) < threshold && abs(_pt.y - pts[ii][jj].y) < threshold)
					GoodViewID[jj] = true, goodCount++;
				else
					GoodViewID[jj] = false;
			}

			if (goodCount > bestCount)
			{
				bestCount = goodCount, b3D = t3D;
				for (ll = 0; ll<nview; ll++)
					BestViewID[ll] = GoodViewID[ll];
			}
			if (bestCount> nview*inlierPercent)
				break;
		}

		int t = nview*inlierPercent;
		if (bestCount >= max(t, 2))
		{
			int count = 0; Inliers[ii].reserve(nview);
			for (jj = 0; jj < nview; jj++)
			{
				if (!BestViewID[jj])
				{
					//pts[ii + jj*npts].x = 0.0, pts[ii + jj*npts].y = 0.0;
					Inliers[ii].push_back(0);
					continue;
				}
				Inliers[ii].push_back(1);

				u = pts[ii][jj].x, v = pts[ii][jj].y;
				goodpts2d[count] = pts[ii][jj], goodpts2dbk[count] = pts[ii][jj];
				for (ll = 0; ll < 12; ll++)
					tP[12 * count + ll] = P[12 * jj + ll];
				count++;
			}

			for (jj = 0; jj < count; jj++)
			{
				u = goodpts2d[jj].x, v = goodpts2d[jj].y;
				if (nonlinear)
					P2D[2 * jj] = u, P2D[2 * jj + 1] = v;
				A[6 * jj + 0] = tP[12 * jj] - u*tP[12 * jj + 8];
				A[6 * jj + 1] = tP[12 * jj + 1] - u*tP[12 * jj + 9];
				A[6 * jj + 2] = tP[12 * jj + 2] - u*tP[12 * jj + 10];
				A[6 * jj + 3] = tP[12 * jj + 4] - v*tP[12 * jj + 8];
				A[6 * jj + 4] = tP[12 * jj + 5] - v*tP[12 * jj + 9];
				A[6 * jj + 5] = tP[12 * jj + 6] - v*tP[12 * jj + 10];
				B[2 * jj + 0] = u*tP[12 * jj + 11] - tP[12 * jj + 3];
				B[2 * jj + 1] = v*tP[12 * jj + 11] - tP[12 * jj + 7];
			}
			QR_Solution_Double(A, B, 2 * bestCount, 3);
			WC[ii].x = B[0], WC[ii].y = B[1], WC[ii].z = B[2];
			ProjectandDistort(WC[ii], goodpts2d, tP, NULL, NULL, count);

			finalerror = 0.0;
			for (jj = 0; jj < count; jj++)
				finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
			finalerror = sqrt(finalerror / count);
			if (finalerror < threshold)
				PassedTri[ii] = true;
			else
				PassedTri[ii] = false;
		}
		else
			PassedTri[ii] = false;

		if (nonlinear && PassedTri[ii])
		{
			P3D[0] = WC[ii].x, P3D[1] = WC[ii].y, P3D[2] = WC[ii].z;
			NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, bestCount);
			WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

			if (refineRanSac)
			{
				goodCount = 0; finalerror = 0.0;
				Inliers[ii].clear();
				for (jj = 0; jj < nview; jj++)
				{
					ProjectandDistort(WC[ii], &_pt, &P[12 * jj], NULL, NULL, 1);
					double difx = _pt.x - pts[ii][jj].x, dify = _pt.y - pts[ii][jj].y, error = pow(difx, 2) + pow(dify, 2);

					if (error < threshold*threshold)
					{
						finalerror += error;
						Inliers[ii].push_back(1);

						GoodViewID[jj] = true;
						tP[12 * goodCount + ll] = P[12 * jj + ll];
						goodpts2dbk[goodCount] = pts[ii][jj];
						P2D[2 * goodCount] = pts[ii][jj].x, P2D[2 * goodCount + 1] = pts[ii][jj].y;
						goodCount++;
					}
					else
						GoodViewID[jj] = false, Inliers[ii].push_back(0);
				}
				finalerror = sqrt(finalerror / goodCount);

				if (goodCount > bestCount)
				{
					NviewTriangulationNonLinear(tP, P2D, P3D, reprojectErr, goodCount);
					WC[ii].x = P3D[0], WC[ii].y = P3D[1], WC[ii].z = P3D[2];

					finalerror = 0.0;
					for (jj = 0; jj < goodCount; jj++)
					{
						ProjectandDistort(WC[ii], goodpts2d, tP + 12 * jj, NULL, NULL, 1);
						finalerror += pow(goodpts2dbk[jj].x - goodpts2d[jj].x, 2) + pow(goodpts2dbk[jj].y - goodpts2d[jj].y, 2);
					}
					finalerror = sqrt(finalerror / goodCount);
				}
				if (finalerror < threshold)
					PassedTri[ii] = true;
				else
					PassedTri[ii] = false;
			}
		}
	}

	delete[]GoodViewID;
	delete[]BestViewID;
	delete[]goodpts2d;
	delete[]goodpts2dbk;
	if (MenCreated)
		delete[]A, delete[]B, delete[]tP;
	return finalerror;
}
void MultiViewQualityCheck(Point2d *Pts, double *Pmat, int LensType, double *K, double *distortion, bool *PassedPoints, int nviews, int npts, double thresh, Point3d *aWC, Point2d *apts, Point2d *bkapts, int *DeviceMask, double *tK, double *tdistortion, double *tP, double *A, double *B)
{
	//Pts: [pts1; pts2; ...; ptsN]: (npts X nviews) matrix
	int ii, jj, kk, devCount;
	Point3d WC;
	bool createMem = false;
	double error;

	if (apts == NULL)
	{
		createMem = true;
		apts = new Point2d[nviews], bkapts = new Point2d[nviews], DeviceMask = new int[nviews];
		tK = new double[9 * nviews], tdistortion = new double[7 * nviews], tP = new double[12 * nviews];
	}

	for (ii = 0; ii < npts; ii++)
	{
		devCount = 0;
		for (jj = 0; jj < nviews; jj++)
		{
			DeviceMask[jj] = 1;
			if (Pts[jj + ii*nviews].x < 1 || Pts[jj + ii*nviews].y < 1)
				DeviceMask[jj] = 0;
			else
			{
				bkapts[devCount].x = Pts[jj + ii*nviews].x, bkapts[devCount].y = Pts[jj + ii*nviews].y;
				apts[devCount].x = bkapts[devCount].x, apts[devCount].y = bkapts[devCount].y;
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					LensCorrectionPoint(&apts[devCount], K + 9 * jj, distortion + 7 * jj);
				else
					FishEyeCorrectionPoint(&apts[devCount], distortion[7 * jj], distortion[7 * jj + 1], distortion[7 * jj + 2]);

				for (kk = 0; kk < 12; kk++)
					tP[12 * devCount + kk] = Pmat[12 * jj + kk];
				for (kk = 0; kk < 9; kk++)
					tK[9 * devCount + kk] = K[9 * jj + kk];
				if (LensType == RADIAL_TANGENTIAL_PRISM)
					for (kk = 0; kk < 7; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				else
					for (kk = 0; kk < 3; kk++)
						tdistortion[7 * devCount + kk] = distortion[7 * jj + kk];
				devCount++;
			}
		}

		NviewTriangulation(apts, tP, &WC, devCount, 1, NULL, A, B);
		aWC[ii] = WC;
		if (LensType == RADIAL_TANGENTIAL_PRISM)
			ProjectandDistort(WC, apts, tP, tK, tdistortion, devCount);
		else
			FisheyeProjectandDistort(WC, apts, tP, tdistortion, devCount);

		error = 0.0;
		for (jj = 0; jj < devCount; jj++)
			error += pow(bkapts[jj].x - apts[jj].x, 2) + pow(bkapts[jj].y - apts[jj].y, 2);
		error = sqrt(error / devCount);
		if (error < thresh)
			PassedPoints[ii] = true;
		else
			PassedPoints[ii] = false;
	}

	if (createMem)
	{
		delete[]apts, delete[]bkapts, delete[]DeviceMask;
		delete[]tK, delete[]tdistortion, delete[]tP;
	}

	return;
}
void NviewTriangulationRANSACDriver(CameraData *AllViewsInfo, vector<int>Selected3DIndex, vector<int> *nSelectedViews, vector<Point2d> *Selected2D, int nviews)
{
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *P = new double[12 * nviews * 2];
	double *tP = new double[12 * nviews * 2];
	int *BestViewID = new int[nviews * 2];
	bool *passedTri = new bool[nviews * 2];

	Point3d t3D;
	for (int ii = 0; ii < Selected3DIndex.size(); ii++)
	{
		int nviewsII = nSelectedViews[ii].size();
		if (nviewsII <= 2 * nviews)
		{
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}

			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);
		}
		else
		{
			double *A = new double[6 * nviewsII];
			double *B = new double[2 * nviewsII];
			double *P = new double[12 * nviewsII];
			for (int jj = 0; jj < nviewsII; jj++)
			{
				int viewID = nSelectedViews[ii].at(jj);
				for (int kk = 0; kk < 12; kk++)
					P[12 * jj + kk] = AllViewsInfo[viewID].P[kk];
			}
			//NviewTriangulationRANSAC(&Selected2D[ii], P, &t3D, passedTri, BestViewID, nviewsII, 1, (int)nChoosek(nviewsII, 2), 0.7, AllViewsInfo[0].threshold, A, B, tP);

			delete[]A, delete[]B, delete[]P;
		}

	}
	delete[]A, delete[]B, delete[]P, delete[]BestViewID;

	return;
}
struct PinholeReprojectionErrorSimpleError {
	PinholeReprojectionErrorSimpleError(double *Pmat, double u, double v)
	{
		P = Pmat, observed_x = u, observed_y = v;
	}

	template <typename T>	bool operator()(const T* const points, T* residuals) 	const
	{
		T numX = (T)P[0] * points[0] + (T)P[1] * points[1] + (T)P[2] * points[2] + (T)P[3];
		T numY = (T)P[4] * points[0] + (T)P[5] * points[1] + (T)P[6] * points[2] + (T)P[7];
		T denum = (T)P[8] * points[0] + (T)P[9] * points[1] + (T)P[10] * points[2] + (T)P[11];

		residuals[0] = numX / denum - T(observed_x);
		residuals[1] = numY / denum - T(observed_y);

		return true;
	}

	static ceres::CostFunction* Create(double *Pmat, const double observed_x, const double observed_y)
	{
		return (new ceres::AutoDiffCostFunction<PinholeReprojectionErrorSimpleError, 2, 3>(new PinholeReprojectionErrorSimpleError(Pmat, observed_x, observed_y)));
	}

	double observed_x, observed_y, *P;
};
double PinholeReprojectionErrorSimpleDebug(double *P, Point3d Point, Point2d uv)
{
	double numX = P[0] * Point.x + P[1] * Point.y + P[2] * Point.z + P[3];
	double numY = P[4] * Point.x + P[5] * Point.y + P[6] * Point.z + P[7];
	double denum = P[8] * Point.x + P[9] * Point.y + P[10] * Point.z + P[11];

	double residual = sqrt(pow(numX / denum - uv.x, 2) + pow(numY / denum - uv.y, 2));
	return residual;
}
void NviewTriangulationNonLinear(double *P, double *Point2D, double *Point3D, double *ReprojectionError, int nviews, int npts)
{
	ceres::Problem problem;

	//printf("Error before: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			ReprojectionError[ii] += PinholeReprojectionErrorSimpleDebug(P + 12 * jj, Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]));
			ceres::CostFunction* cost_function = PinholeReprojectionErrorSimpleError::Create(P + 12 * jj, Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]);
			problem.AddResidualBlock(cost_function, NULL, &Point3D[ii]);
		}
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.FullReport() << "\n";

	//printf("Error after: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
			ReprojectionError[ii] += PinholeReprojectionErrorSimpleDebug(P + 12 * jj, Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]));
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	return;
}

double MinDistanceTwoLines(double *P0, double *u, double *Q0, double *v, double &s, double &t)
{
	//http://geomalgorithms.com/a07-_distance.html
	double w0[] = { P0[0] - Q0[0], P0[1] - Q0[1], P0[2] - Q0[2] };
	double a = dotProduct(u, u), b = dotProduct(u, v), c = dotProduct(v, v), d = dotProduct(u, w0), e = dotProduct(v, w0);
	double denum = a*c - b*b;

	double distance = 0.0;
	if (denum < 0.00001)//Near parallel line
	{
		s = 0.0, t = d / b;
		double Q[] = { Q0[0] + t*v[0], Q0[1] + t*v[1], Q0[2] + t*v[2] };
		distance = sqrt(pow(P0[0] - Q[0], 2) + pow(P0[1] - Q[1], 2) + pow(P0[2] - Q[2], 2));
	}
	else
	{
		s = (b*e - c*d) / denum, t = (a*e - b*d) / denum;
		double P[] = { P0[0] + s*u[0], P0[1] + s*u[1], P0[2] + s*u[2] };
		double Q[] = { Q0[0] + t*v[0], Q0[1] + t*v[1], Q0[2] + t*v[2] };
		distance = sqrt(pow(P[0] - Q[0], 2) + pow(P[1] - Q[1], 2) + pow(P[2] - Q[2], 2));
	}

	return distance;
}

template <typename Type>void Normalize(Point3_<Type>& vect)
{
	double dist = vect.x*vect.x + vect.y*vect.y + vect.z*vect.z;
	dist = std::sqrt(dist);
	vect.x /= (float)dist;
	vect.y /= (float)dist;
	vect.z /= (float)dist;
}
template <typename Type>double Distance(Point3_<Type>& pt_1, Point3_<Type>& pt_2)
{
	double dist = pow(double(pt_1.x - pt_2.x), 2) + pow(double(pt_1.y - pt_2.y), 2) + pow(double(pt_1.z - pt_2.z), 2);
	return sqrt(dist);
}
void Get3DPtfromDist(double *Kinv, double *Rinv, double *T, Point2d& pt, double depth, Point3d &pt3D)
{
	Mat ptMat = Mat::ones(3, 1, CV_64F);
	Mat mKinv(3, 3, CV_64F, Kinv);
	Mat mRinv(3, 3, CV_64F, Rinv);
	Mat mT(3, 1, CV_64F, T);

	ptMat.at<double>(0, 0) = pt.x;
	ptMat.at<double>(1, 0) = pt.y;


	ptMat = mKinv *ptMat;
	ptMat = ptMat / ptMat.at<double>(2, 0);
	ptMat = ptMat * depth;
	ptMat = mRinv * (ptMat - mT);//from cam coord to world coord

	pt3D.x = ptMat.at<double>(0, 0);
	pt3D.y = ptMat.at<double>(1, 0);
	pt3D.z = ptMat.at<double>(2, 0);

	return;
}
bool SelectRefCam_InitPatchFixedScale(Point3d *expansionVec, double &scale3D, Point3d p3D, vector<KeyPoint> pts, vector<CameraData> AllViewsInfo, double PATCH_3D_ARROW_SIZE_WORLD_UNIT)
{
	//reference frame
	double bestScale = -1;
	int bestVisibleIdx = -1;

	//Find the one which has the largest SIFT scale. 
	for (unsigned int i = 0; i < pts.size(); ++i)
	{
		double scale = pts[i].size;		//This is the diameter!!! 
		double patchHalfSize = scale / 2.0;

		double xMax = pts[i].pt.x + scale;
		double xMin = pts[i].pt.x - scale;
		double yMax = pts[i].pt.y + scale;
		double yMin = pts[i].pt.y - scale;

		if (xMin < 10 || yMin < 10 || xMax >= AllViewsInfo[i].width - 10 || yMax >= AllViewsInfo[i].height - 10)
			continue;

		if (scale > bestScale)
		{
			bestScale = scale;
			bestVisibleIdx = i;
		}
	}
	if (bestVisibleIdx < 0)
		return false;

	//X = R*WC+T --> last element of X is dept wrst to that visible camera
	double depth = AllViewsInfo[bestVisibleIdx].R[6] * p3D.x + AllViewsInfo[bestVisibleIdx].R[7] * p3D.y + AllViewsInfo[bestVisibleIdx].R[8] * p3D.z + AllViewsInfo[bestVisibleIdx].T[2];
	Point2d keyPt = pts[bestVisibleIdx].pt;  ///pt should be also located on the ray

	//feature arrow calculation
	double length = pts[bestVisibleIdx].size / 2.0;
	double theta = pts[bestVisibleIdx].angle;//in radian
	Point2d arrowHead1(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);
	theta -= Pi / 2.0;//in radian
	Point2d arrowHead2(keyPt.x + cos(theta)*length, keyPt.y + sin(theta)*length);

	//initialize with patch wich is parallel to reference image
	Point3d PatchCenter;
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, keyPt, depth, PatchCenter);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead1, depth, expansionVec[0]);
	Get3DPtfromDist(AllViewsInfo[bestVisibleIdx].invK, AllViewsInfo[bestVisibleIdx].invR, AllViewsInfo[bestVisibleIdx].T, arrowHead2, depth, expansionVec[1]);

	//Change to the fixed 3D Patch Scale
	Point3d arrow1Direct = expansionVec[0] - PatchCenter;
	Normalize(arrow1Direct);
	expansionVec[0] = PatchCenter + arrow1Direct* PATCH_3D_ARROW_SIZE_WORLD_UNIT;
	Point3d arrow2Direct = expansionVec[1] - PatchCenter;
	Normalize(arrow2Direct);
	expansionVec[1] = PatchCenter + arrow2Direct* PATCH_3D_ARROW_SIZE_WORLD_UNIT;

	scale3D = Distance(PatchCenter, expansionVec[0]);

	return true;
}

int CameraProjector3DReconstructionFmat(CameraData *AllViewsInfo, Point2d *PCcorres, Point3d *ThreeD, int *CameraPair, int nCams, int nProjectors, int nPpts)
{
	int ii, jj;

	//Estimate fundamental matrix
	vector<int> pid;
	vector<Point2f>imgpts1, imgpts2;
	for (ii = 0; ii < nPpts*nProjectors; ii++)
	{
		if (PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].x > 0.0001 && PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].x > 0.0001)
		{
			pid.push_back(ii);
			imgpts1.push_back(Point2f(PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].x, PCcorres[CameraPair[0] + ii*(nProjectors + nCams)].y));
			imgpts2.push_back(Point2f(PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].x, PCcorres[CameraPair[1] + ii*(nProjectors + nCams)].y));
		}
	}
	Mat cvF = findFundamentalMat(imgpts1, imgpts2, FM_8POINT, 0.1, 0.99);

	cout << "Fmat: " << endl;
	cout << cvF << endl << endl;

	//Extract essential matrix
	Mat cvK1(3, 3, CV_64F, AllViewsInfo[CameraPair[0]].K);
	Mat cvK2(3, 3, CV_64F, AllViewsInfo[CameraPair[1]].K);

	Mat cvE = cvK2.t()*cvF*cvK1;
	cout << "Emat: " << endl;
	cout << cvE << endl << endl;

	//Decompose into RT
	SVD svd(cvE, SVD::MODIFY_A);
	double m = (svd.w.at<double>(0) + svd.w.at<double>(1)) / 2;
	double nW[9] = { m, 0, 0, 0, m, 0, 0, 0, 0 };
	Mat cvnW(3, 3, CV_64F, nW);
	Mat cvnE = svd.u*cvnW*svd.vt;
	SVD svd2(cvnE, SVD::MODIFY_A);

	cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = -1.0, cvnW.at<double>(0, 2) = 0.0;
	cvnW.at<double>(1, 0) = 1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
	cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = 1.0;

	//Make sure we return rotation matrices with det(R) == 1
	Mat UWVt = svd2.u*cvnW*svd2.vt;
	if (determinant(UWVt) < 0.0)
	{
		cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = 1.0, cvnW.at<double>(0, 2) = 0.0;
		cvnW.at<double>(1, 0) = -1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
		cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = -1.0;
	}

	UWVt = svd2.u*cvnW*svd2.vt;
	Mat UWtVt = svd2.u*cvnW.t()*svd2.vt;

	double maxU = 0.0;
	for (ii = 0; ii < 3; ii++)
		if (maxU < abs(svd2.u.at<double>(ii, 2)))
			maxU = abs(svd2.u.at<double>(ii, 2));

	//There are 4 possible cases
	double RT2[] = { UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU };

	//Cherality check
	double P1[12], P2[48], RT1[] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };
	mat_mul(AllViewsInfo[CameraPair[0]].K, RT1, P1, 3, 3, 4);
	for (ii = 0; ii < 4; ii++)
		mat_mul(AllViewsInfo[CameraPair[1]].K, RT2 + 12 * ii, P2 + 12 * ii, 3, 3, 4);

	Point2d pt1, pt2; Point3d WC;
	int positivePoints[4] = { 0, 0, 0, 0 }, RTid[4] = { 0, 1, 2, 3 };
	for (ii = 0; ii < imgpts1.size(); ii++)
	{
		pt1.x = imgpts1[ii].x, pt1.y = imgpts1[ii].y;
		pt2.x = imgpts2[ii].x, pt2.y = imgpts2[ii].y;

		for (jj = 0; jj<4; jj++)
		{
			//Stereo_Triangulation2(&pt1, &pt2, P1, P2+12*jj, &WC); 
			if (WC.z > 0.0)
				positivePoints[jj] ++;
		}
	}

	Quick_Sort_Int(positivePoints, RTid, 0, 3);
	if (positivePoints[3] < 10)
	{
		cout << "Something wrong. Only a few points have positve z values" << endl;
		return 1;
	}

	/*for(ii=0; ii<6; ii++)
	AllViewsInfo[CameraPair[0]].rt[ii] = 0.0;

	Mat rvec, Rmat = (Mat_<double>(3,3) << RT2[RTid[3]*12], RT2[RTid[3]*12+1], RT2[RTid[3]*12+2],
	RT2[RTid[3]*12+4], RT2[RTid[3]*12+5], RT2[RTid[3]*12+6],
	RT2[RTid[3]*12+8], RT2[RTid[3]*12+9], RT2[RTid[3]*12+10]);
	Rodrigues( Rmat, rvec);

	for(ii=0; ii<3; ii++)
	{
	AllViewsInfo[CameraPair[1]].RT[ii] = rvec.at<double>(ii);
	AllViewsInfo[CameraPair[1]].RT[ii+3] = RT2[RTid[3]*12+3+4*ii];
	}

	//Triangulate
	for(ii = 0; ii<nPpts*nProjectors; ii++ )
	{
	if(PCcorres[CameraPair[0]+ii*(nProjectors+nCams)].x > 0.0001 && PCcorres[CameraPair[1]+ii*(nProjectors+nCams)].x > 0.0001)
	;//Stereo_Triangulation(&PCcorres[CameraPair[0]+ii*(nProjectors+nCams)], &PCcorres[CameraPair[1]+ii*(nProjectors+nCams)], P1, P2+12*RTid[3], &ThreeD[ii]);
	else
	{
	ThreeD[ii].x = 0.0, ThreeD[ii].y = 0.0, ThreeD[ii].z = 0.0;
	}
	}*/
	return 0;
}
int TwoViewsClean3DReconstructionFmat(CameraData &View1, CameraData &View2, vector<Point2d>imgpts1, vector<Point2d> imgpts2, vector<Point3d> &P3D)
{
	//Assuming correspondences are perfect. Note that points are not undistorted
	int ii, jj;
	int npts = (int)imgpts1.size();

	if (View1.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts1, View1.K, View1.distortion);
	else
		FishEyeCorrectionPoint(imgpts1, View1.distortion[0], View1.distortion[1], View1.distortion[2]);

	if (View2.LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(imgpts2, View2.K, View2.distortion);
	else
		FishEyeCorrectionPoint(imgpts2, View2.distortion[0], View2.distortion[1], View2.distortion[2]);

	//Estimate fundamental matrix
	vector<int> pid;
	Mat cvF = findFundamentalMat(imgpts1, imgpts2, FM_8POINT, 3.0);

	//cout << "Fmat: " << cvF << endl << endl;

	//Extract essential matrix
	Mat cvK1(3, 3, CV_64F, View1.K);
	Mat cvK2(3, 3, CV_64F, View2.K);

	Mat cvE = cvK2.t()*cvF*cvK1;
	//cout << "Emat: " << cvE << endl << endl;

	//Decompose into RT
	SVD svd(cvE, SVD::MODIFY_A);
	double m = (svd.w.at<double>(0) + svd.w.at<double>(1)) / 2;
	double nW[9] = { m, 0, 0, 0, m, 0, 0, 0, 0 };
	Mat cvnW(3, 3, CV_64F, nW);
	Mat cvnE = svd.u*cvnW*svd.vt;
	SVD svd2(cvnE, SVD::MODIFY_A);

	cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = -1.0, cvnW.at<double>(0, 2) = 0.0;
	cvnW.at<double>(1, 0) = 1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
	cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = 1.0;

	//Make sure we return rotation matrices with det(R) == 1
	Mat UWVt = svd2.u*cvnW*svd2.vt;
	if (determinant(UWVt) < 0.0)
	{
		cvnW.at<double>(0, 0) = 0.0, cvnW.at<double>(0, 1) = 1.0, cvnW.at<double>(0, 2) = 0.0;
		cvnW.at<double>(1, 0) = -1.0, cvnW.at<double>(1, 1) = 0.0, cvnW.at<double>(1, 2) = 0.0;
		cvnW.at<double>(2, 0) = 0.0, cvnW.at<double>(2, 1) = 0.0, cvnW.at<double>(2, 2) = -1.0;
	}

	UWVt = svd2.u*cvnW*svd2.vt;
	Mat UWtVt = svd2.u*cvnW.t()*svd2.vt;

	double maxU = 0.0;
	for (ii = 0; ii < 3; ii++)
		if (maxU < abs(svd2.u.at<double>(ii, 2)))
			maxU = abs(svd2.u.at<double>(ii, 2));

	//There are 4 possible cases
	double RT2[] = { UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWVt.at<double>(0, 0), UWVt.at<double>(0, 1), UWVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWVt.at<double>(1, 0), UWVt.at<double>(1, 1), UWVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWVt.at<double>(2, 0), UWVt.at<double>(2, 1), UWVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), svd2.u.at<double>(2, 2) / maxU,

		UWtVt.at<double>(0, 0), UWtVt.at<double>(0, 1), UWtVt.at<double>(0, 2), -svd2.u.at<double>(0, 2) / maxU,
		UWtVt.at<double>(1, 0), UWtVt.at<double>(1, 1), UWtVt.at<double>(1, 2), -svd2.u.at<double>(1, 2) / maxU,
		UWtVt.at<double>(2, 0), UWtVt.at<double>(2, 1), UWtVt.at<double>(2, 2), -svd2.u.at<double>(2, 2) / maxU };

	//Cherality check
	double P1[12], P2[48], RT1[] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };
	mat_mul(View1.K, RT1, P1, 3, 3, 4);
	for (ii = 0; ii < 4; ii++)
		mat_mul(View2.K, RT2 + 12 * ii, P2 + 12 * ii, 3, 3, 4);

	Point3d p3d;
	int positivePoints[4] = { 0, 0, 0, 0 }, RTid[4] = { 0, 1, 2, 3 };
	for (ii = 0; ii < imgpts1.size(); ii++)
	{
		for (jj = 0; jj<4; jj++)
		{
			Stereo_Triangulation(&imgpts1[ii], &imgpts2[ii], P1, P2 + 12 * jj, &p3d);
			if (p3d.z > 0.0)
				positivePoints[jj] ++;
		}
	}

	Quick_Sort_Int(positivePoints, RTid, 0, 3);
	if (positivePoints[3] < 10)
	{
		cout << "Something wrong. Only a few points have positve z values" << endl;
		return 1;
	}

	//Finalize data
	for (ii = 0; ii < 3; ii++)
		View1.rt[ii] = 0.0, View1.rt[ii + 3] = 0.0;

	Mat rvec, Rmat = (Mat_<double>(3, 3) << RT2[RTid[3] * 12], RT2[RTid[3] * 12 + 1], RT2[RTid[3] * 12 + 2],
		RT2[RTid[3] * 12 + 4], RT2[RTid[3] * 12 + 5], RT2[RTid[3] * 12 + 6],
		RT2[RTid[3] * 12 + 8], RT2[RTid[3] * 12 + 9], RT2[RTid[3] * 12 + 10]);
	Rodrigues(Rmat, rvec);

	for (ii = 0; ii < 3; ii++)
		View2.rt[ii] = rvec.at<double>(ii), View2.rt[ii + 3] = RT2[RTid[3] * 12 + 3 + 4 * ii];

	//Triangulate
	Stereo_Triangulation(imgpts1, imgpts2, P1, P2 + 12 * RTid[3], P3D);

	return 0;
}
int TwoCameraReconstruction(char *Path, CameraData *AllViewsInfo, int nviews, int timeID, vector<int> cumulativePts, vector<int>*PointCorres, vector<int> availViews, Point3d *ThreeD)
{
	vector<int>CorrespondencesID, SelectedIndex;
	vector<KeyPoint>keypoints1, keypoints2;
	CorrespondencesID.reserve(10000), SelectedIndex.reserve(10000), keypoints1.reserve(20000), keypoints1.reserve(20000);
	//GetPoint2DPairCorrespondence(Path, nviews, timeID, cumulativePts, availViews, keypoints1, keypoints2, CorrespondencesID, SelectedIndex, true);

	int npts = CorrespondencesID.size() / 2;
	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = CorrespondencesID.at(2 * ii), id2 = CorrespondencesID.at(2 * ii + 1);
		pts1[ii].x = keypoints1.at(id1).pt.x, pts1[ii].y = keypoints1.at(id1).pt.y;
		pts2[ii].x = keypoints2.at(id2).pt.x, pts2[ii].y = keypoints2.at(id2).pt.y;
	}

	if (AllViewsInfo[availViews.at(0)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		LensCorrectionPoint(pts1, AllViewsInfo[availViews.at(0)].K, AllViewsInfo[availViews.at(0)].distortion, npts);
		LensCorrectionPoint(pts2, AllViewsInfo[availViews.at(1)].K, AllViewsInfo[availViews.at(1)].distortion, npts);
	}

	Mat x1s(npts, 2, CV_64F), x2s(npts, 2, CV_64F);
	for (int ii = 0; ii < npts; ii++)
	{
		x1s.at<double>(ii, 0) = pts1[ii].x, x1s.at<double>(ii, 1) = pts1[ii].y;
		x2s.at<double>(ii, 0) = pts2[ii].x, x2s.at<double>(ii, 1) = pts2[ii].y;
	}

	Mat cvK1 = Mat(3, 3, CV_64F, AllViewsInfo[availViews.at(0)].K);
	Mat cvK2 = Mat(3, 3, CV_64F, AllViewsInfo[availViews.at(1)].K);

	Mat E = findEssentialMat(x1s, x2s, cvK1, cvK2, CV_RANSAC, 0.99, 1, 200, noArray());

	Mat R_5pt, rvec_5pt, tvec_5pt;
	recoverPose(E, x1s, x2s, R_5pt, tvec_5pt, cvK1, cvK2, noArray());
	//Rodrigues(R_5pt, rvec_5pt);

	Mat cvP1(3, 4, CV_64F), cvP2(3, 4, CV_64F);
	cvP1 = Mat::eye(3, 4, CV_64F); cvP1 = cvK1*cvP1;
	cvP2(Range::all(), Range(0, 3)) = R_5pt * 1.0; cvP2.col(3) = tvec_5pt * 1.0;  cvP2 = cvK2*cvP2;

	Mat cvThreeD;
	x1s = x1s.t(), x2s = x2s.t();
	triangulatePoints(cvP1, cvP2, x1s, x2s, cvThreeD);

	cvThreeD.row(0) /= cvThreeD.row(3);
	cvThreeD.row(1) /= cvThreeD.row(3);
	cvThreeD.row(2) /= cvThreeD.row(3);
	cvThreeD.row(3) /= cvThreeD.row(3);

	bool *goodPoints = new bool[npts];
	Point3d *t3D = new Point3d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		t3D[ii].x = cvThreeD.at<double>(0, ii);
		t3D[ii].y = cvThreeD.at<double>(1, ii);
		t3D[ii].z = cvThreeD.at<double>(2, ii);
	}

	double P1[12], P2[12];
	for (int ii = 0; ii < 12; ii++)
		P1[ii] = cvP1.at<double>(ii), P2[ii] = cvP2.at<double>(ii);

	double threshold = AllViewsInfo[0].threshold;
	TwoViewTriangulationQualityCheck(pts1, pts2, t3D, P1, P2, goodPoints, threshold, npts, NULL, NULL, NULL, NULL);

	int count = 0;
	for (int ii = 0; ii < npts; ii++)
	{
		if (goodPoints[ii])
		{
			count++;
			int id = SelectedIndex[ii];
			ThreeD[id].x = cvThreeD.at<double>(0, ii);
			ThreeD[id].y = cvThreeD.at<double>(1, ii);
			ThreeD[id].z = cvThreeD.at<double>(2, ii);
			for (int jj = 0; jj < PointCorres[id].size(); jj++)
				ThreeD[PointCorres[id].at(jj)] = ThreeD[id];
		}
	}

	AllViewsInfo[availViews.at(0)].R[0] = 1.0, AllViewsInfo[availViews.at(0)].R[1] = 0.0, AllViewsInfo[availViews.at(0)].R[2] = 0.0, AllViewsInfo[availViews.at(0)].T[0] = 0.0;
	AllViewsInfo[availViews.at(0)].R[3] = 0.0, AllViewsInfo[availViews.at(0)].R[4] = 1.0, AllViewsInfo[availViews.at(0)].R[5] = 0.0, AllViewsInfo[availViews.at(0)].T[1] = 0.0;
	AllViewsInfo[availViews.at(0)].R[6] = 0.0, AllViewsInfo[availViews.at(0)].R[7] = 0.0, AllViewsInfo[availViews.at(0)].R[8] = 1.0, AllViewsInfo[availViews.at(0)].T[2] = 0.0;

	for (int ii = 0; ii < 9; ii++)
		AllViewsInfo[availViews.at(1)].R[ii] = R_5pt.at<double>(ii);
	for (int ii = 0; ii < 3; ii++)
		AllViewsInfo[availViews.at(1)].T[ii] = tvec_5pt.at<double>(ii);

	//Update ViewParas
	GetrtFromRT(AllViewsInfo, availViews);
	GetIntrinsicFromK(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	/*FILE *fp = fopen("C:/temp/2d3D.txt", "w+");
	for (int ii = 0; ii < CorrespondencesID.size() / 2; ii++)
	if (goodPoints[ii])
	fprintf(fp, "%d %d\n", CorrespondencesID.at(2 * ii), SelectedIndex[ii]);
	fclose(fp);

	fp = fopen("C:/temp/2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	if (goodPoints[ii])
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", pts1[ii].x, pts1[ii].y, cvThreeD.at<double>(0, ii), cvThreeD.at<double>(1, ii), cvThreeD.at<double>(2, ii));
	fclose(fp);*/

	delete[]pts1, delete[]pts2, delete[]t3D, delete[]goodPoints;

	if (count < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", availViews.at(0), availViews.at(1), count);
		return 1;
	}
	else
		return 0;
}
void DetermineDevicePose(double *K, double *distortion, int LensModel, double *R, double *T, Point2d *pts, Point3d *ThreeD, int npts, int distortionCorrected, double thresh, int &ninliers)
{
	int ii;
	Mat cvpts(npts, 2, CV_32F), cv3D(npts, 3, CV_32F);

	if (distortionCorrected == 0 && LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(pts, K, distortion, npts);
	else if (distortionCorrected == 0 && LensModel == FISHEYE)
		FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2], npts);

	for (ii = 0; ii < npts; ii++)
	{
		cvpts.at<float>(ii, 0) = pts[ii].x, cvpts.at<float>(ii, 1) = pts[ii].y;
		cv3D.at<float>(ii, 0) = ThreeD[ii].x, cv3D.at<float>(ii, 1) = ThreeD[ii].y, cv3D.at<float>(ii, 2) = ThreeD[ii].z;
	}

	/*FILE *fp = fopen("C:/temp/_2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", cvpts.at<float>(ii, 0), cvpts.at<float>(ii, 1), cv3D.at<float>(ii,0), cv3D.at<float>(ii,1), cv3D.at<float>(ii,2));
	fclose(fp);*/

	Mat cvK = Mat(3, 3, CV_32F), rvec(1, 3, CV_32F), tvec(1, 3, CV_32F);
	for (ii = 0; ii < 9; ii++)
		cvK.at<float>(ii) = (float)K[ii];

	Mat Inliers;
	double ProThresh = 0.995, PercentInlier = 0.4;
	int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	solvePnPRansac(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, iterMax, thresh, npts*PercentInlier, Inliers, CV_EPNP);// CV_ITERATIVE);

	ninliers = Inliers.rows;
	//cout << rvec << endl;
	//cout << tvec << endl;

	Mat Rmat(3, 3, CV_64F);
	Rodrigues(rvec, Rmat);
	for (ii = 0; ii < 9; ii++)
		R[ii] = Rmat.at<double>(ii);
	for (ii = 0; ii < 3; ii++)
		T[ii] = tvec.at<double>(ii);

	return;
}
void DetermineDevicePose(double *K, double *distortion, int LensModel, double *R, double *T, vector<Point2d> pts, vector<Point3d> ThreeD, int distortionCorrected, double thresh, int &ninliers, bool directMethod)
{
	int ii, npts = (int)pts.size();
	Mat cvpts(npts, 2, CV_32F), cv3D(npts, 3, CV_32F);

	if (distortionCorrected == 0 && LensModel == RADIAL_TANGENTIAL_PRISM)
		LensCorrectionPoint(pts, K, distortion);
	else if (distortionCorrected == 0 && LensModel == FISHEYE)
		FishEyeCorrectionPoint(pts, distortion[0], distortion[1], distortion[2]);

	for (ii = 0; ii < npts; ii++)
	{
		cvpts.at<float>(ii, 0) = pts[ii].x, cvpts.at<float>(ii, 1) = pts[ii].y;
		cv3D.at<float>(ii, 0) = ThreeD[ii].x, cv3D.at<float>(ii, 1) = ThreeD[ii].y, cv3D.at<float>(ii, 2) = ThreeD[ii].z;
	}

	/*FILE *fp = fopen("C:/temp/_2d3dCorres.txt", "w+");
	for (int ii = 0; ii < npts; ii++)
	fprintf(fp, "%.6f %.6f %.6f %.6f %.6f\n", cvpts.at<float>(ii, 0), cvpts.at<float>(ii, 1), cv3D.at<float>(ii,0), cv3D.at<float>(ii,1), cv3D.at<float>(ii,2));
	fclose(fp);*/

	Mat cvK = Mat(3, 3, CV_32F), rvec(1, 3, CV_32F), tvec(1, 3, CV_32F);
	for (ii = 0; ii < 9; ii++)
		cvK.at<float>(ii) = (float)K[ii];

	if (directMethod)
		solvePnP(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, ITERATIVE);
	else
	{
		Mat Inliers;
		double ProThresh = 0.995, PercentInlier = 0.4;
		int iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 4)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
		solvePnPRansac(cv3D, cvpts, cvK, Mat(), rvec, tvec, false, iterMax, thresh, npts*PercentInlier, Inliers, CV_EPNP);// CV_ITERATIVE);

		ninliers = Inliers.rows;
	}
	cout << rvec << endl << tvec << endl;

	Mat Rmat(3, 3, CV_64F);
	Rodrigues(rvec, Rmat);
	for (ii = 0; ii < 9; ii++)
		R[ii] = Rmat.at<double>(ii);
	for (ii = 0; ii < 3; ii++)
		T[ii] = tvec.at<double>(ii);

	return;
}
int AddNewViewReconstruction(char *Path, CameraData *AllViewsInfo, int nviews, int timeID, vector<int> cumulativePts, vector<int>*PointCorres, Point3d *All3D, double threshold, vector<int> &availViews)
{
	int ii, jj, kk, ll;

	//Determine next view with highest number of correspondences
	int maxPoints = 0;
	vector<int>viewID; viewID.reserve(2); viewID.push_back(0), viewID.push_back(0);
	vector<int>checkedViews; checkedViews.reserve(100);
	for (ii = 0; ii < availViews.size(); ii++)
	{
		for (jj = 0; jj<checkedViews.size(); jj++)
		{
			if (availViews[ii] == checkedViews.at(jj))
				break;
		}

		if (jj == checkedViews.size())
		{
			checkedViews.push_back(availViews[ii]);
			kk = NextViewFinder(Path, nviews, timeID, availViews[ii], ll, availViews);
			if (ll>maxPoints)
				maxPoints = ll, viewID.at(0) = availViews[ii], viewID.at(1) = kk;
		}
	}
	availViews.push_back(viewID.at(1));
	sort(availViews.begin(), availViews.end());
	printf("Adding view %d to the list...", viewID.at(1));

	bool SwapView = viewID.at(0) < viewID.at(1) ? false : true;
	sort(viewID.begin(), viewID.end());

	//Get correspondences and their indices
	vector<KeyPoint> keypoints1, keypoints2;
	vector<int>TwoDcorrespondencesID, ThreeDCorrespondencesID, SelectedIndex;
	keypoints1.reserve(10000), keypoints2.reserve(10000);
	TwoDcorrespondencesID.reserve(10000), ThreeDCorrespondencesID.reserve(10000), SelectedIndex.reserve(10000);

	GetPoint3D2DPairCorrespondence(Path, nviews, timeID, cumulativePts, viewID, All3D, keypoints1, keypoints2, TwoDcorrespondencesID, ThreeDCorrespondencesID, SelectedIndex, SwapView);
	if (ThreeDCorrespondencesID.size() / 2 < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", viewID.at(0), viewID.at(1), ThreeDCorrespondencesID.size() / 2);
		return 1;
	}

	//Run PnP for pose estimation
	int npts = ThreeDCorrespondencesID.size() / 2;
	Point2d *pts = new Point2d[npts];
	Point3d *t3D = new Point3d[npts];

	for (ii = 0; ii < npts; ii++)
	{
		int id1 = ThreeDCorrespondencesID.at(2 * ii), id2 = ThreeDCorrespondencesID.at(2 * ii + 1);
		if (SwapView)
			pts[ii].x = keypoints1.at(id1).pt.x, pts[ii].y = keypoints1.at(id1).pt.y;
		else
			pts[ii].x = keypoints2.at(id1).pt.x, pts[ii].y = keypoints2.at(id1).pt.y;
		t3D[ii] = All3D[id2];
	}

	if (AllViewsInfo[viewID.at(1)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		if (SwapView)
			LensCorrectionPoint(pts, AllViewsInfo[viewID.at(0)].K, AllViewsInfo[viewID.at(0)].distortion, npts);
		else
			LensCorrectionPoint(pts, AllViewsInfo[viewID.at(1)].K, AllViewsInfo[viewID.at(1)].distortion, npts);
	}

	int ninliers, distortionCorrected = 0;
	if (SwapView)
		DetermineDevicePose(AllViewsInfo[viewID.at(0)].K, NULL, AllViewsInfo[viewID.at(0)].LensModel, AllViewsInfo[viewID.at(0)].R, AllViewsInfo[viewID.at(0)].T, pts, t3D, npts, distortionCorrected, AllViewsInfo[0].threshold * 2, ninliers);
	else
		DetermineDevicePose(AllViewsInfo[viewID.at(1)].K, NULL, AllViewsInfo[viewID.at(1)].LensModel, AllViewsInfo[viewID.at(1)].R, AllViewsInfo[viewID.at(1)].T, pts, t3D, npts, distortionCorrected, AllViewsInfo[0].threshold * 2, ninliers);
	delete[]pts, delete[]t3D;

	//Triangulate new points
	npts = TwoDcorrespondencesID.size() / 2;
	Point2d *pts1 = new Point2d[npts], *pts2 = new Point2d[npts];
	for (int ii = 0; ii < npts; ii++)
	{
		int id1 = TwoDcorrespondencesID.at(2 * ii), id2 = TwoDcorrespondencesID.at(2 * ii + 1);
		pts1[ii].x = keypoints1.at(id1).pt.x, pts1[ii].y = keypoints1.at(id1).pt.y;
		pts2[ii].x = keypoints2.at(id2).pt.x, pts2[ii].y = keypoints2.at(id2).pt.y;
	}

	if (AllViewsInfo[viewID.at(0)].LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		LensCorrectionPoint(pts1, AllViewsInfo[viewID.at(0)].K, AllViewsInfo[viewID.at(0)].distortion, npts);
		LensCorrectionPoint(pts2, AllViewsInfo[viewID.at(1)].K, AllViewsInfo[viewID.at(1)].distortion, npts);
	}

	double P1[12], P2[12], RT1[12], RT2[12];
	AssembleRT(AllViewsInfo[viewID.at(0)].R, AllViewsInfo[viewID.at(0)].T, RT1);
	AssembleRT(AllViewsInfo[viewID.at(1)].R, AllViewsInfo[viewID.at(1)].T, RT2);

	mat_mul(AllViewsInfo[viewID.at(0)].K, RT1, P1, 3, 3, 4);
	mat_mul(AllViewsInfo[viewID.at(1)].K, RT2, P2, 3, 3, 4);

	//Triangulate and remove bad points quality
	bool *goodPoints = new bool[npts];
	Point3d *_t3D = new Point3d[npts];
	Stereo_Triangulation(pts1, pts2, P1, P2, _t3D, npts);
	TwoViewTriangulationQualityCheck(pts1, pts2, _t3D, P1, P2, goodPoints, threshold, npts, NULL, NULL, NULL, NULL);

	int count = 0;
	for (int ii = 0; ii < npts; ii++)
	{
		if (goodPoints[ii])
		{
			count++;
			int id = SelectedIndex[ii];
			All3D[id] = _t3D[ii];
			for (int jj = 0; jj < PointCorres[id].size(); jj++)
				All3D[PointCorres[id].at(jj)] = All3D[id];
		}
	}

	//Update ViewParas
	GetrtFromRT(AllViewsInfo, availViews);
	GetIntrinsicFromK(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	delete[]pts1, delete[]pts2, delete[]_t3D, delete[]goodPoints;

	sort(availViews.begin(), availViews.end());
	if (count < AllViewsInfo[0].ninlierThresh)
	{
		printf("Stiching from %d to %d fails due to low number of inliers (%d)\n", viewID.at(0), viewID.at(1), ThreeDCorrespondencesID.size() / 2);
		return 1;
	}
	else
		return 0;
}

struct FOVReprojectionError {
	FOVReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T> bool operator()(const T* const intrinsic, const T* distortion, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to image coordinate
		T xcn = p[0] / p[2], ycn = p[1] / p[2];
		T u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

		//Apply lens distortion
		T omega = distortion[0], DistCtrX = T(distortion[1]), DistCtrY = T(distortion[2]);
		T x = u - DistCtrX, y = v - DistCtrY;
		T ru = sqrt(x*x + y*y), rd = atan(T(2.0)*ru*tan(T(0.5)*omega)) / omega;
		T t = rd / ru;
		T x_u = t*x, y_u = t*y;

		residuals[0] = (x_u + DistCtrX - T(observed_x)) / (T)scale,
			residuals[1] = (y_u + DistCtrY - T(observed_y)) / (T)scale;
		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, const double scale)
	{
		return (new ceres::AutoDiffCostFunction<FOVReprojectionError, 2, 5, 3, 3, 3>(new FOVReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
struct FOVReprojectionError2 {
	FOVReprojectionError2(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T> bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* distortion, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to image coordinate
		T xcn = p[0] / p[2], ycn = p[1] / p[2];
		T u = fxfy[0] * xcn + skew[0] * ycn + uv0[0], v = fxfy[1] * ycn + uv0[1];

		//Apply lens distortion
		T omega = distortion[0], DistCtrX = T(distortion[1]), DistCtrY = T(distortion[2]);
		T x = u - DistCtrX, y = v - DistCtrY;
		T ru = sqrt(x*x + y*y), rd = atan(T(2.0)*ru*tan(T(0.5)*omega)) / omega;
		T t = rd / ru;
		T x_u = t*x, y_u = t*y;

		residuals[0] = (x_u + DistCtrX - T(observed_x)) / (T)scale,
			residuals[1] = (y_u + DistCtrY - T(observed_y)) / (T)scale;
		return true;
	}

	// Factory to hide the construction of the CostFunction object from the client code.
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::AutoDiffCostFunction<FOVReprojectionError2, 2, 2, 1, 2, 3, 6, 3>(new FOVReprojectionError2(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
void FOVReprojectionDistortionDebug(double *intrinsic, double* distortion, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	double u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

	//Apply lens distortion
	double omega = distortion[0], DistCtr[2] = { distortion[1], distortion[2] };
	double x = u - DistCtr[0], y = v - DistCtr[1];
	double ru = sqrt(x*x + y*y), rd = atan(2.0*ru*tan(0.5*omega)) / omega;
	double t = rd / ru;
	double x_u = t*x, y_u = t*y;

	residuals[0] = x_u + DistCtr[0] - observed.x, residuals[1] = y_u + DistCtr[1] - observed.y;
	return;
}

struct PinholeReprojectionError {
	PinholeReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}

	template <typename T>	bool operator()(const T* const intrinsic, const T* const RT, const T* const point, T* residuals) 	const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xn = p[0] / p[2];
		T yn = p[1] / p[2];

		residuals[0] = (intrinsic[0] * xn + intrinsic[2] * yn + intrinsic[3] - T(observed_x)) / (T)scale;
		residuals[1] = (intrinsic[1] * yn + intrinsic[4] - T(observed_y)) / (T)scale;

		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::AutoDiffCostFunction<PinholeReprojectionError, 2, 5, 6, 3>(new PinholeReprojectionError(observed_x, observed_y, scale)));
	}

	static ceres::CostFunction* CreateNumerDiff(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::NumericDiffCostFunction<PinholeReprojectionError, ceres::CENTRAL, 2, 5, 6, 3>(new PinholeReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
void PinholeReprojectionDebug(double *intrinsic, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	double u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], v = intrinsic[1] * ycn + intrinsic[4];

	residuals[0] = u - observed.x, residuals[1] = v - observed.y;
	return;
}

struct PinholeDistortionReprojectionError {
	PinholeDistortionReprojectionError(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale) {}
	template <typename T>	bool operator()(const T* const intrinsic, const T* const distortion, const T* const RT, const T* const point, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + distortion[0] * r2 + distortion[1] * r4 + distortion[2] * r6;
		T tangentialX = T(2.0)*distortion[4] * xycn + distortion[3] * (r2 + T(2.0)*xcn2);
		T tangentailY = distortion[4] * (r2 + T(2.0)*ycn2) + T(2.0)*distortion[3] * xycn;
		T prismX = distortion[5] * r2;
		T prismY = distortion[6] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = intrinsic[0] * xcn_ + intrinsic[2] * ycn_ + intrinsic[3];
		T predicted_y = intrinsic[1] * ycn_ + intrinsic[4];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError, 2, 5, 7, 6, 3>(new PinholeDistortionReprojectionError(observed_x, observed_y, scale)));
	}
	static ceres::CostFunction* CreateNumerDiff(const double observed_x, const double observed_y, double scale)
	{
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 3>(new PinholeDistortionReprojectionError(observed_x, observed_y, scale)));
	}

	double observed_x, observed_y, scale;
};
struct PinholeDistortionReprojectionError2 {
	PinholeDistortionReprojectionError2(double observed_x, double observed_y, double scale) : observed_x(observed_x), observed_y(observed_y), scale(scale){}
	template <typename T>	bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* const Radial12, const T* const Tangential12, const T*const Radial3, const T*Prism, const T* const RT, const T* const point, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
		T tangentialX = T(2.0)*Tangential12[1] * xycn + Tangential12[0] * (r2 + T(2.0)*xcn2);
		T tangentailY = Tangential12[1] * (r2 + T(2.0)*ycn2) + T(2.0)*Tangential12[0] * xycn;
		T prismX = Prism[0] * r2;
		T prismY = Prism[1] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + uv0[0];
		T predicted_y = fxfy[1] * ycn_ + uv0[1];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError2, 2, 2, 1, 2, 2, 2, 1, 2, 6, 3>(new PinholeDistortionReprojectionError2(observed_x, observed_y, scale)));
	}
	double observed_x, observed_y, scale;
};
struct PinholeDistortionReprojectionError3 {
	PinholeDistortionReprojectionError3(double observed_x, double observed_y, double X, double Y, double Z, double scale) : observed_x(observed_x), observed_y(observed_y), X(X), Y(Y), Z(Z), scale(scale){}
	template <typename T>	bool operator()(const T* const fxfy, const T* const skew, const T* const uv0, const T* const Radial12, const T* const Tangential12, const T*const Radial3, const T*Prism, const T* const RT, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T point[3] = { T(X), T(Y), T(Z) }, p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Apply second and fourth order radial distortion.
		T xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
		T radial = T(1.0) + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
		T tangentialX = T(2.0)*Tangential12[1] * xycn + Tangential12[0] * (r2 + T(2.0)*xcn2);
		T tangentailY = Tangential12[1] * (r2 + T(2.0)*ycn2) + T(2.0)*Tangential12[0] * xycn;
		T prismX = Prism[0] * r2;
		T prismY = Prism[1] * r2;
		T xcn_ = radial*xcn + tangentialX + prismX;
		T ycn_ = radial*ycn + tangentailY + prismY;

		// Compute final projected point position.
		T predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + uv0[0];
		T predicted_y = fxfy[1] * ycn_ + uv0[1];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError3, 2, 2, 1, 2, 2, 2, 1, 2, 6>(new PinholeDistortionReprojectionError3(observed_x, observed_y, X, Y, Z, scale)));
	}
	static ceres::CostFunction* CreateNumDif(const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError3, ceres::CENTRAL, 2, 2, 1, 2, 2, 2, 1, 2, 6>(new PinholeDistortionReprojectionError3(observed_x, observed_y, X, Y, Z, scale)));
	}
	double observed_x, observed_y, X, Y, Z, scale;
};
struct PinholeDistortionReprojectionError4 {
	PinholeDistortionReprojectionError4(double *IntrinsicIn, double observed_x, double observed_y, double X, double Y, double Z, double scale) : observed_x(observed_x), observed_y(observed_y), X(X), Y(Y), Z(Z), scale(scale){ Intrinsic = IntrinsicIn; }
	template <typename T>	bool operator()(const T* const RT, T* residuals) const
	{
		// camera[0,1,2] are the angle-axis rotation.
		T point[3] = { T(X), T(Y), T(Z) }, p[3];
		ceres::AngleAxisRotatePoint(RT, point, p);

		// camera[3,4,5] are the translation.
		p[0] += RT[3], p[1] += RT[4], p[2] += RT[5];

		// Project to normalize coordinate
		T xcn = p[0] / p[2];
		T ycn = p[1] / p[2];

		// Compute final projected point position.
		T predicted_x = (T)Intrinsic[0] * xcn + (T)Intrinsic[2] * ycn + (T)Intrinsic[3];
		T predicted_y = (T)Intrinsic[1] * ycn + (T)Intrinsic[4];

		// The error is the difference between the predicted and observed position.
		residuals[0] = (predicted_x - T(observed_x)) / (T)scale;
		residuals[1] = (predicted_y - T(observed_y)) / (T)scale;

		return true;
	}
	static ceres::CostFunction* Create(double *Intrinsic, const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::AutoDiffCostFunction<PinholeDistortionReprojectionError4, 2, 6>(new PinholeDistortionReprojectionError4(Intrinsic, observed_x, observed_y, X, Y, Z, scale)));
	}
	static ceres::CostFunction* CreateNumDif(double *Intrinsic, const double observed_x, const double observed_y, const double X, const double Y, const double Z, double scale) {
		return (new ceres::NumericDiffCostFunction<PinholeDistortionReprojectionError4, ceres::CENTRAL, 2, 6>(new PinholeDistortionReprojectionError4(Intrinsic, observed_x, observed_y, X, Y, Z, scale)));
	}
	double *Intrinsic;
	double observed_x, observed_y, X, Y, Z, scale;
};
void PinholeDistortionReprojectionDebug(double *intrinsic, double* distortion, double* rt, Point2d observed, Point3d Point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	double point[3] = { Point.x, Point.y, Point.z };
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to image coordinate
	double xcn = p[0] / p[2], ycn = p[1] / p[2];
	Point2d uv(intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3], intrinsic[1] * ycn + intrinsic[4]);

	// Deal with distortion
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };
	double distortionParas[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };

	LensDistortionPoint(&uv, K, distortionParas);

	// The error is the difference between the predicted and observed position.
	residuals[0] = uv.x - observed.x, residuals[1] = uv.y - observed.y;

	return;
}
void PinholeDistortionReprojectionDebug2(double *fxfy, double *skew, double* u0v0, double *Radial12, double *Tangential12, double *Radial3, double *Prism, double* rt, Point2d observed, double *point, double *residuals)
{
	// camera[0,1,2] are the angle-axis rotation.
	// camera[0,1,2] are the angle-axis rotation.
	double p[3];
	ceres::AngleAxisRotatePoint(rt, point, p);

	// camera[3,4,5] are the translation.
	p[0] += rt[3], p[1] += rt[4], p[2] += rt[5];

	// Project to normalize coordinate
	double  xcn = p[0] / p[2], ycn = p[1] / p[2];

	// Apply second and fourth order radial distortion.
	double xcn2 = xcn*xcn, ycn2 = ycn*ycn, xycn = xcn*ycn, r2 = xcn2 + ycn2, r4 = r2*r2, r6 = r2*r4;
	double radial = 1.0 + Radial12[0] * r2 + Radial12[1] * r4 + Radial3[0] * r6;
	double tangentialX = 2.0*Tangential12[1] * xycn + Tangential12[0] * (r2 + 2.0*xcn2);
	double tangentailY = Tangential12[1] * (r2 + 2.0*ycn2) + 2.0*Tangential12[0] * xycn;
	double prismX = Prism[0] * r2;
	double prismY = Prism[1] * r2;
	double xcn_ = radial*xcn + tangentialX + prismX;
	double ycn_ = radial*ycn + tangentailY + prismY;

	// Compute final projected point position.
	double predicted_x = fxfy[0] * xcn_ + skew[0] * ycn_ + u0v0[0];
	double predicted_y = fxfy[1] * ycn_ + u0v0[1];

	// The error is the difference between the predicted and observed position.
	residuals[0] = predicted_x - observed.x;
	residuals[1] = predicted_y - observed.y;

	return;
}

int CayleyProjection(double *intrinsic, double* rt, double *wt, Point2d &predicted, Point3d Point, int width, int height)
{
	//Solving Eq. (5) of the p6p rolling shutter paper for the row location given all other parameters

	//transformed_X = R(v)*X
	double p[3] = { Point.x, Point.y, Point.z };
	double Rcenter[9];	convertRvecToRmat(rt, Rcenter);
	double Tx = rt[3], Ty = rt[4], Tz = rt[5];
	double tx = wt[3], ty = wt[4], tz = wt[5];
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };

	if (abs(wt[0]) + abs(wt[1]) + abs(wt[2]) > 0.5 && (abs(tx) + abs(ty) + abs(tz) > 30))
	{
		double tp[3]; mat_mul(Rcenter, p, tp, 3, 3, 1);
		double X = tp[0], Y = tp[1], Z = tp[2];
		double wx = wt[0], wy = wt[1], wz = wt[2], wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

		//Set up polynomial coefficients (obtained from matlab symbolic)
		double c[5];
		Mat coeffs(1, 5, CV_64F, c);
		c[4] = tz*wz2 + tz*wy2 + tz*wx2;
		c[3] = 2.0 * Y*wyz + 2.0 * X*wxz - ty*wz2 - ty*wy2 - ty*wx2 - Z*wy2 - Z*wx2 + Z*wz2 + Tz*wz2 + Tz*wy2 + Tz*wx2;
		c[2] = -2.0 * Z*wyz - 2.0 * X*wxy - Y*wy2 - Ty*wz2 - Ty*wy2 - Ty*wx2 + 2.0 * Y*wx - 2.0 * X*wy + Y*wz2 + Y*wx2 + tz;
		c[1] = 2.0 * Z*wx - 2.0 * X*wz - ty + Z + Tz;
		c[0] = -Y - Ty;

		std::vector<std::complex<double> > roots;
		solvePoly(coeffs, roots);

		int count = 0;
		for (int ii = 0; ii < roots.size(); ii++)
		{
			if (fabs(roots[ii].imag()) > 1e-10)
				continue;

			double j = roots[ii].real(), j2 = j*j, j3 = j2*j;
			double lamda = (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz) / (j2 * wx2 + j2 * wy2 + j2 * wz2 + 1.0);
			double naiveDepth = Z + Tz;
			if (abs((lamda - naiveDepth) / naiveDepth) > 0.1) //very different from the orginal depth 
				continue;
			double i = (Tx + X + j*tx + Tx*j2 * wx2 + Tx*j2 * wy2 + Tx*j2 * wz2 + X*j2 * wx2 - X*j2 * wy2 - X*j2 * wz2 + j3 * tx*wx2 + j3 * tx*wy2 + j3 * tx*wz2 - 2.0 * Y*j*wz + 2.0 * Z*j*wy + 2.0 * Y*j2 * wxy + 2.0 * Z*j2 * wxz) / (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz);

			Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
			if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
				continue;
			else
			{
				predicted = uv;
				count++;
			}
		}
		return count;
	}
	else
	{
		double wx, wy, wz, wx2, wy2, wz2, wxy, wxz, wyz, denum, Rw[9], R[9], tp[3];

		mat_mul(Rcenter, p, tp, 3, 3, 1);
		tp[1] += Ty, tp[2] += Tz;
		double j = tp[1] / tp[2], j_ = j;

		for (int iter = 0; iter < 40; iter++)
		{
			wx = j*wt[0], wy = j*wt[1], wz = j*wt[2];
			wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

			denum = 1.0 + wx2 + wy2 + wz2;

			Rw[0] = 1.0 + wx2 - wy2 - wz2, Rw[1] = 2.0 * wxy - 2.0 * wz, Rw[2] = 2.0 * wy + 2.0 * wxz,
				Rw[3] = 2.0 * wz + 2.0 * wxy, Rw[4] = 1.0 - wx2 + wy2 - wz2, Rw[5] = 2.0 * wyz - 2.0 * wx,
				Rw[6] = 2.0 * wxz - 2.0 * wy, Rw[7] = 2.0 * wx + 2.0 * wyz, Rw[8] = 1.0 - wx2 - wy2 + wz2;

			for (int ii = 0; ii < 9; ii++)
				Rw[ii] = Rw[ii] / denum;

			mat_mul(Rw, Rcenter, R, 3, 3, 3);
			mat_mul(R, p, tp, 3, 3, 1);
			tp[0] += Tx, tp[1] += Ty, tp[2] += Tz;

			j = (tp[1] + j*ty) / (tp[2] + j*tz);
			if (abs((j - j_) / j_) < 1.0e-9)
				break;
			j_ = j;
		}
		double i = (tp[0] + j*tx) / (tp[2] + j*tz);

		Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
		if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
			return 0;
		else
		{
			predicted = uv;
			return 1;
		}
	}
}
struct CayleyReprojectionError {
	CayleyReprojectionError(double *intrinsicIn, double observed_x, double observed_y, double scale, int width, int height) : observed_x(observed_x), observed_y(observed_y), scale(scale), width(width), height(height)
	{
		intrinsic = intrinsicIn;
	}

	template <typename T>	bool operator()(const double* const rt, const double * const wt, const double* const point, T* residuals) const
	{
		Point2d predicted(0.0, 0.0);
		Point3d p3d(point[0], point[1], point[2]);
		double rt_[6] = { rt[0], rt[1], rt[2], rt[3], rt[4], rt[5] };
		double wt_[6] = { wt[0], wt[1], wt[2], wt[3], wt[4], wt[5] };

		int count = CayleyProjection(intrinsic, rt_, wt_, predicted, p3d, width, height);
		residuals[0] = (predicted.x - observed_x) / scale, residuals[1] = (predicted.y - observed_y) / scale;

		return true;
	}

	static ceres::CostFunction* Create(double *intrinsic, const double observed_x, const double observed_y, double scale, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<CayleyReprojectionError, ceres::CENTRAL, 2, 6, 6, 3>(new CayleyReprojectionError(intrinsic, observed_x, observed_y, scale, width, height)));
	}

	int width, height;
	double *intrinsic, observed_x, observed_y, scale;
};
int CayleyReprojectionDebug(double *intrinsic, double* rt, double *wt, Point2d observed, Point3d Point, int width, int height, double *residuals)
{
	Point2d predicted;
	int count = CayleyProjection(intrinsic, rt, wt, predicted, Point, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return count;
}

int CayleyDistortionProjection(double *intrinsic, double* distortion, double* rt, double *wt, Point2d &predicted, Point3d Point, int width, int height)
{
	//Solving Eq. (5) of the p6p rolling shutter paper for the row location given all other parameters
	double p[3] = { Point.x, Point.y, Point.z };
	double Rcenter[9];	convertRvecToRmat(rt, Rcenter);
	double Tx = rt[3], Ty = rt[4], Tz = rt[5];
	double tx = wt[3], ty = wt[4], tz = wt[5];
	double K[9] = { intrinsic[0], intrinsic[2], intrinsic[3], 0.0, intrinsic[1], intrinsic[4], 0.0, 0.0, 1.0 };

	if (0)//(abs(wt[0]) + abs(wt[1]) + abs(wt[2]) > 0.5 && (abs(tx) + abs(ty) + abs(tz) > 30))
	{
		//Polynomial solving approach. Not very stable if the rolling shutter is small
		double tp[3]; mat_mul(Rcenter, p, tp, 3, 3, 1);
		double X = tp[0], Y = tp[1], Z = tp[2];
		double wx = wt[0], wy = wt[1], wz = wt[2], wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

		//Set up polynomial coefficients (obtained from matlab symbolic)
		double c[5];
		Mat coeffs(1, 5, CV_64F, c);
		c[4] = tz*wz2 + tz*wy2 + tz*wx2;
		c[3] = 2.0 * Y*wyz + 2.0 * X*wxz - ty*wz2 - ty*wy2 - ty*wx2 - Z*wy2 - Z*wx2 + Z*wz2 + Tz*wz2 + Tz*wy2 + Tz*wx2;
		c[2] = -2.0 * Z*wyz - 2.0 * X*wxy - Y*wy2 - Ty*wz2 - Ty*wy2 - Ty*wx2 + 2.0 * Y*wx - 2.0 * X*wy + Y*wz2 + Y*wx2 + tz;
		c[1] = 2.0 * Z*wx - 2.0 * X*wz - ty + Z + Tz;
		c[0] = -Y - Ty;

		std::vector<std::complex<double> > roots;
		solvePoly(coeffs, roots);

		int count = 0;
		for (int ii = 0; ii < roots.size(); ii++)
		{
			if (fabs(roots[ii].imag()) > 1e-10)
				continue;

			double j = roots[ii].real(), j2 = j*j, j3 = j2*j;
			double lamda = (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz) / (j2 * wx2 + j2 * wy2 + j2 * wz2 + 1.0);
			double naiveDepth = Z + Tz;
			if (abs((lamda - naiveDepth) / naiveDepth) > 0.1) //very different from the orginal depth 
				continue;
			double i = (Tx + X + j*tx + Tx*j2 * wx2 + Tx*j2 * wy2 + Tx*j2 * wz2 + X*j2 * wx2 - X*j2 * wy2 - X*j2 * wz2 + j3 * tx*wx2 + j3 * tx*wy2 + j3 * tx*wz2 - 2.0 * Y*j*wz + 2.0 * Z*j*wy + 2.0 * Y*j2 * wxy + 2.0 * Z*j2 * wxz) / (Tz + Z + j*tz + Tz*j2 * wx2 + Tz*j2 * wy2 + Tz*j2 * wz2 - Z*j2 * wx2 - Z*j2 * wy2 + Z*j2 * wz2 + j3 * tz*wx2 + j3 * tz*wy2 + j3 * tz*wz2 - 2.0 * X*j*wy + 2.0 * Y*j*wx + 2.0 * X*j2 * wxz + 2.0 * Y*j2 * wyz);

			Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
			LensDistortionPoint(&uv, K, distortion);
			if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
				continue;
			else
			{
				predicted = uv;
				count++;
			}
		}
		return count;
	}
	else
	{
		//Fix point iteration approach. Very stable
		double wx, wy, wz, wx2, wy2, wz2, wxy, wxz, wyz, denum, Rw[9], R[9], tp[3];

		mat_mul(Rcenter, p, tp, 3, 3, 1);
		tp[1] += Ty, tp[2] += Tz;
		double j = tp[1] / tp[2], j_ = j;

		for (int iter = 0; iter < 40; iter++)
		{
			wx = j*wt[0], wy = j*wt[1], wz = j*wt[2];
			wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;

			denum = 1.0 + wx2 + wy2 + wz2;

			Rw[0] = 1.0 + wx2 - wy2 - wz2, Rw[1] = 2.0 * wxy - 2.0 * wz, Rw[2] = 2.0 * wy + 2.0 * wxz,
				Rw[3] = 2.0 * wz + 2.0 * wxy, Rw[4] = 1.0 - wx2 + wy2 - wz2, Rw[5] = 2.0 * wyz - 2.0 * wx,
				Rw[6] = 2.0 * wxz - 2.0 * wy, Rw[7] = 2.0 * wx + 2.0 * wyz, Rw[8] = 1.0 - wx2 - wy2 + wz2;

			for (int ii = 0; ii < 9; ii++)
				Rw[ii] = Rw[ii] / denum;

			mat_mul(Rw, Rcenter, R, 3, 3, 3);
			mat_mul(R, p, tp, 3, 3, 1);
			tp[0] += Tx, tp[1] += Ty, tp[2] += Tz;

			j = (tp[1] + j*ty) / (tp[2] + j*tz);
			if (abs((j - j_) / j_) < 1.0e-9)
				break;
			j_ = j;
		}
		double i = (tp[0] + j*tx) / (tp[2] + j*tz);

		Point2d uv(intrinsic[0] * i + intrinsic[2] * j + intrinsic[3], intrinsic[1] * j + intrinsic[4]);
		LensDistortionPoint(&uv, K, distortion);
		if (uv.x < 0 || uv.x > width - 1 || uv.y < 0 || uv.y > height - 1)
			return 0;
		else
		{
			predicted = uv;
			return 1;
		}
	}
}
struct CayleyDistortionReprojectionError {
	CayleyDistortionReprojectionError(double observed_x, double observed_y, double scale, int width, int height) : observed_x(observed_x), observed_y(observed_y), scale(scale), width(width), height(height) {}
	template <typename T>	bool operator()(const double* const intrinsic, const double* const distortion, const double* const rt, const double * const wt, const double* const point, T* residuals) const
	{
		Point2d predicted(0.0, 0.0);
		Point3d p3d(point[0], point[1], point[2]);
		double intrinsic_[5] = { intrinsic[0], intrinsic[1], intrinsic[2], intrinsic[3], intrinsic[4] };
		double distortion_[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };
		double rt_[6] = { rt[0], rt[1], rt[2], rt[3], rt[4], rt[5] };
		double wt_[6] = { wt[0], wt[1], wt[2], wt[3], wt[4], wt[5] };

		int count = CayleyDistortionProjection(intrinsic_, distortion_, rt_, wt_, predicted, p3d, width, height);
		residuals[0] = (predicted.x - observed_x) / scale, residuals[1] = (predicted.y - observed_y) / scale;

		return true;
	}

	static ceres::CostFunction* Create(const double observed_x, const double observed_y, double scale, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<CayleyDistortionReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 6, 3>(new CayleyDistortionReprojectionError(observed_x, observed_y, scale, width, height)));
	}

	int width, height;
	double observed_x, observed_y, scale;
};
int CayleyDistortionReprojectionDebug(double *intrinsic, double* distortion, double* rt, double *wt, Point2d observed, Point3d Point, int width, int height, double *residuals)
{
	Point2d predicted;
	int count = CayleyDistortionProjection(intrinsic, distortion, rt, wt, predicted, Point, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return count;
}
void NviewTriangulationNonLinearCayley(CameraData *camInfo, double *Point2D, double *Point3D, double *ReprojectionError, int nviews, int npts)
{
	ceres::Problem problem;

	//printf("Error before: \n");

	double residuals[2];
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			if (!camInfo[jj].valid)
				continue;

			CayleyReprojectionDebug(camInfo[jj].intrinsic, camInfo[jj].rt, camInfo[jj].wt, Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]), Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), camInfo[jj].width, camInfo[jj].height, residuals);
			ReprojectionError[ii] += residuals[0] * residuals[0] + residuals[1] * residuals[1];

			ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camInfo[jj].intrinsic, Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1], 1.0, camInfo[jj].width, camInfo[jj].height);
			problem.AddResidualBlock(cost_function, NULL, camInfo[jj].rt, camInfo[jj].wt, &Point3D[ii]);

			problem.SetParameterBlockConstant(camInfo[jj].rt);
			problem.SetParameterBlockConstant(camInfo[jj].wt);
		}

		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");


	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.FullReport() << "\n";

	//printf("Error after: \n");
	for (int ii = 0; ii < npts; ii++)
	{
		ReprojectionError[ii] = 0.0;
		for (int jj = 0; jj < nviews; jj++)
		{
			if (!camInfo[jj].valid)
				continue;

			CayleyReprojectionDebug(camInfo[jj].intrinsic, camInfo[jj].rt, camInfo[jj].wt, Point2d(Point2D[2 * (ii*nviews + jj)], Point2D[2 * (ii*nviews + jj) + 1]), Point3d(Point3D[3 * ii], Point3D[3 * ii + 1], Point3D[3 * ii + 2]), camInfo[jj].width, camInfo[jj].height, residuals);
			ReprojectionError[ii] += residuals[0] * residuals[0] + residuals[1] * residuals[1];
		}
		ReprojectionError[ii] /= nviews;
		//printf("%f ", ReprojectionError[ii]);
	}
	//printf("\n");

	return;
}

int IncrementalBA(char *Path, int nviews, int timeID, CameraData *AllViewsInfo, vector<int> availViews, vector<int>*PointCorres, vector<int>mask, vector<int> Selected3DIndex, Point3d *All3D, vector<Point2d> *selected2D, vector<int>*nSelectedViews, int nSelectedPts, int totalPts, bool fixIntrinsic, bool fixDistortion, bool showReProjectionError, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, jj, match, id3d, viewID, npts = Selected3DIndex.size();
	double residuals[2];
	const double scale = 1.0;

	double *seleted3D = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
	{
		id3d = Selected3DIndex[ii];
		seleted3D[3 * ii] = All3D[id3d].x, seleted3D[3 * ii + 1] = All3D[id3d].y, seleted3D[3 * ii + 2] = All3D[id3d].z;
	}

	printf("Set up BA ...");
	ceres::Problem problem;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB_%d.txt", availViews.size()), fp = fopen(Fname, "w+");

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *notGood = new vector<bool>[npts];
	for (int jj = 0; jj < npts; jj++)
		discard3Dpoint[jj] = false, notGood[jj].reserve(nSelectedViews[jj].size());

	vector<int>::iterator it;
	for (int jj = 0; jj < npts; jj++)
	{
		id3d = Selected3DIndex.at(jj);
		if (abs(All3D[id3d].x) > LIMIT3D)
		{
			it = find(mask.begin(), mask.end(), id3d);
			if (it != mask.end())
				continue; //the parent of the points has been processed

			//screening: if there are only 2 points and 1 of them fails, discard the pair
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
			{
				if (selected2D[jj][ii].x < 1 || selected2D[jj][ii].y < 1)
				{
					notGood[jj].push_back(false);
					continue;
				}

				viewID = nSelectedViews[jj][ii];
				PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);
				if (abs(residuals[0]) > 3 * AllViewsInfo[0].threshold || abs(residuals[1]) > 3 * AllViewsInfo[0].threshold)
					notGood[jj].push_back(false);
				else
					notGood[jj].push_back(true);
			}

			//Discard point 
			int count = 0;
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
				if (notGood[jj][ii] == true)
					count++;

			discard3Dpoint[jj] = false;
			if (count < 2)
			{
				discard3Dpoint[jj] = true;
				continue;
			}

			//All good, add point and its 2D projections to Ceres
			bool once = true;
			for (ii = 0; ii < nSelectedViews[jj].size(); ii++)
			{
				if (!notGood[jj][ii])
					continue;

				viewID = nSelectedViews[jj][ii];
				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(selected2D[jj][ii].x, selected2D[jj][ii].y, scale);
				problem.AddResidualBlock(cost_function, NULL, AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, &seleted3D[3 * jj]);

				if (debug)
				{
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);
					if (once)
					{
						once = false;
						fprintf(fp, "%d %.4f %.4f %.4f ", id3d, All3D[id3d].x, All3D[id3d].y, All3D[id3d].z);
					}
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", viewID, selected2D[jj][ii].x, selected2D[jj][ii].y, residuals[0], residuals[1]);
				}
			}
			if (!once)
				fprintf(fp, "\n");
		}
	}
	if (debug)
		fclose(fp);

	//Set up constant parameters:
	printf("...set up fixed parameters ...");
	for (int ii = 0; ii < availViews.size(); ii++)
	{
		int viewID = availViews[ii];
		if (fixIntrinsic)
			problem.SetParameterBlockConstant(AllViewsInfo[viewID].intrinsic);
		if (fixDistortion)
			problem.SetParameterBlockConstant(AllViewsInfo[viewID].distortion);
	}

	printf("...run BA...\n");
	ceres::Solver::Options options;
	options.num_threads = 1;
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::DENSE_SCHUR;
	options.minimizer_progress_to_stdout = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.BriefReport() << "\n";

	GetKFromIntrinsic(AllViewsInfo, availViews);
	GetRTFromrt(AllViewsInfo, availViews);
	for (int ii = 0; ii < availViews.size(); ii++)
		AssembleP(AllViewsInfo[availViews[ii]].K, AllViewsInfo[availViews[ii]].R, AllViewsInfo[availViews[ii]].T, AllViewsInfo[availViews[ii]].P);

	//2d points belong to 1 3D point-> distribute 3D to its 2d matches
	for (ii = 0; ii < npts; ii++)
	{
		id3d = Selected3DIndex[ii];
		All3D[id3d].x = seleted3D[3 * ii], All3D[id3d].y = seleted3D[3 * ii + 1], All3D[id3d].z = seleted3D[3 * ii + 2];
		for (jj = 0; jj < PointCorres[id3d].size(); jj++)
		{
			match = PointCorres[id3d].at(jj);
			All3D[match] = All3D[id3d];
		}
	}

	vector<double> ReProjectionError; ReProjectionError.reserve(npts);
	if (debug || showReProjectionError)
	{
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA_%d.txt", availViews.size()), fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			id3d = Selected3DIndex.at(jj);
			if (abs(All3D[id3d].x) > LIMIT3D && !discard3Dpoint[jj])
			{
				it = find(mask.begin(), mask.end(), id3d);
				if (it != mask.end())
					continue; //the parent of the points has been processed

				bool once = true;
				int validViewcount = 0;
				double pointErr = 0.0;
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;

					viewID = nSelectedViews[jj][ii];
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);

					validViewcount++;
					pointErr += residuals[0] * residuals[0] + residuals[1] * residuals[1];
					if (once && debug)
					{
						once = false;
						fprintf(fp, "%d %.4f %.4f %.4f ", id3d, All3D[id3d].x, All3D[id3d].y, All3D[id3d].z);
					}
					if (debug)
						fprintf(fp, "%d %.4f %.4f %.4f %.4f ", viewID, selected2D[jj][ii].x, selected2D[jj][ii].y, residuals[0], residuals[1]);
				}
				if (!once &&debug)
					fprintf(fp, "\n");

				ReProjectionError.push_back(sqrt(pointErr / validViewcount));
			}
		}
		if (debug)
			fclose(fp);

		if (debug)
			sprintf(Fname, "C:/temp/visSfm_%d.txt", availViews.size()), fp = fopen(Fname, "w+");
		for (int jj = 0; jj < npts; jj++)
		{
			id3d = Selected3DIndex.at(jj);
			if (abs(All3D[id3d].x) > LIMIT3D && !discard3Dpoint[jj])
			{
				it = find(mask.begin(), mask.end(), id3d);
				if (it != mask.end())
					continue; //the parent of the points has been processed

				bool once = true;
				int validViewcount = 0;
				double pointErr = 0.0;
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;
					validViewcount++;
				}
				for (int ii = 0; ii < nSelectedViews[jj].size(); ii++)
				{
					if (!notGood[jj][ii])
						continue;

					viewID = nSelectedViews[jj][ii];
					PinholeDistortionReprojectionDebug(AllViewsInfo[viewID].intrinsic, AllViewsInfo[viewID].distortion, AllViewsInfo[viewID].rt, Point2d(selected2D[jj][ii].x, selected2D[jj][ii].y), All3D[id3d], residuals);

					pointErr += residuals[0] * residuals[0] + residuals[1] * residuals[1];
					if (once && debug)
					{
						once = false;
						fprintf(fp, "%.4f %.4f %.4f 0  255 0 %d ", All3D[id3d].x, All3D[id3d].y, All3D[id3d].z, validViewcount);
					}
					if (debug)
						fprintf(fp, "%d %d %.4f %.4f ", viewID, (int)(UniformNoise(10000, 0)), selected2D[jj][ii].x - 1536, selected2D[jj][ii].y - 1024);
				}
				if (!once &&debug)
					fprintf(fp, "\n");
			}
		}
		if (debug)
			fclose(fp);
	}

	if (showReProjectionError)
	{
		double mini = *min_element(ReProjectionError.begin(), ReProjectionError.end());
		double maxi = *max_element(ReProjectionError.begin(), ReProjectionError.end());
		double avg = MeanArray(ReProjectionError);
		double std = sqrt(VarianceArray(ReProjectionError, avg));
		printf("Reprojection error: %.2f %.2f %.2f %.2f\n", mini, maxi, avg, std);
	}

	delete[]discard3Dpoint, delete[]notGood;
	return 0;
}
void IncrementalBundleAdjustment(char *Path, int nviews, int timeID, int maxKeypoints)
{
	int totalPts;
	vector<int> cumulativePts;
	ReadCumulativePoints(Path, nviews, timeID, cumulativePts);
	totalPts = cumulativePts.at(nviews);

	vector<int>CeresDuplicateAddInMask;
	vector<int>*PointCorres = new vector<int>[totalPts];
	//vector<int>PointCorres[191872];
	ReadPointCorrespondences(Path, nviews, timeID, PointCorres, CeresDuplicateAddInMask, totalPts);

	int viewPair[2];
	BestPairFinder(Path, nviews, timeID, viewPair);

	vector<int> availViews; availViews.reserve(nviews);
	availViews.push_back(viewPair[0]), availViews.push_back(viewPair[1]);
	sort(availViews.begin(), availViews.end());

	int nSelectedPts;
	vector<int>Selected3DIndex; Selected3DIndex.reserve(totalPts);
	vector<Point2d> *Selected2D = new vector<Point2d>[totalPts];
	vector<int> *nSelectedViews = new vector<int>[totalPts];

	CameraData *AllViewsInfo = new CameraData[nviews];
	if (ReadIntrinsicResults(Path, AllViewsInfo) != 0)
		return;
	for (int ii = 0; ii < nviews; ii++)
		AllViewsInfo[ii].LensModel = RADIAL_TANGENTIAL_PRISM, AllViewsInfo[ii].threshold = 2.0, AllViewsInfo[ii].ninlierThresh = 50;

	Point3d *All3D = new Point3d[totalPts];
	for (int ii = 0; ii < totalPts; ii++)
		All3D[ii].x = 0.0, All3D[ii].y = 0.0, All3D[ii].z = 0.0;

	TwoCameraReconstruction(Path, AllViewsInfo, nviews, timeID, cumulativePts, PointCorres, availViews, All3D);
	GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
	NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
	IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, false);

	int startnum = 2, addedDevices = startnum;
	for (int ii = 0; ii < nviews - startnum; ii++)
	{
		if (AddNewViewReconstruction(Path, AllViewsInfo, nviews, timeID, cumulativePts, PointCorres, All3D, AllViewsInfo[0].threshold, availViews) == 0)
		{
			printf("succeed!\n");
			addedDevices++;
		}

		if (addedDevices % 2 == 0) // Do BA after every 2 views being added
		{
			GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
			NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
			IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, false);
		}
	}
	printf("Done!\n");

	//Final BA
	GetPoint3D2DAllCorrespondence(Path, nviews, timeID, cumulativePts, All3D, availViews, Selected3DIndex, Selected2D, nSelectedViews, nSelectedPts);
	NviewTriangulationRANSACDriver(AllViewsInfo, Selected3DIndex, nSelectedViews, Selected2D, nviews);
	IncrementalBA(Path, nviews, timeID, AllViewsInfo, availViews, PointCorres, CeresDuplicateAddInMask, Selected3DIndex, All3D, Selected2D, nSelectedViews, nSelectedPts, totalPts, true, true, true, true);

	SaveCurrentSfmGL(Path, AllViewsInfo, availViews, All3D, NULL, totalPts);
	SaveCurrentSfmInfo(Path, AllViewsInfo, availViews, All3D, totalPts);
	//saveNVM("C:/temp", "fountain.nvm", AllViewsInfo, availViews);
	delete[]All3D, delete[]Selected2D, delete[]nSelectedViews;

	return;
}
int GlobalShutterBundleAdjustment(char *Path, CameraData *camera, vector<Point3d>  &Vxyz, vector < vector<int> > viewIdAll3D, vector<vector<Point2d> > uvAll3D, vector<vector<double> > scaleAll3D, vector<int> SharedIntrinsicCamID, int nviews, int fixIntrinsic, int fixDistortion, int fixPose, int fixFirstCamPose, int fix3D, int distortionCorrected, int LossType, bool debug, bool silent)
{
	char Fname[200]; FILE *fp = 0;
	int viewID, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (int ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up BA (%d views) ...\n", nviews);
	ceres::Problem problem;

	ceres::LossFunction *loss_funcion = 0;
	if (LossType == 1) //Huber
		loss_funcion = new ceres::HuberLoss(2.0);

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *Good = new vector<bool>[npts];
	for (int ii = 0; ii < npts; ii++)
		discard3Dpoint[ii] = false, Good[ii].reserve(viewIdAll3D[ii].size());

	int nBadCounts = 0, goodCount = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0;

	int firstCameraInSharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	bool SharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	for (int ii = 0; ii < MaxSharedIntrinsicGroup; ii++)
		SharedIntrinsicGroup[ii] = false;

	int firstValidViewID = -1, refCam = -1, nProjections = 0, nPossibleProjections = 0;
	vector<int> validCamID;
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) < LIMIT3D)
			continue;
		int nvisibles = viewIdAll3D[jj].size();
		for (int ii = 0; ii < nvisibles; ii++)
		{
			viewID = viewIdAll3D[jj][ii];
			if (!camera[viewID].valid)
				Good[jj].push_back(false);
			else
			{
				bool found = false;
				for (int kk = 0; kk < (int)validCamID.size(); kk++)
					if (viewID == validCamID[kk])
					{
						found = true; break;
					}
				if (!found)
					validCamID.push_back(viewID);

				firstValidViewID = viewID;
				if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
				{
					refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
					if (distortionCorrected == 1)
						PinholeReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
						PinholeDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else
						FOVReprojectionDistortionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				}
				else
				{
					if (distortionCorrected == 1)
						PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
						PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
					else
						FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				}

				if (abs(residuals[0]) > camera[firstValidViewID].threshold || abs(residuals[1]) > camera[firstValidViewID].threshold)
				{
					Good[jj].push_back(false);
					//printf("\n@P %d (%.3f %.3f %.3f):  %.2f %.2f", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], residuals[0], residuals[1]);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
				}
				else
				{
					Good[jj].push_back(true);
					//if (SharedIntrinsicCamID.size() > 0 && refCam == -1)
					if (SharedIntrinsicCamID.size() > 0 && !SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
					{
						SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = true;
						firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = viewID;
						printf("Set group %d master camera to %d\n", SharedIntrinsicCamID[viewID], firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]]);
					}
					goodCount++;
				}
			}
		}

		//Discard point 
		int count = 0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			if (Good[jj][ii] == true)
				count++;

		discard3Dpoint[jj] = false;
		if (count < 2)
		{
			discard3Dpoint[jj] = true;
			continue;
		}

		//add 3D point and its 2D projections to Ceres
		bool once = true;
		int validViewcount = 0;
		double pointErrX = 0.0, pointErrY = 0.0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			if (!Good[jj][ii])
				continue;

			nPossibleProjections++;
			viewID = viewIdAll3D[jj][ii];

			//vector<int>::iterator it;
			//it = find(SharedIntrinsicCamID.begin(), SharedIntrinsicCamID.end(), viewID);
			//if (it == SharedIntrinsicCamID.end()) //not shared cameras
			if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
			{
				refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[viewID].rt, &xyz[3 * jj]);
				}
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}
				else
				{
					ceres::CostFunction* cost_function = FOVReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}

				if (fixIntrinsic)
					problem.SetParameterBlockConstant(camera[refCam].intrinsic);
				if (distortionCorrected == 0 && fixDistortion)
					problem.SetParameterBlockConstant(camera[refCam].distortion);
				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
			}
			else
			{
				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].rt, &xyz[3 * jj]);
				}
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
				{
					ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}
				else
				{
					ceres::CostFunction* cost_function = FOVReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii]);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, &xyz[3 * jj]);
				}

				if (fixIntrinsic)
					problem.SetParameterBlockConstant(camera[viewID].intrinsic);
				if (distortionCorrected == 0 && fixDistortion)
					problem.SetParameterBlockConstant(camera[viewID].distortion);
				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);

				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
			}

			validViewcount++;
			pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);

			if (debug)
			{
				if (once)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.2f %.2f\n", residuals[0], residuals[1]);
			}
		}
		if (validViewcount > 1)
		{
			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}

		if (!once)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/Good.txt", Path); fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		fprintf(fp, "%d ", jj);
		for (int ii = 0; ii < Good[jj].size(); ii++)
		{
			if (Good[jj][ii] == false)
				fprintf(fp, "%d ", ii);
		}
		fprintf(fp, "-1\n");
	}
	fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("(%d/%d) bad points with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, nBadCounts + goodCount, maxOutlierX, maxOutlierY);
	printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = silent ? false : true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	for (int ii = 0; ii < (int)validCamID.size() && SharedIntrinsicCamID.size()>0; ii++)
	{
		refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[ii]];
		CopyCamereInfo(camera[refCam], camera[validCamID[ii]], false);
	}
	for (int ii = 0; ii < (int)validCamID.size(); ii++)
	{
		GetKFromIntrinsic(camera[validCamID[ii]]);
		GetRTFromrt(camera[validCamID[ii]]);
		AssembleP(camera[validCamID[ii]].K, camera[validCamID[ii]].R, camera[validCamID[ii]].T, camera[validCamID[ii]].P);
	}
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) > LIMIT3D && !discard3Dpoint[jj])
		{
			bool once = true;
			int validViewcount = 0;
			double pointErrX = 0.0, pointErrY = 0.0;
			for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			{
				if (!Good[jj][ii])
					continue;

				viewID = viewIdAll3D[jj][ii];
				if (distortionCorrected == 1)
					PinholeReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else if (camera[viewID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
				else
					FOVReprojectionDistortionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);

				validViewcount++;
				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
				if (once && debug)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				if (debug)
					fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.2f %.2f\n", residuals[0], residuals[1]);
			}
			if (!once &&debug)
				fprintf(fp, "\n");

			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz, delete[]discard3Dpoint, delete[]Good;
	return 0;
}
int CayleyRollingShutterBundleAdjustment(char *Path, CameraData *camera, vector<Point3d>  &Vxyz, vector < vector<int> > viewIdAll3D, vector<vector<Point2d> > uvAll3D, vector<vector<double> > scaleAll3D, vector<int> SharedIntrinsicCamID, int nviews, int fixIntrinsic, int fixDistortion, int fixPose, int fixFirstCamPose, int fixLocalPose, int fix3D, int distortionCorrected, int LossType, bool debug, bool silent)
{
	char Fname[200]; FILE *fp = 0;
	int viewID, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (int ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("set up Cayley RS-BA (%d views) ...\n", nviews);
	ceres::Problem problem;

	ceres::LossFunction *loss_funcion = 0;
	if (LossType == 1) //Huber
		loss_funcion = new ceres::HuberLoss(5.0);

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");


	double maxOutlierX = 0.0, maxOutlierY = 0.0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);

	bool *discard3Dpoint = new bool[npts];
	vector<bool> *Good = new vector<bool>[npts];
	for (int ii = 0; ii < npts; ii++)
		discard3Dpoint[ii] = false, Good[ii].reserve(viewIdAll3D[ii].size());

	int firstCameraInSharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	bool SharedIntrinsicGroup[MaxSharedIntrinsicGroup];
	for (int ii = 0; ii < MaxSharedIntrinsicGroup; ii++)
		SharedIntrinsicGroup[ii] = false;

	int nBadCounts = 0, goodCount = 0;
	int firstValidViewID = -1, refCam = -1, nProjections = 0, nPossibleProjections = 0;
	vector<int> validCamID;
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) < LIMIT3D)
			continue;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			viewID = viewIdAll3D[jj][ii];
			if (!camera[viewID].valid)
				Good[jj].push_back(false);
			else
			{
				bool found = false;
				for (int kk = 0; kk < (int)validCamID.size(); kk++)
					if (viewID == validCamID[kk])
					{
						found = true; break;
					}
				if (!found)
					validCamID.push_back(viewID);

				if (firstValidViewID == -1)
					firstValidViewID = viewID;

				if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
				{
					refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
					if (distortionCorrected == 0)
						CayleyDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[refCam].width, camera[refCam].height, residuals);
					else
						CayleyReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[refCam].width, camera[refCam].height, residuals);
				}
				else
				{
					if (distortionCorrected == 0)
						CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
					else
						CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (abs(residuals[0]) > camera[firstValidViewID].threshold || abs(residuals[1]) > camera[firstValidViewID].threshold)//because they are not corrected for rolling shutter yet
				{
					Good[jj].push_back(false);
					//printf("\n@P %d (%.3f %.3f %.3f):  %.2f %.2f", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], residuals[0], residuals[1]);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
				}
				else
				{
					Good[jj].push_back(true);
					if (SharedIntrinsicCamID.size() > 0 && !SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
					{
						SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = true;
						firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]] = viewID;
						printf("Set group %d master camera to %d\n", SharedIntrinsicCamID[viewID], firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]]);
					}
					goodCount++;
				}
			}
		}

		//Discard point 
		int count = 0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			if (Good[jj][ii] == true)
				count++;

		discard3Dpoint[jj] = false;
		if (count < 2)
		{
			discard3Dpoint[jj] = true;
			continue;
		}

		//add 3D point and its 2D projections to Ceres
		bool once = true;
		int validViewcount = 0;
		double pointErrX = 0.0, pointErrY = 0.0;
		for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
		{
			if (!Good[jj][ii])
				continue;

			nPossibleProjections++;
			viewID = viewIdAll3D[jj][ii];

			if (SharedIntrinsicCamID.size() > 0 && SharedIntrinsicGroup[SharedIntrinsicCamID[viewID]])
			{
				refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[viewID]];
				if (distortionCorrected == 0)
				{
					ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					if (fixIntrinsic)
						problem.SetParameterBlockConstant(camera[refCam].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(camera[refCam].distortion);

					CayleyDistortionReprojectionDebug(camera[refCam].intrinsic, camera[refCam].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}
				else
				{
					ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera[refCam].intrinsic, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					CayleyReprojectionDebug(camera[refCam].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixLocalPose)
					problem.SetParameterBlockConstant(camera[viewID].wt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);
			}
			else
			{
				if (distortionCorrected == 0)
				{
					ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					if (fixIntrinsic)
						problem.SetParameterBlockConstant(camera[viewID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(camera[viewID].distortion);

					CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}
				else
				{
					ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera[viewID].intrinsic, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, scaleAll3D[jj][ii], camera[viewID].width, camera[viewID].height);
					problem.AddResidualBlock(cost_function, loss_funcion, camera[viewID].rt, camera[viewID].wt, &xyz[3 * jj]);

					CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				}

				if (fixPose)
					problem.SetParameterBlockConstant(camera[viewID].rt);
				if (fixLocalPose)
					problem.SetParameterBlockConstant(camera[viewID].wt);
				if (fixFirstCamPose && viewID == firstValidViewID)
					problem.SetParameterBlockConstant(camera[firstValidViewID].rt);
				if (fix3D)
					problem.SetParameterBlockConstant(&xyz[3 * jj]);
			}

			validViewcount++;
			pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
			if (debug)
			{
				if (once)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.3f %.3f\n", residuals[0], residuals[1]);
			}
		}
		if (validViewcount > 0)
		{
			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}

		if (!once)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/Good.txt", Path); fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		fprintf(fp, "%d ", jj);
		for (int ii = 0; ii < Good[jj].size(); ii++)
		{
			if (Good[jj][ii] == false)
				fprintf(fp, "%d ", ii);
		}
		fprintf(fp, "-1\n");
	}
	fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("(%d/%d) bad points with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, nBadCounts + goodCount, maxOutlierX, maxOutlierY);
	printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 100;
	options.linear_solver_type = ceres::DENSE_SCHUR;
	options.minimizer_progress_to_stdout = silent ? false : true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	if (silent)
		std::cout << summary.BriefReport() << "\n";
	else
		std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	for (int ii = 0; ii < (int)validCamID.size() && SharedIntrinsicCamID.size()>0; ii++)
	{
		refCam = firstCameraInSharedIntrinsicGroup[SharedIntrinsicCamID[ii]];
		CopyCamereInfo(camera[refCam], camera[validCamID[ii]], false);
	}
	for (int ii = 0; ii < (int)validCamID.size(); ii++)
	{
		GetKFromIntrinsic(camera[validCamID[ii]]);
		GetRTFromrt(camera[validCamID[ii]]);
		AssembleP(camera[validCamID[ii]].K, camera[validCamID[ii]].R, camera[validCamID[ii]].T, camera[validCamID[ii]].P);
	}
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);


	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (abs(xyz[3 * jj]) + abs(xyz[3 * jj + 1]) + abs(xyz[3 * jj + 2]) > LIMIT3D && !discard3Dpoint[jj])
		{
			bool once = true;
			int validViewcount = 0;
			double pointErrX = 0.0, pointErrY = 0.0;
			for (int ii = 0; ii < viewIdAll3D[jj].size(); ii++)
			{
				if (!Good[jj][ii])
					continue;

				viewID = viewIdAll3D[jj][ii];
				if (distortionCorrected == 0)
					CayleyDistortionReprojectionDebug(camera[viewID].intrinsic, camera[viewID].distortion, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);
				else
					CayleyReprojectionDebug(camera[viewID].intrinsic, camera[viewID].rt, camera[viewID].wt, uvAll3D[jj][ii], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera[viewID].width, camera[viewID].height, residuals);

				validViewcount++;
				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2);
				if (once && debug)
				{
					once = false;
					fprintf(fp, "%d %.4f %.4f %.4f ", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]);
				}
				if (debug)
					fprintf(fp, "V %d: %.4f %.4f %.4f %.4f ", viewID, uvAll3D[jj][ii].x, uvAll3D[jj][ii].y, residuals[0], residuals[1]);
				//fprintf(fp, "%.3f %.3f\n", residuals[0], residuals[1]);
			}
			if (!once &&debug)
				fprintf(fp, "\n");

			ReProjectionErrorX.push_back(sqrt(pointErrX / validViewcount));
			ReProjectionErrorY.push_back(sqrt(pointErrY / validViewcount));
		}
	}
	if (debug)
		fclose(fp);

	if (ReProjectionErrorX.size() == 0 || ReProjectionErrorY.size() == 0)
		printf("Error. The BA gives 0 inliers!");
	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz, delete[]discard3Dpoint;
	delete[]Good;

	return 0;
}

int GlobalShutterBundleAdjustmentDriver(char *Path, int nViews, int distortionCorrected, vector< int> SharedIntrinsicCamID, int LossType)
{
	printf("Reading Corpus and camera info\n");

	Corpus corpusData;
	char Fname[200]; sprintf(Fname, "%s/Corpus", Path);
	ReadCorpusInfo(Fname, corpusData, false, false);

	for (int ii = 0; ii < nViews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0;
		SharedIntrinsicCamID.push_back(0);
	}

	GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, SharedIntrinsicCamID, nViews, true, true, true, false, false, distortionCorrected, LossType, true, false);

	SaveCorpusInfo(Path, corpusData);

	return 0;
}
int CayleyRollingShutterBundleAdjustmentDriver(char *Path, int nViews, int distortionCorrected, vector< int> SharedIntrinsicCamID, int LossType)
{
	printf("Reading Corpus and camera info\n");

	Corpus corpusData;
	char Fname[200]; sprintf(Fname, "%s/Corpus", Path);
	ReadCorpusInfo(Fname, corpusData, false, true);

	for (int ii = 0; ii < nViews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0;
		SharedIntrinsicCamID.push_back(0);
	}

	//Get back the distorted 2d points
	for (int jj = 0; jj < corpusData.n3dPoints; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
		{
			int viewID = corpusData.viewIdAll3D[jj][ii];
			LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
		}
	}

	/*//Simulate 2d points
	double start = omp_get_wtime();

	vector<vector<int> > IdToDel;
	int n3D = (int)corpusData.xyz.size();
	for (int kk = 0; kk < n3D; kk++)
	{
	vector<int> toDel;
	IdToDel.push_back(toDel);
	}

	int numThreads = omp_get_max_threads();
	omp_set_num_threads(numThreads);

	//#pragma omp parallel for
	for (int kk = 0; kk < n3D; kk++)
	{
	vector<int> toDel;
	for (int ll = 0; ll < (int)corpusData.uvAll3D[kk].size(); ll++)
	{
	int viewID = corpusData.viewIdAll3D[kk][ll];
	Point2d uv = corpusData.uvAll3D[kk][ll];
	int nsolution = CayleyDistortionProjection(corpusData.camera[viewID].intrinsic, corpusData.camera[viewID].distortion, corpusData.camera[viewID].rt, corpusData.camera[viewID].wt, uv, corpusData.xyz[kk], corpusData.camera[viewID].width, corpusData.camera[viewID].height);
	if (nsolution != 1)
	{
	#pragma omp critical
	printf("Problem at 3D point %d, view %d \n", kk, ll);
	//toDel.push_back(ll);
	}
	else
	corpusData.uvAll3D[kk][ll] = uv;
	}
	IdToDel[kk] = toDel;

	#pragma omp critical
	if (kk % 1000 == 0 && omp_get_thread_num() == 0)
	printf("@\r# %.2f%% (%.2fs) Simulating rolling shutter 2d points..", 100.0*kk*numThreads / n3D, omp_get_wtime() - start);
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);

	/*for (int jj = 0; jj < (int)IdToDel.size(); jj++)
	{
	for (int ii = (int)IdToDel[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
	{
	int viewID = IdToDel[jj][ii];
	if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
	printf("%d\n", jj);
	else
	{
	corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
	corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
	corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
	corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
	}
	}
	}
	//sprintf(Fname, "%s/Corpus", Path);/SaveCorpusInfo(Fname, corpusData, false, false);*/

	CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, SharedIntrinsicCamID, nViews, true, true, true, false, false, false, distortionCorrected, LossType, true, false);

	SaveCorpusInfo(Path, corpusData, false, false);

	return 0;
}
int BuildCorpus(char *Path, int distortionCorrected, int ShutterModel, int sharedIntrinsic, int NDplus, int LossType)
{
	printf("Reading Corpus and camera info");
	char Fname[200];

	Corpus corpusData;
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	int nviews = corpusData.nCameras;
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0, corpusData.camera[ii].ninlierThresh = 50, corpusData.camera[ii];
		GetrtFromRT(corpusData.camera[ii].rt, corpusData.camera[ii].R, corpusData.camera[ii].T);
		GetIntrinsicFromK(corpusData.camera[ii]);
		AssembleP(corpusData.camera[ii].K, corpusData.camera[ii].R, corpusData.camera[ii].T, corpusData.camera[ii].P);
		if (distortionCorrected == 1)
			for (int jj = 0; jj < 7; jj++)
				corpusData.camera[ii].distortion[jj] = 0.0;
	}
	printf("...Done\n");

	vector<int>Refinement_SharedIntrinsic;
	if (sharedIntrinsic == 1)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	sprintf(Fname, "%s/ViewPM.txt", Path); FILE *fp = fopen(Fname, "r");
	int nviewsi, viewi, n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		for (int ii = 0; ii < nviewsi; ii++)
			fscanf(fp, "%d ", &viewi);
		n3D++;
	}
	fclose(fp);

	vector<int> cumulativePts;
	ReadCumulativePoints(Path, nviews, -1, cumulativePts);
	int totalPts = cumulativePts[nviews];

	vector<int>*PViewIdAll3D = new vector<int>[n3D];
	vector<int>*PuvIdAll3D = new vector<int>[n3D];

	printf("Reading Matching table....");
	sprintf(Fname, "%s/ViewPM.txt", Path); fp = fopen(Fname, "r");
	n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		PViewIdAll3D[n3D].reserve(nviewsi);
		for (int ii = 0; ii < nviewsi; ii++)
		{
			fscanf(fp, "%d ", &viewi);
			PViewIdAll3D[n3D].push_back(viewi);
		}
		n3D++;
	}
	fclose(fp);

	sprintf(Fname, "%s/IDPM.txt", Path); fp = fopen(Fname, "r");
	int np, pi;
	n3D = 0;
	while (fscanf(fp, "%d ", &np) != EOF)
	{
		PuvIdAll3D[n3D].reserve(np);
		for (int ii = 0; ii < np; ii++)
		{
			fscanf(fp, "%d ", &pi);
			PuvIdAll3D[n3D].push_back(pi);
		}
		n3D++;
	}
	fclose(fp);
	printf("...Done\n");

	//Read all sift points
	printf("Reading SIFT keys....");
	vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
	vector<Point3i> *AllRGB = new vector < Point3i >[nviews];
	for (int ii = 0; ii < nviews; ii++)
	{
		sprintf(Fname, "%s/K%d.dat", Path, ii); ReadKPointsBinarySIFTGPU(Fname, AllKeys[ii]);
		sprintf(Fname, "%s/RGB%d.dat", Path, ii); ReadRGBBinarySIFTGPU(Fname, AllRGB[ii]);
	}
	printf("...Done\n");

	//Correct for distortion if needed
	if (distortionCorrected == 0)
	{
		distortionCorrected = 1;
		Point2d pt;
		for (int ii = 0; ii < nviews; ii++)
		{
			int npts = AllKeys[ii].size();
			if (corpusData.camera[ii].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					LensCorrectionPoint(&pt, corpusData.camera[ii].K, corpusData.camera[ii].distortion);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
			else
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					FishEyeCorrectionPoint(&pt, corpusData.camera[ii].distortion[0], corpusData.camera[ii].distortion[1], corpusData.camera[ii].distortion[2]);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
		}
	}

	//Triangulate points from estimated camera poses
	printf("Triangulating the Corpus...");
	Point3d xyz;
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool *passed = new bool[nviews * 2];
	double *Ps = new double[12 * nviews * 2];

	vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
	Point2d *match2Dpts = new Point2d[nviews * 2];
	double *matchScales = new double[nviews * 2];

	corpusData.xyz.reserve(n3D);
	corpusData.rgb.reserve(n3D);
	corpusData.viewIdAll3D.reserve(n3D);
	corpusData.pointIdAll3D.reserve(n3D);

	vector<int>viewIDs, pointIDs, orgId, threeDid;
	vector<Point2d> uvPer3D, uvperView;
	vector<double>scalePer3D, scalePerView;

	for (int ii = 0; ii < n3D; ii++)
	{
		corpusData.viewIdAll3D.push_back(viewIDs), corpusData.viewIdAll3D[ii].reserve(nviews);
		corpusData.pointIdAll3D.push_back(pointIDs), corpusData.pointIdAll3D[ii].reserve(nviews);
		corpusData.uvAll3D.push_back(uvPer3D), corpusData.uvAll3D[ii].reserve(nviews);
		corpusData.scaleAll3D.push_back(scalePer3D), corpusData.scaleAll3D[ii].reserve(nviews);
	}

	printf("Start: \n");
	double ProThresh = 0.99, PercentInlier = 0.25;
	int goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	bool printout = 0;
	double start = omp_get_wtime();
	for (int jj = 0; jj < n3D; jj++)
	{
		if (jj % 1000 == 0)
			printf("@\r# %.2f%% (%.2fs) Triangualating corpus..", 100.0*jj / n3D, omp_get_wtime() - start);
		int nviewsi = PViewIdAll3D[jj].size();
		if (nviewsi >= NDplus)
		{
			Inliers[0].clear();
			for (int ii = 0; ii < nviewsi; ii++)
			{
				viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];
				if (ShutterModel == 0)
				{
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = corpusData.camera[viewi].P[kk];
				}
				else
				{
					double *wt = corpusData.camera[viewi].wt;
					double *intrinsic = corpusData.camera[viewi].intrinsic;
					double *Rcenter = corpusData.camera[viewi].R;
					double *Tcenter = corpusData.camera[viewi].T;
					double ycn = (AllKeys[viewi][pi].y - intrinsic[4]) / intrinsic[1];

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(corpusData.camera[viewi].K, R, T, Ps + 12 * ii);
				}

				match2Dpts[ii].x = AllKeys[viewi][pi].x, match2Dpts[ii].y = AllKeys[viewi][pi].y;
				matchScales[ii] = AllKeys[viewi][pi].s;
			}
		}
		else
			continue;
		if (printout)
		{
			FILE *fp = fopen("C:/temp/corres.txt", "w+");
			for (int ii = 0; ii < nviewsi; ii++)
				fprintf(fp, "%.1f %.1f\n", match2Dpts[ii].x, match2Dpts[ii].y);
			for (int ii = 0; ii < nviewsi; ii++)
			{
				for (int jj = 0; jj < 12; jj++)
					fprintf(fp, "%.4f ", Ps[jj + ii * 12]);
				fprintf(fp, "\n");
			}
			fclose(fp);
		}

		NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, corpusData.camera[0].threshold, A, B, tPs);
		if (passed[0])
		{
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
				if (Inliers[0][ii])
					ninlier++;
			if (ninlier < NDplus)
				continue; //Corpus needs NDplus+ points!
			corpusData.xyz.push_back(xyz);

			for (int ii = 0; ii < nviewsi; ii++)
			{
				if (Inliers[0][ii])
				{
					viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];

					corpusData.viewIdAll3D[goodNDplus].push_back(viewi);
					corpusData.pointIdAll3D[goodNDplus].push_back(pi);
					corpusData.uvAll3D[goodNDplus].push_back((match2Dpts[ii]));//store corrected 2d points into corpus
					corpusData.scaleAll3D[goodNDplus].push_back((matchScales[ii]));//store corrected 2d points into corpus
				}
			}
			goodNDplus++;
		}
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);
	printf("Found %d (%d+) points.\n\n", goodNDplus, NDplus);

	printf("Runing BA on the triangulated points...");
	//Let's reoptimize verything
	bool fixIntrinsic = 0, fixDistortion = 0, fixPose = 0, fix1stCamPose = 1, fix3D = 0;
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 0;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, fix3D, distortionCorrected, LossType);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, false, fix3D, distortionCorrected, LossType, false);

	//Now, can undistort points again
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 1;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensCorrectionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}
	printf("\n");

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	//Get the color info
	Point3i rgb;
	corpusData.rgb.reserve(goodNDplus);
	for (int kk = 0; kk < goodNDplus; kk++)
	{
		viewi = corpusData.viewIdAll3D[kk][0];
		pi = corpusData.pointIdAll3D[kk][0];
		rgb = AllRGB[viewi][pi];
		corpusData.rgb.push_back(rgb);
	}
	vector<int> AvailViews; AvailViews.reserve(nviews);
	for (int ii = 0; ii < nviews; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, corpusData.camera, AvailViews, corpusData.xyz, corpusData.rgb); // OK for visualization

	//Prune corpus for bad points
	printf("Remove not good points ...");
	vector<int> *notGood = new vector<int>[goodNDplus];
	sprintf(Fname, "%s/Good.txt", Path);	fp = fopen(Fname, "r");
	if (fp != NULL)
	{
		for (int jj = 0; jj < goodNDplus; jj++)
		{
			int pid, ii;
			fscanf(fp, "%d %d", &pid, &ii);
			while (ii != -1)
			{
				notGood[jj].push_back(ii);
				fscanf(fp, "%d ", &ii);
			}
		}
		fclose(fp);
	}

	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = notGood[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
		{
			int viewID = notGood[jj][ii];
			if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
				printf("%d\n", jj);
			else
			{
				corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
				corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
				corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
				corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
			}
		}
	}
	delete[]notGood;
	printf("Done!\n");


	//And generate 3D id, uv, sift id for all views
	printf("and generate Corpus visibility info....");
	vector<int> *twoDIdAllViews = new vector<int>[nviews];
	corpusData.threeDIdAllViews = new vector<int>[nviews];
	corpusData.uvAllViews = new vector<Point2d>[nviews];
	corpusData.scaleAllViews = new vector<double>[nviews];

	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.threeDIdAllViews[ii].reserve(10000);
		corpusData.uvAllViews[ii].reserve(10000);
		corpusData.scaleAllViews[ii].reserve(10000);
		twoDIdAllViews[ii].reserve(10000);
	}

	double scale;
	Point2d uv;
	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.viewIdAll3D[jj].size(); ii++)
		{
			viewi = corpusData.viewIdAll3D[jj][ii], pi = corpusData.pointIdAll3D[jj][ii], uv = corpusData.uvAll3D[jj][ii], scale = corpusData.scaleAll3D[jj][ii];

			corpusData.threeDIdAllViews[viewi].push_back(jj);
			corpusData.uvAllViews[viewi].push_back(uv);
			corpusData.scaleAllViews[viewi].push_back(scale);
			twoDIdAllViews[viewi].push_back(pi);
		}
	}
	printf("Done!\n");

	//Get sift matrix for all views
	printf("Prune SIFT descriptors for only Corpus points....");
	int nSift, totalSift = 0, maxSift = 0;
	corpusData.IDCumView.reserve(nviews + 1);
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.IDCumView.push_back(totalSift);
		nSift = twoDIdAllViews[ii].size();
		if (nSift > maxSift)
			maxSift = nSift;
		totalSift += nSift;
	}
	corpusData.IDCumView.push_back(totalSift);

	/*corpusData.SiftDesc.create(totalSift, SIFTBINS, CV_32F);
	vector<float> desc; desc.reserve(maxSift*SIFTBINS);
	for (int ii = 0; ii < nviews; ii++)
	{
	desc.clear();
	sprintf(Fname, "%s/D%d.dat", Path, ii), ReadDescriptorBinarySIFTGPU(Fname, desc);

	int curPid = corpusData.IDCumView[ii], nSift = twoDIdAllViews[ii].size();
	for (int j = 0; j < nSift; ++j)
	{
	int pid = twoDIdAllViews[ii][j];
	for (int i = 0; i < SIFTBINS; i++)
	corpusData.SiftDesc.at<float>(curPid + j, i) = desc[pid*SIFTBINS + i];
	}
	}*/

	FeatureDesc desci;
	vector<float> desc; desc.reserve(maxSift*SIFTBINS);
	for (int ii = 0; ii < nviews; ii++)
	{
		int nSift = corpusData.uvAllViews[ii].size();

		desc.clear();
		sprintf(Fname, "%s/D%d.dat", Path, ii), ReadDescriptorBinarySIFTGPU(Fname, desc);

		for (int j = 0; j < nSift; ++j)
		{
			int pid = twoDIdAllViews[ii][j];
			for (int i = 0; i < SIFTBINS; i++)
				desci.desc[ii] = desc[pid*SIFTBINS + i];
			corpusData.DescAllViews[ii].push_back(desci);
		}
	}

	printf("...Done\n\n");

	///****NOTE: 2d points in Corpus are corrected***///
	SaveCorpusInfo(Path, corpusData);

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys, delete[]twoDIdAllViews;
	delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts, delete[]matchScales;
	return 0;
}
int BuildCorpusVisualSfm(char *Path, int distortionCorrected, int ShutterModel, int sharedIntrinsic, int NDplus, int LossType)
{
	printf("Reading Corpus and camera info");
	char Fname[200];

	Corpus corpusData;
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	int nviews = corpusData.nCameras;
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.camera[ii].threshold = 5.0, corpusData.camera[ii].ninlierThresh = 50, corpusData.camera[ii];
		GetrtFromRT(corpusData.camera[ii].rt, corpusData.camera[ii].R, corpusData.camera[ii].T);
		GetIntrinsicFromK(corpusData.camera[ii]);
		AssembleP(corpusData.camera[ii].K, corpusData.camera[ii].R, corpusData.camera[ii].T, corpusData.camera[ii].P);
		if (distortionCorrected == 1)
			for (int jj = 0; jj < 7; jj++)
				corpusData.camera[ii].distortion[jj] = 0.0;
	}
	printf("...Done\n");

	vector<int>Refinement_SharedIntrinsic;
	if (sharedIntrinsic == 1)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	sprintf(Fname, "%s/ViewPM.txt", Path); FILE *fp = fopen(Fname, "r");
	int nviewsi, viewi, n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		for (int ii = 0; ii < nviewsi; ii++)
			fscanf(fp, "%d ", &viewi);
		n3D++;
	}
	fclose(fp);

	vector<int> cumulativePts;
	ReadCumulativePointsVisualSfm(Path, nviews, cumulativePts);
	int totalPts = cumulativePts[nviews];

	vector<int>*PViewIdAll3D = new vector<int>[n3D];
	vector<int>*PuvIdAll3D = new vector<int>[n3D];

	printf("Reading Matching table....");
	sprintf(Fname, "%s/ViewPM.txt", Path); fp = fopen(Fname, "r");
	n3D = 0;
	while (fscanf(fp, "%d ", &nviewsi) != EOF)
	{
		PViewIdAll3D[n3D].reserve(nviewsi);
		for (int ii = 0; ii < nviewsi; ii++)
		{
			fscanf(fp, "%d ", &viewi);
			PViewIdAll3D[n3D].push_back(viewi);
		}
		n3D++;
	}
	fclose(fp);

	sprintf(Fname, "%s/IDPM.txt", Path); fp = fopen(Fname, "r");
	int np, pi;
	n3D = 0;
	while (fscanf(fp, "%d ", &np) != EOF)
	{
		PuvIdAll3D[n3D].reserve(np);
		for (int ii = 0; ii < np; ii++)
		{
			fscanf(fp, "%d ", &pi);
			PuvIdAll3D[n3D].push_back(pi);
		}
		n3D++;
	}
	fclose(fp);
	printf("...Done\n");

	//Read all sift points
	printf("Reading SIFT keys....");
	vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
	Mat *AllDesc = new Mat[nviews];
	vector<Point3i> *AllRGB = new vector < Point3i >[nviews];
	Mat cvImg;
	for (int ii = 0; ii < nviews; ii++)
	{
		sprintf(Fname, "%s/%d.sift", Path, ii); readVisualSFMSift(Fname, AllKeys[ii], AllDesc[ii]);// ReadKPointsBinarySIFTGPU(Fname, AllKeys[ii]);

		sprintf(Fname, "%s/RGB%d.dat", Path, ii);
		if (!ReadRGBBinarySIFTGPU(Fname, AllRGB[ii]))
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii);
			cvImg = imread(Fname, IMREAD_COLOR);

			int nkeys = (int)AllKeys[ii].size();
			AllRGB[ii].reserve(nkeys);
			for (int kk = 0; kk < nkeys; kk++)
			{
				int x = (int)AllKeys[ii][kk].x, y = (int)AllKeys[ii][kk].y;
				int id = x + y*cvImg.cols;
				Point3i rgb;
				rgb.z = cvImg.data[3 * id + 0];//b
				rgb.y = cvImg.data[3 * id + 1];//g
				rgb.x = cvImg.data[3 * id + 2];//r
				AllRGB[ii].push_back(rgb);
			}

			sprintf(Fname, "%s/RGB%d.dat", Path, ii); WriteRGBBinarySIFTGPU(Fname, AllRGB[ii]);
		}
	}
	printf("...Done\n");

	//Correct for distortion if needed
	if (distortionCorrected == 0)
	{
		distortionCorrected = 1;
		Point2d pt;
		for (int ii = 0; ii < nviews; ii++)
		{
			int npts = AllKeys[ii].size();
			if (corpusData.camera[ii].LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					LensCorrectionPoint(&pt, corpusData.camera[ii].K, corpusData.camera[ii].distortion);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
			else
			{
				for (int jj = 0; jj < npts; jj++)
				{
					pt.x = AllKeys[ii][jj].x, pt.y = AllKeys[ii][jj].y;
					FishEyeCorrectionPoint(&pt, corpusData.camera[ii].distortion[0], corpusData.camera[ii].distortion[1], corpusData.camera[ii].distortion[2]);
					AllKeys[ii][jj].x = pt.x, AllKeys[ii][jj].y = pt.y;
				}
			}
		}
	}

	//Triangulate points from estimated camera poses
	printf("Triangulating the Corpus...");
	Point3d xyz;
	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool *passed = new bool[nviews * 2];
	double *Ps = new double[12 * nviews * 2];

	vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
	Point2d *match2Dpts = new Point2d[nviews * 2];
	double *matchScales = new double[nviews * 2];

	corpusData.xyz.reserve(n3D);
	corpusData.rgb.reserve(n3D);
	corpusData.viewIdAll3D.reserve(n3D);
	corpusData.pointIdAll3D.reserve(n3D);

	vector<int>viewIDs, pointIDs, orgId, threeDid;
	vector<Point2d> uvPer3D, uvperView;
	vector<double>scalePer3D, scalePerView;

	for (int ii = 0; ii < n3D; ii++)
	{
		corpusData.viewIdAll3D.push_back(viewIDs), corpusData.viewIdAll3D[ii].reserve(nviews);
		corpusData.pointIdAll3D.push_back(pointIDs), corpusData.pointIdAll3D[ii].reserve(nviews);
		corpusData.uvAll3D.push_back(uvPer3D), corpusData.uvAll3D[ii].reserve(nviews);
		corpusData.scaleAll3D.push_back(scalePer3D), corpusData.scaleAll3D[ii].reserve(nviews);
	}

	printf("Start: \n");
	double ProThresh = 0.99, PercentInlier = 0.25;
	int goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
	bool printout = 0;
	double start = omp_get_wtime();
	for (int jj = 0; jj < n3D; jj++)
	{
		if (jj % 1000 == 0)
			printf("@\r# %.2f%% (%.2fs) Triangualating corpus..", 100.0*jj / n3D, omp_get_wtime() - start);
		int nviewsi = PViewIdAll3D[jj].size();
		if (nviewsi >= NDplus)
		{
			Inliers[0].clear();
			for (int ii = 0; ii < nviewsi; ii++)
			{
				viewi = PViewIdAll3D[jj][ii]; pi = PuvIdAll3D[jj][ii];
				if (ShutterModel == 0)
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = corpusData.camera[viewi].P[kk];
				else
				{
					double *wt = corpusData.camera[viewi].wt;
					double *intrinsic = corpusData.camera[viewi].intrinsic;
					double *Rcenter = corpusData.camera[viewi].R;
					double *Tcenter = corpusData.camera[viewi].T;
					double ycn = (AllKeys[viewi][pi].y - intrinsic[4]) / intrinsic[1];

					double wx = ycn*wt[0], wy = ycn*wt[1], wz = ycn*wt[2];
					double wx2 = wx*wx, wy2 = wy*wy, wz2 = wz*wz, wxz = wx*wz, wxy = wx*wy, wyz = wy*wz;
					double denum = 1.0 + wx2 + wy2 + wz2;

					double Rw[9] = { 1.0 + wx2 - wy2 - wz2, 2.0 * wxy - 2.0 * wz, 2.0 * wy + 2.0 * wxz,
						2.0 * wz + 2.0 * wxy, 1.0 - wx2 + wy2 - wz2, 2.0 * wyz - 2.0 * wx,
						2.0 * wxz - 2.0 * wy, 2.0 * wx + 2.0 * wyz, 1.0 - wx2 - wy2 + wz2 };

					for (int jj = 0; jj < 9; jj++)
						Rw[jj] = Rw[jj] / denum;

					double R[9];  mat_mul(Rw, Rcenter, R, 3, 3, 3);
					double T[3] = { Tcenter[0] + ycn*wt[3], Tcenter[1] + ycn*wt[4], Tcenter[2] + ycn*wt[5] };

					AssembleP(corpusData.camera[viewi].K, R, T, Ps + 12 * ii);
				}

				match2Dpts[ii].x = AllKeys[viewi][pi].x, match2Dpts[ii].y = AllKeys[viewi][pi].y;
				matchScales[ii] = AllKeys[viewi][pi].s;
			}
		}
		else
			continue;
		/*if (printout)
		{
		FILE *fp = fopen("C:/temp/corres.txt", "w+");
		for (int ii = 0; ii < nviewsi; ii++)
		fprintf(fp, "%.1f %.1f\n", match2Dpts[ii].x, match2Dpts[ii].y);
		for (int ii = 0; ii < nviewsi; ii++)
		{
		for (int jj = 0; jj < 12; jj++)
		fprintf(fp, "%.4f ", Ps[jj + ii * 12]);
		fprintf(fp, "\n");
		}
		fclose(fp);
		}*/

		NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, corpusData.camera[0].threshold, A, B, tPs);

		if (passed[0])
		{
			int ninlier = 0;
			for (int ii = 0; ii < Inliers[0].size(); ii++)
				if (Inliers[0][ii])
					ninlier++;
			if (ninlier < NDplus)
				continue; //Corpus needs NDplus+ points!
			corpusData.xyz.push_back(xyz);

			for (int ii = 0; ii < nviewsi; ii++)
			{
				if (Inliers[0][ii])
				{
					viewi = PViewIdAll3D[jj][ii], pi = PuvIdAll3D[jj][ii];

					corpusData.viewIdAll3D[goodNDplus].push_back(viewi);
					corpusData.pointIdAll3D[goodNDplus].push_back(pi);
					corpusData.uvAll3D[goodNDplus].push_back((match2Dpts[ii]));//store corrected 2d points into corpus
					corpusData.scaleAll3D[goodNDplus].push_back((matchScales[ii]));//store corrected 2d points into corpus
				}
			}
			goodNDplus++;
		}
	}
	printf("@\r# %.2f%% (%.2fs) \n", 100.0, omp_get_wtime() - start);
	printf("Found %d (%d+) points.\n\n", goodNDplus, NDplus);


	//Let's reoptimize verything
	printf("Runing BA on the triangulated points...");
	bool fixIntrinsic = 0, fixDistortion = 0, fixPose = 0, fix1stCamPose = 1, fix3D = 0;

	if (fixIntrinsic == 0 || fixDistortion == 0)//Get back the distorted points so that the BA can correctly restart
	{
		distortionCorrected = 0;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, fix3D, distortionCorrected, LossType, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nviews, fixIntrinsic, fixDistortion, fixPose, fix1stCamPose, false, fix3D, distortionCorrected, LossType, false, false);

	//Now, can undistort points again
	if (fixIntrinsic == 0 || fixDistortion == 0)
	{
		distortionCorrected = 1;
		for (int jj = 0; jj < (int)corpusData.xyz.size(); jj++)
		{
			for (int ii = 0; ii < (int)corpusData.uvAll3D[jj].size(); ii++)
			{
				int viewID = corpusData.viewIdAll3D[jj][ii];
				LensCorrectionPoint(&corpusData.uvAll3D[jj][ii], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
			}
		}
	}
	printf("\n");

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	//Get the color info
	Point3i rgb;
	corpusData.rgb.reserve(goodNDplus);
	for (int kk = 0; kk < goodNDplus; kk++)
	{
		viewi = corpusData.viewIdAll3D[kk][0];
		pi = corpusData.pointIdAll3D[kk][0];
		rgb = AllRGB[viewi][pi];
		corpusData.rgb.push_back(rgb);
	}
	vector<int> AvailViews; AvailViews.reserve(nviews);
	for (int ii = 0; ii < nviews; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, corpusData.camera, AvailViews, corpusData.xyz, corpusData.rgb); // OK for visualization

	//Prune corpus for bad points
	printf("Remove not good points ...");
	vector<int> *notGood = new vector<int>[goodNDplus];
	sprintf(Fname, "%s/Good.txt", Path);	fp = fopen(Fname, "r");
	if (fp != NULL)
	{
		for (int jj = 0; jj < goodNDplus; jj++)
		{
			int pid, ii;
			fscanf(fp, "%d %d", &pid, &ii);
			while (ii != -1)
			{
				notGood[jj].push_back(ii);
				fscanf(fp, "%d ", &ii);
			}
		}
		fclose(fp);
	}

	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = notGood[jj].size() - 1; ii >= 0; ii--)//start from last to first when deleting vector stack of data
		{
			int viewID = notGood[jj][ii];
			if (viewID >corpusData.viewIdAll3D[jj].size() - 1)
				printf("%d\n", jj);
			else
			{
				corpusData.viewIdAll3D[jj].erase(corpusData.viewIdAll3D[jj].begin() + viewID);
				corpusData.pointIdAll3D[jj].erase(corpusData.pointIdAll3D[jj].begin() + viewID);
				corpusData.uvAll3D[jj].erase(corpusData.uvAll3D[jj].begin() + viewID);
				corpusData.scaleAll3D[jj].erase(corpusData.scaleAll3D[jj].begin() + viewID);
			}
		}
	}
	delete[]notGood;
	sprintf(Fname, "%s/Good.txt", Path);  remove(Fname);


	//And generate 3D id, uv, sift id for all views
	printf("and generate Corpus visibility info....");
	vector<int> *twoDiDAllViews = new vector<int>[nviews];
	corpusData.threeDIdAllViews = new vector<int>[nviews];
	corpusData.uvAllViews = new vector<Point2d>[nviews];
	corpusData.scaleAllViews = new vector<double>[nviews];
	corpusData.DescAllViews = new vector<FeatureDesc>[nviews];

	for (int ii = 0; ii < nviews; ii++)
	{
		twoDiDAllViews[ii].reserve(10000);
		corpusData.threeDIdAllViews[ii].reserve(10000);
		corpusData.uvAllViews[ii].reserve(10000);
		corpusData.scaleAllViews[ii].reserve(10000);
		corpusData.DescAllViews[ii].reserve(10000);
	}

	double scale;
	Point2d uv;
	for (int jj = 0; jj < goodNDplus; jj++)
	{
		for (int ii = 0; ii < (int)corpusData.viewIdAll3D[jj].size(); ii++)
		{
			viewi = corpusData.viewIdAll3D[jj][ii], pi = corpusData.pointIdAll3D[jj][ii], uv = corpusData.uvAll3D[jj][ii], scale = corpusData.scaleAll3D[jj][ii];

			twoDiDAllViews[viewi].push_back(pi);
			corpusData.threeDIdAllViews[viewi].push_back(jj);
			corpusData.uvAllViews[viewi].push_back(uv);
			corpusData.scaleAllViews[viewi].push_back(scale);
		}
	}
	printf("Done!\n");

	//Get sift matrix for all views
	printf("Prune SIFT descriptors for only Corpus points....");
	int nSift, totalSift = 0, maxSift = 0;
	corpusData.IDCumView.reserve(nviews + 1);
	for (int ii = 0; ii < nviews; ii++)
	{
		corpusData.IDCumView.push_back(totalSift);
		nSift = twoDiDAllViews[ii].size();
		if (nSift > maxSift)
			maxSift = nSift;
		totalSift += nSift;
	}
	corpusData.IDCumView.push_back(totalSift);

	FeatureDesc desci;
	for (int ii = 0; ii < nviews; ii++)
	{
		int nSift = corpusData.uvAllViews[ii].size();
		for (int j = 0; j < nSift; ++j)
		{
			int pid = twoDiDAllViews[ii][j];
			for (int i = 0; i < SIFTBINS; i++)
				desci.desc[i] = AllDesc[ii].at<float>(pid, i);
			corpusData.DescAllViews[ii].push_back(desci);
		}
	}

	printf("... Done!\nSaving corpus info\n");
	printf("****NOTE: 2d points in Corpus are corrected***\n");
	SaveCorpusInfo(Path, corpusData);

	printf("... Done\n\n");

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys, delete[]AllDesc, delete[]twoDiDAllViews;
	delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts, delete[]matchScales;

	return 0;
}
int Build3DFromSyncedImages(char *Path, int nviews, int startFrame, int stopFrame, int timeStep, int LensType, int distortionCorrected, int NDplus, double Reprojectionthreshold, double DepthThresh, int *FrameOffset, bool Save2DCorres, bool Gen3DPatchFile, double Patch_World_Unit, bool useRANSAC)
{
	int nFrames = max(MaxnFrames, stopFrame);
	if (FrameOffset == NULL)
	{
		FrameOffset = new int[nviews];
		for (int ii = 0; ii < nviews; ii++)
			FrameOffset[ii] = 0;
	}


	char Fname[200];
	VideoData AllVideoInfo;
	if (ReadVideoData(Path, AllVideoInfo, nviews, startFrame, stopFrame) == 1)
		return 1;

	int totalPts, MAXPTS = 0;
	for (int timeID = startFrame; timeID <= stopFrame; timeID += timeStep)
	{
		sprintf(Fname, "%s/Dynamic/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int nviewsi, viewi, n3D = 0;
		while (fscanf(fp, "%d ", &nviewsi) != EOF)
		{
			for (int ii = 0; ii < nviewsi; ii++)
				fscanf(fp, "%d ", &viewi);
			n3D++;
		}
		fclose(fp);
		if (n3D > MAXPTS)
			MAXPTS = n3D;
	}

	vector<int> cumulativePts; cumulativePts.reserve(nviews);
	vector<int>*PViewIdAll3D = new vector<int>[MAXPTS];
	vector<int>*PuvIdAll3D = new vector<int>[MAXPTS];
	vector<KeyPoint> *AllKeys = new vector < KeyPoint >[nviews];
	vector<Point3i> *RGB = new vector < Point3i >[nviews];
	vector<Point3d> AllXYZ; AllXYZ.reserve(1000);
	vector<Point3i> AllRGB; AllRGB.reserve(1000);

	double *A = new double[6 * nviews * 2];
	double *B = new double[2 * nviews * 2];
	double *tPs = new double[12 * nviews * 2];
	bool passed;
	double *Ps = new double[12 * nviews * 2];
	Point2d *match2Dpts = new Point2d[nviews * 2], *match2Dpts_BK = new Point2d[nviews * 2];
	Point3i *matchRGB = new Point3i[nviews * 2];

	int width = 1280, height = 720;
	double *Img = new double[1280 * 720 * 8];

	FILE *fp1 = 0, *fp2 = 0, *fp3 = 0, *fp4 = 0, *fp5 = 0;
	for (int timeID = startFrame; timeID <= stopFrame; timeID += timeStep)
	{
		printf("Working on time %d ...\n", timeID);
		cumulativePts.clear(); AllXYZ.clear(), AllRGB.clear();
		if (ReadCumulativePoints(Path, nviews, timeID, cumulativePts) == 1)
			continue;
		totalPts = cumulativePts.at(nviews);

		sprintf(Fname, "%s/Dynamic/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int nviewsi, viewi, n3D = 0;
		while (fscanf(fp, "%d ", &nviewsi) != EOF)
		{
			PViewIdAll3D[n3D].clear(), PViewIdAll3D[n3D].reserve(nviewsi);
			for (int ii = 0; ii < nviewsi; ii++)
			{
				fscanf(fp, "%d ", &viewi);
				PViewIdAll3D[n3D].push_back(viewi);
			}
			n3D++;
		}
		fclose(fp);

		sprintf(Fname, "%s/Dynamic/IDPM_%d.txt", Path, timeID); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		int np, pi;
		n3D = 0;
		while (fscanf(fp, "%d ", &np) != EOF)
		{
			PuvIdAll3D[n3D].clear(), PuvIdAll3D[n3D].reserve(np);
			for (int ii = 0; ii < np; ii++)
			{
				fscanf(fp, "%d ", &pi);
				PuvIdAll3D[n3D].push_back(pi);
			}
			n3D++;
		}
		fclose(fp);

		//Read all sift points
		for (int ii = 0; ii < nviews; ii++)
		{
			AllKeys[ii].clear(); RGB[ii].clear();
			sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID + FrameOffset[ii]); ReadKPointsBinarySIFTGPU(Fname, AllKeys[ii]);
			sprintf(Fname, "%s/%d/RGB%d.dat", Path, ii, timeID + FrameOffset[ii]); ReadRGBBinarySIFTGPU(Fname, RGB[ii]);
		}

		//Triangulate points from estimated camera poses
		Point3d xyz;
		vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
		vector<int>viewIDs, pointIDs, orgId, threeDid;
		vector<Point2d> uvPer3D, uvperView;
		Point3d PatchExpansionArrow[2];
		vector<KeyPoint> inlierPts;
		vector<CameraData> inlierViewsInfo;

		sprintf(Fname, "%s/Dynamic/3dGL_%d.xyz", Path, timeID); fp1 = fopen(Fname, "w+");
		if (Save2DCorres)
			sprintf(Fname, "%s/Dynamic/2DCorres_%d.txt", Path, timeID), fp2 = fopen(Fname, "w+");
		if (Gen3DPatchFile)
			sprintf(Fname, "%s/Dynamic/3DMem_%d.txt", Path, timeID), fp3 = fopen(Fname, "w+");

		double ProThresh = 0.99, PercentInlier = 0.25;
		int ninlier, inlierID, goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
		double start = omp_get_wtime();

		sprintf(Fname, "%s/Dynamic/Corres_%d.txt", Path, timeID), fp4 = fopen(Fname, "w+");

		for (int jj = 0; jj < nviews; jj++)
		{
			sprintf(Fname, "%s/%d/bg_%d.png", Path, jj, timeID + FrameOffset[jj]);
			//GrabImage(Fname, Img+jj*width*height, width, height, 1);
		}

		//FILE *fp5 = fopen("C:/temp/id.txt", "w+");
		for (int jj = 0; jj < n3D; jj++)
		{
			int nviewsi = PViewIdAll3D[jj].size();
			if (nviewsi >= NDplus)
			{
				//check for duplication
				bool duplicated = false;
				for (int ii = 1; ii < nviewsi; ii++)
					if (PViewIdAll3D[jj].at(ii - 1) == PViewIdAll3D[jj][ii])
						duplicated = true;
				if (duplicated)
					continue;

				//check for background
				/*bool background = false;
				for (int ii = 1; ii < nviewsi; ii++)
				{
				viewi = PViewIdAll3D[jj][ii];
				pi = PuvIdAll3D[jj][ii];
				match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);
				int x = match2Dpts[ii].x, y = match2Dpts[ii].y;
				if (Img[x + y*width+viewi*width*height] >250)
				background = true;
				}
				if (background)
				continue;

				fprintf(fp4, "%d ", nviewsi);
				for (int ii = 0; ii < nviewsi; ii++)
				{
				viewi = PViewIdAll3D[jj][ii];
				pi = PuvIdAll3D[jj][ii];
				match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);

				fprintf(fp4, "%d %.2f %.2f ", viewi, match2Dpts[ii].x, match2Dpts[ii].y);
				}
				fprintf(fp4, "\n ");*/

				Inliers[0].clear();
				for (int ii = 0; ii < nviewsi; ii++)
				{
					viewi = PViewIdAll3D[jj][ii];
					int fid = timeID + FrameOffset[viewi];
					for (int kk = 0; kk < 12; kk++)
						Ps[12 * ii + kk] = AllVideoInfo.VideoInfo[viewi*nFrames + fid].P[kk];

					pi = PuvIdAll3D[jj][ii];

					match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).pt.x, AllKeys[viewi].at(pi).pt.y);
					matchRGB[ii] = Point3i(RGB[viewi].at(pi).x, RGB[viewi].at(pi).y, RGB[viewi].at(pi).z);

					if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].LensModel == RADIAL_TANGENTIAL_PRISM)
						LensCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].K, AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion);
					else if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].LensModel == FISHEYE)
						FishEyeCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[0],
						AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[1], AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]].distortion[2]);
				}

				if (useRANSAC)
					NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, &passed, Inliers, nviewsi, 1, nviewsi == 2 ? 1 : iterMax, PercentInlier, Reprojectionthreshold, A, B, tPs);
				else
				{
					NviewTriangulation(match2Dpts, Ps, &xyz, nviewsi, 1, NULL, A, B);
					ProjectandDistort(xyz, match2Dpts_BK, Ps, NULL, NULL, nviewsi);

					double finalerror = 0.0;
					for (int ii = 0; ii < nviewsi; ii++)
						finalerror += pow(match2Dpts_BK[ii].x - match2Dpts[ii].x, 2) + pow(match2Dpts_BK[ii].y - match2Dpts[ii].y, 2);
					finalerror = sqrt(finalerror / nviewsi);
					if (finalerror < Reprojectionthreshold)
						passed = true;
					else
						passed = false;
				}

				if (passed)
				{
					inlierPts.clear();
					inlierViewsInfo.clear();

					if (useRANSAC)
					{
						ninlier = 0;
						for (int ii = 0; ii < Inliers[0].size(); ii++)
						{
							if (Inliers[0][ii])
							{
								inlierID = ii, ninlier++;
								if (Gen3DPatchFile)
								{
									viewi = PViewIdAll3D[jj][ii];
									pi = PuvIdAll3D[jj][ii];
									inlierPts.push_back(AllKeys[viewi].at(pi));
									inlierViewsInfo.push_back(AllVideoInfo.VideoInfo[viewi*nFrames + timeID + FrameOffset[viewi]]);
								}
							}
						}
						if (ninlier < NDplus)
							continue; //Corpus needs NDplus+ points!
					}
					else
						inlierID = 0;

					AllXYZ.push_back(xyz);
					AllRGB.push_back(matchRGB[inlierID]);
					if (abs(xyz.x) + abs(xyz.y) + abs(xyz.z) > 0.001)
					{
						//threshold by depth
						double *Center, Dist, minPointCamDistance = 9e9;
						for (int ii = 0; ii < nviews; ii++)
						{
							Center = AllVideoInfo.VideoInfo[ii*nFrames + timeID + FrameOffset[ii]].camCenter;
							Dist = Distance3D(Point3d(Center[0], Center[1], Center[2]), xyz);
							if (Dist < minPointCamDistance)
								minPointCamDistance = Dist;
						}
						if (minPointCamDistance > DepthThresh)
							continue;

						fprintf(fp1, "%.4f %.4f %.4f %d %d %d\n", xyz.x, xyz.y, xyz.z, matchRGB[inlierID].x, matchRGB[inlierID].y, matchRGB[inlierID].z);

						if (Save2DCorres)
						{
							fprintf(fp2, "%d ", ninlier);
							for (int ii = 0; ii < Inliers[0].size(); ii++)
							{
								if (Inliers[0][ii])
								{
									int viewid = PViewIdAll3D[jj][ii];
									LensDistortionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewid*nFrames + timeID + FrameOffset[viewid]].K, AllVideoInfo.VideoInfo[viewid*nFrames + timeID + FrameOffset[viewid]].distortion);
									fprintf(fp2, "%d %f %f ", viewid, match2Dpts[ii].x, match2Dpts[ii].y);
								}
							}
							fprintf(fp2, "\n");
						}

						if (Gen3DPatchFile)
						{
							double scale3D;
							SelectRefCam_InitPatchFixedScale(PatchExpansionArrow, scale3D, xyz, inlierPts, inlierViewsInfo, Patch_World_Unit);
							fprintf(fp3, "Pt3D %d %.4f %.4f %.4f %.4f %.4f %.4f %f %f %f %f %f %f %f\n", goodNDplus, xyz.x, xyz.y, xyz.z, 1.0*matchRGB[inlierID].x / 255.0, 1.0*matchRGB[inlierID].y / 255.0, 1.0*matchRGB[inlierID].z / 255.0,
								scale3D, PatchExpansionArrow[0].x, PatchExpansionArrow[0].y, PatchExpansionArrow[0].z,
								PatchExpansionArrow[1].x, PatchExpansionArrow[1].y, PatchExpansionArrow[1].z);
							fprintf(fp3, "%d ", ninlier);
							for (int ii = 0; ii < Inliers[0].size(); ii++)
							{
								if (Inliers[0][ii])
									fprintf(fp3, "%d %f %f ", PViewIdAll3D[jj][ii], match2Dpts[ii].x, match2Dpts[ii].y);
							}
							fprintf(fp3, "\n");
						}
					}

					goodNDplus++;
				}
			}
		}
		fclose(fp4);

		fclose(fp1);
		if (Save2DCorres)
			fclose(fp2);
		if (Gen3DPatchFile)
			fclose(fp3);
	}

	delete[]PViewIdAll3D, delete[]PuvIdAll3D, delete[]AllKeys;
	delete[]A, delete[]B, delete[]tPs, delete[]Ps, delete[]match2Dpts, delete[]match2Dpts_BK;
	return 0;
}

int MatchCameraToCorpus(char *Path, Corpus &corpusData, CameraData *camera, int cameraID, int timeID, int distortionCorrected, vector<int> &CorpusViewToMatch, const float nndrRatio, const int ninlierThresh)
{
	//Load image and extract features
	const int descriptorSize = SIFTBINS;

	char Fname[200];
	sprintf(Fname, "%s/%d/%d.png", Path, cameraID, timeID);
	Mat img = imread(Fname, CV_LOAD_IMAGE_COLOR);
	if (img.empty())
	{
		printf("Can't read %s\n", Fname);
		return 1;
	}

	double start = omp_get_wtime();
	if (timeID < 0)
		sprintf(Fname, "%s/%d/K.dat", Path, cameraID);
	else
		sprintf(Fname, "%s/%d/K%d.dat", Path, cameraID, timeID);

	bool readsucces = false;
	vector<KeyPoint> keypoints1; keypoints1.reserve(MAXSIFTPTS);
	if (useGPU)
		readsucces = ReadKPointsBinarySIFTGPU(Fname, keypoints1);
	else
		readsucces = ReadKPointsBinary(Fname, keypoints1);
	if (!readsucces)
	{
		printf("%s does not have SIFT points. Please precompute it!\n", Fname);
		exit(1);
	}

	//remove distortion if not removed before in case camera is calibrated
	if (distortionCorrected == 0)
	{
		Point2d pt;
		if (camera[cameraID].LensModel == RADIAL_TANGENTIAL_PRISM && camera[cameraID].notCalibrated == false)
		{
			for (int ii = 0; ii < keypoints1.size(); ii++)
			{
				pt.x = keypoints1[ii].pt.x, pt.y = keypoints1[ii].pt.y;
				LensCorrectionPoint(&pt, camera[cameraID].K, camera[cameraID].distortion);
				keypoints1[ii].pt.x = pt.x, keypoints1[ii].pt.y = pt.y;
			}
		}
		else if (camera[cameraID].LensModel == FISHEYE &&camera[cameraID].notCalibrated == false)
		{
			for (int ii = 0; ii < keypoints1.size(); ii++)
			{
				pt.x = keypoints1[ii].pt.x, pt.y = keypoints1[ii].pt.y;
				FishEyeCorrectionPoint(&pt, camera[cameraID].distortion[0], camera[cameraID].distortion[1], camera[cameraID].distortion[2]);
				keypoints1[ii].pt.x = pt.x, keypoints1[ii].pt.y = pt.y;
			}
		}
	}

	if (timeID < 0)
		sprintf(Fname, "%s/D%d.dat", Path, cameraID);
	else
		sprintf(Fname, "%s/%d/D%d.dat", Path, cameraID, timeID);
	Mat descriptors1 = ReadDescriptorBinarySIFTGPU(Fname);
	if (descriptors1.rows == 1)
	{
		printf("%s does not have SIFT points. Please precompute it!\n", Fname);
		exit(1);
	}

	//USAC config
	bool USEPROSAC = false, USESPRT = true, USELOSAC = true;
	ConfigParamsFund cfg;
	cfg.common.confThreshold = 0.99, cfg.common.minSampleSize = 7, cfg.common.inlierThreshold = 3.0;
	cfg.common.maxHypotheses = 850000, cfg.common.maxSolutionsPerSample = 3;
	cfg.common.prevalidateSample = true, cfg.common.prevalidateModel = true, cfg.common.testDegeneracy = true;
	cfg.common.randomSamplingMethod = USACConfig::SAMP_UNIFORM, cfg.common.verifMethod = USACConfig::VERIF_SPRT, cfg.common.localOptMethod = USACConfig::LO_LOSAC;

	if (USEPROSAC)
		cfg.prosac.maxSamples, cfg.prosac.beta, cfg.prosac.nonRandConf, cfg.prosac.minStopLen;
	if (USESPRT)
		cfg.sprt.tM = 200.0, cfg.sprt.mS = 2.38, cfg.sprt.delta = 0.05, cfg.sprt.epsilon = 0.15;
	if (USELOSAC)
		cfg.losac.innerSampleSize = 15, cfg.losac.innerRansacRepetitions = 5, cfg.losac.thresholdMultiplier = 2.0, cfg.losac.numStepsIterative = 4;

	if (distortionCorrected == 0 && camera[cameraID].distortion != NULL) // allow for more error if the image is not corrected and distortion parameters are unknown
		cfg.common.inlierThreshold *= 1.5;

	//Match extracted features with Corpus
	const bool useBFMatcher = false;
	const int knn = 2, ntrees = 4, maxLeafCheck = 128;

	vector<float>Scale; Scale.reserve(5000);
	vector<Point2f> twoD; twoD.reserve(5000);
	vector<int> threeDiD; threeDiD.reserve(5000);
	vector<int>viewID; viewID.reserve(5000);

	//Finding nearest neighbor
	vector<float>Scale1;
	vector<Point2d>key1, key2;
	vector<int>CorrespondencesID;
	double Fmat[9];
	vector<int>cur3Ds, Inliers;
	key1.reserve(5000), key2.reserve(5000);
	Scale1.reserve(5000);
	CorrespondencesID.reserve(5000), cur3Ds.reserve(5000), Inliers.reserve(5000);

	for (int ii = 0; ii < CorpusViewToMatch.size(); ii++)
	{
		key1.clear(), key2.clear();
		cur3Ds.clear(), Inliers.clear(), CorrespondencesID.clear();

		int camera2ID = CorpusViewToMatch[ii];
		/*int startID = corpusData.IDCumView.at(camera2ID), endID = corpusData.IDCumView.at(camera2ID + 1);
		Mat descriptors2(endID - startID, SIFTBINS, CV_32F);

		for (int jj = startID; jj < endID; jj++)
		for (int kk = 0; kk < SIFTBINS; kk++)
		descriptors2.at<float>(jj - startID, kk) = corpusData.SiftDesc.at<float>(jj, kk);*/

		int nsiftInCorpusView = (int)corpusData.DescAllViews[camera2ID].size();
		Mat descriptors2(nsiftInCorpusView, SIFTBINS, CV_32F);

		for (int jj = 0; jj < nsiftInCorpusView; jj++)
			for (int kk = 0; kk < SIFTBINS; kk++)
				descriptors2.at<float>(jj, kk) = corpusData.DescAllViews[camera2ID][jj].desc[kk];

		/*FILE *fp = fopen("C:/temp/cd.txt", "w+");
		for (int jj = 0; jj < nsiftInCorpusView; jj++)
		{
		int id = -1, pid = corpusData.threeDIdAllViews[camera2ID][jj];
		vector<int> a = corpusData.pointIdAll3D[pid], b = corpusData.viewIdAll3D[pid];
		for (int kk = 0; kk < (int)b.size(); kk++)
		if (b[kk] == camera2ID)
		{
		id = kk;
		break;
		}
		if (id != -1)
		fprintf(fp, "%d %.4f %.4f ", a[id], corpusData.uvAllViews[camera2ID][jj].x, corpusData.uvAllViews[camera2ID][jj].y);
		else
		int a = 0;
		for (int kk = 0; kk < SIFTBINS; kk++)
		fprintf(fp, "%f ", corpusData.DescAllViews[camera2ID][jj].desc[kk]);
		fprintf(fp, "\n");
		}
		fclose(fp);

		fp = fopen("C:/temp/ni.txt", "w+");
		for (int jj = 0; jj < keypoints1.size(); jj++)
		{
		fprintf(fp, "%d %.4f %.4f ", jj, keypoints1[jj].pt.x, keypoints1[jj].pt.y);
		for (int kk = 0; kk < SIFTBINS; kk++)
		fprintf(fp, "%f ", descriptors1.at<float>(jj, kk));
		fprintf(fp, "\n");
		}
		fclose(fp);*/

		double start = omp_get_wtime();
		Mat indices, dists;
		vector<vector<DMatch> > matches;
		if (useBFMatcher)
		{
			cv::BFMatcher matcher(cv::NORM_L2);
			matcher.knnMatch(descriptors2, descriptors1, matches, knn);
		}
		else
		{
			cv::flann::Index flannIndex(descriptors1, cv::flann::KDTreeIndexParams(ntrees));//, cvflann::FLANN_DIST_EUCLIDEAN);
			flannIndex.knnSearch(descriptors2, indices, dists, knn, cv::flann::SearchParams(maxLeafCheck));//Search in desc1 for every desc in 2
		}

		int count = 0;
		if (!useBFMatcher)
		{
			for (int i = 0; i < descriptors2.rows; ++i)
			{
				int ind1 = indices.at<int>(i, 0);
				if (indices.at<int>(i, 0) >= 0 && indices.at<int>(i, 1) >= 0 && dists.at<float>(i, 0) <= nndrRatio * dists.at<float>(i, 1))
				{
					int cur3Did = corpusData.threeDIdAllViews[camera2ID].at(i);
					cur3Ds.push_back(cur3Did);

					key1.push_back(Point2d(keypoints1.at(ind1).pt.x, keypoints1.at(ind1).pt.y));
					Scale1.push_back(keypoints1[ind1].size);
					key2.push_back(corpusData.uvAllViews[camera2ID].at(i));
				}
			}
		}
		else
		{
			for (unsigned int i = 0; i < matches.size(); ++i)
			{
				if (matches.at(i).size() == 2 && matches.at(i).at(0).distance <= nndrRatio * matches.at(i).at(1).distance)
				{
					int cur3Did = corpusData.threeDIdAllViews[camera2ID].at(i);
					cur3Ds.push_back(cur3Did);

					int ind1 = matches.at(i).at(0).trainIdx;
					key1.push_back(Point2d(keypoints1.at(ind1).pt.x, keypoints1.at(ind1).pt.y));
					Scale1.push_back(keypoints1[ind1].size);
					key2.push_back(corpusData.uvAllViews[camera2ID].at(i));
				}
			}
		}

		///****NOTE: 2d points in Corpus are corrected***///
		int ninliers = 0;
		if (key1.size() < ninlierThresh || key2.size() < ninlierThresh)
			continue;
		cfg.common.numDataPoints = key1.size();
		USAC_FindFundamentalMatrix(cfg, key1, key2, Fmat, Inliers, ninliers);

		/*sprintf(Fname, "%s/orig_pts.txt", Path); FILE *fp = fopen(Fname, "w+");
		for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%.2f %.2f %.2f %.2f\n", key1[ii].x, key1[ii].y, key2[ii].x, key2[ii].y);
		fclose(fp);

		sprintf(Fname, "%s/F.txt", Path); fp = fopen(Fname, "w+");
		for (int ii = 0; ii < 9; ii++)
		fprintf(fp, "%.8f ", Fmat[ii]);
		fclose(fp);

		sprintf(Fname, "%s/inliers.txt", Path); fp = fopen(Fname, "w+");
		for (int ii = 0; ii < cfg.common.numDataPoints; ii++)
		fprintf(fp, "%d\n", Inliers[ii]);
		fclose(fp);*/

		if (ninliers < ninlierThresh)
		{
			printf("(%d, %d) to Corpus %d: failed Fundamental matrix test\n\n", cameraID, timeID, camera2ID);
			continue;
		}

		//Add matches to 2d-3d list
		for (int jj = 0; jj < Inliers.size(); jj++)
		{
			if (Inliers[jj] == 1)
			{
				int cur3Did = cur3Ds[jj];
				bool used = false;
				for (int kk = 0; kk < threeDiD.size(); kk++)
				{
					if (cur3Did == threeDiD.at(kk))
					{
						used = true;
						break;
					}
				}
				if (used)
					continue;

				twoD.push_back(Point2f(key1[jj].x, key1[jj].y));
				Scale.push_back(Scale1[jj]);
				threeDiD.push_back(cur3Did);
				viewID.push_back(camera2ID);
				count++;
			}
		}

		bool ShowCorrespondence = 0;
		if (ShowCorrespondence)
		{
			int nchannels = 3;
			sprintf(Fname, "%s/%d/%d.png", Path, cameraID, timeID);
			IplImage *Img1 = cvLoadImage(Fname, nchannels == 3 ? 1 : 0);
			if (Img1->imageData == NULL)
			{
				printf("Cannot load %s\n", Fname);
				return 1;
			}
			sprintf(Fname, "%s/Corpus/%d.png", Path, camera2ID);
			IplImage *Img2 = cvLoadImage(Fname, nchannels == 3 ? 1 : 0);
			if (Img2->imageData == NULL)
			{
				printf("Cannot load %s\n", Fname);
				return 1;
			}

			vector<Point2d> _key1, _key2;
			if (distortionCorrected == 0)
			{
				_key1 = key1; _key2 = key2;
				Point2d pt;
				if (camera[cameraID].LensModel == RADIAL_TANGENTIAL_PRISM && camera[cameraID].notCalibrated == false)
					LensDistortionPoint(_key1, camera[cameraID].K, camera[cameraID].distortion);
				else  if (camera[cameraID].LensModel == FISHEYE && camera[cameraID].notCalibrated == false)
				{
					for (int ii = 0; ii < key1.size(); ii++)
						FishEyeDistortionPoint(&_key1[ii], camera[cameraID].distortion[0], camera[cameraID].distortion[1], camera[cameraID].distortion[2]);
				}

				if (corpusData.camera[camera2ID].LensModel == RADIAL_TANGENTIAL_PRISM && corpusData.camera[camera2ID].notCalibrated == false)
					LensDistortionPoint(_key2, corpusData.camera[camera2ID].K, corpusData.camera[camera2ID].distortion);
				else if (corpusData.camera[camera2ID].LensModel == FISHEYE && corpusData.camera[camera2ID].notCalibrated == false)
				{
					for (int ii = 0; ii < key2.size(); ii++)
						FishEyeDistortionPoint(&_key2[ii], corpusData.camera[camera2ID].distortion[0], corpusData.camera[camera2ID].distortion[1], corpusData.camera[camera2ID].distortion[2]);
				}
			}

			CorrespondencesID.clear();
			for (int ii = 0; ii < key1.size(); ii++)
				if (Inliers[ii] == 1)
					CorrespondencesID.push_back(ii), CorrespondencesID.push_back(ii);

			IplImage* correspond = cvCreateImage(cvSize(Img1->width + Img2->width, Img1->height), 8, nchannels);
			cvSetImageROI(correspond, cvRect(0, 0, Img1->width, Img1->height));
			cvCopy(Img1, correspond);
			cvSetImageROI(correspond, cvRect(Img1->width, 0, correspond->width, correspond->height));
			cvCopy(Img2, correspond);
			cvResetImageROI(correspond);
			if (distortionCorrected == 0)
				DisplayImageCorrespondence(correspond, Img1->width, 0, _key1, _key2, CorrespondencesID, .25);
			else
				DisplayImageCorrespondence(correspond, Img1->width, 0, key1, key2, CorrespondencesID, .25);
			cout << "\a";
		}
#pragma omp critical
		printf("(%d, %d) to Corpus %d: %d 3+ points in %.2fs.\n\n", cameraID, timeID, camera2ID, count, omp_get_wtime() - start);
	}

	sprintf(Fname, "%s/%d/3D2D_%d.txt", Path, cameraID, timeID); FILE *fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", threeDiD.size());
	for (int jj = 0; jj < threeDiD.size(); jj++)
		fprintf(fp, "%d %.16f %.16f %.3f\n", threeDiD[jj], twoD[jj].x, twoD[jj].y, Scale[jj]);
	fclose(fp);

	/*sprintf(Fname, "%s/%d/_3D2D_%d.txt", Path, cameraID, timeID); fp = fopen(Fname, "w+");
	fprintf(fp, "%d\n", threeDiD.size());
	for (int jj = 0; jj < threeDiD.size(); jj++)
	{
	int pid = threeDiD[jj], vid = viewID[jj];
	Point2d twoDCorpus;
	for (int i = 0; i < corpusData.viewIdAll3D[pid].size(); i++)
	{
	if (corpusData.viewIdAll3D[pid].at(i) == vid)
	{
	twoDCorpus = corpusData.uvAll3D[pid].at(i);
	break;
	}
	}
	fprintf(fp, "%d %.2f %.2f %d %.2f %.2f\n", threeDiD[jj], twoD[jj].x, twoD[jj].y, vid, twoDCorpus.x, twoDCorpus.y);
	}
	fclose(fp);*/

	return 0;
}
int CameraPose_GSBA(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> &uvAll3D, vector<double> &scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up Pose BA ...");
	ceres::Problem problem;

	int nBadCounts = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;

	double fxfy[2] = { camera.intrinsic[0], camera.intrinsic[1] };
	double skew = camera.intrinsic[2];
	double uv0[2] = { camera.intrinsic[3], camera.intrinsic[4] };
	double Radial12[2], Tangential[2], Radial3, Prism[2], omega, DistCtr[2];

	if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
	{
		Radial12[0] = camera.distortion[0], Radial12[1] = camera.distortion[1];
		Tangential[0] = camera.distortion[3], Tangential[1] = camera.distortion[4];
		Radial3 = camera.distortion[2], Prism[0] = camera.distortion[5], Prism[1] = camera.distortion[6];
	}
	else
		omega = camera.distortion[0], DistCtr[0] = camera.distortion[1], DistCtr[1] = camera.distortion[2];

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (distortionCorrected)
			PinholeReprojectionDebug(camera.intrinsic, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
		else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			PinholeDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);
		else
			FOVReprojectionDistortionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), residuals);

		if (abs(residuals[0]) > 1.25*camera.threshold || abs(residuals[1]) > 1.25*camera.threshold)
		{
			Good.push_back(false);
			if (abs(residuals[0]) > maxOutlierX)
				maxOutlierX = residuals[0];
			if (abs(residuals[1]) > maxOutlierY)
				maxOutlierY = residuals[1];
			nBadCounts++;
		}
		else
		{
			Good.push_back(true);
			if (distortionCorrected == 1)
			{
				ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, camera.intrinsic, camera.rt, &xyz[3 * jj]);
			}
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError2::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, fxfy, &skew, uv0, Radial12, Tangential, &Radial3, Prism, camera.rt, &xyz[3 * jj]);
			}
			else
			{
				ceres::CostFunction* cost_function = FOVReprojectionError2::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj]);
				problem.AddResidualBlock(cost_function, NULL, fxfy, &skew, uv0, camera.distortion, camera.rt, &xyz[3 * jj]);
			}

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			problem.SetParameterBlockConstant(xyz + 3 * jj);
		}

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], uvAll3D[jj].x, uvAll3D[jj].y, abs(residuals[0]), abs(residuals[1]));
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("(%d/%d) bad points detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, npts, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	if (nBadCounts > npts * 80 / 100)
		return 1;

	//Set up constant parameters:
	if (distortionCorrected == 1)
		problem.SetParameterBlockConstant(camera.intrinsic);
	else
	{
		problem.SetParameterBlockConstant(&skew);
		if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			problem.SetParameterBlockConstant(&Radial3), problem.SetParameterBlockConstant(Prism);
	}

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 300;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	//std::cout << summary.BriefReport() << "\n";
	std::cout << summary.BriefReport() << "\n";

	//Store refined parameters
	if (distortionCorrected == 0)
	{
		camera.intrinsic[0] = fxfy[0], camera.intrinsic[1] = fxfy[1];
		camera.intrinsic[2] = skew;
		camera.intrinsic[3] = uv0[0], camera.intrinsic[4] = uv0[1];
		if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
		{
			camera.distortion[0] = Radial12[0], camera.distortion[1] = Radial12[1];
			camera.distortion[3] = Tangential[0], camera.distortion[4] = Tangential[1];
			camera.distortion[2] = Radial3, camera.distortion[5] = Prism[0], camera.distortion[6] = Prism[1];
		}
		else
			camera.distortion[0] = omega, camera.distortion[1] = DistCtr[0], camera.distortion[2] = DistCtr[1];
	}

	GetKFromIntrinsic(&camera, 1);
	GetRTFromrt(&camera, 1);
	AssembleP(camera.K, camera.R, camera.T, camera.P);
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int ii = 0; ii < npts; ii++)
	{
		if (abs(xyz[3 * ii]) > LIMIT3D)
		{
			if (!Good[ii])
				continue;

			if (distortionCorrected)
				PinholeReprojectionDebug(camera.intrinsic, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
				PinholeDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);
			else
				FOVReprojectionDistortionDebug(camera.intrinsic, camera.distortion, camera.rt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), residuals);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", ii, xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2], uvAll3D[ii].x, uvAll3D[ii].y, abs(residuals[0]), abs(residuals[1]));
		}
	}
	if (debug)
		fclose(fp);


	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz;
	return 0;
}
int CameraPose_RSBA(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> &uvAll3D, vector<double> &scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	char Fname[200]; FILE *fp = 0;
	int ii, npts = Vxyz.size();
	double residuals[2];

	double *xyz = new double[npts * 3];
	for (ii = 0; ii < npts; ii++)
		xyz[3 * ii] = Vxyz[ii].x, xyz[3 * ii + 1] = Vxyz[ii].y, xyz[3 * ii + 2] = Vxyz[ii].z;

	printf("Set up Pose BA ...");
	ceres::Problem problem;

	int nBadCounts = 0;
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(npts);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(npts);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");
	for (int jj = 0; jj < npts; jj++)
	{
		if (distortionCorrected)
			CayleyReprojectionDebug(camera.intrinsic, camera.rt, camera.wt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera.width, camera.height, residuals);
		else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			CayleyDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, camera.wt, uvAll3D[jj], Point3d(xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2]), camera.width, camera.height, residuals);

		if (abs(residuals[0]) > 1.25*camera.threshold || abs(residuals[1]) > 1.25*camera.threshold)
		{
			Good.push_back(false);
			if (abs(residuals[0]) > maxOutlierX)
				maxOutlierX = residuals[0];
			if (abs(residuals[1]) > maxOutlierY)
				maxOutlierY = residuals[1];
			nBadCounts++;
		}
		else
		{
			Good.push_back(true);
			if (distortionCorrected == 1)
			{
				ceres::CostFunction* cost_function = CayleyReprojectionError::Create(camera.intrinsic, uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj], camera.width, camera.height);
				problem.AddResidualBlock(cost_function, NULL, camera.rt, camera.wt, &xyz[3 * jj]);
			}
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
			{
				ceres::CostFunction* cost_function = CayleyDistortionReprojectionError::Create(uvAll3D[jj].x, uvAll3D[jj].y, scaleAll3D[jj], camera.width, camera.height);
				problem.AddResidualBlock(cost_function, NULL, camera.intrinsic, camera.distortion, camera.rt, camera.wt, &xyz[3 * jj]);
			}
			problem.SetParameterBlockConstant(&xyz[3 * jj]);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
		}

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", jj, xyz[3 * jj], xyz[3 * jj + 1], xyz[3 * jj + 2], uvAll3D[jj].x, uvAll3D[jj].y, abs(residuals[0]), abs(residuals[1]));
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("(%d/%d) bad points detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, npts, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	if (nBadCounts > npts * 80 / 100)
		return 1;

	//Set up constant parameters:
	if (distortionCorrected == 0)
	{
		if (fixIntrinsic)
			problem.SetParameterBlockConstant(camera.intrinsic);
		if (fixDistortion)
			problem.SetParameterBlockConstant(camera.distortion);
	}

	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 300;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = false;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;
	options.use_nonmonotonic_steps = false;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.BriefReport() << "\n";


	GetKFromIntrinsic(&camera, 1);
	GetRTFromrt(&camera, 1);
	AssembleP(camera.K, camera.R, camera.T, camera.P);
	for (int ii = 0; ii < npts; ii++)
		Vxyz[ii] = Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]);

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0;

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
	for (int ii = 0; ii < npts; ii++)
	{
		if (abs(xyz[3 * ii]) > LIMIT3D)
		{
			if (!Good[ii])
				continue;

			if (distortionCorrected)
				CayleyReprojectionDebug(camera.intrinsic, camera.rt, camera.wt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), camera.width, camera.height, residuals);
			else if (camera.LensModel == RADIAL_TANGENTIAL_PRISM)
				CayleyDistortionReprojectionDebug(camera.intrinsic, camera.distortion, camera.rt, camera.wt, uvAll3D[ii], Point3d(xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2]), camera.width, camera.height, residuals);

			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", ii, xyz[3 * ii], xyz[3 * ii + 1], xyz[3 * ii + 2], uvAll3D[ii].x, uvAll3D[ii].y, abs(residuals[0]), abs(residuals[1]));
		}
	}
	if (debug)
		fclose(fp);


	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
#pragma omp critical
	printf("Reprojection error after BA:\nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	delete[]xyz;
	return 0;
}
int P6P_RS(char *Path, CameraData &camera, vector<Point3d>  Vxyz, vector<Point2d> uvAll3D, vector<double> scaleAll3D, vector<bool> &Good, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, bool debug)
{
	//TO DO
	return 0;
}
int EstimateCameraPoseFromCorpus(char *Path, Corpus &corpusData, CameraData  &cameraParas, int cameraID, bool fixIntrinsic, bool fixDistortion, int distortionCorrected, int sharedIntriniscOptim, int timeID)
{
	char Fname[200];
	int threeDid, npts, ptsCount = 0;
	double u, v, s = 1.0;

	sprintf(Fname, "%s/%d/3D2D_%d.txt", Path, cameraID, timeID);
	FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return -1;
	}
	fscanf(fp, "%d ", &npts);
	vector<int> threeDidVec;
	Point2d *pts = new Point2d[npts];
	double *Scale = new double[npts];
	Point3d *t3D = new Point3d[npts];
	while (fscanf(fp, "%d %lf %lf %lf ", &threeDid, &u, &v, &s) != EOF)
	{
		threeDidVec.push_back(threeDid);
		pts[ptsCount].x = u, pts[ptsCount].y = v, Scale[ptsCount] = s;
		t3D[ptsCount].x = corpusData.xyz.at(threeDid).x, t3D[ptsCount].y = corpusData.xyz.at(threeDid).y, t3D[ptsCount].z = corpusData.xyz.at(threeDid).z;
		ptsCount++;
	}
	fclose(fp);


	int ninliers;
	DetermineDevicePose(cameraParas.K, cameraParas.distortion, cameraParas.LensModel, cameraParas.R, cameraParas.T, pts, t3D, npts, distortionCorrected, cameraParas.threshold, ninliers);
	GetrtFromRT(&cameraParas, 1);

	vector<bool> Good; Good.reserve(npts);
	vector<Point3d> Vxyz; Vxyz.reserve(npts);
	vector<Point2d> uv; uv.reserve(npts);
	vector<double>scale; scale.reserve(npts);

	for (int ii = 0; ii < npts; ii++)
	{
		Vxyz.push_back(Point3d(t3D[ii].x, t3D[ii].y, t3D[ii].z));
		uv.push_back(Point2d(pts[ii].x, pts[ii].y));
		scale.push_back(Scale[ii]);
	}

	cameraParas.ShutterModel = 0;
	if (cameraParas.ShutterModel == 0)
	{
		if (CameraPose_GSBA(Path, cameraParas, Vxyz, uv, scale, Good, fixIntrinsic, fixDistortion, distortionCorrected, true) == 1)
			return -1;
	}
	else
	{
		if (CameraPose_RSBA(Path, cameraParas, Vxyz, uv, scale, Good, fixIntrinsic, fixDistortion, distortionCorrected, true) == 1)
			return -1;
		printf("Local RS pose: ");
		for (int ii = 0; ii < 6; ii++)
			printf("%f ", cameraParas.wt[ii]);
		printf("\n");
	}

	if (sharedIntriniscOptim != 0)
	{
		sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, cameraID, timeID);	fp = fopen(Fname, "w+");
		for (int ii = 0; ii < npts; ii++)
			if (Good[ii])
				fprintf(fp, "%d %f %f %f %.6f %.6f %.2f\n", threeDidVec[ii], Vxyz[ii].x, Vxyz[ii].y, Vxyz[ii].z, uv[ii].x, uv[ii].y, scale[ii]);
		fclose(fp);
	}

	if (fixIntrinsic == 0)
		printf("Intrinsic: %.1f %.1f %.1f %.1f %.1f\n", cameraParas.intrinsic[0], cameraParas.intrinsic[1], cameraParas.intrinsic[2], cameraParas.intrinsic[3], cameraParas.intrinsic[4]);
	if (fixDistortion == 0)
	{
		printf("Distortion: ");
		if (cameraParas.LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				printf("%.1e ", cameraParas.distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				printf("%.1e ", cameraParas.distortion[ii]);
		printf("\n");
	}

	sprintf(Fname, "%s/Intrinsic_%d.txt", Path, cameraID);
	fp = fopen(Fname, "a+");
	fprintf(fp, "%d %d %d %d %d ", timeID, cameraParas.LensModel, cameraParas.ShutterModel, cameraParas.width, cameraParas.height);
	for (int ii = 0; ii < 5; ii++)
		fprintf(fp, "%f ", cameraParas.intrinsic[ii]);
	if (cameraParas.LensModel == RADIAL_TANGENTIAL_PRISM)
		for (int ii = 0; ii < 7; ii++)
			fprintf(fp, "%f ", cameraParas.distortion[ii]);
	else
		for (int ii = 0; ii < 3; ii++)
			fprintf(fp, "%f ", cameraParas.distortion[ii]);
	fprintf(fp, "\n");
	fclose(fp);

	ninliers = 0;
	for (int ii = 0; ii < npts; ii++)
		if (Good[ii])
			ninliers++;

	double iR[9], center[3];
	mat_invert(cameraParas.R, iR);

	cameraParas.Rgl[0] = cameraParas.R[0], cameraParas.Rgl[1] = cameraParas.R[1], cameraParas.Rgl[2] = cameraParas.R[2], cameraParas.Rgl[3] = 0.0;
	cameraParas.Rgl[4] = cameraParas.R[3], cameraParas.Rgl[5] = cameraParas.R[4], cameraParas.Rgl[6] = cameraParas.R[5], cameraParas.Rgl[7] = 0.0;
	cameraParas.Rgl[8] = cameraParas.R[6], cameraParas.Rgl[9] = cameraParas.R[7], cameraParas.Rgl[10] = cameraParas.R[8], cameraParas.Rgl[11] = 0.0;
	cameraParas.Rgl[12] = 0, cameraParas.Rgl[13] = 0, cameraParas.Rgl[14] = 0, cameraParas.Rgl[15] = 1.0;

	mat_mul(iR, cameraParas.T, center, 3, 3, 1); //Center = -iR*T 
	cameraParas.camCenter[0] = -center[0], cameraParas.camCenter[1] = -center[1], cameraParas.camCenter[2] = -center[2];

	delete[]pts, delete[]t3D;
	if (ninliers < cameraParas.ninlierThresh)
	{
		printf("Estimated pose for View (%d, %d).. fails ... low inliers (%d/%d). Camera center: %.4f %.4f %.4f \n\n", cameraID, timeID, ninliers, npts, cameraParas.T[0], cameraParas.T[1], cameraParas.T[2]);
		return -1;
	}
	else
	{
		printf("Estimated pose for View (%d, %d).. succeds ... inliers (%d/%d). Camera center: %.4f %.4f %.4f \n\n", cameraID, timeID, ninliers, npts, cameraParas.T[0], cameraParas.T[1], cameraParas.T[2]);
		return ninliers;
	}
}
int VideoPose_GSBA(char *Path, int selectedCamID, int startFrame, int stopFrame, int fixedIntrinisc, int fixDistortion, int fixed3D, int distortionCorrected, double threshold)
{
	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCamID, startFrame, stopFrame) == 1)
		return 1;

	//Read BA data
	double scale; Point2d uv; Point3d P3d;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = false, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.txt", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCamID, frameID);	FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.txt", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}

	bool setReferenceflag = false;
	int RefFrameID, nBadCounts, validPtsCount;
	double residuals[2], maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);

	double ErrorMultiplier[2] = { 10.0, 3.0 };
	for (int iteration = 0; iteration < 2; iteration++)
	{
		ceres::Problem problem;
		ceres::LossFunction* loss_function = iteration == 0 ? new HuberLoss(threshold) : NULL;

		nBadCounts = 0, validPtsCount = 0;
		Good.clear(), ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
		{
			for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
			{
				int frameID = frameIDPer3D[pid][fid];
				uv = P2dPer3D[pid][fid];
				scale = scalePer3D[pid][fid];
				P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

				if (!setReferenceflag)
				{
					if (distortionCorrected)
						PinholeReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					else
					{
						if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
							PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
						else
							FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					}
				}
				else
				{
					if (distortionCorrected)
						PinholeReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					else
					{
						if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
							PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
						else
							FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
					}
				}

				if (abs(residuals[0]) > ErrorMultiplier[iteration] * threshold || abs(residuals[1]) > ErrorMultiplier[iteration] * threshold)
				{
					Good.push_back(false);
					if (abs(residuals[0]) > maxOutlierX)
						maxOutlierX = residuals[0];
					if (abs(residuals[1]) > maxOutlierY)
						maxOutlierY = residuals[1];
					nBadCounts++;
					continue;
				}
				else
				{
					Good.push_back(true);
					if (!setReferenceflag)
						RefFrameID = frameID, setReferenceflag = true;

					if (distortionCorrected == 0)
					{
						if (!fixed3D)
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError2::Create(uv.x, uv.y, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 2, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3,
								VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[RefFrameID].distortion + 3, VideoInfoI.VideoInfo[RefFrameID].distortion + 2, VideoInfoI.VideoInfo[RefFrameID].distortion + 5,
								VideoInfoI.VideoInfo[frameID].rt, &P3D[3 * pid]);
						}
						else
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError3::Create(uv.x, uv.y, P3d.x, P3d.y, P3d.z, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 2, VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3,
								VideoInfoI.VideoInfo[RefFrameID].distortion, VideoInfoI.VideoInfo[RefFrameID].distortion + 3, VideoInfoI.VideoInfo[RefFrameID].distortion + 2, VideoInfoI.VideoInfo[RefFrameID].distortion + 5,
								VideoInfoI.VideoInfo[frameID].rt);
						}

						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].intrinsic[2]);
						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].distortion[2]);
						problem.SetParameterBlockConstant(&VideoInfoI.VideoInfo[RefFrameID].distortion[5]);

						if (fixedIntrinisc)
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic),
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic + 3);
						if (fixDistortion)
						{
							if (VideoInfoI.VideoInfo[RefFrameID].LensModel == RADIAL_TANGENTIAL_PRISM)
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion),
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion + 3);
							else
								problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
						}
					}
					else
					{
						if (!fixed3D)
						{
							ceres::CostFunction* cost_function = PinholeReprojectionError::Create(uv.x, uv.y, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, &P3D[3 * pid]);
							problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
						}
						else
						{
							ceres::CostFunction* cost_function = PinholeDistortionReprojectionError4::Create(VideoInfoI.VideoInfo[RefFrameID].intrinsic, uv.x, uv.y, P3d.x, P3d.y, P3d.z, scale);
							problem.AddResidualBlock(cost_function, loss_function, VideoInfoI.VideoInfo[frameID].rt);
						}
					}

					validPtsCount++;
					ReProjectionErrorX.push_back(abs(residuals[0]));
					ReProjectionErrorY.push_back(abs(residuals[1]));
				}
			}
		}

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX);
		double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY);
		double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
		{
			printf("\n %d bad points (%d good points) detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
			printf("Reprojection error before BA \nMin: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		}

		ceres::Solver::Options options;
		options.num_threads = omp_get_max_threads();
		options.num_linear_solver_threads = omp_get_max_threads();
		options.max_num_iterations = 30;
		options.linear_solver_type = ceres::SPARSE_SCHUR;
		options.minimizer_progress_to_stdout = true;
		options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		std::cout << "Iterration " << iteration << ": " << summary.BriefReport() << endl << endl;
	}

	//Store refined parameters
	//printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
		GetRTFromrt(&VideoInfoI.VideoInfo[frameID], 1);
		AssembleP(VideoInfoI.VideoInfo[frameID].K, VideoInfoI.VideoInfo[frameID].R, VideoInfoI.VideoInfo[frameID].T, VideoInfoI.VideoInfo[frameID].P);
	}

	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	int count = -1;
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			int frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			if (distortionCorrected)
				PinholeReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
			else
			{
				if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
					PinholeDistortionReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
				else
					FOVReprojectionDistortionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, VideoInfoI.VideoInfo[frameID].rt, uv, P3d, residuals);
			}

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));
		}
	}

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/gIntrinsic_%d.txt", Path, selectedCamID); FILE *fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	sprintf(Fname, "%s/gCamPose_%d.txt", Path, selectedCamID); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		//Center = -iR*T 
		GetRCGL(VideoInfoI.VideoInfo[frameID]);

		fprintf(fp, "%d ", frameID);
		for (int jj = 0; jj < 16; jj++)
			fprintf(fp, "%.16f ", VideoInfoI.VideoInfo[frameID].Rgl[jj]);
		for (int jj = 0; jj < 3; jj++)
			fprintf(fp, "%.16f ", VideoInfoI.VideoInfo[frameID].camCenter[jj]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	return 0;
}
int VideoPose_RS_Cayley_BA(char *Path, int selectedCamID, int startF, int stopF, int fixIntrinsic, int fixDistortion, int fixPose, int fixfirstCamPose, int fix3D, int distortionCorrected, bool doubleRefinement, double threshold)
{
	char Fname[200];
	int nframes = stopF - startF + 1;
	printf("Wroking on camera %d:\n", selectedCamID);
	Corpus CorpusData;
	//Read intrinsic for selected CamID;
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCamID, startF, stopF) == 1)
		return 1;
	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].ShutterModel = 1;

	vector<int> Refinement_SharedIntrinsic;
	for (int ii = 0; ii <= stopF; ii++)
		Refinement_SharedIntrinsic.push_back(0);

	int dummy, nPoints, useColor;
	sprintf(Fname, "%s/Corpus/Corpus_3D.txt", Path); FILE *fp = fopen(Fname, "r");
	if (fp == NULL)
	{
		printf("Cannot load %s\n", Fname);
		return 1;
	}
	fscanf(fp, "%d %d %d", &dummy, &nPoints, &useColor);
	CorpusData.nCameras = nframes;
	CorpusData.n3dPoints = nPoints;


	Point3d xyz;	Point3i rgb;
	CorpusData.xyz.reserve(nPoints);
	if (useColor)
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf %d %d %d", &xyz.x, &xyz.y, &xyz.z, &rgb.x, &rgb.y, &rgb.z);
			CorpusData.xyz.push_back(xyz);
			CorpusData.rgb.push_back(rgb);
		}
	}
	else
	{
		CorpusData.rgb.reserve(nPoints);
		for (int jj = 0; jj < nPoints; jj++)
		{
			fscanf(fp, "%lf %lf %lf ", &xyz.x, &xyz.y, &xyz.z);
			CorpusData.xyz.push_back(xyz);
		}
	}

	//Generate corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D
	vector<int> selectedCamID3D;
	vector<Point2d> uv3D;
	vector<double> scale3D;
	for (int ii = 0; ii < nPoints; ii++)
	{
		CorpusData.viewIdAll3D.push_back(selectedCamID3D); CorpusData.viewIdAll3D.back().reserve(nframes);
		CorpusData.uvAll3D.push_back(uv3D); CorpusData.uvAll3D.back().reserve(nframes);
		CorpusData.scaleAll3D.push_back(scale3D); CorpusData.scaleAll3D.back().reserve(nframes);
	}

	int pid; double s;
	Point2f uv;
	//int goodfile = 0;
	for (int fid = startF; fid <= stopF; fid++)
	{
		sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCamID, fid); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			continue;
		}
		/*int count = 0;
		while (fscanf(fp, "%d %lf %lf %lf %f %f %lf", &pid, &xyz.x, &xyz.y, &xyz.z, &uv.x, &uv.y, &s) != EOF)
			count++;
		fclose(fp);

		if (count < 4000)
			continue;*/

		//fp = fopen(Fname, "r");
		while (fscanf(fp, "%d %lf %lf %lf %f %f %lf", &pid, &xyz.x, &xyz.y, &xyz.z, &uv.x, &uv.y, &s) != EOF)
		{
			CorpusData.viewIdAll3D[pid].push_back(fid);
			CorpusData.uvAll3D[pid].push_back(uv);
			CorpusData.scaleAll3D[pid].push_back(s);
		}
		fclose(fp);
		//goodfile++;
	}
	//printf("# good frames: %d\n", goodfile);

	if (distortionCorrected == 1 && !fixIntrinsic && !fixDistortion)
	{
		for (int jj = 0; jj < CorpusData.n3dPoints; jj++)
		{
			for (int ii = 0; ii < (int)CorpusData.uvAll3D[jj].size(); ii++)
			{
				int selectedCamID = CorpusData.viewIdAll3D[jj][ii];
				LensDistortionPoint(&CorpusData.uvAll3D[jj][ii], VideoInfoI.VideoInfo[selectedCamID].K, VideoInfoI.VideoInfo[selectedCamID].distortion);
			}
		}
		distortionCorrected = 0;
	}

	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].threshold = !doubleRefinement ? threshold : 100.0; //make sure that most points are inliers
	CayleyRollingShutterBundleAdjustment(Path, VideoInfoI.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
		Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, 1, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii <= stopF; ii++)
			VideoInfoI.VideoInfo[ii].threshold = threshold;
		CayleyRollingShutterBundleAdjustment(Path, VideoInfoI.VideoInfo, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D,
			Refinement_SharedIntrinsic, nframes, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, 0, fix3D, distortionCorrected, 1, false, false);
	}
	sprintf(Fname, "%s/Good.txt", Path), remove(Fname);

	//write video data
	printf("Writing refined poses ....");
	vector<int> computedTime;
	for (int ii = startF; ii <= stopF; ii++)
		if (VideoInfoI.VideoInfo[ii].valid)
			computedTime.push_back(ii);
	sprintf(Fname, "%s/Intrinsic_RSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraIntrinsic(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);
	sprintf(Fname, "%s/CamPose_RSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraPoses(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);

	for (int ii = 0; ii <= stopF; ii++)
		VideoInfoI.VideoInfo[ii].ShutterModel = 0;
	sprintf(Fname, "%s/CamPose_sRSCayley_%d.txt", Path, selectedCamID);	SaveVideoCameraPoses(Fname, VideoInfoI.VideoInfo, computedTime, selectedCamID, 0);

	//ReSaveBundleAdjustedNVMResults(Fname, CorpusData);
	printf("Done!\n");

	return 0;
}

void RollingShutterSplineProjection(double *intrinsic, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d &predicted, Point3d &point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], tr[6], np[3], p[3] = { point.x, point.y, point.z };

	double *Bi = new double[nCtrl];

	//Get initial estimate of the projected location
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc<KnotLoc[SplineOrder - 1])
		subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
	else if (subframeLoc > KnotLoc[nCtrl])
		subframeLoc = KnotLoc[nCtrl] - 0.5;

	BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

	int nlocalControls = SplineOrder + 2;
	for (int jj = 0; jj < 6; jj++)
	{
		/*for (int ii = 0; ii < nCtrl; ii++)
		{
		double bi = Bi[ii];
		if (bi < 1.0e-6)
		continue;
		int found = 0, foundActingID = 0;
		for (int kk = 0; kk < 6; kk++)
		if (ActingID[kk] == ii)
		{
		foundActingID = kk;
		found++;
		break;
		}
		if (found == 0)
		printf("CP problem @Frame %d \n", frameID);

		twist[jj] += ActingControlPose[jj + 6 * foundActingID] * bi;
		}*/
		if (se3)
		{
			twist[jj] = 0.0;
			for (int ii = 0; ii < nlocalControls; ii++)
				twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
		}
		else
		{
			tr[jj] = 0;
			for (int ii = 0; ii < nlocalControls; ii++)
				tr[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
		}
	}

	if (se3)
		convertTwistToRT(twist, R, T);
	else
	{
		convertRvecToRmat(tr + 3, R);
		for (int ii = 0; ii < 3; ii++)
			T[ii] = tr[ii];
	}

	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	int iter, iterMax = 20;
	double dif;
	for (iter = 0; iter < iterMax; iter++)
	{
		subframeLoc = v / height + frameID;
		if (subframeLoc<KnotLoc[SplineOrder - 1])
			subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
		else if (subframeLoc > KnotLoc[nCtrl])
			subframeLoc = KnotLoc[nCtrl] - 0.5;

		BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

		for (int jj = 0; jj < 6; jj++)
		{
			if (se3)
			{
				twist[jj] = 0.0;
				for (int ii = 0; ii < nlocalControls; ii++)
					twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
			}
			else
			{
				tr[jj] = 0;
				for (int ii = 0; ii < nlocalControls; ii++)
					tr[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
			}
		}

		if (se3)
			convertTwistToRT(twist, R, T);
		else
		{
			convertRvecToRmat(tr + 3, R);
			for (int ii = 0; ii < 3; ii++)
				T[ii] = tr[ii];
		}

		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		dif = abs((ycn - ycn_) / ycn_);
		if (dif < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	//if (v<-1.0 || v>height)
	//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];
	predicted.x = u, predicted.y = v;

	//if (iter > iterMax - 1 && dif > 1.0e-6)
	//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

	delete[]Bi;

	return;
}
void RollingShutterSplineReprojectionDebug(double *intrinsic, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d &observed, Point3d &point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterSplineProjection(intrinsic, ActingID, ActingControlPose, KnotLoc, nBreak, nCtrl, SplineOrder, se3, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterSplineReprojectionError {
	RollingShutterSplineReprojectionError(double *IntrinsicIn, double *KnotLocIn, int nBreak, int nCtrl, int SplineOrder, bool se3, int *ActingIDIn, Point2d observed2D, double scale, int pid, int frameID, int width, int height) :
		nBreak(nBreak), nCtrl(nCtrl), SplineOrder(SplineOrder), se3(se3), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		KnotLoc = KnotLocIn;
		Intrinsic = IntrinsicIn;
		for (int ii = 0; ii < SplineOrder + 2; ii++)
			ActingID[ii] = ActingIDIn[ii];
	}

	template <typename T>	bool operator()(const double* const ControlPoses0, const double* const ControlPoses1, const double* const ControlPoses2, const double* const ControlPoses3,
		const double* const ControlPoses4, const double* const ControlPoses5, const double* const point, T* residuals) const
	{
		Point3d p3d(point[0], point[1], point[2]);

		double control[36];
		for (int ii = 0; ii < 6; ii++)
			control[ii] = ControlPoses0[ii], control[ii + 6] = ControlPoses1[ii], control[ii + 12] = ControlPoses2[ii],
			control[ii + 18] = ControlPoses3[ii], control[ii + 24] = ControlPoses4[ii], control[ii + 30] = ControlPoses5[ii];

		Point2d predicted2D;
		int *aID = new int[6];
		for (int ii = 0; ii < 6; ii++)
			aID[ii] = ActingID[ii];

		RollingShutterSplineProjection(Intrinsic, aID, control, KnotLoc, nBreak, nCtrl, SplineOrder, se3, predicted2D, p3d, frameID, width, height);

		residuals[0] = (predicted2D.x - observed2D.x) / scale, residuals[1] = (predicted2D.y - observed2D.y) / scale;

		delete[]aID;
		return true;
	}
	static ceres::CostFunction* CreateNumerDiff(double *Intrinsic, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, bool se3, Point2d observed2D, int *ActingID, double scale, int pid, int frameID, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<RollingShutterSplineReprojectionError, ceres::CENTRAL, 2, 6, 6, 6, 6, 6, 6, 3>
			(new RollingShutterSplineReprojectionError(Intrinsic, KnotLoc, nBreak, nCtrl, SplineOrder, se3, ActingID, observed2D, scale, pid, frameID, width, height)));
	}

	bool se3;
	int pid, nBreak, nCtrl, SplineOrder;
	double scale, *Intrinsic, *KnotLoc;
	int width, height, frameID, ActingID[6];
	Point2d observed2D;
};
void RollingShutterDistortionSplineProjection(double *intrinsic, double *distortion, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d &predicted, Point3d point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], np[3], p[3] = { point.x, point.y, point.z };
	double *Bi = new double[nCtrl];

	//Get initial estimate of the projected location
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc<KnotLoc[SplineOrder - 1])
		subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
	else if (subframeLoc > KnotLoc[nCtrl])
		subframeLoc = KnotLoc[nCtrl] - 0.5;

	BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

	int nlocalControls = SplineOrder + 2;
	for (int jj = 0; jj < 6; jj++)
	{
		twist[jj] = 0.0;
		for (int ii = 0; ii < nlocalControls; ii++)
			twist[jj] += ActingControlPose[jj + nlocalControls * ii] * Bi[ActingID[ii]];
	}

	convertTwistToRT(twist, R, T);
	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	for (int iter = 0; iter < 40; iter++)
	{
		subframeLoc = 0.5 + frameID;
		if (subframeLoc<KnotLoc[SplineOrder - 1])
			subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
		else if (subframeLoc > KnotLoc[nCtrl])
			subframeLoc = KnotLoc[nCtrl] - 0.5;

		BSplineGetBasis(subframeLoc, Bi, KnotLoc, nBreak, nCtrl, SplineOrder);

		for (int jj = 0; jj < 6; jj++)
		{
			twist[jj] = 0.0;
			for (int ii = 0; ii < nlocalControls; ii++)
				twist[jj] += ActingControlPose[jj + nlocalControls* ii] * Bi[ActingID[ii]];
		}

		convertTwistToRT(twist, R, T);
		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		if (abs((ycn - ycn_) / ycn_) < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];

	predicted.x = u, predicted.y = v;
	LensDistortionPoint2(&predicted, intrinsic, distortion);

	delete[]Bi;

	return;
}
void RollingShutterDistortionSplineReprojectionDebug(double *intrinsic, double *distortion, int *ActingID, double *ActingControlPose, double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d observed, Point3d point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterDistortionSplineProjection(intrinsic, distortion, ActingID, ActingControlPose, KnotLoc, nBreak, nCtrl, SplineOrder, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterDistortionSplineReprojectionError {
	RollingShutterDistortionSplineReprojectionError(double *KnotLocIn, int nBreak, int nCtrl, int SplineOrder, int *ActingIDIn, Point2d observed2D, double scale, int frameID, int width, int height) :
		nBreak(nBreak), nCtrl(nCtrl), SplineOrder(SplineOrder), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		KnotLoc = KnotLocIn;
		for (int ii = 0; ii < SplineOrder + 2; ii++)
			ActingID[ii] = ActingIDIn[ii];
	}

	template <typename T>	bool operator()(const double* const intrinsic, const double* const distortion,
		const double* const ControlPoses0, const double* const ControlPoses1, const double* const ControlPoses2, const double* const ControlPoses3, const double* const ControlPoses4, const double* const ControlPoses5,
		const double* const point, T* residuals) const
	{
		double intrinsic_[5] = { intrinsic[0], intrinsic[1], intrinsic[2], intrinsic[3], intrinsic[4] };
		double distortion_[7] = { distortion[0], distortion[1], distortion[2], distortion[3], distortion[4], distortion[5], distortion[6] };
		Point3d p3d(point[0], point[1], point[2]);

		double control[36];
		for (int ii = 0; ii < 6; ii++)
			control[ii] = ControlPoses0[ii], control[ii + 6] = ControlPoses1[ii], control[ii + 12] = ControlPoses2[ii],
			control[ii + 18] = ControlPoses3[ii], control[ii + 24] = ControlPoses4[ii], control[ii + 30] = ControlPoses5[ii];

		int *aID = new int[6];
		for (int ii = 0; ii < 6; ii++)
			aID[ii] = ActingID[ii];

		Point2d predicted2D;
		RollingShutterDistortionSplineProjection(intrinsic_, distortion_, aID, control, KnotLoc, nBreak, nCtrl, SplineOrder, predicted2D, p3d, frameID, width, height);

		residuals[0] = (predicted2D.x - observed2D.x) / scale, residuals[1] = (predicted2D.y - observed2D.y) / scale;

		return true;
	}
	static ceres::CostFunction* CreateNumerDiff(double *KnotLoc, int nBreak, int nCtrl, int SplineOrder, Point2d observed2D, int *ActingID, double scale, int frameID, int width, int height)
	{
		return (new ceres::NumericDiffCostFunction<RollingShutterDistortionSplineReprojectionError, ceres::CENTRAL, 2, 5, 7, 6, 6, 6, 6, 6, 6, 3>
			(new RollingShutterDistortionSplineReprojectionError(KnotLoc, nBreak, nCtrl, SplineOrder, ActingID, observed2D, scale, frameID, width, height)));
	}

	int pid, nBreak, nCtrl, SplineOrder;
	double scale, *KnotLoc;
	int width, height, frameID, ActingID[6];
	Point2d observed2D;
};
int VideoSplineRSBA(char *Path, int startFrame, int stopFrame, int selectedCams, int distortionCorrected, int fixedIntrinisc, int fixDistortion, double threshold, int controlStep, int SplineOrder, bool se3, bool debug)
{
	//SplineOrder:  4 (cubic spline)
	if (se3)
		printf("Using se(3) parameterization\n");
	else
		printf("Using so(3) parameterization\n");

	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCams, startFrame, stopFrame) == 1)
		return 1;

	Point2d uv; Point3d P3d;  double scale;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = true, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCams, frameID);	FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}

	//Set up Bspline: Control points are placed every controlStep frame
	int nCtrls = (stopFrame - startFrame) / controlStep + 1, nbreaks = nCtrls - SplineOrder + 2, extraNControls = 2;
	int ActingID[6];
	double breakStep = 1.0*(stopFrame - startFrame) / (nbreaks - 1);

	//Figure out which frame is not available and take value from its neighbor
	int *ControlLoc = new int[nCtrls];
	for (int ii = 0; ii < nCtrls; ii++)
	{
		int fid = controlStep*ii + startFrame;
		if (!VideoInfoI.VideoInfo[fid].valid)
		{
			int searchRange = 1;
			while (true)
			{
				for (int jj = -searchRange; jj <= searchRange; jj++)
				{
					if (jj == 0 || abs(jj) != searchRange)
						continue;
					if (fid + searchRange<startFrame || fid + searchRange>stopFrame || !VideoInfoI.VideoInfo[fid + searchRange].valid)
						continue;
					ControlLoc[ii] = fid + searchRange;
				}
			}
		}
		else
			ControlLoc[ii] = fid;
	}

	//Set open-uniform break points
	double *BreakLoc = new double[nbreaks];
	for (int ii = 0; ii < nbreaks; ii++)
		BreakLoc[ii] = breakStep*ii + startFrame;

	double *KnotLoc = new double[nCtrls + SplineOrder];
	BSplineGetKnots(KnotLoc, BreakLoc, nbreaks, nCtrls, SplineOrder);

	//Init control pose in se3
	double twist[6], tr[6];
	double *ControlPose = new double[6 * nCtrls];//stack of groups of 6 numbers 
	for (int ii = 0; ii < nCtrls; ii++)
	{
		if (se3)
		{
			convertRTToTwist(VideoInfoI.VideoInfo[ControlLoc[ii]].R, VideoInfoI.VideoInfo[ControlLoc[ii]].T, twist);
			for (int jj = 0; jj < 6; jj++)
				ControlPose[jj + 6 * ii] = twist[jj];
		}
		else
		{
			convertRmatToRvec(VideoInfoI.VideoInfo[ControlLoc[ii]].R, tr + 3);
			for (int jj = 0; jj < 3; jj++)
				tr[jj] = VideoInfoI.VideoInfo[ControlLoc[ii]].T[jj];
			for (int jj = 0; jj < 6; jj++)
				ControlPose[jj + 6 * ii] = tr[jj];
		}
	}

	//Start solver
	bool setReferenceflag = false;
	int frameID, RefFrameID, nBadCounts = 0, validPtsCount = 0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0, residuals[2];

	ceres::Problem problem;
	//ceres::LossFunction* loss_function = new HuberLoss(3.0*threshold);

	FILE *fp = 0;
	if (debug)
		sprintf(Fname, "%s/reprojectionB.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			//Determine its acting controlPts
			double subframeLoc = 0.5 + frameID;
			if (subframeLoc<KnotLoc[SplineOrder - 1])
				subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
			else if (subframeLoc > KnotLoc[nCtrls])
				subframeLoc = KnotLoc[nCtrls] - 0.5;
			BSplineFindActiveCtrl(ActingID, subframeLoc, KnotLoc, nbreaks, nCtrls, SplineOrder, extraNControls);

			if (!setReferenceflag)
			{
				if (distortionCorrected)
					RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			}
			else
				if (distortionCorrected)
					RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			if (abs(residuals[0]) > 10.0*threshold || abs(residuals[1]) > 10.0*threshold)
			{
				Good.push_back(false);
				if (abs(residuals[0]) > maxOutlierX)
					maxOutlierX = residuals[0];
				if (abs(residuals[1]) > maxOutlierY)
					maxOutlierY = residuals[1];
				nBadCounts++;
				continue;
			}
			else
			{
				Good.push_back(true);
				if (!setReferenceflag)
					RefFrameID = frameID, setReferenceflag = true;

				if (distortionCorrected == 1)
				{
					ceres::CostFunction* cost_function = RollingShutterSplineReprojectionError::CreateNumerDiff(VideoInfoI.VideoInfo[RefFrameID].intrinsic, KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
						uv, ActingID, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					problem.AddResidualBlock(cost_function, NULL, &ControlPose[6 * ActingID[0]], &ControlPose[6 * ActingID[1]], &ControlPose[6 * ActingID[2]],
						&ControlPose[6 * ActingID[3]], &ControlPose[6 * ActingID[4]], &ControlPose[6 * ActingID[5]], &P3D[3 * pid]);
				}
				else
				{
					ceres::CostFunction* cost_function = RollingShutterDistortionSplineReprojectionError::CreateNumerDiff(KnotLoc, nbreaks, nCtrls, SplineOrder, uv, ActingID, scale, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					problem.AddResidualBlock(cost_function, NULL, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion,
						&ControlPose[6 * ActingID[0]], &ControlPose[6 * ActingID[1]], &ControlPose[6 * ActingID[2]], &ControlPose[6 * ActingID[3]], &ControlPose[6 * ActingID[4]], &ControlPose[6 * ActingID[5]], &P3D[3 * pid]);

					if (fixedIntrinisc)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
				}

				validPtsCount++;
				ReProjectionErrorX.push_back(abs(residuals[0]));
				ReProjectionErrorY.push_back(abs(residuals[1]));

				if (debug)
					fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
			}
		}
	}
	if (debug)
		fclose(fp);

	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("\n %d bad points (%d good points) detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	//printf("...run \n");
	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 30;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
	}

	int count = -1;
	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	if (debug)
		sprintf(Fname, "%s/reprojectionA.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			//Determine its acting controlPts
			double subframeLoc = 0.5 + frameID;
			if (subframeLoc<KnotLoc[SplineOrder - 1])
				subframeLoc = KnotLoc[SplineOrder - 1] + 0.5;
			else if (subframeLoc > KnotLoc[nCtrls])
				subframeLoc = KnotLoc[nCtrls] - 0.5;
			BSplineFindActiveCtrl(ActingID, subframeLoc, KnotLoc, nbreaks, nCtrls, SplineOrder, extraNControls);

			if (distortionCorrected)
				RollingShutterSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder, se3,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			else
				RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, ControlPose + ActingID[0] * (SplineOrder + extraNControls), KnotLoc, nbreaks, nCtrls, SplineOrder,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			if (debug)
				fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/IntrinsicS_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	if (se3)
		sprintf(Fname, "%s/CamPoseS_se3_%d.txt", Path, selectedCams);
	else
		sprintf(Fname, "%s/CamPoseS_so3_%d.txt", Path, selectedCams);
	fp = fopen(Fname, "w+");
	fprintf(fp, "%d %d %d %d\n", nCtrls, nbreaks, SplineOrder, se3 ? 1 : 0);
	for (int ii = 0; ii < nCtrls; ii++)
	{
		fprintf(fp, "%d ", ControlLoc[ii]);
		for (int jj = 0; jj < 6; jj++)
			fprintf(fp, "%.8e ", ControlPose[ii * 6 + jj]);
		fprintf(fp, "\n");
	}
	for (int ii = 0; ii < nbreaks; ii++)
		fprintf(fp, "%.16e\n", BreakLoc[ii]);
	fclose(fp);

	delete[]ControlLoc, delete[]BreakLoc, delete[]KnotLoc, delete[]ControlPose;

	return 0;
}

void RollingShutterDCTProjection(double *intrinsic, double *Coeffs0, double *Coeffs1, double *Coeffs2, double *Coeffs3, double *Coeffs4, double *Coeffs5, int nCoeffs, Point2d &predicted, Point3d &point, int frameID, int width, int height)
{
	double R[9], T[3], twist[6], np[3], p[3] = { point.x, point.y, point.z };
	double *iB = new double[nCoeffs];

	//Get initial estimate of the projected location: must be in 0->n-1 range
	double subframeLoc = 0.5 + frameID;
	if (subframeLoc > nCoeffs - 1)
		subframeLoc = nCoeffs - 1;

	//Get twist = iB*C;
	GenerateiDCTBasis(iB, nCoeffs, subframeLoc);

	for (int jj = 0; jj < 6; jj++)
		twist[jj] = 0.0;
	for (int ii = 0; ii < nCoeffs; ii++)
	{
		twist[0] += Coeffs0[ii] * iB[ii];
		twist[1] += Coeffs1[ii] * iB[ii];
		twist[2] += Coeffs2[ii] * iB[ii];
		twist[3] += Coeffs3[ii] * iB[ii];
		twist[4] += Coeffs4[ii] * iB[ii];
		twist[5] += Coeffs5[ii] * iB[ii];
	}
	convertTwistToRT(twist, R, T);

	//Initiate projection solver
	np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
	np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];
	double ycn = np[1] / np[2], ycn_ = ycn;
	double v = intrinsic[1] * ycn + intrinsic[4]; //to get time info

	//Iteratively solve for ycn = P(ycn)*X
	int iter, iterMax = 20;
	double dif;
	for (iter = 0; iter < iterMax; iter++)
	{
		subframeLoc = v / height + frameID;
		if (subframeLoc > nCoeffs)
			subframeLoc = nCoeffs;

		GenerateiDCTBasis(iB, nCoeffs, subframeLoc);

		for (int jj = 0; jj < 6; jj++)
			twist[jj] = 0.0;
		for (int ii = 0; ii < nCoeffs; ii++)
		{
			twist[0] += Coeffs0[ii] * iB[ii];
			twist[1] += Coeffs1[ii] * iB[ii];
			twist[2] += Coeffs2[ii] * iB[ii];
			twist[3] += Coeffs3[ii] * iB[ii];
			twist[4] += Coeffs4[ii] * iB[ii];
			twist[5] += Coeffs5[ii] * iB[ii];
		}
		convertTwistToRT(twist, R, T);

		np[1] = R[3] * p[0] + R[4] * p[1] + R[5] * p[2] + T[1];
		np[2] = R[6] * p[0] + R[7] * p[1] + R[8] * p[2] + T[2];

		ycn = np[1] / np[2];
		v = intrinsic[1] * ycn + intrinsic[4];
		dif = abs((ycn - ycn_) / ycn_);
		if (dif < 1.0e-9)
			break;
		ycn_ = ycn;
	}

	//if (v<-1.0 || v>height)
	//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

	np[0] = R[0] * p[0] + R[1] * p[1] + R[2] * p[2] + T[0];
	double xcn = np[0] / np[2], u = intrinsic[0] * xcn + intrinsic[2] * ycn + intrinsic[3];
	predicted.x = u, predicted.y = v;

	//if (iter > iterMax - 1 && dif > 1.0e-6)
	//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

	delete[]iB;

	return;
}
void RollingShutterDCTReprojectionDebug(double *intrinsic, double *Coeffs0, double *Coeffs1, double *Coeffs2, double *Coeffs3, double *Coeffs4, double *Coeffs5, int nCoeffs, Point2d &observed, Point3d &point, int frameID, int width, int height, double *residuals)
{
	Point2d predicted;
	RollingShutterDCTProjection(intrinsic, Coeffs0, Coeffs1, Coeffs2, Coeffs3, Coeffs4, Coeffs5, nCoeffs, predicted, point, frameID, width, height);
	residuals[0] = predicted.x - observed.x, residuals[1] = predicted.y - observed.y;

	return;
}
struct RollingShutterDCTReprojectionError {
	RollingShutterDCTReprojectionError(double *IntrinsicIn, double *WeightIn, int nCoeffs, Point2d observed2D, double scale, int pid, int frameID, int width, int height) :
		nCoeffs(nCoeffs), observed2D(observed2D), scale(scale), pid(pid), frameID(frameID), width(width), height(height)
	{
		Intrinsic = IntrinsicIn;
		Weight = WeightIn;
	}

	template <typename T>    bool operator()(T const* const* Parameters, T* residuals)     const
	{
		T R[9], Trans[3], np[3];
		T *iB = new T[nCoeffs];

		//Get initial estimate of the projected location: must be in 0->n-1 range
		T subframeLoc = (T)(0.5 + frameID);
		if (subframeLoc > (T)(nCoeffs - 1))
			subframeLoc = (T)(nCoeffs - 1);

		//GenerateiDCTBasis(iB, nCoeffs, subframeLoc); 	//Get twist = iB*C;
		iB[0] = (T)(sqrt(1.0 / nCoeffs));
		double s = sqrt(2.0 / nCoeffs);
		for (int kk = 1; kk < nCoeffs; kk++)
			iB[kk] = (T)(s)*cos((T)(Pi*kk) *(subframeLoc + (T)0.5) / (T)nCoeffs);

		T twist[6];
		for (int jj = 0; jj < 6; jj++)
		{
			twist[jj] = (T)0.0;
			for (int ii = 0; ii < nCoeffs; ii++)
				twist[jj] += Parameters[jj + 1][ii] * (T)iB[ii];
		}

		//convertTwistToRT(twist, R, Trans);
		T t[3] = { twist[0], twist[1], twist[2] }, w[3] = { twist[3], twist[4], twist[5] };
		T theta = sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]), theta2 = theta* theta;
		T wx2[9], wx[9] = { (T)0.0, -w[2], w[1], w[2], (T)0.0, -w[0], -w[1], w[0], (T)0.0 };
		//mat_mul(wx, wx, wx2, 3, 3, 3);
		for (int ii = 0; ii < 3; ii++)
		{
			for (int jj = 0; jj < 3; jj++)
			{
				wx2[ii * 3 + jj] = (T)0.0;
				for (int kk = 0; kk < 3; kk++)
					wx2[ii * 3 + jj] += wx[ii * 3 + kk] * wx[kk * 3 + jj];
			}
		}

		T V[9] = { (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0 };
		R[0] = (T)1.0, R[1] = (T)0.0, R[2] = (T)0.0, R[3] = (T)0.0, R[4] = (T)1.0, R[5] = (T)0.0, R[6] = (T)0.0, R[7] = (T)0.0, R[8] = (T)1.0;
		if (theta < (T)1.0e-9)
			Trans[0] = t[0], Trans[1] = t[1], Trans[2] = t[2]; //Rotation is idenity
		else
		{
			T A = sin(theta) / theta, B = ((T)1.0 - cos(theta)) / theta2, C = ((T)1.0 - A) / theta2;
			for (int ii = 0; ii < 9; ii++)
			{
				R[ii] += A*wx[ii] + B*wx2[ii];
				V[ii] += B*wx[ii] + C*wx2[ii];
			}

			//mat_mul(V, t, Trans, 3, 3, 1);
			for (int ii = 0; ii < 3; ii++)
			{
				Trans[ii] = (T)0.0;
				for (int kk = 0; kk < 3; kk++)
					Trans[ii] += V[ii * 3 + kk] * t[kk];
			}
		}

		//Initiate projection solver
		np[1] = R[3] * Parameters[0][0] + R[4] * Parameters[0][1] + R[5] * Parameters[0][2] + Trans[1];
		np[2] = R[6] * Parameters[0][0] + R[7] * Parameters[0][1] + R[8] * Parameters[0][2] + Trans[2];
		T ycn = np[1] / np[2], ycn_ = ycn;
		T v = (T)Intrinsic[1] * ycn + (T)Intrinsic[4]; //to get time info

		//Iteratively solve for ycn = P(ycn)*X
		T dif;
		int iter, iterMax = 20;
		for (iter = 0; iter < iterMax; iter++)
		{
			subframeLoc = (T)(0.5 + frameID);
			if (subframeLoc >(T)(nCoeffs - 1))
				subframeLoc = (T)(nCoeffs - 1);

			//GenerateiDCTBasis(iB, nCoeffs, subframeLoc); 	//Get twist = iB*C;
			iB[0] = (T)(sqrt(1.0 / nCoeffs));
			double s = sqrt(2.0 / nCoeffs);
			for (int kk = 1; kk < nCoeffs; kk++)
				iB[kk] = (T)(s)*cos((T)(Pi*kk) *(subframeLoc + (T)0.5) / (T)nCoeffs);

			T twist[6];
			for (int jj = 0; jj < 6; jj++)
			{
				twist[jj] = (T)0.0;
				for (int ii = 0; ii < nCoeffs; ii++)
					twist[jj] += Parameters[jj + 1][ii] * (T)iB[ii];
			}

			//convertTwistToRT(twist, R, Trans);
			T t[3] = { twist[0], twist[1], twist[2] }, w[3] = { twist[3], twist[4], twist[5] };
			T theta = sqrt(w[0] * w[0] + w[1] * w[1] + w[2] * w[2]), theta2 = theta* theta;
			T wx2[9], wx[9] = { (T)0.0, -w[2], w[1], w[2], (T)0.0, -w[0], -w[1], w[0], (T)0.0 };
			//mat_mul(wx, wx, wx2, 3, 3, 3);
			for (int ii = 0; ii < 3; ii++)
			{
				for (int jj = 0; jj < 3; jj++)
				{
					wx2[ii * 3 + jj] = (T)0.0;
					for (int kk = 0; kk < 3; kk++)
						wx2[ii * 3 + jj] += wx[ii * 3 + kk] * wx[kk * 3 + jj];
				}
			}

			T V[9] = { (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0, (T)0.0, (T)0.0, (T)0.0, (T)1.0 };
			R[0] = (T)1.0, R[1] = (T)0.0, R[2] = (T)0.0, R[3] = (T)0.0, R[4] = (T)1.0, R[5] = (T)0.0, R[6] = (T)0.0, R[7] = (T)0.0, R[8] = (T)1.0;
			if (theta < (T)1.0e-9)
				Trans[0] = t[0], Trans[1] = t[1], Trans[2] = t[2]; //Rotation is idenity
			else
			{
				T A = sin(theta) / theta, B = ((T)1.0 - cos(theta)) / theta2, C = ((T)1.0 - A) / theta2;
				for (int ii = 0; ii < 9; ii++)
				{
					R[ii] += A*wx[ii] + B*wx2[ii];
					V[ii] += B*wx[ii] + C*wx2[ii];
				}

				//mat_mul(V, t, Trans, 3, 3, 1);
				for (int ii = 0; ii < 3; ii++)
				{
					Trans[ii] = (T)0.0;
					for (int kk = 0; kk < 3; kk++)
						Trans[ii] += V[ii * 3 + kk] * t[kk];
				}
			}

			np[1] = R[3] * Parameters[0][0] + R[4] * Parameters[0][1] + R[5] * Parameters[0][2] + Trans[1];
			np[2] = R[6] * Parameters[0][0] + R[7] * Parameters[0][1] + R[8] * Parameters[0][2] + Trans[2];

			ycn = np[1] / np[2];
			v = Intrinsic[1] * ycn + Intrinsic[4];
			dif = abs((ycn - ycn_) / ycn_);
			if (dif < 1.0e-9)
				break;
			ycn_ = ycn;
		}

		//if (v<-1.0 || v>height)
		//	printf("Projection problem @Frame %d (%.2f)\n", frameID, v);

		np[0] = R[0] * Parameters[0][0] + R[1] * Parameters[0][1] + R[2] * Parameters[0][2] + Trans[0];
		T xcn = np[0] / np[2], u = Intrinsic[0] * xcn + Intrinsic[2] * ycn + Intrinsic[3];

		//if (iter > iterMax - 1 && dif > 1.0e-6)
		//	printf("Frame %d: %.2f %.2f %.9e \n", frameID, u, v, dif);

		residuals[0] = (u - (T)observed2D.x) / (T)scale, residuals[1] = (v - (T)observed2D.y) / (T)scale;

		delete[]iB;
		return true;
	}

	int width, height, pid, frameID, nCoeffs;
	double scale, *Intrinsic, *Weight;
	Point2d observed2D;
};
struct RollingShutterDCTRegularizationError {
	RollingShutterDCTRegularizationError(double *WeightIn, int nCoeffs, double sqrtlamda) : nCoeffs(nCoeffs), sqrtlamda(sqrtlamda)
	{
		Weight = WeightIn;
	}

	template <typename T>    bool operator()(T const* const* Parameters, T* residuals)     const
	{
		for (int jj = 0; jj < 6; jj++)
			for (int ii = 0; ii < nCoeffs; ii++)
				residuals[ii + 6 * nCoeffs] = (T)sqrtlamda*Parameters[jj][ii] * (T)Weight[ii];

		return true;
	}

	int nCoeffs;
	double sqrtlamda, *Weight;
};
int VideoDCTRSBA(char *Path, int startFrame, int stopFrame, int selectedCams, int distortionCorrected, int fixedIntrinisc, int fixDistortion, double threshold, int sampleStep, double lamda, bool debug)
{
	FILE *fp = 0;
	char Fname[200];
	VideoData VideoInfoI;
	if (ReadVideoDataI(Path, VideoInfoI, selectedCams, startFrame, stopFrame) == 1)
		return 1;

	Point2d uv; Point3d P3d;  double scale;
	vector<int>P3dID;
	vector<double>P3D;
	vector< vector<int> >frameIDPer3D;
	vector< vector<double> >scalePer3D;
	vector<vector<Point2d> >P2dPer3D;

	bool ReadCalibInputData = true, SaveCalibInputData = false;
	if (ReadCalibInputData)
	{
		sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
		ifstream fin; fin.open(Fname, ios::binary);
		if (!fin.is_open())
		{
			cout << "Cannot open: " << Fname << endl;
			return false;
		}

		int npts;  fin.read(reinterpret_cast<char *>(&npts), sizeof(int));
		P3D.reserve(npts * 3);

		vector<int> FrameIDs;
		vector<double>Scales;
		vector<Point2d>P2ds;
		for (int ii = 0; ii < npts; ii++)
		{
			int nvisibles; fin.read(reinterpret_cast<char *>(&nvisibles), sizeof(int));
			float x;  fin.read(reinterpret_cast<char *>(&x), sizeof(float)); P3D.push_back(x);
			float y;  fin.read(reinterpret_cast<char *>(&y), sizeof(float)); P3D.push_back(y);
			float z;  fin.read(reinterpret_cast<char *>(&z), sizeof(float)); P3D.push_back(z);

			frameIDPer3D.push_back(FrameIDs); frameIDPer3D[ii].reserve(nvisibles);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(nvisibles);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(nvisibles);
			for (int jj = 0; jj < nvisibles; jj++)
			{
				int fid; fin.read(reinterpret_cast<char *>(&fid), sizeof(int));
				float u, v; fin.read(reinterpret_cast<char *>(&u), sizeof(float)); fin.read(reinterpret_cast<char *>(&v), sizeof(float));
				float s; fin.read(reinterpret_cast<char *>(&s), sizeof(float));

				frameIDPer3D[ii].push_back(fid);
				P2dPer3D[ii].push_back(Point2d(u, v));
				scalePer3D[ii].push_back(s);
			}
		}
		fin.close();
	}
	else
	{
		int pid, ReservedSpace = 20000;
		vector<int> FrameIDs;
		vector<Point2d>P2ds;
		vector<double>Scales;
		P3dID.reserve(ReservedSpace);
		P3D.reserve(ReservedSpace * 3);
		for (int ii = 0; ii < ReservedSpace; ii++)
		{
			frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
			P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
			scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
		}

		for (int frameID = startFrame; frameID <= stopFrame; frameID++)
		{
			sprintf(Fname, "%s/%d/Inliers_3D2D_%d.txt", Path, selectedCams, frameID);	fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot load %s\n", Fname);
				continue;
			}
			while (fscanf(fp, "%d %lf %lf %lf %lf %lf %lf ", &pid, &P3d.x, &P3d.y, &P3d.z, &uv.x, &uv.y, &scale) != EOF)
			{
				int foundLoc = -1, maxLoc = (int)P3dID.size();
				for (foundLoc = 0; foundLoc < maxLoc; foundLoc++)
				{
					if (pid == P3dID[foundLoc])
						break;
				}

				if (foundLoc == maxLoc)
				{
					if (ReservedSpace == maxLoc) //need to add more space
					{
						for (int ii = 0; ii < 1000; ii++)
						{
							frameIDPer3D.push_back(FrameIDs), frameIDPer3D[ii].reserve(stopFrame - startFrame + 1);
							P2dPer3D.push_back(P2ds), P2dPer3D[ii].reserve(stopFrame - startFrame + 1);
							scalePer3D.push_back(Scales); scalePer3D[ii].reserve(stopFrame - startFrame + 1);
						}
						ReservedSpace += 1000;
					}


					frameIDPer3D[maxLoc].push_back(frameID);
					P2dPer3D[maxLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
					P3D.push_back(P3d.x), P3D.push_back(P3d.y); P3D.push_back(P3d.z);
					P3dID.push_back(pid);
				}
				else
				{
					frameIDPer3D[foundLoc].push_back(frameID);
					P2dPer3D[foundLoc].push_back(uv);
					scalePer3D[foundLoc].push_back(scale);
				}
			}
			fclose(fp);
		}

		//Find 3d points with less than nvisible views
		const int nvisibles = 5;
		vector<int> NotOftenVisible;
		for (int ii = 0; ii < (int)P3dID.size(); ii++)
			if (frameIDPer3D[ii].size() < nvisibles)
				NotOftenVisible.push_back(ii);
		printf("(%d/%d) points not visible by at least %d frames\n", NotOftenVisible.size(), P3dID.size(), nvisibles);

		//Clean from bottom to top
		for (int ii = (int)NotOftenVisible.size() - 1; ii >= 0; ii--)
		{
			P3dID.erase(P3dID.begin() + NotOftenVisible[ii]);
			P3D.erase(P3D.begin() + 3 * NotOftenVisible[ii], P3D.begin() + 3 * NotOftenVisible[ii] + 3);
			frameIDPer3D.erase(frameIDPer3D.begin() + NotOftenVisible[ii]);
			P2dPer3D.erase(P2dPer3D.begin() + NotOftenVisible[ii]);
			scalePer3D.erase(scalePer3D.begin() + NotOftenVisible[ii]);
		}

		//Save the Data
		if (SaveCalibInputData)
		{
			sprintf(Fname, "%s/VideoPose_Optim_Input.dat", Path);
			ofstream fout; fout.open(Fname, ios::binary);

			int npts = (int)P3D.size() / 3;
			fout.write(reinterpret_cast<char *>(&npts), sizeof(int));
			for (int ii = 0; ii < npts; ii++)
			{
				int nvisibles = (int)frameIDPer3D[ii].size();
				float X = (float)P3D[3 * ii], Y = (float)P3D[3 * ii + 1], Z = (float)P3D[3 * ii + 2];

				fout.write(reinterpret_cast<char *>(&nvisibles), sizeof(int));
				fout.write(reinterpret_cast<char *>(&X), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Y), sizeof(float));
				fout.write(reinterpret_cast<char *>(&Z), sizeof(float));
				for (int jj = 0; jj < nvisibles; jj++)
				{
					float u = (float)P2dPer3D[ii][jj].x, v = (float)P2dPer3D[ii][jj].y, s = (float)scalePer3D[ii][jj];
					fout.write(reinterpret_cast<char *>(&frameIDPer3D[ii][jj]), sizeof(int));
					fout.write(reinterpret_cast<char *>(&u), sizeof(float));
					fout.write(reinterpret_cast<char *>(&v), sizeof(float));
					fout.write(reinterpret_cast<char *>(&s), sizeof(float));
				}
			}
			fout.close();
		}
	}


	//Set up DCT sampled evenly every sampleStep
	int nCoeffs = (int)((stopFrame - startFrame) / sampleStep + 1);

	double *sqrtWeight = new double[nCoeffs];
	GenerateDCTBasis(nCoeffs, NULL, sqrtWeight);
	for (int ii = 0; ii < nCoeffs; ii++)
		sqrtWeight[ii] = sqrt(-sqrtWeight[ii]); //(1) using precomputed sqrt is better for ceres' squaring residual square nature; (2) weigths are negative, but that does not matter for ctwc optim.

	//Initialize basis coefficients
	int count = 0, nframes = 0;
	for (int ii = startFrame; ii <= stopFrame; ii++)
		if (VideoInfoI.VideoInfo[ii].valid)
			nframes++;

	double twist[6];
	double *FrameTime = new double[nframes], *FramePose = new double[6 * (stopFrame - startFrame + 1)];
	for (int ii = startFrame; ii <= stopFrame; ii++)
	{
		if (VideoInfoI.VideoInfo[ii].valid)
		{
			convertRTToTwist(VideoInfoI.VideoInfo[ii].R, VideoInfoI.VideoInfo[ii].T, twist);
			for (int jj = 0; jj < 6; jj++)
				FramePose[ii + jj * nframes] = twist[jj];

			FrameTime[count - startFrame] = 1.0*(ii - startFrame) / (stopFrame - startFrame)*(nCoeffs - 1);//Normalize to [0, n-1] range
			count++;
		}
	}

	double *iBi = new double[nCoeffs], *iBAll = new double[nframes*nCoeffs];
	for (int ii = 0; ii < nframes; ii++)
		GenerateiDCTBasis(iBAll + ii*nCoeffs, nCoeffs, FrameTime[ii]);


	//Trucated basis solver: iPd(:, 1:activeBasis)*C =  X_d
	double err;
	const int nactiveBasis = 20;
	double *C = new double[6 * nCoeffs];
	Map < Matrix < double, Dynamic, Dynamic, RowMajor > > eiBAll(iBAll, nframes, nCoeffs);
	MatrixXd etiBAll = eiBAll.block(0, 0, nframes, nactiveBasis);
	JacobiSVD<MatrixXd> etiP_svd(etiBAll, ComputeThinU | ComputeThinV);
	for (int ii = 0; ii < 6; ii++)
	{
		Map<VectorXd> eX(FramePose + nframes*ii, nframes);
		Map<VectorXd> eC(C + nCoeffs*ii, nactiveBasis);

		if (eX.norm() < 0.1)// happens for rotation sometimes
		{
			for (int jj = 0; jj < nCoeffs; jj++)
				C[jj + nCoeffs*ii] = 0.0;
			err = (etiBAll*eC - eX).norm();
		}
		else
		{
			eC = etiP_svd.solve(eX);

			for (int jj = nactiveBasis; jj < nCoeffs; jj++)
				C[jj + nCoeffs*ii] = 0.0; //set coeffs outside active basis to 0
			err = (etiBAll*eC - eX).norm() / eX.norm();
		}
	}

	//Start solver
	bool setReferenceflag = false;
	int frameID, RefFrameID, nBadCounts = 0, validPtsCount = 0;
	vector<bool>Good; Good.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve((stopFrame - startFrame + 1) * 5000);
	vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve((stopFrame - startFrame + 1) * 5000);
	double maxOutlierX = 0.0, maxOutlierY = 0.0, pointErrX = 0.0, pointErrY = 0.0, residuals[2];

	ceres::Problem problem;
	//ceres::LossFunction* loss_function = new HuberLoss(3.0*threshold);

	//Image projection cost
	if (debug)
		sprintf(Fname, "%s/reprojectionB.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			if (!setReferenceflag)
			{
				if (distortionCorrected)
					RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, FramePose + ActingID[0] * 6, KnotLoc, nbreaks, nCtrls, SplineOrder,
				//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			}
			else
				if (distortionCorrected)
					RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
					uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
				else
					;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion, ActingID, FramePose + ActingID[0] * 6, KnotLoc, nbreaks, nCtrls, SplineOrder,
			//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			if (abs(residuals[0]) > 10.0*threshold || abs(residuals[1]) > 10.0*threshold)
			{
				Good.push_back(false);
				if (abs(residuals[0]) > maxOutlierX)
					maxOutlierX = residuals[0];
				if (abs(residuals[1]) > maxOutlierY)
					maxOutlierY = residuals[1];
				nBadCounts++;
				continue;
			}
			else
			{
				Good.push_back(true);
				if (!setReferenceflag)
					RefFrameID = frameID, setReferenceflag = true;

				if (distortionCorrected)
				{
					//ceres::DynamicAutoDiffCostFunction<RollingShutterDCTReprojectionError, 4> *cost_function = new ceres::DynamicAutoDiffCostFunction < RollingShutterDCTReprojectionError, 4 >
					//	(new RollingShutterDCTReprojectionError(VideoInfoI.VideoInfo[RefFrameID].intrinsic, sqrtWeight, nCoeffs, uv, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height));

					ceres::DynamicNumericDiffCostFunction<RollingShutterDCTReprojectionError, ceres::CENTRAL> *cost_function = new ceres::DynamicNumericDiffCostFunction<RollingShutterDCTReprojectionError, ceres::CENTRAL>
						(new RollingShutterDCTReprojectionError(VideoInfoI.VideoInfo[RefFrameID].intrinsic, sqrtWeight, nCoeffs, uv, scale, pid, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height));

					vector<double*> parameter_blocks;
					parameter_blocks.push_back(&P3D[3 * pid]);
					cost_function->AddParameterBlock(3);
					for (int ii = 0; ii < 6; ii++)
					{
						parameter_blocks.push_back(C + ii*nCoeffs);
						cost_function->AddParameterBlock(nCoeffs);
					}
					cost_function->SetNumResiduals(2);

					problem.AddResidualBlock(cost_function, NULL, parameter_blocks);

					//problem.SetParameterBlockConstant(&parameter_blocks[npts][0]);
				}
				else
				{
					//ceres::CostFunction* cost_function = RollingShutterDistortionSplineReprojectionError::CreateNumerDiff(KnotLoc, nbreaks, nCtrls, SplineOrder, uv, ActingID, scale, frameID, VideoInfoI.VideoInfo[RefFrameID].width, VideoInfoI.VideoInfo[RefFrameID].height);
					//problem.AddResidualBlock(cost_function, NULL, VideoInfoI.VideoInfo[RefFrameID].intrinsic, VideoInfoI.VideoInfo[RefFrameID].distortion,
					//	&FramePose[6 * ActingID[0]], &FramePose[6 * ActingID[1]], &FramePose[6 * ActingID[2]], &FramePose[6 * ActingID[3]], &FramePose[6 * ActingID[4]], &FramePose[6 * ActingID[5]], &P3D[3 * pid]);

					if (fixedIntrinisc)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].intrinsic);
					if (fixDistortion)
						problem.SetParameterBlockConstant(VideoInfoI.VideoInfo[RefFrameID].distortion);
				}

				validPtsCount++;
				ReProjectionErrorX.push_back(abs(residuals[0]));
				ReProjectionErrorY.push_back(abs(residuals[1]));

				if (debug)
					fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
			}
		}
	}
	if (debug)
		fclose(fp);

	//Regularization cost
	ceres::DynamicAutoDiffCostFunction<RollingShutterDCTRegularizationError, 4> *cost_function =
		new ceres::DynamicAutoDiffCostFunction < RollingShutterDCTRegularizationError, 4 >(new RollingShutterDCTRegularizationError(sqrtWeight, nCoeffs, sqrt(lamda)));

	vector<double*> parameter_blocks;
	for (int ii = 0; ii < 6; ii++)
	{
		parameter_blocks.push_back(C + ii*nCoeffs);
		cost_function->AddParameterBlock(nCoeffs);
	}
	cost_function->SetNumResiduals(6 * nCoeffs);
	problem.AddResidualBlock(cost_function, NULL, parameter_blocks);


	double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	double avgX = MeanArray(ReProjectionErrorX);
	double stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	double avgY = MeanArray(ReProjectionErrorY);
	double stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	{
		printf("\n %d bad points (%d good points) detected with maximum reprojection error of (%.2f %.2f) \n", nBadCounts, validPtsCount, maxOutlierX, maxOutlierY);
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
	}

	//printf("...run \n");
	ceres::Solver::Options options;
	options.num_threads = omp_get_max_threads();
	options.num_linear_solver_threads = omp_get_max_threads();
	options.max_num_iterations = 30;
	options.linear_solver_type = ceres::SPARSE_SCHUR;
	options.minimizer_progress_to_stdout = true;
	options.trust_region_strategy_type = ceres::LEVENBERG_MARQUARDT;

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";

	//Store refined parameters
	printf("Reference cam: %d\n", RefFrameID);
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		CopyCamereInfo(VideoInfoI.VideoInfo[RefFrameID], VideoInfoI.VideoInfo[frameID], false);
		GetKFromIntrinsic(VideoInfoI.VideoInfo[frameID]);
	}

	count = -1;
	ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
	pointErrX = 0.0, pointErrY = 0.0, validPtsCount = 0;

	if (debug)
		sprintf(Fname, "%s/reprojectionA.txt", Path), fp = fopen(Fname, "w+");
	for (int pid = 0; pid < (int)P3D.size() / 3; pid++)
	{
		for (int fid = 0; fid < (int)frameIDPer3D[pid].size(); fid++)
		{
			frameID = frameIDPer3D[pid][fid];
			uv = P2dPer3D[pid][fid];
			scale = scalePer3D[pid][fid];
			P3d.x = P3D[3 * pid], P3d.y = P3D[3 * pid + 1], P3d.z = P3D[3 * pid + 2];

			count++;
			if (!Good[count])
				continue;

			if (distortionCorrected)
				RollingShutterDCTReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, C, C + nCoeffs, C + 2 * nCoeffs, C + 3 * nCoeffs, C + 4 * nCoeffs, C + 5 * nCoeffs, nCoeffs,
				uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);
			else
				;// RollingShutterDistortionSplineReprojectionDebug(VideoInfoI.VideoInfo[frameID].intrinsic, VideoInfoI.VideoInfo[frameID].distortion, ActingID, FramePose + 6 * ActingID[0], KnotLoc, nbreaks, nCtrls, SplineOrder,
			//uv, P3d, frameID, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height, residuals);

			validPtsCount++;
			ReProjectionErrorX.push_back(abs(residuals[0]));
			ReProjectionErrorY.push_back(abs(residuals[1]));

			if (debug)
				fprintf(fp, "%d %d %.4f %.4f %.4f %.4f %.4f %.4f %.4f \n", pid, frameID, P3D[3 * pid], P3D[3 * pid + 1], P3D[3 * pid + 2], uv.x, uv.y, residuals[0], residuals[1]);
		}
	}
	if (debug)
		fclose(fp);

	miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
	avgX = MeanArray(ReProjectionErrorX);
	stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
	miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
	avgY = MeanArray(ReProjectionErrorY);
	stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));

#pragma omp critical
	printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);

	//Write the data
	sprintf(Fname, "%s/IntrinsicDCT_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	for (int frameID = startFrame; frameID <= stopFrame; frameID++)
	{
		fprintf(fp, "%d %d %d %d ", frameID, VideoInfoI.VideoInfo[frameID].LensModel, VideoInfoI.VideoInfo[frameID].width, VideoInfoI.VideoInfo[frameID].height);
		for (int ii = 0; ii < 5; ii++)
			fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].intrinsic[ii]);
		if (VideoInfoI.VideoInfo[frameID].LensModel == RADIAL_TANGENTIAL_PRISM)
			for (int ii = 0; ii < 7; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		else
			for (int ii = 0; ii < 3; ii++)
				fprintf(fp, "%.4f ", VideoInfoI.VideoInfo[frameID].distortion[ii]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	sprintf(Fname, "%s/CamPoseDCT_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+");
	fprintf(fp, "%d %d %d\n", startFrame, nCoeffs, sampleStep);
	for (int jj = 0; jj < 6; jj++)
	{
		for (int ii = 0; ii < nCoeffs; ii++)
			fprintf(fp, "%.8e ", C[ii + jj*nCoeffs]);
		fprintf(fp, "\n");
	}
	fclose(fp);

	delete[]FrameTime, delete[]FramePose;
	delete[]sqrtWeight, delete[]iBi, delete[]iBAll, delete[]C;

	return 0;
}
int LocalizeCameraFromCorpusDriver(char *Path, int startFrame, int stopFrame, int IncreFrame, int module, int nCams, int selectedCams, int distortionCorrected, int GetIntrinsicFromCorpus, int sharedIntriniscOptim, int LensType)
{
	//Required calibrated cameras if Fisheye or lens with large distortion is used.
	char Fname[200];
	const int ninlierThresh = 10;
	const float nndrRatio = 0.7;
	Corpus corpusData;
	sprintf(Fname, "%s/Corpus", Path);
	if (module == 0)
		ReadCorpusInfo(Fname, corpusData, false, false);
	else
		ReadCorpusInfo(Fname, corpusData, false, true);

	///****NOTE: Required calibrated cameras if Fisheye or lens with large distortion is used***///
	bool fixIntrinsic = true, fixDistortion = true;
	CameraData *AllCamsInfo = new CameraData[nCams];
	if (!ReadIntrinsicResults(Path, AllCamsInfo))
	{
		if (GetIntrinsicFromCorpus == 1)
		{
			printf("Calibrated information extracted from Corpus cameras. The output 2D-3D correspondences will be corrected for lens distortion\n");
			for (int ii = 0; ii < nCams; ii++)
			{
				for (int jj = 0; jj < 5; jj++)
					AllCamsInfo[ii].intrinsic[jj] = corpusData.camera[0].intrinsic[jj];
				GetKFromIntrinsic(AllCamsInfo[ii]);
				AllCamsInfo[ii].notCalibrated = false;

				AllCamsInfo[ii].LensModel = LensType, AllCamsInfo[ii].threshold = 5.0, AllCamsInfo[ii].ninlierThresh = ninlierThresh;
				for (int jj = 0; jj < 7; jj++)
					AllCamsInfo[ii].distortion[jj] = corpusData.camera[0].distortion[jj];
				AllCamsInfo[ii].width = corpusData.camera[0].width, AllCamsInfo[ii].height = corpusData.camera[0].height;
			}
		}
		else
		{
			//Uncalibrated cam-->have to search for focal length + distortion
			printf("UnCalibrated case. The output 2D-3D correspondences will NOT be corrected for lens distortion\n");
			fixIntrinsic = false, fixDistortion = false;
			for (int ii = 0; ii < nCams; ii++)
			{
				int width = 1920, height = 1080;
				double focal = 0.91*max(width, height);
				AllCamsInfo[ii].intrinsic[0] = focal, AllCamsInfo[ii].intrinsic[1] = focal, AllCamsInfo[ii].intrinsic[2] = 0,
					AllCamsInfo[ii].intrinsic[3] = width / 2, AllCamsInfo[ii].intrinsic[4] = height / 2;
				GetKFromIntrinsic(AllCamsInfo[ii]);

				AllCamsInfo[ii].notCalibrated = true;
				AllCamsInfo[ii].LensModel = LensType, AllCamsInfo[ii].threshold = 5.0, AllCamsInfo[ii].ninlierThresh = ninlierThresh;
				for (int jj = 0; jj < 7; jj++)
					AllCamsInfo[ii].distortion[jj] = 0.0;
				AllCamsInfo[ii].width = width, AllCamsInfo[ii].height = height;
			}
		}
	}
	else
	{
		printf("Calibrated case. The output 2D-3D correspondences will be corrected for lens distortion\n");
		for (int ii = 0; ii < nCams; ii++)
			AllCamsInfo[ii].notCalibrated = false, AllCamsInfo[ii].threshold = 5.0, AllCamsInfo[ii].ninlierThresh = 40;
	}

	if (AllCamsInfo[selectedCams].notCalibrated == true && module == 1) //needed when try to run pnp without focal length info
	{
		CameraData CamsInfo;
		int width = 1920, height = 1080, bestFocal = 0, bestInlier = 0;
		for (int range = -10; range <= 10; range++) // search over focal length which gives highest # inliers
		{
			int focal = (1.0 + 0.01*range)*max(width, height);
			CamsInfo.intrinsic[0] = focal, CamsInfo.intrinsic[1] = focal, CamsInfo.intrinsic[2] = 0, CamsInfo.intrinsic[3] = width / 2, CamsInfo.intrinsic[4] = height / 2;
			GetKFromIntrinsic(CamsInfo);

			CamsInfo.notCalibrated = true;
			CamsInfo.LensModel = LensType, CamsInfo.ShutterModel = 0, CamsInfo.threshold = 5.0, CamsInfo.ninlierThresh = ninlierThresh;
			for (int jj = 0; jj < 7; jj++)
				CamsInfo.distortion[jj] = 0.0;
			CamsInfo.width = width, CamsInfo.height = height;

			int ninliers = EstimateCameraPoseFromCorpus(Path, corpusData, CamsInfo, selectedCams, fixIntrinsic, fixDistortion, distortionCorrected, sharedIntriniscOptim, startFrame);
			if (ninliers > bestInlier)
			{
				bestInlier = ninliers;
				bestFocal = CamsInfo.intrinsic[0];
			}
		}
		printf("Best focal: %d, best inliers: %d\n", bestFocal, bestInlier);
		AllCamsInfo[selectedCams].intrinsic[0] = bestFocal, AllCamsInfo[selectedCams].intrinsic[1] = bestFocal, AllCamsInfo[selectedCams].intrinsic[2] = 0,
			AllCamsInfo[selectedCams].intrinsic[3] = width / 2, AllCamsInfo[selectedCams].intrinsic[4] = height / 2;
		GetKFromIntrinsic(AllCamsInfo[selectedCams]);

		if (startFrame == 1 && module == 1)
		{
			sprintf(Fname, "%s/Intrinsic_%d.txt", Path, selectedCams); FILE*fp = fopen(Fname, "w+");	fclose(fp);
			sprintf(Fname, "%s/CamPose_%d.txt", Path, selectedCams); fp = fopen(Fname, "w+"); fclose(fp);
		}
	}


	double start = omp_get_wtime();
	if (module == 0)
	{
#pragma omp parallel for
		for (int frameID = startFrame; frameID <= stopFrame; frameID += IncreFrame)
		{
			vector<int> CorpusViewToMatch;
			CorpusViewToMatch.reserve(corpusData.nCameras);

			int toMatch;
			sprintf(Fname, "%s/%d/ToMatch.txt", Path, selectedCams);
			FILE *fp = fopen(Fname, "r");
			if (fp == NULL)
			{
				printf("Cannot read %s\n", Fname);
				abort();
			}
			while (fscanf(fp, "%d ", &toMatch) != EOF)
				CorpusViewToMatch.push_back(toMatch);
			fclose(fp);

			///****NOTE: 2d points in Corpus are corrected. 2D points in the image-to-be-localized are not distorted if camera is not calibrated***///
			MatchCameraToCorpus(Path, corpusData, AllCamsInfo, selectedCams, frameID, distortionCorrected, CorpusViewToMatch, nndrRatio, ninlierThresh);
		}
	}
	else
	{
		vector<int> computedTime; computedTime.reserve(stopFrame - startFrame + 1);
		CameraData *SelectedCameraInfo = new CameraData[stopFrame - startFrame + 1];
		for (int frameID = startFrame; frameID <= stopFrame; frameID += IncreFrame)
		{
			computedTime.clear();
			CopyCamereInfo(AllCamsInfo[selectedCams], SelectedCameraInfo[frameID - startFrame]);
			if (AllCamsInfo[selectedCams].notCalibrated == true)
				distortionCorrected = 0;//3D_2D files contain un-corrected data
			else
				distortionCorrected = 1;//3D_2D files contain corrected data

			int ninliers = EstimateCameraPoseFromCorpus(Path, corpusData, SelectedCameraInfo[frameID - startFrame], selectedCams, fixIntrinsic, fixDistortion, distortionCorrected, sharedIntriniscOptim, frameID);
			if (ninliers < AllCamsInfo[selectedCams].ninlierThresh)
				computedTime.push_back(-1);
			else
			{
				computedTime.push_back(frameID - startFrame);
				sprintf(Fname, "%s/CamPose_%d.txt", Path, selectedCams);
				SaveVideoCameraPoses(Fname, SelectedCameraInfo, computedTime, selectedCams, startFrame);
			}
		}
		delete[]AllCamsInfo, delete[]SelectedCameraInfo;
		printf("Finished estimating poses for camera %d\n", selectedCams);
	}

	printf("Total time %d: %.3fs\n", selectedCams, omp_get_wtime() - start);

	return 0;
}

int BundleAdjustDomeTableCorres(char *Path, int startF_HD, int stopF_HD, int startF_VGA, int stopF_VGA, bool fixIntrinsicHD, bool fixDistortionHD, bool fixPoseHD, bool fixIntrinsicVGA, bool fixDistortionVGA, bool fixPoseVGA, bool debug)
{
	double threshold = 15.0;
	const int nHDs = 30, nPanels = 20, nVGAPanel = 24, nVGAs = nPanels*nVGAPanel;
	int nHDUsed = 20, notUsedHD = 14;
	char Fname[200];
	Corpus CorpusData;

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	loadBundleAdjustedNVMResults(Fname, CorpusData);

	//Get 2D corres
	{
		int frameID;
		Point2d *TableHD = new Point2d[(stopF_HD - startF_HD + 1)*nHDs];
		int *frame3D_HD = new int[stopF_HD - startF_HD + 1];
		for (int ii = startF_HD; ii <= stopF_HD; ii++)
		{
			frame3D_HD[ii - startF_HD] = ii;
			for (int jj = 0; jj < nHDs; jj++)
				TableHD[(ii - startF_HD)*nHDs + jj].x = -1, TableHD[(ii - startF_HD)*nHDs + jj].y = -1;
		}

		sprintf(Fname, "%s/Correspondences_HD.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
		{
			frame3D_HD[frameID - startF_HD] = frameID;
			for (int jj = 0; jj < nHDs; jj++)
				fscanf(fp, "%lf %lf ", &TableHD[(frameID - startF_HD)*nHDs + jj].x, &TableHD[(frameID - startF_HD)*nHDs + jj].y);
		}
		fclose(fp);

		//Get 3D init
		double *P3D_HD = new double[3 * (stopF_HD - startF_HD + 1)];
		for (int ii = 0; ii < 3 * (stopF_HD - startF_HD + 1); ii++)
			P3D_HD[ii] = 0.0;

		sprintf(Fname, "%s/C0_0.txt", Path); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
			fscanf(fp, "%lf %lf %lf", &P3D_HD[3 * (frameID - startF_HD)], &P3D_HD[3 * (frameID - startF_HD) + 1], &P3D_HD[3 * (frameID - startF_HD) + 2]);
		fclose(fp);

		printf("Set up BA ...");
		ceres::Problem problem;

		if (debug)
			sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

		vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(stopF_HD - startF_HD + 1);
		vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(stopF_HD - startF_HD + 1);

		int totalProjections = 0, nPossibleProjections = 0, minInliers = 999;
		for (int ii = startF_HD; ii < stopF_HD; ii++)
		{
			if (abs(P3D_HD[3 * (ii - startF_HD)]) + abs(P3D_HD[3 * (ii - startF_HD) + 1]) + abs(P3D_HD[3 * (ii - startF_HD) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]);

			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				nPossibleProjections++;
				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");

			if (minInliers > nvalidViews)
				minInliers = nvalidViews;
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));


			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);

				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, 1.0);
				problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, &P3D_HD[3 * (ii - startF_HD)]);

				if (fixIntrinsicHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].intrinsic);
				if (fixDistortionHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].distortion);
				if (fixPoseHD)
					problem.SetParameterBlockConstant(CorpusData.camera[jj].rt);
			}
		}
		if (debug)
			fclose(fp);

		printf("Done with problem building\n");

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d. Min inliers: %d\n", totalProjections, nPossibleProjections, minInliers);


		printf("...run BA...\n");
		ceres::Solver::Options options;
		options.num_threads = 4;
		options.max_num_iterations = 30;
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.minimizer_progress_to_stdout = true;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = false;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		//std::cout << summary.BriefReport() << "\n";
		std::cout << summary.FullReport() << "\n";

		totalProjections = 0;
		ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");
		for (int ii = startF_HD; ii < stopF_HD; ii++)
		{
			if (abs(P3D_HD[3 * (ii - startF_HD)]) + abs(P3D_HD[3 * (ii - startF_HD) + 1]) + abs(P3D_HD[3 * (ii - startF_HD) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.f %.f %.f ", ii, P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]);
			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nHDUsed; jj++)
			{
				if (jj == notUsedHD)
					continue;
				if (TableHD[(ii - startF_HD)*nHDs + jj].x < 0 || TableHD[(ii - startF_HD)*nHDs + jj].y < 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj].intrinsic, CorpusData.camera[jj].distortion, CorpusData.camera[jj].rt, TableHD[(ii - startF_HD)*nHDs + jj],
					Point3d(P3D_HD[3 * (ii - startF_HD)], P3D_HD[3 * (ii - startF_HD) + 1], P3D_HD[3 * (ii - startF_HD) + 2]), residuals);

				if (abs(residuals[0]) + abs(residuals[1]) > threshold * 3)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableHD[(ii - startF_HD)*nHDs + jj].x, TableHD[(ii - startF_HD)*nHDs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));
		}
		if (debug)
			fclose(fp);

		miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d\n", totalProjections, nPossibleProjections);

		sprintf(Fname, "%s/BA_Camera_AllParams_after2.txt", Path);
		ReSaveBundleAdjustedNVMResults(Fname, CorpusData, 1.0);

		delete[]P3D_HD, delete[]TableHD, delete[] frame3D_HD;
	}

	{
		int frameID;
		Point2d *TableVGA = new Point2d[(stopF_VGA - startF_VGA + 1)*nVGAs];
		int *frame3D_VGA = new int[stopF_VGA - startF_VGA + 1];
		for (int ii = startF_VGA; ii <= stopF_VGA; ii++)
		{
			frame3D_VGA[ii - startF_VGA] = ii;
			for (int jj = 0; jj < nVGAs; jj++)
				TableVGA[(ii - startF_VGA)*nVGAs + jj].x = -1, TableVGA[(ii - startF_VGA)*nVGAs + jj].y = -1;
		}

		sprintf(Fname, "%s/Correspondences_VGA.txt", Path);	FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
		{
			frame3D_VGA[frameID - startF_VGA] = frameID;
			for (int jj = 0; jj < nVGAs; jj++)
				fscanf(fp, "%lf %lf ", &TableVGA[(frameID - startF_VGA)*nVGAs + jj].x, &TableVGA[(frameID - startF_VGA)*nVGAs + jj].y);
		}
		fclose(fp);

		//Get 3D init
		double *P3D_VGA = new double[3 * (stopF_VGA - startF_VGA + 1)];
		for (int ii = 0; ii < 3 * (stopF_VGA - startF_VGA + 1); ii++)
			P3D_VGA[ii] = 0.0;

		sprintf(Fname, "%s/C1_0.txt", Path); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d ", &frameID) != EOF)
			fscanf(fp, "%lf %lf %lf", &P3D_VGA[3 * (frameID - startF_VGA)], &P3D_VGA[3 * (frameID - startF_VGA) + 1], &P3D_VGA[3 * (frameID - startF_VGA) + 2]);
		fclose(fp);

		printf("Set up BA ...");
		ceres::Problem problem;

		if (debug)
			sprintf(Fname, "C:/temp/reprojectionB2.txt"), fp = fopen(Fname, "w+");

		vector<double> ReProjectionErrorX; ReProjectionErrorX.reserve(stopF_VGA - startF_VGA + 1);
		vector<double> ReProjectionErrorY; ReProjectionErrorY.reserve(stopF_VGA - startF_VGA + 1);

		int totalProjections = 0, nPossibleProjections = 0, minInliers = 999;
		for (int ii = startF_VGA; ii < stopF_VGA; ii++)
		{
			if (abs(P3D_VGA[3 * (ii - startF_VGA)]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 1]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]);

			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				nPossibleProjections++;
				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				//printf("%d %d %f %f\n", ii, jj, residuals[0], residuals[1]);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");

			if (minInliers > nvalidViews)
				minInliers = nvalidViews;
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));


			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);
				if (abs(residuals[0]) + abs(residuals[1]) > threshold)
					continue;

				ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, 1.0);
				problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, &P3D_VGA[3 * (ii - startF_VGA)]);

				if (fixIntrinsicVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].intrinsic);
				if (fixDistortionVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].distortion);
				if (fixPoseVGA)
					problem.SetParameterBlockConstant(CorpusData.camera[jj + nHDs].rt);
			}
		}
		if (debug)
			fclose(fp);

		printf("Done with problem building\n");

		double miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		double avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		double miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		double avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error before BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d. Min inliers: %d\n", totalProjections, nPossibleProjections, minInliers);


		printf("...run BA...\n");
		ceres::Solver::Options options;
		options.num_threads = 4;
		options.max_num_iterations = 15;
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.minimizer_progress_to_stdout = true;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = false;

		ceres::Solver::Summary summary;
		ceres::Solve(options, &problem, &summary);
		//std::cout << summary.BriefReport() << "\n";
		std::cout << summary.FullReport() << "\n";

		totalProjections = 0;
		ReProjectionErrorX.clear(), ReProjectionErrorY.clear();
		if (debug)
			sprintf(Fname, "C:/temp/reprojectionA2.txt"), fp = fopen(Fname, "w+");
		for (int ii = startF_VGA; ii < stopF_VGA; ii++)
		{
			if (abs(P3D_VGA[3 * (ii - startF_VGA)]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 1]) + abs(P3D_VGA[3 * (ii - startF_VGA) + 2]) < 0.01)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f ", ii, P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]);
			int nvalidViews = 0;
			double pointErrX = 0, pointErrY = 0, residuals[2];
			for (int jj = 0; jj < nVGAs; jj++)
			{
				if (TableVGA[(ii - startF_VGA)*nVGAs + jj].x < 0 || TableVGA[(ii - startF_VGA)*nVGAs + jj].y < 0)
					continue;

				if (abs(CorpusData.camera[jj + nHDs].LensModel) != 0)
					continue;

				PinholeDistortionReprojectionDebug(CorpusData.camera[jj + nHDs].intrinsic, CorpusData.camera[jj + nHDs].distortion, CorpusData.camera[jj + nHDs].rt, TableVGA[(ii - startF_VGA)*nVGAs + jj],
					Point3d(P3D_VGA[3 * (ii - startF_VGA)], P3D_VGA[3 * (ii - startF_VGA) + 1], P3D_VGA[3 * (ii - startF_VGA) + 2]), residuals);

				if (!IsNumber(residuals[0]) || !IsFiniteNumber(residuals[0]))
					continue;

				if (abs(residuals[0]) + abs(residuals[1]) > threshold *1.5)
					continue;

				pointErrX += pow(residuals[0], 2), pointErrY += pow(residuals[1], 2), nvalidViews++;
				totalProjections++;

				if (debug)
					fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, TableVGA[(ii - startF_VGA)*nVGAs + jj].x, TableVGA[(ii - startF_VGA)*nVGAs + jj].y, residuals[0], residuals[1]);
			}
			if (debug)
				fprintf(fp, "\n");
			ReProjectionErrorX.push_back(sqrt(pointErrX / nvalidViews)), ReProjectionErrorY.push_back(sqrt(pointErrY / nvalidViews));
		}
		if (debug)
			fclose(fp);

		miniX = *min_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end()), maxiX = *max_element(ReProjectionErrorX.begin(), ReProjectionErrorX.end());
		avgX = MeanArray(ReProjectionErrorX), stdX = sqrt(VarianceArray(ReProjectionErrorX, avgX));
		miniY = *min_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end()), maxiY = *max_element(ReProjectionErrorY.begin(), ReProjectionErrorY.end());
		avgY = MeanArray(ReProjectionErrorY), stdY = sqrt(VarianceArray(ReProjectionErrorY, avgY));
		printf("Reprojection error after BA \n Min: (%.2f, %.2f) Max: (%.2f,%.2f) Mean: (%.2f,%.2f) Std: (%.2f,%.2f)\n", miniX, miniY, maxiX, maxiY, avgX, avgY, stdX, stdY);
		printf("Total projections: %d/%d\n", totalProjections, nPossibleProjections);

		sprintf(Fname, "%s/BA_Camera_AllParams_after3.txt", Path);
		ReSaveBundleAdjustedNVMResults(Fname, CorpusData, 1.0);

		delete[]P3D_VGA, delete[]TableVGA, delete[] frame3D_VGA;
	}

	return 0;
}
int BundleAdjustDomeMultiNVM(char *Path, int nNvm, int maxPtsPerNvM, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool debug)
{
	char Fname[200];
	Corpus CorpusData;

	const int maxCams = 30 + 24 * 20;
	double thresh = 4.0;

	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	loadBundleAdjustedNVMResults(Fname, CorpusData);

	printf("Set up BA ...");
	ceres::Problem problem;

	vector<int> *AllViewIDList = new vector<int>[maxPtsPerNvM * nNvm];
	vector<Point2d>* AllUVList = new vector<Point2d>[maxPtsPerNvM * nNvm];

	int nvis, viewID, curPid = 0;
	double u, v;
	FILE *fp = 0;
	for (int nvmID = 1; nvmID <= nNvm; nvmID++)
	{
		//Read correspondences
		sprintf(Fname, "%s/calib%d_corres.txt", Path, nvmID); fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot load %s\n", Fname);
			return 1;
		}
		while (fscanf(fp, "%d", &nvis) != EOF)
		{
			AllViewIDList[curPid].reserve(nvis), AllUVList[curPid].reserve(nvis);
			for (int ii = 0; ii < nvis; ii++)
			{
				fscanf(fp, "%d %lf %lf", &viewID, &u, &v);
				AllViewIDList[curPid].push_back(viewID);
				AllUVList[curPid].push_back(Point2d(u, v));
			}
			curPid++;
		}
	}
	printf("Finished loading data\n");

	Point3d p3d;
	int minInliers, nLargeErr = 0, curValidPid = 0;
	double minInliersPercent = 1.0, residuals[2];
	double P[12 * maxCams];
	double *A = new double[6 * maxCams], *B = new double[2 * maxCams], *tP = new double[12 * maxCams];
	vector<double> ReProjectionError; ReProjectionError.reserve(curPid);
	double *Allp3D = new double[curPid * 3];
	int *ValidPid = new int[curPid];

	if (debug)
		sprintf(Fname, "C:/temp/reprojectionB.txt"), fp = fopen(Fname, "w+");

	vector<int> viewIDList, Inliers;
	vector<Point2d> uvList, uvListUndistorted;
	for (int pid = 0; pid < curPid; pid++)
	{
		ValidPid[pid] = 0;
		nvis = AllViewIDList[pid].size();
		viewIDList.clear(), uvList.clear(), uvListUndistorted.clear();
		for (int ii = 0; ii < nvis; ii++)
		{
			viewIDList.push_back(AllViewIDList[pid][ii]);
			uvList.push_back(AllUVList[pid][ii]);
			uvListUndistorted.push_back(AllUVList[pid][ii]);
		}

		//triangulate
		for (int jj = 0; jj < nvis; jj++)
		{
			int viewID = viewIDList[jj];
			LensCorrectionPoint(&uvListUndistorted[jj], CorpusData.camera[viewID].K, CorpusData.camera[viewID].distortion);
			for (int kk = 0; kk < 12; kk++)
				P[12 * jj + kk] = CorpusData.camera[viewID].P[kk];
		}

		bool passed;
		Inliers.clear();
		double avgerror = NviewTriangulationRANSAC(&uvListUndistorted, P, &p3d, &passed, &Inliers, nvis, 1, 100, 0.7, thresh, A, B, tP, false, false);
		if (!passed)
		{
			nLargeErr++;
			printf("Ave Error is larger than %f at point %d \n", thresh, pid);
			continue;
		}
		else
		{
			int ninlier = 0;
			for (int kk = 0; kk < Inliers.size(); kk++)
				if (Inliers.at(kk))
					ninlier++;

			if (ninlier < 3)
			{
				//printf("Two few matches at point %d \n", pid);
				continue;
			}

			ReProjectionError.push_back(avgerror);
			double inlierPercent = 1.0*ninlier / Inliers.size();
			if (minInliersPercent > inlierPercent)
				minInliersPercent = inlierPercent, minInliers = ninlier;
		}
		Allp3D[pid * 3] = p3d.x, Allp3D[pid * 3 + 1] = p3d.y, Allp3D[pid * 3 + 2] = p3d.z;
		ValidPid[pid] = 1;

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f ", pid, p3d.x, p3d.y, p3d.z);

		for (int jj = 0; jj < nvis; jj++)
		{
			if (Inliers[jj] == 0)
				continue;

			PinholeDistortionReprojectionDebug(CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, uvList[jj], p3d, residuals);
			if (abs(residuals[0]) + abs(residuals[1]) > thresh)
				continue;

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, uvList[jj].x, uvList[jj].y, residuals[0], residuals[1]);

			ceres::CostFunction* cost_function = PinholeDistortionReprojectionError::Create(uvList[jj].x, uvList[jj].y, 1.0);
			problem.AddResidualBlock(cost_function, NULL, CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, &Allp3D[3 * pid]);

			if (fixIntrinsic)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].intrinsic);
			if (fixDistortion)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].distortion);
			if (fixPose)
				problem.SetParameterBlockConstant(CorpusData.camera[viewIDList[jj]].rt);
		}
		curValidPid++;

		if (debug)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	printf("Done with problem building\n");

	double miniE = *min_element(ReProjectionError.begin(), ReProjectionError.end()), maxiE = *max_element(ReProjectionError.begin(), ReProjectionError.end());
	double avgE = MeanArray(ReProjectionError), stdE = sqrt(VarianceArray(ReProjectionError, avgE));
	printf("Reprojection error after BA \nMin: %.2f Max: %.2f Mean: %.2f Std: %.2f\n", miniE, maxiE, avgE, stdE);
	printf("Total points: %d/%d. #Large error: %d. Min inliers: %.2f%% (%d)\n", curValidPid, curPid, nLargeErr, minInliersPercent, minInliers);


	printf("...run BA...\n");
	ceres::Solver::Options options;
	options.num_threads = 4;
	options.max_num_iterations = 50;
	if (CorpusData.nCameras < 200)
	{
		options.linear_solver_type = ceres::DENSE_SCHUR;
		options.trust_region_strategy_type = ceres::DOGLEG;
		options.use_nonmonotonic_steps = true;
	}
	else
	{
#ifdef _WIN32
		options.linear_solver_type = ceres::ITERATIVE_SCHUR;
		options.preconditioner_type = ceres::PreconditionerType::JACOBI;
		options.visibility_clustering_type = ceres::VisibilityClusteringType::CANONICAL_VIEWS;
		options.sparse_linear_algebra_library_type = ceres::SUITE_SPARSE;
		options.minimizer_progress_to_stdout = true;
#else
		printf("Error! Only works for windows\n");
#endif
	}

	ceres::Solver::Summary summary;
	ceres::Solve(options, &problem, &summary);
	std::cout << summary.FullReport() << "\n";


	if (debug)
		sprintf(Fname, "C:/temp/reprojectionA.txt"), fp = fopen(Fname, "w+");

	ReProjectionError.clear();
	for (int pid = 0; pid < curPid; pid++)
	{
		if (ValidPid[pid] == 0)
			continue;

		nvis = AllViewIDList[pid].size();
		viewIDList.clear(), uvList.clear();
		for (int ii = 0; ii < nvis; ii++)
		{
			viewIDList.push_back(AllViewIDList[pid][ii]);
			uvList.push_back(AllUVList[pid][ii]);
		}
		p3d.x = Allp3D[pid * 3], p3d.y = Allp3D[pid * 3 + 1], p3d.z = Allp3D[pid * 3 + 2];

		if (debug)
			fprintf(fp, "%d %.4f %.4f %.4f ", pid, Allp3D[pid * 3], Allp3D[pid * 3 + 1], Allp3D[pid * 3 + 2]);

		int jj, nvalidprojections = 0;
		double Error = 0.0;
		for (jj = 0; jj < nvis; jj++)
		{
			PinholeDistortionReprojectionDebug(CorpusData.camera[viewIDList[jj]].intrinsic, CorpusData.camera[viewIDList[jj]].distortion, CorpusData.camera[viewIDList[jj]].rt, uvList[jj], p3d, residuals);
			if (abs(residuals[0]) + abs(residuals[1]) > 2 * thresh)
				continue;
			nvalidprojections++;
			Error += residuals[0] * residuals[0] + residuals[1] * residuals[1];

			if (debug)
				fprintf(fp, "%d %.4f %.4f %.4f %.4f ", jj, uvList[jj].x, uvList[jj].y, residuals[0], residuals[1]);
		}
		if (jj > 0)
			ReProjectionError.push_back(sqrt(Error / nvalidprojections));

		if (debug)
			fprintf(fp, "\n");
	}
	if (debug)
		fclose(fp);

	sprintf(Fname, "%s/3Dpts.txt", Path);	fp = fopen(Fname, "w+");
	for (int pid = 0; pid < curPid; pid++)
	{
		if (ValidPid[pid] == 0)
			continue;
		fprintf(fp, "%f %f %f \n", Allp3D[pid * 3], Allp3D[pid * 3 + 1], Allp3D[pid * 3 + 2]);
	}
	fclose(fp);

	miniE = *min_element(ReProjectionError.begin(), ReProjectionError.end()), maxiE = *max_element(ReProjectionError.begin(), ReProjectionError.end());
	avgE = MeanArray(ReProjectionError), stdE = sqrt(VarianceArray(ReProjectionError, avgE));
	printf("Reprojection error after BA \nMin: %.2f Max: %.2f Mean: %.2f Std: %.2f\n", miniE, maxiE, avgE, stdE);
	printf("Total points: %d/%d. Min inliers: %.2f%% (%d)\n", curValidPid, curPid, minInliersPercent, minInliers);

	sprintf(Fname, "%s/BA_Camera_AllParams_after2.txt", Path);
	saveBundleAdjustedNVMResults(Fname, CorpusData);

	delete[]Allp3D, delete[]ValidPid, delete[]A, delete[]B, delete[]tP;
	return 0;
}
int ReCalibratedFromGroundTruthCorrespondences(char *Path, int camID, int startFrame, int stopFrame, int Allnpts, int ShutterModel)
{
	char Fname[1024]; FILE *fp = 0;
	bool fixIntrinsic = true, fixDistortion = true, fixPose = true, fixfirstCamPose = true, distortionCorrected = false;

	Corpus corpusData;
	sprintf(Fname, "%s/Corpus/BA_Camera_AllParams_after.txt", Path);
	if (!loadBundleAdjustedNVMResults(Fname, corpusData))
		return 1;

	vector<int>AvailableViews;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		if (corpusData.camera[fid].valid)
		{
			AvailableViews.push_back(fid);
			corpusData.camera[fid].threshold = 1000000.0; //make sure that all points are inliers
			corpusData.camera[fid].ShutterModel = ShutterModel;
		}
	}

	//Setup 2d point correspondences for all views according to the frame-level sync result
	vector<Point3d> P3D(Allnpts);
	vector <vector<int> > viewIdAll3D;
	vector<vector<Point2d> > uvAll3D;
	vector<vector<double> > scaleAll3D;

	vector<int>viewID3D;
	vector<double>scale3D;
	for (int fid = startFrame; fid <= stopFrame; fid++)
		viewID3D.push_back(fid),
		scale3D.push_back(1.0);

	int  nframes = stopFrame - startFrame + 1;
	Point2d *Correspondences = new Point2d[Allnpts*nframes];
	vector<int> NotAvail;
	for (int fid = startFrame; fid <= stopFrame; fid++)
	{
		sprintf(Fname, "%s/%d/Corner/CV_%d.txt", Path, camID, fid); FILE *fp = fopen(Fname, "r");
		if (fp == NULL)
		{
			printf("Cannot open %s\n", Fname);

			for (int pid = 0; pid < Allnpts; pid++)
				Correspondences[fid + pid*nframes] = Point2d(-1, -1);

			corpusData.camera[fid].valid = false;
			continue;
		}
		for (int pid = 0; pid < Allnpts; pid++)
			fscanf(fp, "%lf %lf ", &Correspondences[fid + pid*nframes].x, &Correspondences[fid + pid*nframes].y);
		fclose(fp);
	}

	vector<Point2d> uv3D;
	for (int pid = 0; pid < Allnpts; pid++)
	{
		viewIdAll3D.push_back(viewID3D);
		scaleAll3D.push_back(scale3D);

		uv3D.clear();
		for (int fid = 0; fid < nframes; fid++)
			uv3D.push_back(Correspondences[fid + pid*nframes]);

		uvAll3D.push_back(uv3D);
	}

	//Retriangulate, assuming global shutter
	/*double error, point3d[3];
	double *P = new double[12 * nframes], *A = new double[6 * nframes], *B = new double[2 * nframes], *points2d = new double[nframes * 2];

	Point3d p3d;
	vector<Point2d> p2d;
	for (int ii = 0; ii < Allnpts; ii++)
	{
	if (viewIdAll3D[ii].size() > 1)
	{
	p2d.clear();
	int count = 0;
	for (int jj = 0; jj < viewIdAll3D[ii].size(); jj++)
	{
	if (corpusData.camera[viewIdAll3D[ii][jj]].valid)
	{
	for (int kk = 0; kk < 12; kk++)
	P[count * 12 + kk] = corpusData.camera[viewIdAll3D[ii][jj]].P[kk];
	p2d.push_back(uvAll3D[ii][jj]);

	int viewID = viewIdAll3D[ii][jj];
	LensCorrectionPoint(&p2d[count], corpusData.camera[viewID].K, corpusData.camera[viewID].distortion);
	count++;
	}
	}

	NviewTriangulation(&p2d, P, &p3d, count, 1, NULL, A, B);
	P3D[ii] = p3d;
	}
	}
	delete[]P, delete[]A, delete[]B, delete[]points2d;*/
	NviewTriangulation(corpusData.camera, corpusData.nCameras, viewIdAll3D, uvAll3D, P3D);

	//Re-adjust the bundle
	vector<int>sharedCam;
	for (int ii = 0; ii < nframes; ii++)
		sharedCam.push_back(0);
	vector<bool>GoodPoints;

	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, P3D, viewIdAll3D, uvAll3D, scaleAll3D, sharedCam, AvailableViews.size(), fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, P3D, viewIdAll3D, uvAll3D, scaleAll3D, sharedCam, AvailableViews.size(), fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, true, distortionCorrected, 0, false, false);

	//sprintf(Fname, "%s/rBA_Camera_AllParams_after.txt", Path);
	//ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	sprintf(Fname, "%s/Corpus", Path);
	SaveCurrentSfmGL(Fname, corpusData.camera, AvailableViews, P3D, vector<Point3i>());
	visualizationDriver(Path, nframes, startFrame, stopFrame, false, false, false, false, false, false, 0);

	delete[]Correspondences;
	return 0;
}
int RefineVisualSfM2(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement)
{
	char Fname[200];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
				ImgSize.push_back(Point2i(img.cols, img.rows));
			else
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	Corpus corpusData;
	sprintf(Fname, "%s/Corpus/corpus.nvm", Path);
	if (!loadNVM(Fname, corpusData, ImgSize))
		return 1;

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < nimages; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	vector<int>AvailableViews;
	for (int ii = 0; ii < nimages; ii++)
	{
		corpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		corpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < corpusData.nCameras; ii++)
			corpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, corpusData.camera, corpusData.xyz, corpusData.viewIdAll3D, corpusData.uvAll3D, corpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);
	}

	sprintf(Fname, "%s/Corpus/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, corpusData);

	sprintf(Fname, "%s/Corpus", Path);
	for (int ii = 0; ii < nimages; ii++)
		AvailableViews.push_back(ii);
	SaveCurrentSfmGL(Fname, corpusData.camera, AvailableViews, corpusData.xyz, vector<Point3i>());

	return 0;
}
int RefineVisualSfM(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement)
{
	char Fname[512];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
			else
				ImgSize.push_back(Point2i(img.cols, img.rows));
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	//Fill up the visSfm corpus data. Assume all cameras are reconstructed
	printf("Reading corpus info ....\n");
	Corpus CorpusData;
	sprintf(Fname, "%s/Corpus.nvm", Path);
	loadNVM(Fname, CorpusData, ImgSize, nplus);
	printf("%d %d+ 3D points", CorpusData.n3dPoints, nplus);

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}

	//Refine visSfm corpus
	printf("Refine corpus ....\n");
	for (int ii = 0; ii < CorpusData.nCameras; ii++)
	{
		CorpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		CorpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			CorpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);
	}
	printf("\n");

	//write corpusData
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, CorpusData);

	vector<int>AvailViews;
	for (int ii = 0; ii < nimages; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, CorpusData.camera, AvailViews, CorpusData.xyz, CorpusData.rgb);

	return 0;
}
int RefineVisualSfMAndCreateCorpus(char *Path, int nimages, int nplus, int ShutterModel, double threshold, bool sharedInstrinsic, bool fixIntrinsic, bool fixDistortion, bool fixPose, bool fixfirstCamPose, bool distortionCorrected, bool doubleRefinement)
{
	char Fname[512];

	vector<Point2i> ImgSize;
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.png", Path, ii);
		Mat img = imread(Fname, 0);
		if (img.empty())
		{
			sprintf(Fname, "%s/%d.jpg", Path, ii); img = imread(Fname, 0);
			if (img.empty())
			{
				printf("Cannot load %s. Abort()", Fname);
				abort();
			}
			else
				ImgSize.push_back(Point2i(img.cols, img.rows));
		}
		else
			ImgSize.push_back(Point2i(img.cols, img.rows));
	}

	//read all visualsfm sift. Assume all cameras are reconstructed
	printf("Reading sift points ...");
	vector<KeyPoint> *AllKeyPts = new vector<KeyPoint>[nimages];
	Mat *AllDesc = new Mat[nimages];
	for (int ii = 0; ii < nimages; ii++)
	{
		sprintf(Fname, "%s/%d.sift", Path, ii);
		readVisualSFMSift(Fname, AllKeyPts[ii], AllDesc[ii]);
	}
	printf("\n");

	//Fill up the visSfm corpus data. Assume all cameras are reconstructed
	printf("Reading corpus info ....\n");
	Corpus CorpusData;
	sprintf(Fname, "%s/Corpus.nvm", Path);
	loadNVM(Fname, CorpusData, ImgSize, nplus, AllKeyPts, AllDesc);
	printf("%d %d+ 3D points", CorpusData.n3dPoints, nplus);

	int nSift, totalSift = 0;
	CorpusData.IDCumView.reserve(nimages + 1);
	for (int ii = 0; ii < nimages; ii++)
	{
		CorpusData.IDCumView.push_back(totalSift);
		nSift = (int)CorpusData.uvAllViews[ii].size();
		totalSift += nSift;
	}
	CorpusData.IDCumView.push_back(totalSift);
	printf("\n");

	vector<int>Refinement_SharedIntrinsic;
	if (sharedInstrinsic)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			Refinement_SharedIntrinsic.push_back(0); //first visible camera is the reference camera to build the corpus

		sprintf(Fname, "%s/SharedIntrinsic.txt", Path); FILE *fp = fopen(Fname, "r");
		if (fp != NULL)
		{
			int camID, group;
			while (fscanf(fp, "%d %d", &camID, &group) != EOF)
				Refinement_SharedIntrinsic[camID] = group;
			fclose(fp);
		}
	}


	//Refine visSfm corpus
	printf("Refine corpus ....\n");
	for (int ii = 0; ii < CorpusData.nCameras; ii++)
	{
		CorpusData.camera[ii].threshold = 100.0; //make sure that most points are inliers
		CorpusData.camera[ii].ShutterModel = ShutterModel;
	}

	vector<bool>GoodPoints;
	if (ShutterModel == 0)
		GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
	else
		CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);

	if (doubleRefinement)
	{
		for (int ii = 0; ii < CorpusData.nCameras; ii++)
			CorpusData.camera[ii].threshold = threshold;

		if (ShutterModel == 0)
			GlobalShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, distortionCorrected, 0, false, false);
		else
			CayleyRollingShutterBundleAdjustment(Path, CorpusData.camera, CorpusData.xyz, CorpusData.viewIdAll3D, CorpusData.uvAll3D, CorpusData.scaleAll3D, Refinement_SharedIntrinsic, nimages, fixIntrinsic, fixDistortion, fixPose, fixfirstCamPose, false, distortionCorrected, 0, false, false);
	}
	printf("\n");

	//write corpusData
	printf("Write corpus info ....");
	sprintf(Fname, "%s/BA_Camera_AllParams_after.txt", Path);
	ReSaveBundleAdjustedNVMResults(Fname, CorpusData);

	SaveCorpusInfo(Path, CorpusData);

	vector<int>AvailViews;
	for (int ii = 0; ii < nimages; ii++)
		AvailViews.push_back(ii);
	SaveCurrentSfmGL(Path, CorpusData.camera, AvailViews, CorpusData.xyz, CorpusData.rgb);

	delete[]AllKeyPts, delete[]AllDesc;

	return 0;
}

double FmatPointError(double *Fmat, Point2d p1, Point2d p2)
{
	//F*p1
	double Fx[3] = { Fmat[0] * p1.x + Fmat[1] * p1.y + Fmat[2],
		Fmat[3] * p1.x + Fmat[4] * p1.y + Fmat[5],
		Fmat[6] * p1.x + Fmat[7] * p1.y + Fmat[8] };

	//F'*p2
	double FTXp[3] = { Fmat[0] * p2.x + Fmat[3] * p2.y + Fmat[6],
		Fmat[1] * p2.x + Fmat[4] * p2.y + Fmat[7],
		Fmat[2] * p2.x + Fmat[5] * p2.y + Fmat[8] };

	double error = pow(p2.x * Fx[0] + p2.y*Fx[1] + Fx[2], 2) *
		(1.0 / (Fx[0] * Fx[0] + Fx[1] * Fx[1])
		+ 1.0 / (FTXp[0] * FTXp[0] + FTXp[1] * FTXp[1]));

	return error;
}
void computeFmat(CameraData Cam1, CameraData Cam2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9] = { Cam1.K[0], Cam1.K[1], Cam1.K[2], 0, Cam1.K[4], Cam1.K[5], 0, 0, 1.0 };
	double K2[9] = { Cam2.K[0], Cam2.K[1], Cam2.K[2], 0, Cam2.K[4], Cam2.K[5], 0, 0, 1.0 };
	double rt1[6] = { Cam1.rt[0], Cam1.rt[1], Cam1.rt[2], Cam1.rt[3], Cam1.rt[4], Cam1.rt[5] };
	double rt2[6] = { Cam2.rt[0], Cam2.rt[1], Cam2.rt[2], Cam2.rt[3], Cam2.rt[4], Cam2.rt[5] };

	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}
void computeFmatfromKRT(CameraData *CameraInfo, int nviews, int *selectedIDs, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9] = { CameraInfo[selectedIDs[0]].K[0], CameraInfo[selectedIDs[0]].K[1], CameraInfo[selectedIDs[0]].K[2],
		0, CameraInfo[selectedIDs[0]].K[4], CameraInfo[selectedIDs[0]].K[5],
		0, 0, 1.0 };
	double K2[9] = { CameraInfo[selectedIDs[1]].K[0], CameraInfo[selectedIDs[1]].K[1], CameraInfo[selectedIDs[1]].K[2],
		0, CameraInfo[selectedIDs[1]].K[4], CameraInfo[selectedIDs[1]].K[5],
		0, 0, 1.0 };
	double rt1[6] = { CameraInfo[selectedIDs[0]].rt[0], CameraInfo[selectedIDs[0]].rt[1], CameraInfo[selectedIDs[0]].rt[2],
		CameraInfo[selectedIDs[0]].rt[3], CameraInfo[selectedIDs[0]].rt[4], CameraInfo[selectedIDs[0]].rt[5] };
	double rt2[6] = { CameraInfo[selectedIDs[1]].rt[0], CameraInfo[selectedIDs[1]].rt[1], CameraInfo[selectedIDs[1]].rt[2],
		CameraInfo[selectedIDs[1]].rt[3], CameraInfo[selectedIDs[1]].rt[4], CameraInfo[selectedIDs[1]].rt[5] };

	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}
//if ChooseCorpusView != -1, selectedCams and seletectedTime will be overwritten
void computeFmatfromKRT(CorpusandVideo &CorpusandVideoInfo, int *selectedCams, int *seletectedTime, int ChooseCorpusView1, int ChooseCorpusView2, double *Fmat)
{
	int ii;
	double tmat[9], tmat2[9];
	double K1[9], K2[9], rt1[6], rt2[6];

	if (ChooseCorpusView1 != -1)
	{
		K1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[0], K1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[1], K1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[4], K1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[0], rt1[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[1], rt1[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[2],
			rt1[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[3], rt1[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[4], rt1[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView1].rt[5];
	}
	else
	{
		int ID = selectedCams[0] * MaxnFrames + seletectedTime[0];
		K1[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K1[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K1[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K1[3] = 0, K1[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K1[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K1[6] = 0, K1[7] = 0, K1[8] = 1.0;

		rt1[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt1[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt1[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt1[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt1[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt1[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}

	if (ChooseCorpusView2 != -1)
	{
		K2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[0], K2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[1], K2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[4], K2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[0], rt2[1] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[1], rt2[2] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[2],
			rt2[3] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[3], rt2[4] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[4], rt2[5] = CorpusandVideoInfo.CorpusInfo[ChooseCorpusView2].rt[5];
	}
	else
	{
		int ID = selectedCams[1] * MaxnFrames + seletectedTime[1];
		K2[0] = CorpusandVideoInfo.VideoInfo[ID].K[0], K2[1] = CorpusandVideoInfo.VideoInfo[ID].K[1], K2[2] = CorpusandVideoInfo.VideoInfo[ID].K[2],
			K2[3] = 0, K2[4] = CorpusandVideoInfo.VideoInfo[ID].K[4], K2[5] = CorpusandVideoInfo.VideoInfo[ID].K[5],
			K2[6] = 0, K2[7] = 0, K2[8] = 1.0;

		rt2[0] = CorpusandVideoInfo.VideoInfo[ID].rt[0], rt2[1] = CorpusandVideoInfo.VideoInfo[ID].rt[1], rt2[2] = CorpusandVideoInfo.VideoInfo[ID].rt[2],
			rt2[3] = CorpusandVideoInfo.VideoInfo[ID].rt[3], rt2[4] = CorpusandVideoInfo.VideoInfo[ID].rt[4], rt2[5] = CorpusandVideoInfo.VideoInfo[ID].rt[5];
	}


	double RT1[16], RT2[16], R1[9], R2[9], T1[3], T2[3];
	GetRTFromrt(rt1, R1, T1);
	RT1[0] = R1[0], RT1[1] = R1[1], RT1[2] = R1[2], RT1[3] = T1[0];
	RT1[4] = R1[3], RT1[5] = R1[4], RT1[6] = R1[5], RT1[7] = T1[1];
	RT1[8] = R1[6], RT1[9] = R1[7], RT1[10] = R1[8], RT1[11] = T1[2];
	RT1[12] = 0, RT1[13] = 0, RT1[14] = 0, RT1[15] = 1;

	GetRTFromrt(rt2, R2, T2);
	RT2[0] = R2[0], RT2[1] = R2[1], RT2[2] = R2[2], RT2[3] = T2[0];
	RT2[4] = R2[3], RT2[5] = R2[4], RT2[6] = R2[5], RT2[7] = T2[1];
	RT2[8] = R2[6], RT2[9] = R2[7], RT2[10] = R2[8], RT2[11] = T2[2];
	RT2[12] = 0, RT2[13] = 0, RT2[14] = 0, RT2[15] = 1;

	double iRT1[16], RT12[16], R12[9], T12[3];
	mat_invert(RT1, iRT1, 4);
	mat_mul(RT2, iRT1, RT12, 4, 4, 4);
	DesembleRT(R12, T12, RT12);

	double Emat12[9], Tx[9];
	Tx[0] = 0.0, Tx[1] = -T12[2], Tx[2] = T12[1];
	Tx[3] = T12[2], Tx[4] = 0.0, Tx[5] = -T12[0];
	Tx[6] = -T12[1], Tx[7] = T12[0], Tx[8] = 0.0;

	mat_mul(Tx, R12, Emat12, 3, 3, 3);

	double iK1[9], iK2[9];
	mat_invert(K1, iK1, 3);
	mat_invert(K2, iK2, 3);
	mat_transpose(iK2, tmat, 3, 3);
	mat_mul(tmat, Emat12, tmat2, 3, 3, 3);
	mat_mul(tmat2, iK1, Fmat, 3, 3, 3);

	for (ii = 0; ii < 9; ii++)
		Fmat[ii] = Fmat[ii] / Fmat[8];

	return;
}

/*int Trajectory3DGen(char *Path, int nviews, int startTime, int stopTime, int timeID, int LensType, int distortionCorrected, double Reprojectionthreshold)
{
int nFrames = stopTime - startTime + 1;
char Fname[200];
VideoData AllVideoInfo;
if (ReadVideoData(Path, AllVideoInfo, nviews, startTime, stopTime) == 1)
return 1;

//startTime = 0, stopTime = 0;

int totalPts, MAXPTS = 0;
for (int timeID = startTime; timeID <= stopTime; timeID++)
{
sprintf(Fname, "%s/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
continue;
}
int nviewsi, viewi, n3D = 0;
while (fscanf(fp, "%d ", &nviewsi) != EOF)
{
for (int ii = 0; ii < nviewsi; ii++)
fscanf(fp, "%d ", &viewi);
n3D++;
}
fclose(fp);
if (n3D > MAXPTS)
MAXPTS = n3D;
}

vector<int> cumulativePts; cumulativePts.reserve(nviews);
vector<int>*CandiateViewMatch = new vector<int>[MAXPTS];
vector<int>*CandiatePointIDMatch = new vector<int>[MAXPTS];
vector<int> *AllViewID = new vector<int>[MAXPTS];
vector<SiftKeypoint> *AllKeys = new vector < SiftKeypoint >[nviews];
vector<Point3i> *RGB = new vector < Point3i >[nviews];
vector<Point3d> AllXYZ; AllXYZ.reserve(1000);
vector<Point3i> AllRGB; AllRGB.reserve(1000);

double *A = new double[6 * nviews * 2];
double *B = new double[2 * nviews * 2];
double *tPs = new double[12 * nviews * 2];
bool *passed = new bool[nviews * 2];
double *Ps = new double[12 * nviews * 2];
Point2d *match2Dpts = new Point2d[nviews * 2];
Point3i *matchRGB = new Point3i[nviews * 2];


cumulativePts.clear(); AllXYZ.clear(), AllRGB.clear();
if (ReadCumulativePoints(Path, nviews, timeID, cumulativePts) == 1)
return 1;
totalPts = cumulativePts.at(nviews);

sprintf(Fname, "%s/ViewPM_%d.txt", Path, timeID); FILE *fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
return 1;
}
int nviewsi, viewi, n3D = 0;
while (fscanf(fp, "%d ", &nviewsi) != EOF)
{
CandiateViewMatch[n3D].clear(), CandiateViewMatch[n3D].reserve(nviewsi);
for (int ii = 0; ii < nviewsi; ii++)
{
fscanf(fp, "%d ", &viewi);
CandiateViewMatch[n3D].push_back(viewi);
}
n3D++;
}
fclose(fp);

sprintf(Fname, "%s/IDPM_%d.txt", Path, timeID); fp = fopen(Fname, "r");
if (fp == NULL)
{
printf("Cannot load %s\n", Fname);
return 1;
}
int np, pi;
n3D = 0;
while (fscanf(fp, "%d ", &np) != EOF)
{
CandiatePointIDMatch[n3D].clear(), CandiatePointIDMatch[n3D].reserve(np);
for (int ii = 0; ii < np; ii++)
{
fscanf(fp, "%d ", &pi);
CandiatePointIDMatch[n3D].push_back(pi);
}
n3D++;
}
fclose(fp);

//Read all sift points
for (int ii = 0; ii < nviews; ii++)
{
AllKeys[ii].clear(); RGB[ii].clear();
sprintf(Fname, "%s/%d/K%d.dat", Path, ii, timeID); ReadKPointsBinarySIFTGPU(Fname, AllKeys[ii]);
sprintf(Fname, "%s/%d/RGB%d.dat", Path, ii, timeID); ReadRGBBinarySIFTGPU(Fname, RGB[ii]);
}

//Triangulate points from estimated camera poses
Point3d xyz;
vector<int>Inliers[1];  Inliers[0].reserve(nviews * 2);
vector<int>viewIDs, pointIDs, orgId, threeDid;
vector<Point2d> uvPer3D, uvperView;
Point2d X;

double ProThresh = 0.99, PercentInlier = 0.25;
int NDplus = 2, goodNDplus = 0, iterMax = (int)(log(1.0 - ProThresh) / log(1.0 - pow(PercentInlier, 2)) + 0.5); //log(1-eps) / log(1 - (inlier%)^min_pts_requires)
double start = omp_get_wtime();
for (int jj = 0; jj < n3D; jj++)
{
int nviewsi = CandiateViewMatch[jj].size();
if (nviewsi >= NDplus)
{
Inliers[0].clear();
for (int ii = 0; ii < nviewsi; ii++)
{
viewi = CandiateViewMatch[jj][ii];
for (int kk = 0; kk < 12; kk++)
Ps[12 * ii + kk] = AllVideoInfo.VideoInfo[viewi*nFrames + timeID].P[kk];

pi = CandiatePointIDMatch[jj][ii];

X = Point2d(AllKeys[viewi].at(pi).x, AllKeys[viewi].at(pi).y);
match2Dpts[ii] = Point2d(AllKeys[viewi].at(pi).x, AllKeys[viewi].at(pi).y);
matchRGB[ii] = Point3i(RGB[viewi].at(pi).x, RGB[viewi].at(pi).y, RGB[viewi].at(pi).z);

if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID].LensModel == RADIAL_TANGENTIAL_PRISM)
LensCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].K, AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion);
else if (distortionCorrected == 0 && AllVideoInfo.VideoInfo[viewi*nFrames + timeID].LensModel == FISHEYE)
FishEyeCorrectionPoint(&match2Dpts[ii], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[0],
AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[1], AllVideoInfo.VideoInfo[viewi*nFrames + timeID].distortion[2]);
}

NviewTriangulationRANSAC(match2Dpts, Ps, &xyz, passed, Inliers, nviewsi, 1, iterMax, PercentInlier, Reprojectionthreshold, A, B, tPs);
if (passed[0])
{
int ninlier = 0, inlierID;
for (int ii = 0; ii < Inliers[0].size(); ii++)
if (Inliers[0][ii])
inlierID = ii, ninlier++;
if (ninlier < NDplus)
continue; //Corpus needs NDplus+ points!

for (int ii = 0; ii < Inliers[0].size(); ii++)
if (Inliers[0][ii])
viewIDs.push_back(CandiateViewMatch[jj][ii]);

AllXYZ.push_back(xyz);
AllRGB.push_back(matchRGB[inlierID]);
goodNDplus++;
}
viewIDs.clear();
}
}

//Back project and compute flow until erros grows too large
while (true)
{

}

delete[]CandiateViewMatch, delete[]CandiatePointIDMatch, delete[]AllViewID, delete[]AllKeys;
delete[]A, delete[]B, delete[]tPs, delete[]passed, delete[]Ps, delete[]match2Dpts;
return 0;
}*/
int Evaluate3DTrajectory(char *Path)
{
	//const int nViews = 480;
	//CameraData CameraInfo[nViews];
	//ReadDomeVGACalibFile(Path, CameraInfo);

	TrajectoryData InfoTraj;
	LoadTrackData(Path, 150, InfoTraj, true);

	//vector<int> TrajectUsed;
	//for (int ii = 0; ii < 8000; ii++)
	//	TrajectUsed.push_back(ii);

	return 0;
}


